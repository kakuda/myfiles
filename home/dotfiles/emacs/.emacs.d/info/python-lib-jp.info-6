これは python-lib-jp.info、python-lib-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-lib-jp.info,  Node: Textbox オブジェクト,  Prev: cursestextpad,  Up: cursestextpad

14.8.1 Textbox オブジェクト
---------------------------

以下のような `Textbox' オブジェクトをインスタンス生成することが
できます:

`Textbox(win)'
     テキストボックスウィジェットオブジェクトを返します。WIN
     引数は、テキストボックスを入れるための `WindowObject' で
     なければなりません。テキストボックスの編集カーソルは、最初は
     テキストボックスが入っているウィンドウの左上角に配置され、その
     座標は `(0, 0)' です。インスタンスの `stripspaces'
     フラグの初期値はオンに設定されます。

`Textbox' オブジェクトは以下のメソッドを持ちます:

`edit([validator])'
     普段使うことになるエントリポイントです。終了キーストロークの一つが
     入力されるまで編集キーストロークを受け付けます。VALIDATOR
     を与える場合、関数でなければなりません。VALIDATOR は
     キーストロークが入力されるたびにそのキーストロークが引数となって
     呼び出されます; 返された値に対して、コマンドキーストロークとして
     解釈が行われます。このメソッドはウィンドウの内容を文字列として返します;
     ウィンドウ内の空白が含められるかどうかは `stripspaces' メンバ
     で決められます。

`do_command(ch)'
     単一のコマンドキーストロークを処理します。以下にサポートされている
     特殊キーストロークを示します:

     キーストローク                     動作
     ------                             -----
     Control-A                          ウィンドウの左端に移動します。
     Control-B                          カーソルを左へ移動し、必要なら前の行に折り返します。
     Control-D                          カーソル下の文字を削除します。
     Control-E                          右端 (stripspaces がオフのとき)
                                        または行末 (stripspaces
                                        がオンのとき) に移動します。
     Control-F                          カーソルを右に移動し、必要なら次の行に折り返します。
     Control-G                          ウィンドウを終了し、その内容を返します。
     Control-H                          逆方向に文字を削除します。(バックスペース)
     Control-J                          ウィンドウが 1
                                        行であれば終了し、そうでなければ新しい行を挿入します。
     Control-K                          行が空白行ならその行全体を削除し、そうでなければカーソル以降行末までを消去します。
     Control-L                          スクリーンを更新します。
     Control-N                          カーソルを下に移動します; 1
                                        行下に移動します。
     Control-O                          カーソルの場所に空行を 1
                                        行挿入します。
     Control-P                          カーソルを上に移動します; 1
                                        行上に移動します。

     移動操作は、カーソルがウィンドウの縁にあって移動ができない場合には
     何も行いません。場合によっては、以下のような同義のキーストロークが
     サポートされています:

     定数                               キーストローク
     ------                             -----
     KEY_LEFT                           <Control-B>
     KEY_RIGHT                          <Control-F>
     KEY_UP                             <Control-P>
     KEY_DOWN                           <Control-N>
     KEY_BACKSPACE                      <Control-h>

     他のキーストロークは、与えられた文字を挿入し、(行折り返し付きで)
     右に移動するコマンドとして扱われます。

`gather()'
     このメソッドはウィンドウの内容を文字列として返します;
     ウィンドウ内の 空白が含められるかどうかは `stripspaces'
     メンバ変数で決められ ます。

`stripspaces'
     このデータメンバはウィンドウ内の空白領域の解釈方法を制御するための
     フラグです。フラグがオンに設定されている場合、各行の末端にある
     空白領域は無視されます; すなわち、末端空白領域にカーソルが入ると、
     その場所の代わりに行の末尾にカーソルが移動します。また、末端の空白
     領域はウィンドウの内容を取得する際に剥ぎ取られます。


File: python-lib-jp.info,  Node: curseswrapper,  Next: cursesascii,  Prev: cursestextpad,  Up: 汎用オペレーティングシステムサービス

14.9 curses プログラムのための端末ハンドラ
==========================================

curses プログラムのための端末設定ラッパ。 _Added in Python version 1.6_

このモジュールでは関数 `wrapper()' 一つを提供しています。 これは curses
使用アプリケーションの残りの部分となるもう一つの関数です。
アプリケーションが例外を送出した場合、`wrapper()' は
例外を再送出してトレースバックを生成する前に端末を正常な状態に復元します。

`wrapper(func, ...)'
     curses を初期化し、別の関数 FUNC を呼び出、エラーが発生
     した場合には通常のキーボード／スクリーン動作に戻すラッパ関数です。
     呼び出し可能オブジェクト FUNC は主ウィンドウの 'stdscr' に
     対する最初の引数として渡されます。その他の引数は `wrapper()'
     に渡されます。

フック関数を呼び出す前に、 `wrapper()' は cbreak モード
をオン、エコーをオフにし、端末キーパッドを有効にします。
端末がカラーをサポートしている場合にはカラーを初期化します。
(通常終了も例外による終了も) 終了時には cooked モードに復元し、
エコーをオンにし、端末キーパッドを無効化します。


File: python-lib-jp.info,  Node: cursesascii,  Next: cursespanel,  Prev: curseswrapper,  Up: 汎用オペレーティングシステムサービス

14.10 ASCII 文字に関するユーティリティ
======================================

ASCII 文字に関する定数および集合帰属関数。

_Added in Python version 1.6_

`curses.ascii' モジュールでは、 ASCII 文字を指す 名前定数と、様々な
ASCII 文字区分についてある文字が帰属するか
どうかを調べる関数を提供します。
このモジュールで提供されている定数は以下の制御文字の名前です:

Name                                 Meaning
------                               -----
NUL                                  空
SOH                                  ヘディング開始、コンソール割り込み
STX                                  テキスト開始
ETX                                  テキスト終了
EOT                                  テキスト伝送終了
ENQ                                  問い合わせ、`ACK' フロー制御時に使用
ACK                                  肯定応答
BEL                                  ベル
BS                                   一文字後退
TAB                                  タブ
HT                                   `TAB' の別名: "水平タブ"
LF                                   改行
NL                                   `LF' の別名: "改行"
VT                                   垂直タブ
FF                                   改頁
CR                                   復帰
SO                                   シフトアウト、他の文字セットの開始
SI                                   シフトイン、標準の文字セットに復帰
DLE                                  データリンクでのエスケープ
DC1                                  装置制御 1、フロー制御のための XON
DC2                                  装置制御 2、ブロックモードフロー制御
DC3                                  装置制御 3、フロー制御のための XOFF
DC4                                  装置制御 4
NAK                                  否定応答
SYN                                  同期信号
ETB                                  ブロック転送終了
CAN                                  キャンセル
EM                                   媒体終端
SUB                                  代入文字
ESC                                  エスケープ文字
FS                                   ファイル区切り文字
GS                                   グループ区切り文字
RS                                   レコード区切り文字、ブロックモード終了子
US                                   単位区切り文字
SP                                   空白文字
DEL                                  削除

これらの大部分は、最近は実際に定数の意味通りに使われることがほとんど
ないので注意してください。これらのニーモニック符号はデジタル計算機
より前のテレプリンタにおける慣習から付けられたものです。

このモジュールでは、標準 C ライブラリの関数を雛型とする以下の関数を
サポートしています:

`isalnum(c)'
     ASCII 英数文字かどうかを調べます; `isalpha(C) or isdigit(C)'
     と等価です。

`isalpha(c)'
     ASCII アルファベット文字かどうかを調べます; `isupper(C) or
     islower(C)' と等価です。

`isascii(c)'
     文字が 7 ビット ASCII 文字に合致するかどうかを調べます。

`isblank(c)'
     ASCII 余白文字かどうかを調べます。

`iscntrl(c)'
     ASCII 制御文字 (0x00 から 0x1f の範囲) かどうかを調べます。

`isdigit(c)'
     ASCII 10 進数字、すなわち `0' から `9' までの
     文字かどうかを調べます。 `C in string.digits' と等価です。

`isgraph(c)'
     空白以外の ASCII 印字可能文字かどうかを調べます。

`islower(c)'
     ASCII 小文字かどうかを調べます。

`isprint(c)'
     空白文字を含め、 ASCII 印字可能文字かどうかを調べます。

`ispunct(c)'
     空白または英数字以外の ASCII 印字可能文字かどうかを調べます。

`isspace(c)'
     ASCII 余白文字、すなわち空白、改行、復帰、改頁、水平タブ、
     垂直タブかどうかを調べます。

`isupper(c)'
     ASCII 大文字かどうかを調べます。

`isxdigit(c)'
     ASCII 16 進数字かどうかを調べます。 `C in string.hexdigits'
     と等価です。

`isctrl(c)'
     ASCII 制御文字 (0 から 31 までの値) かどうかを調べます。

`ismeta(c)'
     非 ASCII 文字 (0x80 またはそれ以上の値) かどうかを調べます。

これらの関数は数字も文字列も使えます; 引数を文字列にした場合、
組み込み関数 `ord()' を使って変換されます。

これらの関数は全て、関数に渡した文字列の最初の文字から得られた
ビット値を調べるので注意してください; 関数はホスト計算機で使われている
文字列エンコーディングについて何ら関知しません。文字列エンコーディング
について関知する (そして国際化に関するプロパティを正しく扱う) 関数
については、 モジュール `string' を参照してください。

以下の 2 つの関数は、引数として 1
文字の文字列または整数で表したバイト値の どちらでもとり得ます;
これらの関数は引数と同じ型で値を返します。

`ascii(c)'
     ASCII 値を返します。C の下位 7 ビットに対応します。

`ctrl(c)'
     与えた文字に対応する制御文字を返します (0x1f とビット単位で論理積
     を取ります) 。

`alt(c)'
     与えた文字に対応する 8 ビット文字を返します (0x80
     とビット単位で論理和 を取ります) 。

以下の関数は 1 文字からなる文字列値または整数値を引数に取り、文字列
を返します。

`unctrl(c)'
     ASCII 文字 C の文字列表現を返します。もし C が印字可能
     文字であれば、返される文字列は C そのものになります。 もし C
     が制御文字 (0x00-0x1f) であれば、 キャレット (`^')
     と、その後ろに続く C に対応した 大文字からなる文字列になります。C
     が ASCII 削除文字 (0x7f) であれば、文字列は `'^{}?'' になります。C
     のメタビット (0x80)
     がセットされていれば、メタビットは取り去られ、前述のルール
     が適用され、`!' が前につけられます。

`controlnames'
     0 (NUL) から 0x1f (US) までの 32 の ASCII 制御文字と、空白文字
     `SP' のニーモニック符号名からなる 33
     要素の文字列によるシーケンスです。


File: python-lib-jp.info,  Node: cursespanel,  Next: platform,  Prev: cursesascii,  Up: 汎用オペレーティングシステムサービス

14.11 curses のためのパネルスタック拡張
=======================================

curses ウィンドウに深さの概念を追加するパネルスタック拡張。

パネルは深さ (depth) の機能が追加されたウィンドウです。これにより、
ウィンドウをお互いに重ね合わせることができ、各ウィンドウの可視部分だけ
が表示されます。パネルはスタック中に追加したり、スタック内で上下移動
させたり、スタックから除去することができます。

* Menu:

* 関数 4::
* Panel オブジェクト::


File: python-lib-jp.info,  Node: 関数 4,  Next: Panel オブジェクト,  Prev: cursespanel,  Up: cursespanel

14.11.1 関数
------------

`curses.panel' では以下の関数を定義しています:

`bottom_panel()'
     パネルスタックの最下層のパネルを返します。

`new_panel(win)'
     与えられたウィンドウ WIN に関連付けられたパネルオブジェクトを
     返します。
     返されたパネルオブジェクトを参照しておく必要があることに注意
     してください。もし参照しなければ、パネルオブジェクトは
     ガベージコレクションされてパネルスタックから削除されます。

`top_panel()'
     パネルスタックの最上層のパネルを返します。

`update_panels()'
     仮想スクリーンをパネルスタック変更後の状態に更新します。この関数では
     `curses.doupdate()' を呼ばないので、ユーザは自分で呼び出す
     必要があります。


File: python-lib-jp.info,  Node: Panel オブジェクト,  Prev: 関数 4,  Up: cursespanel

14.11.2 Panel オブジェクト
--------------------------

上記の `new_panel()' が返す Panel オブジェクトは
スタック順の概念を持つウィンドウです。
ウィンドウはパネルに関連付けられており、表示する内容を決定
している一方、パネルのメソッドはパネルスタック中のウィンドウの深さ
管理を担います。

Panel オブジェクトは以下のメソッドを持っています:

`above()'
     現在のパネルの上にあるパネルを返します。

`below()'
     現在のパネルの下にあるパネルを返します。

`bottom()'
     パネルをスタックの最下層にプッシュします。

`hidden()'
     パネルが隠れている (不可視である) 場合に真を返し、そうでない場合
     偽を返します。

`hide()'
     パネルを隠します。この操作ではオブジェクトは消去されず、
     スクリーン上のウィンドウを不可視にするだけです。

`move(y, x)'
     パネルをスクリーン座標 `(Y, X)' に移動します。

`replace(win)'
     パネルに関連付けられたウィンドウを WIN に変更します。

`set_userptr(obj)'
     パネルのユーザポインタを OBJ に設定します。このメソッドは
     任意のデータをパネルに関連付けるために使われ、任意の Python
     オブジェクト にすることができます。

`show()'
     (隠れているはずの) パネルを表示します。

`top()'
     パネルをスタックの最上層にプッシュします。

`userptr()'
     パネルのユーザポインタを返します。任意の Python オブジェクトです。

`window()'
     パネルに関連付けられているウィンドウオブジェクトを返します。


File: python-lib-jp.info,  Node: platform,  Next: errno,  Prev: cursespanel,  Up: 汎用オペレーティングシステムサービス

14.12 実行中プラットフォームの固有情報を参照する
================================================

実行中プラットフォームからできるだけ多くの固有情報を取得する

_Added in Python version 2.3_

_Notice:_
プラットフォーム毎にアルファベット順に並べています。Linuxについては
UNIXセクションを参照してください。

* Menu:

* クロス プラットフォーム::
* Java プラットフォーム::
* Windows プラットフォーム::
* Mac OS プラットフォーム::
* UNIX プラットフォーム::


File: python-lib-jp.info,  Node: クロス プラットフォーム,  Next: Java プラットフォーム,  Prev: platform,  Up: platform

14.12.1 クロス プラットフォーム
-------------------------------

`architecture(executable=sys.executable, bits='', linkage='')'
     EXECUTABLEで指定した実行可能ファイル（省略時はPythonインタープリ
     タのバイナリ）の各種アーキテクチャ情報を調べます。

     戻り値はタプル`(bits, linkage)'で、アーキテクチャのビット数と実行
     可能ファイルのリンク形式を示します。どちらの値も文字列で返ります。

     値が不明な場合は、パラメータで指定した値が返ります。BITSを
     `'''と指定した場合、ビット数として`sizeof(pointer)'が返
     ります。（Pythonのバージョンが1.5.2以下の場合は、サポートされているポ
     インタサイズとして`sizeof(long)'を使用します。）

     この関数は、システムの`file'コマンドを使用します。`file'はほ
     とんどのUNIXプラットフォームと一部の非UNIXプラットフォームで利用
     可能ですが、`file'コマンドが利用できず、かつEXECUTABLEが
     Pythonインタープリタでない場合には適切なデフォルト値が返ります。

`machine()'
     `'i386''のような、機種を返します。不明な場合は空文字列を返します。

`node()'
     コンピュータのネットワーク名を返します。ネットワーク名は完全修飾名とは
     限りません。不明な場合は空文字列を返します。

`platform(aliased=0, terse=0)'
     実行中プラットフォームを識別する文字列を返します。この文字列には、有益
     な情報をできるだけ多く付加しています。

     戻り値は機械で処理しやすい形式ではなく、_人間にとって読みやすい_
     形式となっています。異なったプラットフォームでは異なった戻り値となるよ
     うになっています。

     ALIASED が真なら、システムの名称として一般的な名称ではなく、別名
     を使用して結果を返します。たとえば、SunOS は Solaris
     となります。この 機能は `system_alias()' で実装されています。

     TERSEが真なら、プラットフォームを特定するために最低限必要な情報
     だけを返します。


`processor()'
     `'amdk6''のような、（現実の）プロセッサ名を返します。

     不明な場合は空文字列を返します。NetBSDのようにこの情報を提供しない、ま
     たは`machine()'と同じ値しか返さないプラットフォームも多く存在
     しますので、注意してください。

`python_build()'
     Pythonのビルド番号と日付を、`(BUILDNO, BUILDDATE)'の
     タプルで返します。


`python_compiler()'
     Pythonをコンパイルする際に使用したコンパイラを示す文字列を返します。

`python_version()'
     Pythonのバージョンを、`'major.minor.patchlevel''形式の文字列で返
     します。

     `sys.version'と異なり、patchlevel（デフォルトでは0)も必ず含まれて
     います。

`python_version_tuple()'
     Pythonのバージョンを、文字列のタプル `(MAJOR, MINOR, PATCHLEVEL)'
     で返します。

     `sys.version'と異なり、patchlevel（デフォルトでは`0')も必ず
     含まれています。

`release()'
     `'2.2.0'' や `'NT'' のような、システムのリリース情報を返しま
     す。不明な場合は空文字列を返します。

`system()'
     `'Linux'', `'Windows'', `'Java'' のような、システム/OS
     名を返します。不明な場合は空文字列を返します。

`system_alias(system, release, version)'
     マーケティング目的で使われる一般的な別名に変換して`(SYSTEM,
     RELEASE, VERSION)' を返します。混乱を避けるために、情報を
     並べなおす場合があります。

`version()'
     `'#3 on degas''のような、システムのリリース情報を返します。不明
     な場合は空文字列を返します。

`uname()'
     非常に可搬性の高い uname
     インターフェースで、実行中プラットフォームを
     示す情報を、文字列のタプル`(SYSTEM, NODE, RELEASE, VERSION,
     MACHINE, PROCESSOR)' で返し ます。

     `os.uname()'と異なり、複数のプロセッサ名が候補としてタプルに
     追加される場合があります。

     不明な項目は `'''となります。


File: python-lib-jp.info,  Node: Java プラットフォーム,  Next: Windows プラットフォーム,  Prev: クロス プラットフォーム,  Up: platform

14.12.2 Java プラットフォーム
-----------------------------

`java_ver(release='', vendor='', vminfo=('','',''), osinfo=('','',''))'
     Jython用のバージョンインターフェースで、タプル`(RELEASE, VENDOR,
     VMINFO, OSINFO)' を返します。VMINFOは タプル`(VM_NAME, VM_RELEASE,
     VM_VENDOR)'、 OSINFOはタプル`(OS_NAME, OS_VERSION,
     OS_ARCH)'です。不明な項目は引数で指定した値（デフォルトは
     `'''）となります。


File: python-lib-jp.info,  Node: Windows プラットフォーム,  Next: Mac OS プラットフォーム,  Prev: Java プラットフォーム,  Up: platform

14.12.3 Windows プラットフォーム
--------------------------------

`win32_ver(release='', version='', csd='', ptype='')'
     Windowsのレジストリからバージョン情報を取得し、バージョン番号/CSDレベ
     ル/OSタイプ（シングルプロセッサ又はマルチプロセッサ）をタプル
     `(VERSION, CSD, PTYPE)'で返します。

     参考：PTYPEはシングルプロセッサのNT上では `'Uniprocessor
     Free''、マルチプロセッサでは `'Multiprocessor
     Free''となります。_'Free'_ がついている場合
     はデバッグ用のコードが含まれていないことを示し、_'Checked'_がつい
     ていれば引数や範囲のチェックなどのデバッグ用コードが含まれていることを
     示します。

     _Notice:_ [note] この関数は、Mark
     Hammondの`win32all'がインストールされたWin32
     互換プラットフォームでのみ利用可能です。


* Menu:

* Win95/98 固有::


File: python-lib-jp.info,  Node: Win95/98 固有,  Prev: Windows プラットフォーム,  Up: Windows プラットフォーム

14.12.3.1 Win95/98 固有
.......................

`popen(cmd, mode='r', bufsize=None)'
     可搬性の高い `popen()' インターフェースで、可能なら
     `win32pipe.popen()'を使用します。`win32pipe.popen()' はWindows
     NTでは利用可能ですが、Windows 9xではハングしてしまいます。



File: python-lib-jp.info,  Node: Mac OS プラットフォーム,  Next: UNIX プラットフォーム,  Prev: Windows プラットフォーム,  Up: platform

14.12.4 Mac OS プラットフォーム
-------------------------------

`mac_ver(release='', versioninfo=('','',''), machine='')'
     Mac OSのバージョン情報を、タプル`(RELEASE, VERSIONINFO,
     MACHINE)'で返します。VERSIONINFO は、タ プル`(VERSION, DEV_STAGE,
     NON_RELEASE_VERSION)' です。

     不明な項目は`'''となります。タプルの要素は全て文字列です。

     この関数で使用している`gestalt()' API については、
     `http://www.rgaros.nl/gestalt/'を参照してください。



File: python-lib-jp.info,  Node: UNIX プラットフォーム,  Prev: Mac OS プラットフォーム,  Up: platform

14.12.5 UNIX プラットフォーム
-----------------------------

`dist(distname='', version='', id='', supported_dists=('SuSE','debian','redhat','mandrake'))'
     OSディストリビューション名の取得を試みます。戻り値はタプル
     `(DISTNAME, VERSION, ID)'で、不明な項目は引数で
     指定した値となります。

`libc_ver(executable=sys.executable, lib='', version='', chunksize=2048)'
     executableで指定したファイル（省略時はPythonインタープリタ）がリンクし
     ているlibcバージョンの取得を試みます。戻り値は文字列のタプル
     `(LIB, VERSION)'で、不明な項目は引数で指定した値とな ります。

     この関数は、実行形式に追加されるシンボルの細かな違いによって、libcの
     バージョンを特定します。この違いは`gcc'でコンパイルされた実行
     可能ファイルでのみ有効だと思われます。

     CHUNKSIZEにはファイルから情報を取得するために読み込むバイト数を
     指定します。


File: python-lib-jp.info,  Node: errno,  Next: ctypes,  Prev: platform,  Up: 汎用オペレーティングシステムサービス

14.13 標準の errno システムシンボル
===================================

標準の errno システムシンボル。

このモジュールから標準の `errno' システムシンボルを取得することが
できます。個々のシンボルの値は `errno' に対応する整数値です。
これらのシンボルの名前は、`linux/include/errno.h' から借用され
ており、かなり網羅的なはずです。

`errorcode'
     errno 値を背後のシステムにおける文字列表現に対応付ける辞書です。
     例えば、`errno.errorcode[errno.EPERM]' は `'EPERM''
     に対応付けられます。

数値のエラーコードをエラーメッセージに変換するには、 `os.strerror()'
を使ってください。

以下のリストの内、現在のプラットフォームで使われていないシンボルは
モジュール上で定義されていません。定義されているシンボルだけを挙げた
リストは `errno.errorcode.keys()' として取得することができます。
取得できるシンボルには以下のようなものがあります:

`EPERM'
     許可されていない操作です (Operation not permitted)

`ENOENT'
     ファイルまたはディレクトリがありません (No such file or directory)

`ESRCH'
     指定したプロセスが存在しません (No such process)

`EINTR'
     割り込みシステムコールです (Interrupted system call)

`EIO'
     I/O エラーです (I/O error)

`ENXIO'
     そのようなデバイスまたはアドレスはありません (No such device or
     address)

`E2BIG'
     引数リストが長すぎます (Arg list too long)

`ENOEXEC'
     実行形式にエラーがあります (Exec format error)

`EBADF'
     ファイル番号が間違っています (Bad file number)

`ECHILD'
     子プロセスがありません (No child processes)

`EAGAIN'
     再試行してください (Try again)

`ENOMEM'
     空きメモリがありません (Out of memory)

`EACCES'
     許可がありません (Permission denied)

`EFAULT'
     不正なアドレスです (Bad address)

`ENOTBLK'
     ブロックデバイスが必要です (Block device required)

`EBUSY'
     そのデバイスまたは資源は使用中です (Device or resource busy)

`EEXIST'
     ファイルがすでに存在します	(File exists)

`EXDEV'
     デバイス間のリンクです (Cross-device link)

`ENODEV'
     そのようなデバイスはありません (No such device)

`ENOTDIR'
     ディレクトリではありません (Not a directory)

`EISDIR'
     ディレクトリです (Is a directory)

`EINVAL'
     無効な引数です (Invalid argument)

`ENFILE'
     ファイルテーブルがオーバフローしています (File table overflow)

`EMFILE'
     開かれたファイルが多すぎます (Too many open files)

`ENOTTY'
     タイプライタではありません (Not a typewriter)

`ETXTBSY'
     テキストファイルが使用中です (Text file busy)

`EFBIG'
     ファイルが大きすぎます (File too large)

`ENOSPC'
     デバイス上に空きがありません (No space left on device)

`ESPIPE'
     不正なシークです (Illegal seek)

`EROFS'
     読み出し専用ファイルシステムです (Read-only file system)

`EMLINK'
     リンクが多すぎます (Too many links)

`EPIPE'
     パイプが壊れました (Broken pipe)

`EDOM'
     数学引数が関数の定義域を越えています (Math argument out of domain
     of func)

`ERANGE'
     表現できない数学演算結果になりました (Math result not
     representable)

`EDEADLK'
     リソースのデッドロックが起きます (Resource deadlock would occur)

`ENAMETOOLONG'
     ファイル名が長すぎます (File name too long)

`ENOLCK'
     レコードロッキングが利用できません (No record locks available)

`ENOSYS'
     実装されていない機能です (Function not implemented)

`ENOTEMPTY'
     ディレクトリが空ではありません (Directory not empty)

`ELOOP'
     これ以上シンボリックリンクを追跡できません (Too many symbolic
     links encountered)

`EWOULDBLOCK'
     操作がブロックします (Operation would block)

`ENOMSG'
     指定された型のメッセージはありません (No message of desired type)

`EIDRM'
     識別子が除去されました (Identifier removed)

`ECHRNG'
     チャネル番号が範囲を超えました (Channel number out of range)

`EL2NSYNC'
     レベル 2 で同期がとれていません (Level 2 not synchronized)

`EL3HLT'
     レベル 3 で終了しました (Level 3 halted)

`EL3RST'
     レベル 3 でリセットしました (Level 3 reset)

`ELNRNG'
     リンク番号が範囲を超えています (Link number out of range)

`EUNATCH'
     プロトコルドライバが接続されていません (Protocol driver not
     attached)

`ENOCSI'
     CSI 構造体がありません (No CSI structure available)

`EL2HLT'
     レベル 2 で終了しました (Level 2 halted)

`EBADE'
     無効な変換です (Invalid exchange)

`EBADR'
     無効な要求記述子です (Invalid request descriptor)

`EXFULL'
     変換テーブルが一杯です (Exchange full)

`ENOANO'
     陰極がありません (No anode)

`EBADRQC'
     無効なリクエストコードです (Invalid request code)

`EBADSLT'
     無効なスロットです (Invalid slot)

`EDEADLOCK'
     ファイルロックにおけるデッドロックエラーです (File locking
     deadlock error)

`EBFONT'
     フォントファイル形式が間違っています (Bad font file format)

`ENOSTR'
     ストリーム型でないデバイスです (Device not a stream)

`ENODATA'
     利用可能なデータがありません (No data available)

`ETIME'
     時間切れです (Timer expired)

`ENOSR'
     streams リソースを使い切りました (Out of streams resources)

`ENONET'
     計算機はネットワーク上にありません (Machine is not on the network)

`ENOPKG'
     パッケージがインストールされていません (Package not installed)

`EREMOTE'
     対象物は遠隔にあります (Object is remote)

`ENOLINK'
     リンクが切られました (Link has been severed)

`EADV'
     Advertise エラーです (Advertise error)

`ESRMNT'
     Srmount エラーです (Srmount error)

`ECOMM'
     送信時の通信エラーです (Communication error on send)

`EPROTO'
     プロトコルエラーです (Protocol error)

`EMULTIHOP'
     多重ホップを試みました (Multihop attempted)

`EDOTDOT'
     RFS 特有のエラーです (RFS specific error)

`EBADMSG'
     データメッセージではありません (Not a data message)

`EOVERFLOW'
     定義されたデータ型にとって大きすぎる値です (Value too large for
     defined data type)

`ENOTUNIQ'
     名前がネットワーク上で一意でありません (Name not unique on
     network)

`EBADFD'
     ファイル記述子の状態が不正です (File descriptor in bad state)

`EREMCHG'
     遠隔のアドレスが変更されました (Remote address changed)

`ELIBACC'
     必要な共有ライブラリにアクセスできません (Can not access a needed
     shared library)

`ELIBBAD'
     壊れた共有ライブラリにアクセスしています (Accessing a corrupted
     shared library)

`ELIBSCN'
     a.out の .lib セクションが壊れています (.lib section in a.out
     corrupted)

`ELIBMAX'
     リンクを試みる共有ライブラリが多すぎます (Attempting to link in
     too many shared libraries)

`ELIBEXEC'
     共有ライブラリを直接実行することができません (Cannot exec a shared
     library directly)

`EILSEQ'
     不正なバイト列です (Illegal byte sequence)

`ERESTART'
     割り込みシステムコールを復帰しなければなりません (Interrupted
     system call should be restarted)

`ESTRPIPE'
     ストリームパイプのエラーです (Streams pipe error)

`EUSERS'
     ユーザが多すぎます (Too many users)

`ENOTSOCK'
     非ソケットに対するソケット操作です (Socket operation on
     non-socket)

`EDESTADDRREQ'
     目的アドレスが必要です (Destination address required)

`EMSGSIZE'
     メッセージが長すぎます (Message too long)

`EPROTOTYPE'
     ソケットに対して不正なプロトコル型です (Protocol wrong type for
     socket)

`ENOPROTOOPT'
     利用できないプロトコルです (Protocol not available)

`EPROTONOSUPPORT'
     サポートされていないプロトコルです (Protocol not supported)

`ESOCKTNOSUPPORT'
     サポートされていないソケット型です (Socket type not supported)

`EOPNOTSUPP'
     通信端点に対してサポートされていない操作です (Operation not
     supported on transport endpoint)

`EPFNOSUPPORT'
     サポートされていないプロトコルファミリです (Protocol family not
     supported)

`EAFNOSUPPORT'
     プロトコルでサポートされていないアドレスファミリです (Address
     family not supported by protocol)

`EADDRINUSE'
     アドレスは使用中です (Address already in use)

`EADDRNOTAVAIL'
     要求されたアドレスを割り当てできません (Cannot assign requested
     address)

`ENETDOWN'
     ネットワークがダウンしています (Network is down)

`ENETUNREACH'
     ネットワークに到達できません (Network is unreachable)

`ENETRESET'
     リセットによってネットワーク接続が切られました (Network dropped
     connection because of reset)

`ECONNABORTED'
     ソフトウェアによって接続が終了されました (Software caused
     connection abort)

`ECONNRESET'
     接続がピアによってリセットされました (Connection reset by peer)

`ENOBUFS'
     バッファに空きがありません (No buffer space available)

`EISCONN'
     通信端点がすでに接続されています (Transport endpoint is already
     connected)

`ENOTCONN'
     通信端点が接続されていません (Transport endpoint is not connected)

`ESHUTDOWN'
     通信端点のシャットダウン後は送信できません (Cannot send after
     transport endpoint shutdown)

`ETOOMANYREFS'
     参照が多すぎます: 接続できません (Too many references: cannot
     splice)

`ETIMEDOUT'
     接続がタイムアウトしました (Connection timed out)

`ECONNREFUSED'
     接続を拒否されました (Connection refused)

`EHOSTDOWN'
     ホストはシステムダウンしています (Host is down)

`EHOSTUNREACH'
     ホストへの経路がありません (No route to host)

`EALREADY'
     すでに処理中です (Operation already in progress)

`EINPROGRESS'
     現在処理中です (Operation now in progress)

`ESTALE'
     無効な NFS ファイルハンドルです (Stale NFS file handle)

`EUCLEAN'
     (Structure needs cleaning)

`ENOTNAM'
     XENIX 名前付きファイルではありません (Not a XENIX named type file)

`ENAVAIL'
     XENIX セマフォは利用できません (No XENIX semaphores available)

`EISNAM'
     名前付きファイルです (Is a named type file)

`EREMOTEIO'
     遠隔側の I/O エラーです (Remote I/O error)

`EDQUOT'
     ディスククオータを超えました (Quota exceeded)


File: python-lib-jp.info,  Node: ctypes,  Prev: errno,  Up: 汎用オペレーティングシステムサービス

14.14 Pythonのための外部関数ライブラリ。
========================================

A foreign function library for Python.  _Added in Python version 2.5_

`ctypes'はPythonのための外部関数ライブラリです。このライブラリは
Cと互換性のあるデータ型を提供し、動的リンク/共有ライブラリ内の
関数呼び出しを可能にします。動的リンク/共有ライブラリを純粋なPythonで
ラップするために使うことができます。

* Menu:

* ctypesチュートリアル::
* ctypesリファレンス::


File: python-lib-jp.info,  Node: ctypesチュートリアル,  Next: ctypesリファレンス,  Prev: ctypes,  Up: ctypes

14.14.1 ctypesチュートリアル
----------------------------

注意: このチュートリアルのコードサンプルは動作確認のために`doctest'を
使います。コードサンプルの中にはLinux、Windows、あるいはMac OS X上で
異なる動作をするものがあるため、サンプルのコメントにdoctest命令を
入れてあります。

注意: かなりのコードサンプルでctypesの`c{_}int'型を参照しています。
32ビットシステムにおいてこの型は`c{_}long'型のエイリアスです。
そのため、`c{_}int'型を想定しているときに`c{_}long'が
表示されたとしても、混乱しないようにしてください --
実際には同じ型なのです。

* Menu:

* 動的リンクライブラリをロードする::
* ロードしたdllから関数にアクセスする::
* 関数を呼び出す::
* 基本のデータ型::
* 続・関数を呼び出す::
* 自作のデータ型とともに関数を呼び出す::
* 要求される引数の型を指定する 関数プロトタイプ::
* 戻り値の型::
* ポインタを渡すまたは、パラメータの参照渡し::
* 構造体と共用体::
* 構造体/共用体アライメントとバイトオーダー::
* 構造体と共用体におけるビットフィールド::
* 配列::
* ポインタ::
* 型変換::
* 不完全型::
* コールバック関数::
* dllからエクスポートされている値へアクセスする::
* 予期しないこと::
* 可変サイズのデータ型::
* バグ、ToDoおよび実装されていないもの::


File: python-lib-jp.info,  Node: 動的リンクライブラリをロードする,  Next: ロードしたdllから関数にアクセスする,  Prev: ctypesチュートリアル,  Up: ctypesチュートリアル

14.14.1.1 動的リンクライブラリをロードする
..........................................

動的リンクライブラリをロードするために、`ctypes'はCDLLをエクスポートします。
WindowsではさらにWINDLLとOLEDLLオブジェクトもエクスポートします。

これらのオブジェクトの属性としてライブラリにアクセスすることでライブラリをロードします。
CDLLは標準`cdecl'呼び出し規約を用いて関数をエクスポートしているライブラリをロードします。
それに対して、WINDLLライブラリは`stdcall'呼び出し規約を用いる関数を呼び出します。
OLEDLLも`stdcall'呼び出し規約を使いますが、関数がWindows
`HRESULT'エラーコードを
返すことを想定しています。このエラーコードは関数呼び出しが失敗したとき、
`WindowsError' Python例外を自動的に発生させるために使われます。

Windows用の例ですが、`msvcrt'はほとんどの標準C関数が含まれているMS標準Cライブラリであり、
cdecl呼び出し規約を使うことに注意してください:
     >>> from ctypes import *
     >>> print windll.kernel32 # doctest: +WINDOWS
     <WinDLL 'kernel32', handle ... at ...>
     >>> print cdll.msvcrt # doctest: +WINDOWS
     <CDLL 'msvcrt', handle ... at ...>
     >>> libc = cdll.msvcrt # doctest: +WINDOWS
     >>>

Windowsではいつもの'.dll'ファイル拡張子を自動的に追加します。

Linuxではライブラリをロードするために拡張子を_含む_ファイル名を
指定する必要があるので、属性アクセスは動作しません。
dllローダーの`LoadLibrary'メソッドを使うか、
コンストラクタを呼び出してCDLLのインスタンスを作ることでライブラリを
ロードするかのどちらかを行わなければなりません:
     >>> cdll.LoadLibrary("libc.so.6") # doctest: +LINUX
     <CDLL 'libc.so.6', handle ... at ...>
     >>> libc = CDLL("libc.so.6")     # doctest: +LINUX
     >>> libc                         # doctest: +LINUX
     <CDLL 'libc.so.6', handle ... at ...>
     >>>


File: python-lib-jp.info,  Node: ロードしたdllから関数にアクセスする,  Next: 関数を呼び出す,  Prev: 動的リンクライブラリをロードする,  Up: ctypesチュートリアル

14.14.1.2 ロードしたdllから関数にアクセスする
.............................................

dllオブジェクトの属性として関数にアクセスします:
     >>> from ctypes import *
     >>> libc.printf
     <_FuncPtr object at 0x...>
     >>> print windll.kernel32.GetModuleHandleA # doctest: +WINDOWS
     <_FuncPtr object at 0x...>
     >>> print windll.kernel32.MyOwnFunction # doctest: +WINDOWS
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
       File "ctypes.py", line 239, in __getattr__
         func = _StdcallFuncPtr(name, self)
     AttributeError: function 'MyOwnFunction' not found
     >>>

`kernel32'や`user32'のようなwin32システムdllは、多くの場合
関数のUNICODEバージョンに加えてANSIバージョンもエクスポートすることに
注意してください。UNICODEバージョンは後ろに`W'が付いた名前でエクスポートされ、
ANSIバージョンは`A'が付いた名前でエクスポートされます。
与えられたモジュールの_モジュールハンドル_を返すwin32
`GetModuleHandle'関数は
次のようなCプロトタイプを持ちます。UNICODEバージョンが定義されているか
どうかにより`GetModuleHandle'としてどちらか一つを公開するためにマクロが使われます:
     /* ANSI version */
     HMODULE GetModuleHandleA(LPCSTR lpModuleName);
     /* UNICODE version */
     HMODULE GetModuleHandleW(LPCWSTR lpModuleName);

WINDLLは魔法を使ってどちらか一つを選ぼうとはしません。
`GetModuleHandleA'もしくは`GetModuleHandleW'を明示的に指定して
必要とするバージョンにアクセスし、通常の文字列かユニコード文字列を使って
それぞれ呼び出さなければなりません。

時には、dllが関数を`"??2@YAPAXI@Z"'のようなPython識別子として
有効でない名前でエクスポートすることがあります。このような場合に
関数を取り出すには、`getattr'を使わなければなりません。
     >>> getattr(cdll.msvcrt, "??2@YAPAXI@Z") # doctest: +WINDOWS
     <_FuncPtr object at 0x...>
     >>>

Windowsでは、名前ではなく序数によって関数をエクスポートするdllもあります。
こうした関数には序数を使ってdllオブジェクトにインデックス指定することで
アクセスします:
     >>> cdll.kernel32[1] # doctest: +WINDOWS
     <_FuncPtr object at 0x...>
     >>> cdll.kernel32[0] # doctest: +WINDOWS
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
       File "ctypes.py", line 310, in __getitem__
         func = _StdcallFuncPtr(name, self)
     AttributeError: function ordinal 0 not found
     >>>


File: python-lib-jp.info,  Node: 関数を呼び出す,  Next: 基本のデータ型,  Prev: ロードしたdllから関数にアクセスする,  Up: ctypesチュートリアル

14.14.1.3 関数を呼び出す
........................

これらの関数は他のPython呼び出し可能オブジェクトと同じように呼び出すことができます。
この例では`time()'関数（UNIXエポックからのシステム時間を秒単位で返す）と、
`GetModuleHandleA()'関数（win32モジュールハンドルを返す）を使います。

この例は両方の関数をNULLポインタとともに呼び出します
(`None'をNULLポインタとして使う必要があります):
     >>> print libc.time(None) # doctest: +SKIP
     1150640792
     >>> print hex(windll.kernel32.GetModuleHandleA(None)) # doctest: +WINDOWS
     0x1d000000
     >>>

`ctypes'は引数の数を間違えたり、あるいは呼び出し規約を間違えた関数呼び出しから
あなたを守ろうとします。残念ながら、これはWindowsでしか機能しません。
関数が返った後にスタックを調べることでこれを行います。したがって、
エラーは発生しますが、その関数は呼び出された_後です_:
     >>> windll.kernel32.GetModuleHandleA() # doctest: +WINDOWS
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: Procedure probably called with not enough arguments (4 bytes missing)
     >>> windll.kernel32.GetModuleHandleA(0, 0) # doctest: +WINDOWS
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: Procedure probably called with too many arguments (4 bytes in excess)
     >>>

同じ例外が`cdecl'呼び出し規約を使って`stdcall'関数を呼び出したときに発生しますし、
逆の場合も同様です。
     >>> cdll.kernel32.GetModuleHandleA(None) # doctest: +WINDOWS
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: Procedure probably called with not enough arguments (4 bytes missing)
     >>>

     >>> windll.msvcrt.printf("spam") # doctest: +WINDOWS
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: Procedure probably called with too many arguments (4 bytes in excess)
     >>>

正しい呼び出し規約を知るためには、呼び出したい関数についてのCヘッダファイル
もしくはドキュメントを見なければなりません。

Windowsでは、関数が無効な引数とともに呼び出された場合の一般保護例外による
クラッシュを防ぐために、`ctypes'はwin32構造化例外処理を使います:
     >>> windll.kernel32.GetModuleHandleA(32) # doctest: +WINDOWS
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     WindowsError: exception: access violation reading 0x00000020
     >>>

しかし、`ctypes'を使ってPythonをクラッシュさせる方法は十分なほどあるので、
よく注意すべきです。

`None'、整数、長整数、バイト文字列およびユニコード文字列だけが、
こうした関数呼び出しにおいてパラメータとして直接使えるネイティブの
Pythonオブジェクトです。`None'はCの`NULL'ポインタとして
渡され、バイト文字列とユニコード文字列はそのデータを含むメモリブロックへの
ポインタ(`char *' または `wchar{_}t *')として渡されます。
Python整数とPython長整数はプラットホームのデフォルトのC
`int'型として渡され、 その値はC `int'型に合うようにマスクされます。

他のパラメータ型をもつ関数呼び出しに移る前に、
`ctypes'データ型についてさらに学ぶ必要があります。


File: python-lib-jp.info,  Node: 基本のデータ型,  Next: 続・関数を呼び出す,  Prev: 関数を呼び出す,  Up: ctypesチュートリアル

14.14.1.4 基本のデータ型
........................

`ctypes'はたくさんのCと互換性のあるデータ型を定義しています :

     ctypesの型             Cの型                  Pythonの型
     ------                 -----                  -----
     `c{_}char'             `char'                 1文字の 文字列
     `c{_}wchar'            `wchar{_}t'            1文字の
                                                   ユニコード文字列
     `c{_}byte'             `char'                 整数/長整数
     `c{_}ubyte'            `unsigned char'        整数/長整数
     `c{_}short'            `short'                整数/長整数
     `c{_}ushort'           `unsigned short'       整数/長整数
     `c{_}int'              `int'                  整数/長整数
     `c{_}uint'             `unsigned int'         整数/長整数
     `c{_}long'             `long'                 整数/長整数
     `c{_}ulong'            `unsigned long'        整数/長整数
     `c{_}longlong'         `{_}{_}int64' or       整数/長整数
                            `long long'            
     `c{_}ulonglong'        `unsigned              整数/長整数
                            {_}{_}int64' or        
                            `unsigned long long'   
     `c{_}float'            `float'                浮動小数点数
     `c{_}double'           `double'               浮動小数点数
     `c{_}char{_}p'         `char *' (NUL 終端)    文字列または `None'
     `c{_}wchar{_}p'        `wchar{_}t *' (NUL     ユニコードまたは
                            終端)                  `None'
     `c{_}void{_}p'         `void *'               整数/長整数
                                                   または`None'


これら全ての型はその型を呼び出すことによって作成でき、オプションとして型と値が合っている
初期化子を指定することができます:
     >>> c_int()
     c_long(0)
     >>> c_char_p("Hello, World")
     c_char_p('Hello, World')
     >>> c_ushort(-3)
     c_ushort(65533)
     >>>

これらの型は変更可能であり、値を後で変更することもできます:
     >>> i = c_int(42)
     >>> print i
     c_long(42)
     >>> print i.value
     42
     >>> i.value = -99
     >>> print i.value
     -99
     >>>

新しい値をポインタ型`c{_}char{_}p'、`c{_}wchar{_}p'、
および`c{_}void{_}p'のインスタンスへ代入すると、
メモリブロックの_内容ではなく_指している_メモリ位置_が変わります、
(もちろんできません。なぜなら、Python文字列は変更不可能だからです):
     >>> s = "Hello, World"
     >>> c_s = c_char_p(s)
     >>> print c_s
     c_char_p('Hello, World')
     >>> c_s.value = "Hi, there"
     >>> print c_s
     c_char_p('Hi, there')
     >>> print s                 # 最初の文字列は変更されていない
     Hello, World
     >>>

しかし、変更可能なメモリを指すポインタであることを想定している関数へ
それらを渡さないように注意すべきです。もし変更可能なメモリブロックが必要なら、
ctypesには`create{_}string{_}buffer'関数があり、いろいろな方法で作成する
ことできます。
現在のメモリブロックの内容は`raw'プロパティを使ってアクセス
(あるいは変更)することができます。もし現在のメモリブロックにNUL終端文字列として
アクセスしたいなら、`value'プロパティを使ってください:
     >>> from ctypes import *
     >>> p = create_string_buffer(3)      # 3バイトのバッファを作成、NULで初期化される
     >>> print sizeof(p), repr(p.raw)
     3 '\x00\x00\x00'
     >>> p = create_string_buffer("Hello")      # NUL終端文字列を含むバッファを作成
     >>> print sizeof(p), repr(p.raw)
     6 'Hello\x00'
     >>> print repr(p.value)
     'Hello'
     >>> p = create_string_buffer("Hello", 10)  # 10バイトのバッファを作成
     >>> print sizeof(p), repr(p.raw)
     10 'Hello\x00\x00\x00\x00\x00'
     >>> p.value = "Hi"
     >>> print sizeof(p), repr(p.raw)
     10 'Hi\x00lo\x00\x00\x00\x00\x00'
     >>>

`create{_}string{_}buffer'関数は初期のctypesリリースにあった`c{_}string'関数
だけでなく、(エイリアスとしてはまだ利用できる)`c{_}buffer'関数をも置き換えるものです。
Cの型`wchar{_}t'のユニコード文字を含む変更可能なメモリブロックを作成するには、
`create{_}unicode{_}buffer'関数を使ってください。


File: python-lib-jp.info,  Node: 続・関数を呼び出す,  Next: 自作のデータ型とともに関数を呼び出す,  Prev: 基本のデータ型,  Up: ctypesチュートリアル

14.14.1.5 続・関数を呼び出す
............................

printfは`sys.stdout'では_なく_、本物の標準出力チャンネルへ
プリントすることに注意してください。したがって、これらの例は
コンソールプロンプトでのみ動作し、_IDLE_や_PythonWin_では動作しません:
     >>> printf = libc.printf
     >>> printf("Hello, %s\n", "World!")
     Hello, World!
     14
     >>> printf("Hello, %S", u"World!")
     Hello, World!
     13
     >>> printf("%d bottles of beer\n", 42)
     42 bottles of beer
     19
     >>> printf("%f bottles of beer\n", 42.5)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ArgumentError: argument 2: exceptions.TypeError: Don't know how to convert parameter 2
     >>>

前に述べたように、必要なCのデータ型へ変換できるようにするためには、
整数、文字列およびユニコード文字列を除くすべてのPython型を
対応する`ctypes'型でラップしなければなりません:
     >>> printf("An int %d, a double %f\n", 1234, c_double(3.14))
     Integer 1234, double 3.1400001049
     31
     >>>


File: python-lib-jp.info,  Node: 自作のデータ型とともに関数を呼び出す,  Next: 要求される引数の型を指定する 関数プロトタイプ,  Prev: 続・関数を呼び出す,  Up: ctypesチュートリアル

14.14.1.6 自作のデータ型とともに関数を呼び出す
..............................................

自作のクラスのインスタンスを関数引数として使えるように、`ctypes'引数変換を
カスタマイズすることもできます。
`ctypes'は`{_}as{_}parameter{_}'属性を探し出し、関数引数として使います。
もちろん、整数、文字列もしくはユニコードの中の一つでなければなりません:
     >>> class Bottles(object):
     ...     def __init__(self, number):
     ...         self._as_parameter_ = number
     ...
     >>> bottles = Bottles(42)
     >>> printf("%d bottles of beer\n", bottles)
     42 bottles of beer
     19
     >>>

インスタンスのデータを`{_}as{_}parameter{_}'インスタンス変数の中に
入れたくない場合には、そのデータを利用できるようにする`property'を
定義することができます。


File: python-lib-jp.info,  Node: 要求される引数の型を指定する 関数プロトタイプ,  Next: 戻り値の型,  Prev: 自作のデータ型とともに関数を呼び出す,  Up: ctypesチュートリアル

14.14.1.7 要求される引数の型を指定する (関数プロトタイプ)
.........................................................

`argtypes'属性を設定することによって、
DLLからエクスポートされている関数に要求される引数の型を指定することができます。

`argtypes'はCデータ型のシーケンスでなければなりません(この場合
`printf'関数はおそらく良い例ではありません。なぜなら、
引数の数が可変であり、フォーマット文字列に依存した異なる型の
パラメータを取るからです。一方では、この機能の実験には とても便利です):
     >>> printf.argtypes = [c_char_p, c_char_p, c_int, c_double]
     >>> printf("String '%s', Int %d, Double %f\n", "Hi", 10, 2.2)
     String 'Hi', Int 10, Double 2.200000
     37
     >>>

(Cの関数のプロトタイプのように)書式を指定すると互換性のない引数型になるのを防ぎ、
引数を有効な型へ変換しようとします:
     >>> printf("%d %d %d", 1, 2, 3)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ArgumentError: argument 2: exceptions.TypeError: wrong type
     >>> printf("%s %d %f", "X", 2, 3)
     X 2 3.00000012
     12
     >>>

関数呼び出しへ渡す自作のクラスを定義した場合には、
`argtypes'シーケンスの中で使えるようにするために、
そのクラスに`from{_}param'クラスメソッドを実装しなければなりません。
`from{_}param'クラスメソッドは関数呼び出しへ渡された
Pythonオブジェクトを受け取り、型チェックもしくはこのオブジェクトが受け入れ可能であると
確かめるために必要なことはすべて行ってから、オブジェクト自身、
`{_}as{_}parameter{_}'属性、あるいは、この場合に
C関数引数として渡したい何かの値を返さなければなりません。
繰り返しになりますが、その返される結果は整数、文字列、ユニコード、`ctypes'インスタンス、
あるいは`{_}as{_}parameter{_}'属性をもつものであるべきです。


File: python-lib-jp.info,  Node: 戻り値の型,  Next: ポインタを渡すまたは、パラメータの参照渡し,  Prev: 要求される引数の型を指定する 関数プロトタイプ,  Up: ctypesチュートリアル

14.14.1.8 戻り値の型
....................

デフォルトでは、関数はC
`int'を返すと仮定されます。他の戻り値の型を指定するには、
関数オブジェクトの`restype'属性に設定します。

さらに高度な例として、`strchr'関数を使います。この関数は文字列ポインタとcharを受け取り、
文字列へのポインタを返します。
     >>> strchr = libc.strchr
     >>> strchr("abcdef", ord("d")) # doctest: +SKIP
     8059983
     >>> strchr.restype = c_char_p # c_char_pは文字列へのポインタ
     >>> strchr("abcdef", ord("d"))
     'def'
     >>> print strchr("abcdef", ord("x"))
     None
     >>>

上の`ord("x")'呼び出しを避けたいなら、`argtypes'属性を設定することができます。
二番目の引数が一文字のPython文字列からCのcharへ変換されます:
     >>> strchr.restype = c_char_p
     >>> strchr.argtypes = [c_char_p, c_char]
     >>> strchr("abcdef", "d")
     'def'
     >>> strchr("abcdef", "def")
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ArgumentError: argument 2: exceptions.TypeError: one character string expected
     >>> print strchr("abcdef", "x")
     None
     >>> strchr("abcdef", "d")
     'def'
     >>>

外部関数が整数を返す場合は、`restype'属性として呼び出し可能な
Pythonオブジェクト(例えば、関数またはクラス)を使うこともできます。
呼び出し可能オブジェクトはC関数が返す`integer'とともに呼び出され、
この呼び出しの結果は関数呼び出しの結果として使われるでしょう。
これはエラーの戻り値をチェックして自動的に例外を発生させるために役に立ちます:
     >>> GetModuleHandle = windll.kernel32.GetModuleHandleA # doctest: +WINDOWS
     >>> def ValidHandle(value):
     ...     if value == 0:
     ...         raise WinError()
     ...     return value
     ...
     >>>
     >>> GetModuleHandle.restype = ValidHandle # doctest: +WINDOWS
     >>> GetModuleHandle(None) # doctest: +WINDOWS
     486539264
     >>> GetModuleHandle("something silly") # doctest: +WINDOWS
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
       File "<stdin>", line 3, in ValidHandle
     WindowsError: [Errno 126] The specified module could not be found.
     >>>

`WinError'はエラーコードの文字列表現を得るためにWindowsの`FormatMessage()'
apiを 呼び出し、例外を_返す_関数です。`WinError'はオプションで
エラーコードパラメータを取ります。このパラメータが使われない場合は、
エラーコードを取り出すために`GetLastError()'を呼び出します。

`errcheck'属性によってもっと強力なエラーチェック機構を利用できることに
注意してください。詳細はリファレンスマニュアルを参照してください。


File: python-lib-jp.info,  Node: ポインタを渡すまたは、パラメータの参照渡し,  Next: 構造体と共用体,  Prev: 戻り値の型,  Up: ctypesチュートリアル

14.14.1.9 ポインタを渡す(または、パラメータの参照渡し)
......................................................

時には、C
api関数がパラメータのデータ型として_ポインタ_を想定していることが
あります。おそらくパラメータと同一の場所に書き込むためか、もしくは
そのデータが大きすぎて値渡しできない場合です。これは_パラメータの参照渡し_としても
知られています。

`ctypes'は`byref'関数をエクスポートしており、パラメータを参照渡しするために
使用します。`pointer'関数を使っても同じ効果が得られます。
しかし、`pointer'は本当のポインタオブジェクトを構築するためより多くの処理を行うことから、
Python側でポインタオブジェクト自体を必要としないならば`byref'を使う方がより高速です:
     >>> i = c_int()
     >>> f = c_float()
     >>> s = create_string_buffer('\000' * 32)
     >>> print i.value, f.value, repr(s.value)
     0 0.0 ''
     >>> libc.sscanf("1 3.14 Hello", "%d %f %s",
     ...             byref(i), byref(f), s)
     3
     >>> print i.value, f.value, repr(s.value)
     1 3.1400001049 'Hello'
     >>>


File: python-lib-jp.info,  Node: 構造体と共用体,  Next: 構造体/共用体アライメントとバイトオーダー,  Prev: ポインタを渡すまたは、パラメータの参照渡し,  Up: ctypesチュートリアル

14.14.1.10 構造体と共用体
.........................

構造体と共用体は`ctypes'モジュールに定義されている`Structure'および`Union'
ベースクラスから導出されなければなりません。それぞれのサブクラスは`{_}fields{_}'属性を
定義する必要があります。`{_}fields{_}'は_フィールド名_と_フィールド型_を持つ
_2要素タプル_のリストでなければなりません。

フィールド型は`c{_}int'か他の`ctypes'型(構造体、共用体、配列、ポインタ)から
導出された`ctypes'型である必要があります。

`x'と`y'という名前の二つの整数からなる簡単なPOINT構造体の例です。
コンストラクタで構造体の初期化する方法の説明にもなっています:
     >>> from ctypes import *
     >>> class POINT(Structure):
     ...     _fields_ = [("x", c_int),
     ...                 ("y", c_int)]
     ...
     >>> point = POINT(10, 20)
     >>> print point.x, point.y
     10 20
     >>> point = POINT(y=5)
     >>> print point.x, point.y
     0 5
     >>> POINT(1, 2, 3)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: too many initializers
     >>>

また、さらに複雑な構造体を構成することができます。Structureはそれ自体が
フィールド型に構造体を使うことで他の構造体を内部に持つことができます。

`upperleft'と`lowerright'という名前の二つのPOINTを持つRECT構造体です:
     >>> class RECT(Structure):
     ...     _fields_ = [("upperleft", POINT),
     ...                 ("lowerright", POINT)]
     ...
     >>> rc = RECT(point)
     >>> print rc.upperleft.x, rc.upperleft.y
     0 5
     >>> print rc.lowerright.x, rc.lowerright.y
     0 0
     >>>

入れ子になった構造体はいくつかの方法を用いてコンストラクタで
初期化することができます:
     >>> r = RECT(POINT(1, 2), POINT(3, 4))
     >>> r = RECT((1, 2), (3, 4))

フィールド記述子は_クラス_から取り出せます。デバッグするときに役に立つ情報を
得ることができます:
     >>> print POINT.x
     <Field type=c_long, ofs=0, size=4>
     >>> print POINT.y
     <Field type=c_long, ofs=4, size=4>
     >>>


File: python-lib-jp.info,  Node: 構造体/共用体アライメントとバイトオーダー,  Next: 構造体と共用体におけるビットフィールド,  Prev: 構造体と共用体,  Up: ctypesチュートリアル

14.14.1.11 構造体/共用体アライメントとバイトオーダー
....................................................

デフォルトでは、StructureとUnionのフィールドはCコンパイラが行うのと同じ方法で
アライメントされています。サブクラスを定義するときに`{_}pack{_}'クラス属性を
指定することでこの動作を変えることは可能です。
このクラス属性には正の整数を設定する必要があり、フィールドの最大アライメントを指定します。
これはMSVCで`{#}pragma pack(n)'が行っていること同じです。

`ctypes'はStructureとUnionに対してネイティブのバイトオーダーを使います。
ネイティブではないバイトオーダーの構造体を作成するには、BigEndianStructure、
LittleEndianStructure、BigEndianUnionおよびLittleEndianUnionベースクラスの中の一つを
使います。これらのクラスにポインタフィールドを持たせることはできません。


File: python-lib-jp.info,  Node: 構造体と共用体におけるビットフィールド,  Next: 配列,  Prev: 構造体/共用体アライメントとバイトオーダー,  Up: ctypesチュートリアル

14.14.1.12 構造体と共用体におけるビットフィールド
.................................................

ビットフィールドを含む構造体と共用体を作ることができます。
ビットフィールドは整数フィールドに対してのみ作ることができ、
ビット幅は`{_}fields{_}'タプルの第三要素で指定します:
     >>> class Int(Structure):
     ...     _fields_ = [("first_16", c_int, 16),
     ...                 ("second_16", c_int, 16)]
     ...
     >>> print Int.first_16
     <Field type=c_long, ofs=0:0, bits=16>
     >>> print Int.second_16
     <Field type=c_long, ofs=0:16, bits=16>
     >>>


File: python-lib-jp.info,  Node: 配列,  Next: ポインタ,  Prev: 構造体と共用体におけるビットフィールド,  Up: ctypesチュートリアル

14.14.1.13 配列
...............

Arrayはシーケンスであり、決まった数の同じ型のインスタンスを持ちます。

推奨されている配列の作成方法はデータ型に正の整数を掛けることです:
     TenPointsArrayType = POINT * 10

ややわざとらしいデータ型の例になりますが、他のものに混ざって
4個のPOINTがある構造体です:
     >>> from ctypes import *
     >>> class POINT(Structure):
     ...    _fields_ = ("x", c_int), ("y", c_int)
     ...
     >>> class MyStruct(Structure):
     ...    _fields_ = [("a", c_int),
     ...                ("b", c_float),
     ...                ("point_array", POINT * 4)]
     >>>
     >>> print len(MyStruct().point_array)
     4
     >>>

インスタンスはクラスを呼び出す通常の方法で作成します:
     arr = TenPointsArrayType()
     for pt in arr:
         print pt.x, pt.y

上記のコードは`0 0'という行が並んだものを表示します。
配列の要素がゼロで初期化されているためです。

正しい型の初期化子を指定することもできます:
     >>> from ctypes import *
     >>> TenIntegers = c_int * 10
     >>> ii = TenIntegers(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
     >>> print ii
     <c_long_Array_10 object at 0x...>
     >>> for i in ii: print i,
     ...
     1 2 3 4 5 6 7 8 9 10
     >>>


File: python-lib-jp.info,  Node: ポインタ,  Next: 型変換,  Prev: 配列,  Up: ctypesチュートリアル

14.14.1.14 ポインタ
...................

ポインタのインスタンスは`ctypes'型に対して`pointer'関数を
呼び出して作成します:
     >>> from ctypes import *
     >>> i = c_int(42)
     >>> pi = pointer(i)
     >>>

ポインタインスタンスはポインタが指すオブジェクト(上の例では`i')を返す
`contents'属性を持ちます:
     >>> pi.contents
     c_long(42)
     >>>

`ctypes'はOOR (original object
return、元のオブジェクトを返すこと)ではないことに
注意してください。属性を取り出す度に、新しい同等のオブジェクトを作成していいるのです:
     >>> pi.contents is i
     False
     >>> pi.contents is pi.contents
     False
     >>>

別の`c{_}int'インスタンスがポインタのcontents属性に代入されると、
これが記憶されているメモリ位置を指すポインタに変化します:
     >>> i = c_int(99)
     >>> pi.contents = i
     >>> pi.contents
     c_long(99)
     >>>

ポインタインスタンスは整数でインデックス指定することもできます:
     >>> pi[0]
     99
     >>>

整数インデックスへ代入するとポインタが指す値が変更されます:
     >>> print i
     c_long(99)
     >>> pi[0] = 22
     >>> print i
     c_long(22)
     >>>

0ではないインデックスを使うこともできますが、Cの場合と同じように
自分が何をしているかを理解している必要があります。
任意のメモリ位置にアクセスもしくは変更できるのです。
一般的にこの機能を使うのは、C関数からポインタを受け取り、そのポインタが
単一の要素ではなく実際に配列を指していると_分かっている_場合だけです。

舞台裏では、`pointer'関数は単にポインタインスタンスを作成する
という以上のことを行っています。はじめにポインタ_型_を作成する必要があります。
これは任意の`ctypes'型を受け取る`POINTER'関数を使って行われ、新しい型を
返します:
     >>> PI = POINTER(c_int)
     >>> PI
     <class 'ctypes.LP_c_long'>
     >>> PI(42)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: expected c_long instead of int
     >>> PI(c_int(42))
     <ctypes.LP_c_long object at 0x...>
     >>>

ポインタ型を引数なしで呼び出すと`NULL'ポインタを作成します。
`NULL'ポインタは`False'ブール値を持っています:
     >>> null_ptr = POINTER(c_int)()
     >>> print bool(null_ptr)
     False
     >>>

`ctypes'はポインタの指す値を取り出すときに`NULL'かどうかを調べます
(しかし、`NULL'でないポインタの指す値の取り出す行為はPythonをクラッシュさせるでしょう):
     >>> null_ptr[0]
     Traceback (most recent call last):
         ....
     ValueError: NULL pointer access
     >>>

     >>> null_ptr[0] = 1234
     Traceback (most recent call last):
         ....
     ValueError: NULL pointer access
     >>>


File: python-lib-jp.info,  Node: 型変換,  Next: 不完全型,  Prev: ポインタ,  Up: ctypesチュートリアル

14.14.1.15 型変換
.................

たいていの場合、ctypesは厳密な型チェックを行います。これが意味するのは、
関数の`argtypes'リスト内に、もしくは、構造体定義におけるメンバーフィールドの型として
`POINTER(c{_}int)'がある場合、厳密に同じ型のインスタンスだけを
受け取るということです。このルールにはctypesが他のオブジェクトを
受け取る場合に例外がいくつかあります。例えば、ポインタ型の代わりに
互換性のある配列インスタンスを渡すことができます。このように、
`POINTER(c{_}int)'に対して、ctypesはc{_}intの配列を受け取ります:
     >>> class Bar(Structure):
     ...     _fields_ = [("count", c_int), ("values", POINTER(c_int))]
     ...
     >>> bar = Bar()
     >>> bar.values = (c_int * 3)(1, 2, 3)
     >>> bar.count = 3
     >>> for i in range(bar.count):
     ...     print bar.values[i]
     ...
     1
     2
     3
     >>>

POINTER型フィールドを`NULL'に設定するために、`None'を代入してもよい:
     >>> bar.values = None
     >>>

XXX list other conversions...

時には、非互換な型のインスタンスであることもあります。`C'では、
ある型を他の型へキャストすることができます。`ctypes'は
同じやり方で使える`cast'関数を提供しています。上で定義した`Bar'構造体は
`POINTER(c{_}int)'ポインタまたは`c{_}int'配列を`values'フィールドに
対して受け取り、他の型のインスタンスは受け取りません:
     >>> bar.values = (c_byte * 4)()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: incompatible types, c_byte_Array_4 instance instead of LP_c_long instance
     >>>

このような場合には、`cast'関数が便利です。

`cast'関数はctypesインスタンスを異なるctypesデータ型を指すポインタへ
キャストするために使えます。`cast'は二つのパラメータ、
ある種のポインタかそのポインタへ変換できるctypesオブジェクトと、
ctypesポインタ型を取ります。そして、第二引数のインスタンスを返します。
このインスタンスは第一引数と同じメモリブロックを参照しています:
     >>> a = (c_byte * 4)()
     >>> cast(a, POINTER(c_int))
     <ctypes.LP_c_long object at ...>
     >>>

したがって、`cast'を`Bar'構造体の`values'フィールドへ代入するために
使うことができます:
     >>> bar = Bar()
     >>> bar.values = cast((c_byte * 4)(), POINTER(c_int))
     >>> print bar.values[0]
     0
     >>>


File: python-lib-jp.info,  Node: 不完全型,  Next: コールバック関数,  Prev: 型変換,  Up: ctypesチュートリアル

14.14.1.16 不完全型
...................

_不完全型_はメンバーがまだ指定されていない構造体、共用体もしくは配列です。
Cでは、前方宣言により指定され、後で定義されます:
     struct cell; /* 前方宣言 */

     struct {
         char *name;
         struct cell *next;
     } cell;

ctypesコードへの直接的な変換ではこうなるでしょう。 しかし、動作しません:
     >>> class cell(Structure):
     ...     _fields_ = [("name", c_char_p),
     ...                 ("next", POINTER(cell))]
     ...
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
       File "<stdin>", line 2, in cell
     NameError: name 'cell' is not defined
     >>>

なぜなら、新しい`class cell'はクラス文自体の中では利用できないからです。
`ctypes'では、`cell'クラスを定義して、`{_}fields{_}'属性を
クラス文の後で設定することができます:
     >>> from ctypes import *
     >>> class cell(Structure):
     ...     pass
     ...
     >>> cell._fields_ = [("name", c_char_p),
     ...                  ("next", POINTER(cell))]
     >>>

試してみましょう。`cell'のインスタンスを二つ作り、互いに参照し合うように
します。最後に、つながったポインタを何度かたどります:
     >>> c1 = cell()
     >>> c1.name = "foo"
     >>> c2 = cell()
     >>> c2.name = "bar"
     >>> c1.next = pointer(c2)
     >>> c2.next = pointer(c1)
     >>> p = c1
     >>> for i in range(8):
     ...     print p.name,
     ...     p = p.next[0]
     ...
     foo bar foo bar foo bar foo bar
     >>>


File: python-lib-jp.info,  Node: コールバック関数,  Next: dllからエクスポートされている値へアクセスする,  Prev: 不完全型,  Up: ctypesチュートリアル

14.14.1.17 コールバック関数
...........................

`ctypes'はCの呼び出し可能な関数ポインタをPython呼び出し可能オブジェクトから
作成できるようにします。これらは_コールバック関数_と呼ばれることがあります。

最初に、コールバック関数のためのクラスを作る必要があります。そのクラスには
呼び出し規約、戻り値の型およびこの関数が受け取る引数の数と型についての情報があります。

CFUNCTYPEファクトリ関数は通常のcdecl呼び出し規約を用いて
コールバック関数のための型を作成します。
Windowsでは、WINFUNCTYPEファクトリ関数がstdcall呼び出し規約を用いて
コールバック関数の型を作成します。

これらのファクトリ関数はともに最初の引数に戻り値の型、
残りの引数としてコールバック関数が想定する引数の型を渡して
呼び出されます。

標準Cライブラリの`qsort'関数を使う例を示します。
これはコールバック関数の助けをかりて要素をソートするために使われます。
`qsort'は整数の配列をソートするために使われます:
     >>> IntArray5 = c_int * 5
     >>> ia = IntArray5(5, 1, 7, 33, 99)
     >>> qsort = libc.qsort
     >>> qsort.restype = None
     >>>

`qsort'はソートするデータを指すポインタ、データ配列の要素の数、
要素の一つの大きさ、およびコールバック関数である比較関数へのポインタを引数に渡して
呼び出さなければなりません。そして、コールバック関数は要素を指す二つのポインタを渡されて
呼び出され、一番目が二番目より小さいなら負の数を、等しいならゼロを、
それ以外なら正の数を返さなければなりません。

コールバック関数は整数へのポインタを受け取り、整数を
返す必要があります。まず、コールバック関数のための`type'を 作成します:
     >>> CMPFUNC = CFUNCTYPE(c_int, POINTER(c_int), POINTER(c_int))
     >>>

コールバック関数のはじめての実装なので、受け取った引数を単純に表示して、
0を返します(漸進型開発(incremental development)です ;-):
     >>> def py_cmp_func(a, b):
     ...     print "py_cmp_func", a, b
     ...     return 0
     ...
     >>>

Cの呼び出し可能なコールバック関数を作成します:
     >>> cmp_func = CMPFUNC(py_cmp_func)
     >>>

そうすると、準備完了です:
     >>> qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +WINDOWS
     py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...>
     py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...>
     py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...>
     py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...>
     py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...>
     py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...>
     py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...>
     py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...>
     py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...>
     py_cmp_func <ctypes.LP_c_long object at 0x00...> <ctypes.LP_c_long object at 0x00...>
     >>>

ポインタの中身にアクセスする方法がわかっているので、コールバック関数を再定義しましょう:
     >>> def py_cmp_func(a, b):
     ...     print "py_cmp_func", a[0], b[0]
     ...     return 0
     ...
     >>> cmp_func = CMPFUNC(py_cmp_func)
     >>>

Windowsでの実行結果です:
     >>> qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +WINDOWS
     py_cmp_func 7 1
     py_cmp_func 33 1
     py_cmp_func 99 1
     py_cmp_func 5 1
     py_cmp_func 7 5
     py_cmp_func 33 5
     py_cmp_func 99 5
     py_cmp_func 7 99
     py_cmp_func 33 99
     py_cmp_func 7 33
     >>>

linuxではソート関数がはるかに効率的に動作しており、
実施する比較の数が少ないように見えるのが不思議です:
     >>> qsort(ia, len(ia), sizeof(c_int), cmp_func) # doctest: +LINUX
     py_cmp_func 5 1
     py_cmp_func 33 99
     py_cmp_func 7 33
     py_cmp_func 5 7
     py_cmp_func 1 7
     >>>

ええ、ほぼ完成です！最終段階は、実際に二つの要素を比較して
実用的な結果を返すことです:
     >>> def py_cmp_func(a, b):
     ...     print "py_cmp_func", a[0], b[0]
     ...     return a[0] - b[0]
     ...
     >>>

Windowsでの最終的な実行結果です:
     >>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) # doctest: +WINDOWS
     py_cmp_func 33 7
     py_cmp_func 99 33
     py_cmp_func 5 99
     py_cmp_func 1 99
     py_cmp_func 33 7
     py_cmp_func 1 33
     py_cmp_func 5 33
     py_cmp_func 5 7
     py_cmp_func 1 7
     py_cmp_func 5 1
     >>>

Linuxでは:
     >>> qsort(ia, len(ia), sizeof(c_int), CMPFUNC(py_cmp_func)) # doctest: +LINUX
     py_cmp_func 5 1
     py_cmp_func 33 99
     py_cmp_func 7 33
     py_cmp_func 1 7
     py_cmp_func 5 7
     >>>

Windowsの`qsort'関数はlinuxバージョンより多く比較する必要があることがわかり、
非常におもしろいですね！

簡単に確認できるように、今では配列はソートされています:
     >>> for i in ia: print i,
     ...
     1 5 7 33 99
     >>>

*コールバック関数についての重要な注意事項:*

Cコードから使われる限り、CFUNCTYPEオブジェクトへの参照を確実に保持してください。
`ctypes'は保持しません。もしあなたがやらなければ、オブジェクトはゴミ集めされてしまい、
コールバックしたときにあなたのプログラムをクラッシュさせるかもしれません。


File: python-lib-jp.info,  Node: dllからエクスポートされている値へアクセスする,  Next: 予期しないこと,  Prev: コールバック関数,  Up: ctypesチュートリアル

14.14.1.18 dllからエクスポートされている値へアクセスする
........................................................

dllは関数だけでなく変数をエクスポートしていることもあります。
Pythonライブラリにある例としては`Py{_}OptimizeFlag'、
起動時の`-O'または`-OO'フラグに依存して、 0,
1または2が設定される整数があります。

`ctypes'は型の`in{_}dll'クラスメソッドを使ってこのように
値にアクセスできます。PYTHONAPIはPython C apiへのアクセスできるように
するための予め定義されたシンボルです:
     >>> opt_flag = c_int.in_dll(pythonapi, "Py_OptimizeFlag")
     >>> print opt_flag
     c_long(0)
     >>>

インタープリタが`-O'を指定されて動き始めた場合、サンプルは
`c{_}long(1)'を表示するでしょうし、`-OO'が指定されたならば
`c{_}long(2)'を表示するでしょう。

ポインタの使い方を説明する拡張例では、Pythonがエクスポートする
`PyImport{_}FrozenModules'ポインタにアクセスします。

Pythonドキュメントからの引用すると: _このポインタは
メンバーがすべてNULLまたはゼロであるレコードを最後に持つ"struct
{_}frozen"レコードの 配列を指すように初期化されます。
フローズン(frozen)モジュールがインポートされたとき、このテーブルから探索されます。
サードパーティ製コードは動的に作成されたフローズンモジュールの集合を提供するためと、
これにいたずらすることができます。_

これで、このポインタを操作することが役に立つことを証明できるでしょう。
例の大きさを制限するために、このテーブルを`ctypes'を使って読む方法だけを
示します:
     >>> from ctypes import *
     >>>
     >>> class struct_frozen(Structure):
     ...     _fields_ = [("name", c_char_p),
     ...                 ("code", POINTER(c_ubyte)),
     ...                 ("size", c_int)]
     ...
     >>>

私たちは`struct {_}frozen'データ型を定義済みなので、このテーブルを指す
ポインタを得ることができます:
     >>> FrozenTable = POINTER(struct_frozen)
     >>> table = FrozenTable.in_dll(pythonapi, "PyImport_FrozenModules")
     >>>

`table'が`struct{_}frozen'レコードの配列への`pointer'なので、
その配列に対して反復処理を行えます。しかし、ループが確実に終了するように
する必要があります。なぜなら、ポインタに大きさの情報がないからです。
遅かれ早かれ、アクセス違反か何かでクラッシュすることになるでしょう。
NULLエントリに達したときはループを抜ける方が良い:
     >>> for item in table:
     ...    print item.name, item.size
     ...    if item.name is None:
     ...        break
     ...
     __hello__ 104
     __phello__ -104
     __phello__.spam 104
     None 0
     >>>

標準Pythonはフローズンモジュールとフローズンパッケージ(負のサイズのメンバーで
表されています)を持っているという事実はあまり知られておらず、テストにだけ
使われています。例えば、`import {_}{_}hello{_}{_}'を試してみてください。


File: python-lib-jp.info,  Node: 予期しないこと,  Next: 可変サイズのデータ型,  Prev: dllからエクスポートされている値へアクセスする,  Up: ctypesチュートリアル

14.14.1.19 予期しないこと
.........................

`ctypes'には別のことを期待しているのに実際に起きる起きることは違うという場合が
あります。

次に示す例について考えてみてください:
     >>> from ctypes import *
     >>> class POINT(Structure):
     ...     _fields_ = ("x", c_int), ("y", c_int)
     ...
     >>> class RECT(Structure):
     ...     _fields_ = ("a", POINT), ("b", POINT)
     ...
     >>> p1 = POINT(1, 2)
     >>> p2 = POINT(3, 4)
     >>> rc = RECT(p1, p2)
     >>> print rc.a.x, rc.a.y, rc.b.x, rc.b.y
     1 2 3 4
     >>> # now swap the two points
     >>> rc.a, rc.b = rc.b, rc.a
     >>> print rc.a.x, rc.a.y, rc.b.x, rc.b.y
     3 4 3 4
     >>>

うーん、最後の文に`3 4 1 2'と表示されることを期待していたはずです。
何が起きたのでしょうか？上の行の`rc.a, rc.b = rc.b, rc.a'の
各段階はこのようになります:
     >>> temp0, temp1 = rc.b, rc.a
     >>> rc.a = temp0
     >>> rc.b = temp1
     >>>

`temp0'と`temp1'は前記の`rc'オブジェクトの内部バッファで
まだ使われているオブジェクトです。したがって、`rc.a = temp0'を実行すると
`temp0'のバッファ内容が`rc'のバッファへコピーされます。さらに、
これは`temp1'の内容を変更します。そのため、最後の代入`rc.b = temp1'は、
期待する結果にはならないのです。

Structure、UnionおよびArrayのサブオブジェクトを取り出しても、そのサブオブジェクトが
_コピー_されるわけではなく、ルートオブジェクトの内部バッファにアクセスする
ラッパーオブジェクトを取り出すことを覚えておいてください。

期待とは違う振る舞いをする別の例はこれです:
     >>> s = c_char_p()
     >>> s.value = "abc def ghi"
     >>> s.value
     'abc def ghi'
     >>> s.value is s.value
     False
     >>>

なぜ`False'と表示されるのでしょうか？ctypesインスタンスは
メモリの内容にアクセスするいくつかの記述子付きメモリを含むオブジェクトです。
メモリブロックにPythonオブジェクトを保存してもオブジェクト自身が保存
される訳ではなく、オブジェクトの`contents'が保存されます。
そのcontentsに再アクセスすると新しいPythonオブジェクトがその度に作られます。


File: python-lib-jp.info,  Node: 可変サイズのデータ型,  Next: バグ、ToDoおよび実装されていないもの,  Prev: 予期しないこと,  Up: ctypesチュートリアル

14.14.1.20 可変サイズのデータ型
...............................

`ctypes'は可変サイズの配列と構造体をサポートしています
(バージョン0.9.9.7で追加されました)。

`resize'関数は既存のctypesオブジェクトのメモリバッファのサイズを
変更したい場合に使えます。この関数は第一引数にオブジェクト、第二引数に
要求されたサイズをバイト単位で指定します。メモリブロックはオブジェクト型で
指定される通常のメモリブロックより小さくすることはできません。
これをやろうとすると、`ValueError'が発生します:
     >>> short_array = (c_short * 4)()
     >>> print sizeof(short_array)
     8
     >>> resize(short_array, 4)
     Traceback (most recent call last):
         ...
     ValueError: minimum size is 8
     >>> resize(short_array, 32)
     >>> sizeof(short_array)
     32
     >>> sizeof(type(short_array))
     8
     >>>

これはこれで上手くいっていますが、この配列の追加した要素へ
どうやってアクセスするのでしょうか？この型は要素の数が4個であると
まだ認識しているので、他の要素にアクセスするとエラーになります:
     >>> short_array[:]
     [0, 0, 0, 0]
     >>> short_array[7]
     Traceback (most recent call last):
         ...
     IndexError: invalid index
     >>>

`ctypes'で可変サイズのデータ型を使うもう一つの方法は、
必要なサイズが分かった後にPythonの動的性質を使って
一つ一つデータ型を(再)定義することです。


File: python-lib-jp.info,  Node: バグ、ToDoおよび実装されていないもの,  Prev: 可変サイズのデータ型,  Up: ctypesチュートリアル

14.14.1.21 バグ、ToDoおよび実装されていないもの
...............................................

列挙型は実装されていません。ベースクラスに`c{_}int'を使うことで
簡単に実装できます。

`long double'は実装されていません。


File: python-lib-jp.info,  Node: ctypesリファレンス,  Prev: ctypesチュートリアル,  Up: ctypes

14.14.2 ctypesリファレンス
--------------------------

* Menu:

* 共有ライブラリを見つける::
* 共有ライブラリをロードする::
* 外部関数::
* 関数プロトタイプ::
* ユーティリティ関数::
* データ型 2::
* 基本データ型::
* 標準データ型::
* 配列とポインタ::


File: python-lib-jp.info,  Node: 共有ライブラリを見つける,  Next: 共有ライブラリをロードする,  Prev: ctypesリファレンス,  Up: ctypesリファレンス

14.14.2.1 共有ライブラリを見つける
..................................

コンパイルされる言語でプログラミングしている場合、共有ライブラリはプログラムを
コンパイル/リンクしているときと、そのプログラムが動作しているときにアクセスされます。

ctypesライブラリローダーはプログラムが動作しているときのように振る舞い、
ランタイムローダーを直接呼び出すのに対し、`find{_}library'関数の目的は
コンパイラが行うのと似た方法でライブラリを探し出すことです
(複数のバージョンの共有ライブラリがあるプラットホームでは、
一番最近に見つかったものがロードされます)。

`ctypes.util'モジュールはロードするライブラリを決めるのに
役立つ関数を提供します。

`find_library(name)'
     ライブラリを見つけてパス名を返そうと試みます。NAMEは
     LIBのような接頭辞、`.so'、`.dylib'のような接尾辞、
     あるいは、バージョン番号が何も付いていないライブラリの名前です
     (これは posix リンカのオプション`-l')に使われている形式です)。
     もしライブラリが見つからなければ、`None'を返します。

厳密な機能はシステムに依存します。

Linuxでは、`find{_}library'はライブラリファイルを見つけるために
外部プログラム (/sbin/ldcon?g、gccおよびobjdump)を実行しようとします。
ライブラリファイルのファイル名を返します。いくつか例があります:
     >>> from ctypes.util import find_library
     >>> find_library("m")
     'libm.so.6'
     >>> find_library("c")
     'libc.so.6'
     >>> find_library("bz2")
     'libbz2.so.1.0'
     >>>

OS Xでは、`find{_}library'はライブラリの位置を探すために、
予め定義された複数の命名方法とパスを試し、成功すればフルパスを返します:
     >>> from ctypes.util import find_library
     >>> find_library("c")
     '/usr/lib/libc.dylib'
     >>> find_library("m")
     '/usr/lib/libm.dylib'
     >>> find_library("bz2")
     '/usr/lib/libbz2.dylib'
     >>> find_library("AGL")
     '/System/Library/Frameworks/AGL.framework/AGL'
     >>>

Windows では、`find{_}library'はシステムの探索パスに沿って探し、
フルパスを返します。しかし、予め定義された命名方法がないため、
`find{_}library("c")'のような呼び出しは失敗し、 `None'を返します。

もし`ctypes'を使って共有ライブラリをラップするなら、
実行時にライブラリを探すために`find{_}library'を使う代わりに、
開発時に共有ライブラリ名をを決めて、ラッパーモジュールに
ハードコードした方が良い_かもしれません_。


File: python-lib-jp.info,  Node: 共有ライブラリをロードする,  Next: 外部関数,  Prev: 共有ライブラリを見つける,  Up: ctypesリファレンス

14.14.2.2 共有ライブラリをロードする
....................................

共有ライブラリをPythonプロセスへロードする方法はいくつかあります。
一つの方法は下記のクラスの一つをインスタンス化することです:

`CDLL(name, mode=DEFAULT_MODE, handle=None)'
     このクラスのインスタンスはロードされた共有ライブラリをあらわします。
     これらのライブラリの関数は標準 C 呼び出し規約を使用し、
     `int'を返すと仮定されます。

`OleDLL(name, mode=DEFAULT_MODE, handle=None)'
     Windows用: このクラスのインスタンスはロードされた共有ライブラリを
     あらわします。これらのライブラリの関数は`stdcall'呼び出し規約を使用し、
     windows固有の`HRESULT'コードを返すと仮定されます。
     `HRESULT'値には関数呼び出しが失敗したのか成功したのかを
     特定する情報とともに、補足のエラーコードが含まれます。
     戻り値が失敗を知らせたならば、`WindowsError'が自動的に 発生します。

`WinDLL(name, mode=DEFAULT_MODE, handle=None)'
     Windows用: このクラスのインスタンスはロードされた共有ライブラリを
     あらわします。これらのライブラリの関数は`stdcall'呼び出し規約を使用し、
     デフォルトでは`int'を返すと仮定されます。

     Windows CEでは標準呼び出し規約だけが使われます。便宜上、
     このプラットホームでは、`WinDLL'と`OleDLL'が
     標準呼び出し規約を使用します。

これらのライブラリがエクスポートするどの関数でも呼び出す前に Python GIL
は解放され、後でまた必要になります。

`PyDLL(name, mode=DEFAULT_MODE, handle=None)'
     Python GILが関数呼び出しの間解放_されず_、関数実行の後にPython
     エラーフラグが
     チェックされるということを除けば、このクラスのインスタンスは
     `CDLL'インスタンスのように振る舞います。エラーフラグがセットされた場合、
     Python 例外が発生します。

     要するに、これはPython C
     api関数を直接呼び出すのに便利だというだけです。

これらすべてのクラスは少なくとも一つの引数、すなわちロードする共有ライブラリの
パスを渡して呼び出すことでインスタンス化されます。すでにロード済みの
共有ライブラリへのハンドルがあるなら、`handle'名前付き引数として
渡すことができます。土台となっているプラットホームの`dlopen'または
`LoadLibrary'関数がプロセスへライブラリをロードするために使われ、
そのライブラリに対するハンドルを得ます。

MODEパラメータはライブラリがどうやってロードされたかを特定するために
使うことができます。詳細は、`dlopen(3)'マニュアルページを参考にしてください。
WindowsではMODEは無視されます。

`RTLD_GLOBAL'
     MODEパラメータとして使うフラグ。このフラグが利用できないプラットホームでは、
     整数のゼロと定義されています。

`RTLD_LOCAL'
     MODEパラメータとして使うフラグ。これが利用できないプラットホームでは、
     RTLD{_}GLOBALと同様です。

`DEFAULT_MODE'
     共有ライブラリをロードするために使われるデフォルトモード。 OSX
     10.3ではRTLD{_}GLOBALであり、そうでなければ
     RTLD{_}LOCALと同じです。

これらのクラスのインスタンスには公開メソッドがありません。けれども、
`{_}{_}getattr{_}{_}'と`{_}{_}getitem{_}{_}'は
特別ははたらきをします。その共有ライブラリがエクスポートする関数に
添字を使って属性としてアクセスできるのです。`{_}{_}getattr{_}{_}'と
`{_}{_}getitem{_}{_}'のどちらもが結果をキャッシュし、
そのため常に同じオブジェクトを返すことに注意してください。

次に述べる公開属性が利用できます。それらの名前はエクスポートされた関数名に
衝突しないように下線で始まります:

`_handle'
     ライブラリへのアクセスに用いられるシステムハンドル。

`_name'
     コンストラクタに渡されたライブラリの名前。

共有ライブラリは(`LibraryLoader'クラスのインスタンスである)
前もって作られたオブジェクトの一つを使うことによってロードすることもできます。
それらの`LoadLibrary'メソッドを呼び出すか、ローダーインスタンスの属性として
ライブラリを取り出すかのどちらかによりロードします。

`LibraryLoader(dlltype)'
     共有ライブラリをロードするクラス。`dlltype'は`CDLL'、`PyDLL'、
     `WinDLL'もしくは`OleDLL'型の一つであるべきです。

     `{_}{_}getattr{_}{_}'は特別なはたらきをします:
     ライブラリローダーインスタンスの
     属性として共有ライブラリにアクセスするとそれがロードされるということを可能にします。
     結果はキャッシュされます。そのため、繰り返し属性アクセスを行うと
     いつも同じライブラリが返されます。

`LoadLibrary(name)'
     共有ライブラリをプロセスへロードし、それを返します。
     このメソッドはライブラリの新しいインスタンスを常に返します。

これらの前もって作られたライブラリローダーを利用することができます:

`cdll'
     `CDLL'インスタンスを作ります。

`windll'
     Windows用: `WinDLL'インスタンスを作ります。

`oledll'
     Windows用: `OleDLL'インスタンスを作ります。

`pydll'
     `PyDLL'インスタンスを作ります。

C Python api に直接アクセするために、すぐに使用できる
Python共有ライブラリオブジェクトが用意されています:

`pythonapi'
     属性としてPython C api関数を公開する`PyDLL'のインスタンス。
     これらすべての関数はC
     `int'を返すと仮定されますが、もちろん常に正しいとは
     限りません。そのため、これらの関数を使うためには
     正しい`restype'属性を代入しなければなりません。


File: python-lib-jp.info,  Node: 外部関数,  Next: 関数プロトタイプ,  Prev: 共有ライブラリをロードする,  Up: ctypesリファレンス

14.14.2.3 外部関数
..................

前節で説明した通り、外部関数はロードされた共有ライブラリの属性として
アクセスできます。デフォルトではこの方法で作成された関数オブジェクトは
どんな数の引数でも受け取り、引数としてどんな
ctypesデータのインスタンスをも
受け取り、そして、ライブラリローダーが指定したデフォルトの結果の値の型を
返します。関数オブジェクトはプライベートクラスのインスタンスです:

`_FuncPtr'
     Cの呼び出し可能外部関数のためのベースクラス。

外部関数のインスタンスも C 互換データ型です。それらは
Cの関数ポインタを表しています。

この振る舞いは外部関数オブジェクトの特別な属性に代入することによって、
カスタマイズすることができます。

`restype'
     外部関数の結果の型を指定するためにctypes型を代入する。
     何も返さない関数を表す`void'に対しては`None'を 使います。

     ctypes 型ではない呼び出し可能な Python
     オブジェクトを代入することは可能です。 このような場合、関数がC
     `int'を返すと仮定され、呼び出し可能オブジェクトは
     この整数を引数に呼び出されます。さらに処理を行ったり、エラーチェックをしたり
     できるようにするためです。これの使用は推奨されません。より柔軟な後処理や
     エラーチェックのためには restype として ctypes
     型を使い、`errcheck'属性へ
     呼び出し可能オブジェクトを代入してください。

`argtypes'
     関数が受け取る引数の型を指定するためにctypes型のタプルを代入します。
     `stdcall'呼び出し規約をつかう関数はこのタプルの長さと同じ数の引数で
     呼び出されます。
     その上、C呼び出し規約をつかう関数は追加の不特定の引数も取ります。

     外部関数が呼ばれたとき、それぞれの実引数は`argtypes'タプルの要素の
     `from{_}param'クラスメソッドへ渡されます。このメソッドは実引数を
     外部関数が受け取るオブジェクトに合わせて変えられるようにします。
     例えば、`argtypes'タプルの`c{_}char{_}p'要素は、
     ctypes変換規則にしたがって引数として渡されたユニコード文字列を
     バイト文字列へ変換するでしょう。

     新: ctypes型でない要素をargtypesに入れることができますが、
     個々の要素は引数として使える値(整数、文字列、ctypesインスタンス)を返す
     `from{_}param'メソッドを持っていなければなりません。
     これにより関数パラメータとしてカスタムオブジェクトを
     適合するように変更できるアダプタが定義可能となります。

`errcheck'
     Python関数または他の呼び出し可能オブジェクトをこの属性に代入します。
     呼び出し可能オブジェクトは三つ以上の引数とともに呼び出されます。

`callable(result, func, arguments)'
     `result'は外部関数が返すもので、`restype'属性で 指定されます。

     `func'は外部関数オブジェクト自身で、これにより複数の関数の処理結果を
     チェックまたは後処理するために、同じ呼び出し可能オブジェクトを再利用
     できるよになります。

     `arguments'は関数呼び出しに最初に渡されたパラメータが入ったタプルです。
     これにより使われた引数に基づた特別な振る舞いをさせることができるようになります。

     この関数が返すオブジェクトは外部関数呼び出しから返された値でしょう。
     しかし、戻り値をチェックして、外部関数呼び出しが失敗しているなら例外を
     発生させることもできます。

`ArgumentError()'
     この例外は外部関数呼び出しが渡された引数を変換できなかったときに
     発生します。


File: python-lib-jp.info,  Node: 関数プロトタイプ,  Next: ユーティリティ関数,  Prev: 外部関数,  Up: ctypesリファレンス

14.14.2.4 関数プロトタイプ
..........................

外部関数は関数プロトタイプをインスタンス化することによって作成されます。
関数プロトタイプはCの関数プロトタイプと似ています。実装を定義せずに、
関数(戻り値、引数の型、呼び出し規約)を記述します。
ファクトリ関数は関数に要求する戻り値の型と引数の型とともに呼び出されます。

`CFUNCTYPE(restype, *argtypes)'
     返された関数プロトタイプは標準C呼び出し規約をつかう関数を作成します。
     関数は呼び出されている間GILを解放します。

`WINFUNCTYPE(restype, *argtypes)'
     Windows用: 返された関数プロトタイプは`stdcall'呼び出し規約を
     つかう関数を作成します。ただし、`WINFUNCTYPE'が
     `CFUNCTYPE'と同じであるWindows CEを除く。
     関数は呼び出されている間GILを解放します。

`PYFUNCTYPE(restype, *argtypes)'
     返された関数プロトタイプはPython呼び出し規約をつかう関数を作成します。
     関数は呼び出されている間GILを解放_しません_。

ファクトリ関数によって作られた関数プロトタイプは呼び出しのパラメータの型と数に依存した
別の方法でインスタンス化することができます。

`prototype(address)'
     指定されたアドレスの外部関数を返します。

`prototype(callable)'
     Pythonの`callable'からCの呼び出し可能関数(コールバック関数)を作成します。

`prototype(func_spec[, paramflags])'
     共有ライブラリがエクスポートしている外部関数を返します。
     `func{_}spec'は2要素タプル`(name{_}or{_}ordinal,
     library)'でなければなりません。
     第一要素はエクスポートされた関数の名前である文字列、またはエクスポートされた関数の
     序数である小さい整数です。第二要素は共有ライブラリインスタンスです。

`prototype(vtbl_index, name[, paramflags[, iid]])'
     COMメソッドを呼び出す外部関数を返します。
     `vtbl{_}index'は仮想関数テーブルのインデックスで、非負の小さい整数です。
     NAMEはCOMメソッドの名前です。IIDはオプションの
     インターフェイス識別子へのポインタで、拡張されたエラー情報の提供のために
     使われます。

     COMメソッドは特殊な呼び出し規約を用います。このメソッドは
     `argtypes'タプルに指定されたパラメータに加えて、
     第一引数としてCOMインターフェイスへのポインタを必要とします。

オプションのPARAMFLAGSパラメータは上述した機能より多機能な
外部関数ラッパーを作成します。

PARAMFLAGSは`argtypes'と同じ長さのタプルでなければならない。

このタプルの個々の要素はパラメータについてのより詳細な情報を持ち、
1、2もしくは3要素を含むタプルでなければならない。

第一要素はパラメータについてのフラグを含んだ整数です。

`1'
     入力パラメータを関数に指定します。

`2'
     出力パラメータ。外部関数が値を書き込みます。

`4'
     デフォルトで整数ゼロになる入力パラメータ。

オプションの第二要素はパラメータ名の文字列です。これが指定された場合は、
外部関数を名前付きパラメータで呼び出すことができます。

オプションの第三要素はこのパラメータのデフォルト値です。

この例では、デフォルトパラメータと名前付き引数をサポートするために
Windows `MessageBoxA'関数をラップする方法を示します。
windowsヘッダファイルのCの宣言はこれです:
     WINUSERAPI int WINAPI
     MessageBoxA(
         HWND hWnd ,
         LPCSTR lpText,
         LPCSTR lpCaption,
         UINT uType);

`ctypes'を使ってラップします:

          >>> from ctypes import c_int, WINFUNCTYPE, windll
          >>> from ctypes.wintypes import HWND, LPCSTR, UINT
          >>> prototype = WINFUNCTYPE(c_int, HWND, LPCSTR, LPCSTR, UINT)
          >>> paramflags = (1, "hwnd", 0), (1, "text", "Hi"), (1, "caption", None), (1, "flags", 0)
          >>> MessageBox = prototype(("MessageBoxA", windll.user32), paramflags)
          >>>


今はMessageBox外部関数をこのような方法で呼び出すことができます:
     >>> MessageBox()
     >>> MessageBox(text="Spam, spam, spam")
     >>> MessageBox(flags=2, text="foo bar")
     >>>

二番目の例は出力パラメータについて説明します。win32の`GetWindowRect'関数は、
指定されたウィンドウの大きさを呼び出し側が与える`RECT'構造体へコピーすることで
取り出します。 Cの宣言はこうです:
     WINUSERAPI BOOL WINAPI
     GetWindowRect(
          HWND hWnd,
          LPRECT lpRect);

`ctypes'を使ってラップします:

          >>> from ctypes import POINTER, WINFUNCTYPE, windll, WinError
          >>> from ctypes.wintypes import BOOL, HWND, RECT
          >>> prototype = WINFUNCTYPE(BOOL, HWND, POINTER(RECT))
          >>> paramflags = (1, "hwnd"), (2, "lprect")
          >>> GetWindowRect = prototype(("GetWindowRect", windll.user32), paramflags)
          >>>


もし単一の値もしくは一つより多い場合には出力パラメータ値が入ったタプルがあるならば、
出力パラメータを持つ関数は自動的に出力パラメータ値を返すでしょう。
そのため、今はGetWindowRect関数は呼び出されたときにRECTインスタンスを返します。

さらに出力処理やエラーチェックを行うために、出力パラメータを`errcheck'プロトコルと
組み合わせることができます。win32 `GetWindowRect'
api関数は成功したか失敗したかを
知らせるために`BOOL'を返します。そのため、この関数はエラーチェックを行って、
api呼び出しが失敗した場合に例外を発生させることができます:
     >>> def errcheck(result, func, args):
     ...     if not result:
     ...         raise WinError()
     ...     return args
     >>> GetWindowRect.errcheck = errcheck
     >>>

`errcheck'関数が変更なしに受け取った引数タプルを返したならば、
`ctypes'は出力パラメータに対して通常の処理を続けます。
`RECT'インスタンスの代わりにwindow座標のタプルを返してほしいなら、
関数のフィールドを取り出し、代わりにそれらを返すことができます。
通常処理はもはや行われないでしょう:
     >>> def errcheck(result, func, args):
     ...     if not result:
     ...         raise WinError()
     ...     rc = args[1]
     ...     return rc.left, rc.top, rc.bottom, rc.right
     >>>
     >>> GetWindowRect.errcheck = errcheck
     >>>


File: python-lib-jp.info,  Node: ユーティリティ関数,  Next: データ型 2,  Prev: 関数プロトタイプ,  Up: ctypesリファレンス

14.14.2.5 ユーティリティ関数
............................

`addressof(obj)'
     メモリバッファのアドレスを示す整数を返します。`obj'は
     ctypes型のインスタンスでなければなりません。

`alignment(obj_or_type)'
     ctypes型のアライメントの必要条件を返します。
     `obj{_}or{_}type'はctypes型またはインスタンスでなければなりません。

`byref(obj)'
     `obj'(ctypes型のインスタンスでなければならない)への軽量ポインタを返します。
     返されるオブジェクトは外部関数呼び出しのパラメータとしてのみ使用できます。
     `pointer(obj)'と似たふるまいをしますが、作成が非常に速く行えます。

`cast(obj, type)'
     この関数はCのキャスト演算子に似ています。`obj'と同じメモリブロックを
     指している`type'の新しいインスタンスを返します。
     `type'はポインタ型でなければならず、`obj'は
     ポインタとして解釈できるオブジェクトでなければならない。

`create_string_buffer(init_or_size[, size])'
     この関数は変更可能な文字バッファを作成します。返されるオブジェクトは
     `c{_}char'のctypes配列です。

     `init{_}or{_}size'は配列のサイズを指定する整数もしくは
     配列要素を初期化するために使われる文字列である必要があります。

     第一引数として文字列が指定された場合は、バッファが文字列の長さより一要素分大きく
     作られます。配列の最後の要素がNUL終端文字であるためです。
     文字列の長さを使うべきでない場合は、配列のサイズを指定するために
     整数を第二引数として渡すことができます。

     第一引数がユニコード文字列ならば、ctypes変換規則にしたがい
     8ビット文字列へ変換されます。

`create_unicode_buffer(init_or_size[, size])'
     この関数は変更可能なユニコード文字バッファを作成します。
     返されるオブジェクトは`c{_}wchar'のctypes配列です。

     `init{_}or{_}size'は配列のサイズを指定する整数もしくは
     配列要素を初期化するために使われるユニコード文字列です。

     第一引数としてユニコード文字列が指定された場合は、バッファが文字列の長さより
     一要素分大きく作られます。配列の最後の要素がNUL終端文字であるためです。
     文字列の長さを使うべきでない場合は、配列のサイズを指定するために
     整数を第二引数として渡すことができます。

     第一引数が8ビット文字列ならば、ctypes変換規則にしたがい
     ユニコード文字列へ変換されます。

`DllCanUnloadNow()'
     Windows用: この関数はctypesをつかってインプロセスCOMサーバーを
     実装できるようにするためのフックです。{_}ctypes拡張dllが
     エクスポートしているDllCanUnloadNow関数から呼び出されます。

`DllGetClassObject()'
     Windows用: この関数はctypesをつかってインプロセスCOMサーバーを
     実装できるようにするためのフックです。`{_}ctypes'拡張dllが
     エクスポートしているDllGetClassObject関数から呼び出されます。

`FormatError([code])'
     Windows用:
     エラーコードの説明文を返す。エラーコードが指定されない場合は、
     Windows
     api関数GetLastErrorを呼び出して、もっとも新しいエラーコードが
     使われます。

`GetLastError()'
     Windows用: 呼び出し側のスレッド内でWindowsによって設定された
     最新のエラーコードを返します。

`memmove(dst, src, count)'
     標準Cのmemmoveライブラリ関数と同じもの: COUNTバイトを
     `src'からDSTへコピーします。DSTと`src'は
     ポインタへ変換可能な整数またはctypesインスタンスでなければなりません。

`memset(dst, c, count)'
     標準Cのmemsetライブラリ関数と同じもの: アドレスDSTの
     メモリブロックを値CをCOUNTバイト分書き込みます。
     DSTはアドレスを指定する整数またはctypesインスタンスである
     必要があります。

`POINTER(type)'
     このファクトリ関数は新しいctypesポインタ型を作成して返します。
     ポインタ型はキャッシュされ、内部で再利用されます。したがって、この関数を
     繰り返し呼び出してもコストは小さいです。型はctypes型でなければなりません。

`pointer(obj)'
     この関数は`obj'を指す新しいポインタインスタンスを作成します。
     戻り値はPOINTER(type(obj))型のオブジェクトです。

     注意:
     外部関数呼び出しへオブジェクトへのポインタを渡したいだけなら、
     はるかに高速な`byref(obj)'を使うべきです。

`resize(obj, size)'
     この関数はobjの内部メモリバッファのサイズを変更します。
     objはctypes型のインスタンスでなければなりません。
     バッファをsizeof(type(obj))で与えられるオブジェクト型の
     本来のサイズより小さくすることはできませんが、バッファを
     拡大することはできます。

`set_conversion_mode(encoding, errors)'
     この関数は8ビット文字列とユニコード文字列の間で変換するときに
     使われる規則を設定します。encodingは`'utf-8''や`'mbcs''のような
     エンコーディングを指定する文字列でなければなりません。
     errorsはエンコーディング/デコーディングエラーについての
     エラー処理を指定する文字列でなければなりません。
     指定可能な値の例としては、`"strict"'、`"replace"'または
     `"ignore"'があります。

     `set{_}conversion{_}mode'は以前の変換規則を含む2要素タプルです。
     windowsでは初期の変換規則は`('mbcs', 'ignore')'であり、
     他のシステムでは`('ascii', 'strict')'です。

`sizeof(obj_or_type)'
     ctypes型もしくはインスタンスのメモリバッファのサイズをバイト単位で
     返します。Cの`sizeof()'関数と同じ動作です。

`string_at(address[, size])'
     この関数はメモりアドレスaddressから始まる文字列を返します。
     sizeが指定された場合はサイズとして使われます。指定されなければ、
     文字列がゼロ終端されていると仮定します。

`WinError(code=None, descr=None)'
     Windows用:
     この関数はctypesの中でもおそらく最悪な名前がつけれたものです。
     WindowsErrorのインスタンスを作成します。CODEが指定されないならば、
     エラーコードを決めるために`GetLastError'が呼び出されます。
     `descr'が指定されないならば、`FormatError'が
     エラーの説明文を得るために呼び出されます。

`wstring_at(address)'
     この関数はユニコード文字列としてメモリアドレス`address'から始まる
     ワイドキャラクタ文字列を返します。`size'が指定されたならば、
     文字列の文字数として使われます。指定されなければ、
     文字列がゼロ終端されていると仮定します。


File: python-lib-jp.info,  Node: データ型 2,  Next: 基本データ型,  Prev: ユーティリティ関数,  Up: ctypesリファレンス

14.14.2.6 データ型
..................

`_CData'
     この非公開クラスはすべてのctypesデータ型の共通のベースクラスです。
     他のものに取り込まれることで、すべてのctypes型インスタンスがはC互換データを
     保持するメモリブロックを内部に持ちます。
     メモリブロックのアドレスを`addressof()'ヘルパー関数が
     返さします。別のインスタンス変数は`{_}objects'として
     公開されます。これはメモリブロックがポインタを含む場合に
     存続し続ける必要のある他のPythonオブジェクトを含んでいます。

ctypesデータ型の共通メソッド、すべてのクラスメソッドが存在します(正確には、
メタクラスのメソッドです):

`from_address(address)'
     このメソッドはaddressによって指定されたメモリを使用している
     ctypes型のインスタンスを返します。addressは整数でなければならない。

`from_param(obj)'
     このメソッドはobjをctypes型に適合させます。その型が外部関数の
     `argtypes'タプルに存在する場合に、実際の外部関数呼び出しに
     使われるオブジェクトを与えて呼び出します。
     関数呼び出しパラメータとして使えるオブジェクトを返さなければなりません。

     すべてのctypesデータ型にはこのクラスメソッドのデフォルト実装が存在し、
     通常は`obj'がその型のインスタンスならそのままを返します。
     いくつかの型は他のオブジェクトも受け取ります。

`in_dll(library, name)'
     このメソッドは共有ライブラリがエクスポートするctypes型のインスタンスを
     返します。NAMEはデータをエクスポートしているシンボル名であり、
     LIBRARYはロードされた共有ライブラリです。

ctypesデータ型に共通のインスタンス変数:

`_b_base_'
     時にはctypesデータインスタンスは自信が含まれるメモリブロックを持たないことがあります。
     その代わり、ベースオブジェクトのメモリブロックの一部を共有します。
     `{_}b{_}base{_}'読み出し専用メンバーがメモリブロックを保有している
     ルートctypesオブジェクトです。

`_b_needsfree_'
     ctypesデータインスタンスが確保したメモリブロック自体を保有している場合、
     この読み出し専用変数は真であり、それ以外では偽です。

`_objects'
     このメンバーは`None'またはPythonオブジェクトが含まれる辞書であり、
     Pythonオブジェクトはメモリブロックの内容を有効に保つために、
     生き続けている必要があります。このオブジェクトはデバッギングのために
     エクスポートされているだけです。この辞書の内容を決して変更してはいけません。


File: python-lib-jp.info,  Node: 基本データ型,  Next: 標準データ型,  Prev: データ型 2,  Up: ctypesリファレンス

14.14.2.7 基本データ型
......................

`_SimpleCData'
     この非公開クラスはすべての基本ctypesデータ型のベースクラスです。
     ここでこのクラスに触れたのは、基本ctypesデータ型の共通属性を含んでいるからです。
     `{_}SimpleCData'は`{_}CData'のサブクラスですので、
     そのメソッドと属性を継承しています。

インスタンスはただ一つの属性を持ちます:

`value'
     この属性にはインスタンスの実際の値が入っています。それは
     整数とポインタ型に対しては整数、文字型に対しては
     一文字だけの文字列、文字ポインタ型に対しては
     Python文字列またはユニコード文字列です。

     `value'属性をctypesインスタンスから取り出したとき、
     たいていは新しいオブジェクトがその都度返されます。`ctypes'は
     元のオブジェクトを戻すことは_しません_。常に新しいオブジェクトが
     作られます。同じことはすべての他のctypesオブジェクトインスタンスに
     対しても当てはまります。

基本データ型は、外部関数呼び出しの結果として返されたときや、
例えば構造体のフィールドメンバーや配列要素を取り出すときに、
ネイティブのPython型へ透過的に変換されます。言い換えると、
外部関数が`c{_}char{_}p'の`restype'を持つ場合は、
`c{_}char{_}p'インスタンスでは_なく_常にPython文字列を
受け取ることでしょう。

基本データ型のサブクラスはこの振る舞いを継承_しません_。
したがって、外部関数の`restype'が`c{_}void{_}p'の
サブクラスならば、関数呼び出しからこのサブクラスのインスタンスを
受け取ります。もちろん、`value'属性にアクセスしてポインタの値を
得ることができます。

これらが基本データ型です:

`c_byte'
     Cのsigned charデータ型を表し、小整数として値を解釈します。
     コンストラクタはオプションの整数初期化子を受け取ります。
     オーバーフローのチェックは行われません。

`c_char'
     C charデータ型を表し、単一の文字として値を解釈します。
     コンストラクタはオプションの文字列初期化子を受け取り、
     その文字列の長さちょうど一文字である必要があります。

`c_char_p'
     C char *データ型を表し、ゼロ終端文字列へのポインタで
     なければなりません。コンストラクタは整数のアドレスもしくは
     文字列を受け取ります。

`c_double'
     C doubleデータ型を表します。コンストラクタはオプションの
     浮動小数点数初期化子を受け取ります。

`c_float'
     C floatデータ型を表します。コンストラクタはオプションの
     浮動小数点数初期化子を受け取ります。

`c_int'
     C signed intデータ型を表します。コンストラクタはオプションの
     整数初期化子を受け取ります。オーバーフローのチェックは行われません。
     `sizeof(int) == sizeof(long)'であるプラットホームでは、
     `c{_}long'の別名です。

`c_int8'
     C 8-bit `signed int'データ型を表します。たいていは、
     `c{_}byte'の別名です。

`c_int16'
     C 16-bit signed intデータ型を表します。たいていは、
     `c{_}short'の別名です。

`c_int32'
     C 32-bit signed intデータ型を表します。たいていは、
     `c{_}int'の別名です。

`c_int64'
     C 64-bit `signed int'データ型を表します。たいていは、
     `c{_}longlong'の別名です。

`c_long'
     C `signed long'データ型を表します。コンストラクタはオプションの
     整数初期化子を受け取ります。オーバーフローのチェックは行われません。

`c_longlong'
     C `signed long
     long'データ型を表します。コンストラクタはオプションの
     整数初期化子を受け取ります。オーバーフローのチェックは行われません。

`c_short'
     C `signed short'データ型を表します。コンストラクタはオプションの
     整数初期化子を受け取ります。オーバーフローのチェックは行われません。

`c_size_t'
     C `size{_}t'データ型を表します。

`c_ubyte'
     C `unsigned char'データ型を表します。その値は小整数として
     解釈されます。コンストラクタはオプションの整数初期化子を
     受け取ります。オーバーフローのチェックは行われません。

`c_uint'
     C `unsigned int'データ型を表します。コンストラクタはオプションの
     整数初期化子を受け取ります。オーバーフローのチェックは行われません。
     `sizeof(int) == sizeof(long)'であるプラットホームでは、
     `c{_}ulong'の別名です。

`c_uint8'
     C 8-bit unsigned intデータ型を表します。たいていは、
     `c{_}ubyte'の別名です。

`c_uint16'
     C 16-bit unsigned intデータ型を表します。たいていは、
     `c{_}ushort'の別名です。

`c_uint32'
     C 32-bit unsigned intデータ型を表します。たいていは、
     `c{_}uint'の別名です。

`c_uint64'
     C 64-bit unsigned intデータ型を表します。たいていは、
     `c{_}ulonglong'の別名です。

`c_ulong'
     C `unsigned long'データ型を表します。コンストラクタはオプションの
     整数初期化子を受け取ります。オーバーフローのチェックは行われません。

`c_ulonglong'
     C `unsigned long long'データ型を表します。コンストラクタは
     オプションの整数初期化子を受け取ります。オーバーフローのチェックは
     行われません。

`c_ushort'
     C `unsigned short'データ型を表します。コンストラクタはオプションの
     整数初期化子を受け取ります。オーバーフローのチェックは行われません。

`c_void_p'
     C `void *'データ型を表します。値は整数として表されます。
     コンストラクタはオプションの整数初期化子を受け取ります。

`c_wchar'
     C `wchar{_}t'データ型を表し、値はユニコード文字列の
     単一の文字として解釈されます。コンストラクタはオプションの
     文字列初期化子を受け取り、その文字列の長さはちょうど
     一文字である必要があります。

`c_wchar_p'
     C `wchar{_}t *'データ型を表し、ゼロ終端ワイド文字列への
     ポインタでなければなりません。コンストラクタは整数のアドレス
     もしくは文字列を受け取ります。

`c_bool'
     C `bool'データ型(より正確には、C99の_Bool)を表します。
     その値はTrueまたはFalseであり、コンストラクタは
     どんなオブジェクト(真値を持ちます)でも受け取ります。 _Added in
     Python version 2.6_

`HRESULT'
     Windows用: `HRESULT'値を表し、関数またはメソッド呼び出しに対する
     成功またはエラーの情報を含んでいます。

`py_object'
     C `PyObject *'データ型を表します。引数なしでこれを呼び出すと
     `NULL' `PyObject *'ポインタを作成します。

`ctypes.wintypes'モジュールは他のWindows固有のデータ型を提供します。
例えば、`HWND'、`WPARAM'または`DWORD'です。
`MSG'や`RECT'のような有用な構造体も定義されています。


File: python-lib-jp.info,  Node: 標準データ型,  Next: 配列とポインタ,  Prev: 基本データ型,  Up: ctypesリファレンス

14.14.2.8 標準データ型
......................

`Union(*args, **kw)'
     ネイティブのバイトオーダーでの共用体のための抽象ベースクラス。

`BigEndianStructure(*args, **kw)'
     _ビックエンディアン_バイトオーダーでの構造体のための抽象ベースクラス。

`LittleEndianStructure(*args, **kw)'
     _リトルエンディアン_バイトオーダーでの構造体のための抽象ベースクラス。

ネイティブではないバイトオーダーを持つ構造体にポインタ型フィールドあるいは
ポインタ型フィールドを含む他のどんなデータ型をも入れることはできません。

`Structure(*args, **kw)'
     _ネイティブ_のバイトオーダーでの構造体のための抽象ベースクラス。

具象構造体型と具象共用体型はこれらの型の一つをサブクラス化することで
作らなければなりません。少なくとも、`{_}fields{_}'クラス変数を
定義する必要があります。`ctypes'は、属性に直接アクセスしてフィールドを
読み書きできるようにする記述子を作成するでしょう。これらは、

`_fields_'
     構造体のフィールドを定義するシーケンス。要素は2要素タプルか3要素タプルで
     なければなりません。第一要素はフィールドの名前です。
     第二要素はフィールドの型を指定します。それはどんなctypesデータ型でも
     構いません。

     `c{_}int'のような整数型のために、オプションの第三要素を
     与えることができます。フィールドのビット幅を定義する
     正の小整数である必要があります。

     一つの構造体と共用体の中で、フィールド名はただ一つである必要があります。
     これはチェックされません。名前が繰り返しでてきたときにアクセスできるのは
     一つのフィールドだけです。

     Structureサブクラスを定義するクラス文の_後で_、
     `{_}fields{_}'クラス変数を定義することができます。
     これにより自身を直接または間接的に参照するデータ型を
     作成できるようになります:
          class List(Structure):
              pass
          List._fields_ = [("pnext", POINTER(List)),
                           ...
                          ]

     しかし、`{_}fields{_}'クラス変数はその型が最初に使われる
     (インスタンスが作成される、それに対して`sizeof()'が呼び出されるなど)より前に
     定義されていなければなりません。その後`{_}fields{_}'クラス変数へ代入すると
     AttributeErrorが発生します。

     構造体および共用体サブクラスは位置引数と名前付き引数の両方を受け取ります。
     位置引数は`{_}fields{_}'定義中に現れたのと同じ順番で
     フィールドを初期化するために使われ、
     名前付き引数は対応する名前を使ってフィールドを初期化するために
     使われます。

     構造体型のサブクラスを定義することができ、もしあるならサブクラス内で
     定義された`{_}fields{_}'に加えて、ベースクラスのフィールドも
     継承します。

`_pack_'
     インスタンスの構造体フィールドのアライメントを上書きできるようにする
     オブションの小整数。`{_}pack{_}'は`{_}fields{_}'が
     代入されたときすでに定義されていなければならない。そうでなければ、
     何ら影響はありません。

`_anonymous_'
     無名(匿名)フィールドの名前が並べあげられたオプションのシーケンス。
     `{_}fields{_}'が代入されたとき、`{_}anonymous{_}'がすでに
     定義されていなければならない。そうでなければ、何ら影響はありません。

     この変数に並べあげられたフィールドは構造体型もしくは共用体型フィールドで
     ある必要があります。構造体フィールドまたは共用体フィールドを作る必要なく、
     入れ子になったフィールドに直接アクセスできるようにするために、
     `ctypes'は構造体型の中に記述子を作成します。

     型の例です(Windows):
          class _U(Union):
              _fields_ = [("lptdesc", POINTER(TYPEDESC)),
                          ("lpadesc", POINTER(ARRAYDESC)),
                          ("hreftype", HREFTYPE)]

          class TYPEDESC(Structure):
              _fields_ = [("u", _U),
                          ("vt", VARTYPE)]

              _anonymous_ = ("u",)

     `TYPEDESC'構造体はCOMデータ型を表現しており、`vt'フィールドは
     共用体フィールドのどれが有効であるかを指定します。`u'フィールドは
     匿名フィールドとして定義されているため、TYPEDESCインスタンスから取り除かれて
     そのメンバーへ直接アクセスできます。
     `td.lptdesc'と`td.u.lptdesc'は同等ですが、前者がより高速です。
     なぜなら一時的な共用体インスタンスを作る必要がないためです:
          td = TYPEDESC()
          td.vt = VT_PTR
          td.lptdesc = POINTER(some_type)
          td.u.lptdesc = POINTER(some_type)


構造体のサブ-サブクラスを定義することができ、ベースクラスのフィールドを
継承します。サブクラス定義に別の`{_}fields{_}'変数がある場合は、
この中で指定されたフィールドはベースクラスのフィールドへ追加されます。

構造体と共用体のコンストラクタは位置引数とキーワード引数の両方を受け取ります。
位置引数は`{_}fields{_}'の中に現れたのと同じ順番でメンバーフィールドを
初期化するために使われます。コンストラクタのキーワード引数は属性代入として解釈され、
そのため、同じ名前をもつ`{_}fields{_}'を初期化するか、
`{_}fields{_}'に存在しない名前に対しては新しい属性を作ります。


File: python-lib-jp.info,  Node: 配列とポインタ,  Prev: 標準データ型,  Up: ctypesリファレンス

14.14.2.9 配列とポインタ
........................

未作成 - チュートリアルの節~*Note ポインタ::ポインタと 節~*Note
配列::配列を参照してください。


File: python-lib-jp.info,  Node: オプションのオペレーティングシステムサービス,  Next: Unix独特のサービス,  Prev: 汎用オペレーティングシステムサービス,  Up: Top

15 オプションのオペレーティングシステムサービス
***********************************************

この章で説明するモジュールでは、
特定のオペレーティングシステムでだけ利用できる
オペレーティングシステム機能へのインターフェースを提供します。
このインターフェースは、 おおむね UNIX や C
のインターフェースにならってモデル化してありますが、
他のシステム上（WindowsやNTなど）でも利用できることがあります。
次に概要を示します。

* Menu:

* select::
* thread::
* threading::
* dummy_thread::
* dummy_threading::
* mmap::
* readline::
* rlcompleter::


File: python-lib-jp.info,  Node: select,  Next: thread,  Prev: オプションのオペレーティングシステムサービス,  Up: オプションのオペレーティングシステムサービス

15.1 I/O 処理の完了を待機する
=============================

複数のストリームに対してI/O 処理の完了を待機します。

このモジュールでは、ほとんどのオペレーティングシステムで利用可能な
`select()' および `poll()' 関数へのアクセス 機構を提供します。Windows
の上ではソケットに対してしか動作しないので 注意してください;
その他のオペレーティングシステムでは、他のファイル 形式でも (特に
UNIXではパイプにも) 動作します。通常のファイルに
対して適用し、最後にファイルを読み出した時から内容が増えているかを
決定するために使うことはできません。

このモジュールでは以下の内容を定義しています:

`error'
     エラーが発生したときに送出される例外です。エラーに付属する 値は、
     `errno' からとったエラーコードを表す数値とその
     エラーコードに対応する文字列からなるペアで、C 関数の `perror()'
     が出力するものと同様です。

`poll()'
     (全てのオペレーティングシステムでサポートされているわけでは
     ありません。) ポーリングオブジェクトを返します。このオブジェクトは
     ファイル記述子を登録したり登録解除したりすることができ、
     ファイル記述子に対する I/O イベント発生をポーリングすることが
     できます; ポーリングオブジェクトが提供しているメソッドについては
     下記の ~*Note threading:: 節を参照してください。

`select(iwtd, owtd, ewtd[, timeout])'
     UNIX の `select()' システムコールに対する直接的な
     インタフェースです。最初の 3 つの引数は `待機可能なオブジェクト'
     からなるシーケンスです: ファイル記述子を表す整数値、または
     引数を持たず、整数を返すメソッド `fileno()' を持つ
     オブジェクトです。待機可能なオブジェクトの 3
     つのシーケンスはそれぞれ 入力、出力、そして `例外状態'
     に対応します。いずれかに空のシーケンスを
     指定してもかまいませんが、3
     つ全てを空のシーケンスにしてもよいかどうか
     はプラットフォームに依存します (UNIX では動作し、Windows では
     動作しないことが知られています)。オプションの TIMEOUT 引数
     にはタイムアウトまでの秒数を浮動小数点数型で指定します。 TIMEOUT
     引数が省略された場合、関数は少なくとも一つのファイル
     記述子が何らかの準備完了状態になるまでブロックします。
     タイムアウト値ゼロは、ポーリングを行いブロックしないことを示します。

     戻り値は準備完了状態のオブジェクトからなる 3 つのリストです:
     従ってこのリストはそれぞれ関数の最初の 3 つの引数のサブセットに
     なります。ファイル記述子のいずれも準備完了にならないままタイムアウト
     した場合、3 つの空のリストが返されます。

     シーケンスの中に含めることのできるオブジェクトは Python ファイル
     オブジェクト (すなわち `sys.stdin', あるいは `open()' や
     `os.popen()' が返すオブジェクト)、`socket.socket()'
     が返すソケットオブジェクト  です。 "wrapper"
     クラスを自分で定義することもできます。この場合、 適切な
     (単なる乱数ではなく本当のファイル記述子を返す)`fileno()'
     メソッドを持つ必要があります _Note:_ `select' はWindows
     のファイルオブジェクトを受理 しませんが、ソケットは受理します  。
     Windows では、 背後の `select()' 関数は WinSock
     ライブラリで提供されて おり、WinSock
     によって生成されたものではないファイル記述子を扱う
     ことができないのです。

* Menu:

* ポーリングオブジェクト::


File: python-lib-jp.info,  Node: ポーリングオブジェクト,  Prev: select,  Up: select

15.1.1 ポーリングオブジェクト
-----------------------------

`poll()' システムコールはほとんどの UNIX システムでサポート
されており、非常に多数のクライアントに同時にサービスを提供するような
ネットワークサーバが高い拡張性を持てるようにしています。 `poll()'
に高い拡張性があるのは、`select()' が
ビット対応表を構築し、対象ファイルの記述子に対応するビットを立て、
その後全ての対応表の全てのビットを線形探索するのに対し、 `poll()'
は対象のファイル記述子を列挙するだけでよいから です。 `select()' は
O(最大のファイル記述子番号) なのに対し、 `poll()' は
O(対象とするファイル記述子の数) で済みます。

`register(fd[, eventmask])'
     ファイル記述子をポーリングオブジェクトに登録します。これ以降の
     `poll()' メソッド呼び出しでは、そのファイル記述子に処理待ち中の
     I/O イベントがあるかどうかを監視します。FD は整数か、 整数値を返す
     `fileno()' メソッドを持つオブジェクトを取ります。
     ファイルオブジェクトも通常 `fileno()' を実装しているので、
     引数として使うことができます。

     EVENTMASK はオプションのビットマスクで、どのタイプの I/O イベント
     を監視したいかを記述します。この値は以下の表で述べる定数 `POLLIN'、
     `POLLPRI'、および `POLLOUT' の組み合わせにすることが
     できます。ビットマスクを指定しない場合、標準の値が使われ、 3
     種のイベント全てに対して監視が行われます。

     定数                               意味
     ------                             -----
     POLLIN                             読み出せるデータの存在
     POLLPRI                            緊急の読み出しデータの存在
     POLLOUT                            書き出せるかどうか:
                                        書き出し処理がブロックしないかどうか
     POLLERR                            何らかのエラー状態
     POLLHUP                            ハングアップ
     POLLNVAL                           無効な要求: 記述子が開かれていない

     すでに登録済みのファイル記述子を登録してもエラーにはならず、
     一度だけ登録した場合と同じ効果になります。

`unregister(fd)'
     ポーリングオブジェクトによって追跡中のファイル記述子を登録解除します。
     `register()' メソッドと同様に、FD は整数か、 整数値を返す
     `fileno()' メソッドを持つオブジェクトを取ります。

     登録されていないファイル記述子を登録解除しようとすると `KeyError'
     例外が送出されます。

`poll([timeout])'
     登録されたファイル記述子に対してポーリングを行い、 報告すべき I/O
     イベントまたはエラーの発生したファイル記述子に 毎に 2 要素のタプル
     `(FD, EVENT)' からなるリスト
     を返します。リストは空になることもあります。 FD
     はファイル記述子で、EVENT は該当するファイル記述子
     について報告されたイベントを表すビットマスクです -- 例えば
     `POLLIN' は入力待ちを示し、`POLLOUT' はファイル記述子
     に対する書き込みが可能を示す、などです。
     空のリストは呼び出しがタイムアウトしたか、報告すべきイベントが
     どのファイル記述子でも発生しなかったことを示します。 TIMEOUT
     が与えられた場合、処理を戻すまで待機する時間の長さを
     ミリ秒単位で指定します。TIMEOUT が省略されたり、負の値であったり、
     あるいは `None' の場合、そのポーリングオブジェクトが監視している
     何らかのイベントが発生するまでブロックします。


File: python-lib-jp.info,  Node: thread,  Next: threading,  Prev: select,  Up: オプションのオペレーティングシステムサービス

15.2 マルチスレッドのコントロール
=================================

1つのインタープリタの中でのマルチスレッド制御

このモジュールはマルチスレッド(別名 "軽量プロセス" ("light-weight
processes")または"タスク"("tasks"))
に用いられる低レベルプリミティブを提供します --
グローバルデータ空間を共有するマルチスレッドを制御します。
同期のための単純なロック(別名 "mutexes"または バイナリセマフォ("binary
semaphores"))が提供されています。 

このモジュールはオプションです。 Windows, Linux, SGI IRIX, Solaris
2.x、そして同じようなPOSIXスレッド
(別名"pthread")実装のシステム上でサポートされます。
`thread'を使用することのできないシステムでは、
`dummy_thread'が用意されています。
`dummy_thread'はこのモジュールと同じインターフェース
を持ち、置き換えて使用することができます。

定数と関数は以下のように定義されています:

`error'
     スレッド特有のエラーで送出されます。

`LockType'
     これはロックオブジェクトのタイプです。

`start_new_thread(function, args[, kwargs])'
     新しいスレッドを開始して、そのIDを返します。
     スレッドは引数リストARGS(タプルでなければなりません)の
     関数FUNCTIONを実行します。
     オプション引数KWARGSはキーワード引数の辞書を指定します。
     関数が戻るとき、スレッドは黙って終了します。
     関数が未定義の例外でターミネートしたとき、スタックトレースが表示され、
     そしてスレッドが終了します(しかし他のスレッドは走り続けます)。

`interrupt_main()'
     メインスレッドで `KeyboardInterrupt' を送出します。サブスレッドは
     この関数を使ってメインスレッドに割り込みをかけることができます。
     _Added in Python version 2.3_

`exit()'
     `SystemExit'例外を送出します。
     それが捕えられないときは、黙ってスレッドを終了させます。

`allocate_lock()'
     新しいロックオブジェクトを返します。
     ロックのメソッドはこの後に記述されます。
     ロックは初期状態としてアンロック状態です。

`get_ident()'
     現在のスレッドの`スレッドID'を返します。 これは0でない整数です。
     この値は直接の意味を持っていません;
     例えばスレッド特有のデータの辞書に索引をつけるためのような、
     マジッククッキーとして意図されています。
     スレッドが終了し、他のスレッドが作られたとき、
     スレッドIDは再利用されるかもしれません。

`stack_size([size])'
     新しいスレッドが作られる際に使われるスレッドのスタックサイズを返します。
     オプションの SIZE 引数は次に作られるスレッドに対する
     スタックサイズを指定するものですが、0
     (プラットフォームまたは設定されたデフォルト) または少なくとも
     32,768 (32kB) であるような正の整数でなければなりません。
     もしスタックサイズの変更がサポートされていなければ `ThreadError'
     が送出されます。また指定されたスタックサイズが条件を満たしていなければ
     `ValueError' が送出されスタックサイズは変更されないままになります。
     32kB
     は今のところインタプリタ自体に十分なスタックスペースを保証するための値として
     サポートされる最小のスタックサイズです。プラットフォームによってはスタックサイズの
     値に固有の制限が課されることもあります。たとえば 32kB
     より大きな最小スタックサイズを
     要求されたり、システムメモリサイズの倍数の割り当てを要求されるなどです
     - より
     詳しい情報はプラットフォームごとの文書で確認してください(4kB
     ページは一般的ですので、 情報が見当たらないときには 4096
     の倍数を指定しておくといいかもしれません)。 利用可能: Windows,
     POSIX スレッドのあるシステム。 _Added in Python version 2.5_

ロックオブジェクトは次のようなメソッドを持っています:

`acquire([waitflag])'
     オプションの引数なしで使用すると、このメソッドは他のスレッドがロックし
     ているかどうかにかかわらずロックを獲得します。
     ただし他のスレッドがすでにロックしている場合には解除されるまで
     待ってからロックを獲得します (同時にロックを獲得できるスレッドは
     ひとつだけであり、これこそがロックの存在理由です)。 整数の引数
     WAITFLAG を指定すると、その値によって動作が変わります。 引数が `0'
     のときは、待たずにすぐ獲得できる場合にだけロックを獲得 します。`0'
     以外の値を与えると、先の例と同様、ロックの状態に
     かかわらず獲得をおこないます。なお、ロックを獲得すると
     `True'、できなかったときには `False' を返します。

`release()'
     ロックを解放します。そのロックは既に獲得されたものでなければなりませんが、
     しかし同じスレッドによって獲得されたものである必要はありません。

`locked()'
     ロックの状態を返します:
     同じスレッドによって獲得されたものなら`True'、
     違うのなら`False'を返します。

これらのメソッドに加えて、ロックオブジェクトは `with' 文を通じて
以下の例のように使うこともできます。

     from __future__ import with_statement
     import thread

     a_lock = thread.allocate_lock()

     with a_lock:
         print "a_lock is locked while this executes"

*Caveats:*

   * スレッドは割り込みと奇妙な相互作用をします:
     `KeyboardInterrupt'例外は任意のスレッドによって受け取られます。
     (`signal' モジュールが利用可能なとき、
     割り込みは常にメインスレッドへ行きます。)

   * `sys.exit()'を呼び出す、 あるいは`SystemExit'例外を送出することは、
     `exit()'を呼び出すことと同じです。

   * I/O待ちをブロックするかもしれない全ての組込み関数が、
     他のスレッドの走行を許すわけではありません。
     (ほとんどの一般的なもの (`time.sleep()', `FILE.read()',
     `select.select()')は期待通りに働きます。)

   * ロックの`acquire()'メソッドに割り込むことはできません --
     `KeyboardInterrupt'例外は、ロックが獲得された後に発生します。

   * メインスレッドが終了したとき、他のスレッドが生き残るかどうかは、
     システムが定義します。 ネイティブスレッド実装を使うSGI
     IRIXでは生き残ります。 その他の多くのシステムでは、`try' ...
     `finally'節
     を実行せずに殺されたり、デストラクタを実行せずに殺されたりします。 

   *
     メインスレッドが終了したとき、それの通常のクリーンアップは行なわれず
     (`try' ... `finally'節が尊重されることは除きます)、
     標準I/Oファイルはフラッシュされません。



File: python-lib-jp.info,  Node: threading,  Next: dummy_thread,  Prev: thread,  Up: オプションのオペレーティングシステムサービス

15.3 高水準のスレッドインタフェース
===================================

高水準のスレッドインタフェース

このモジュールでは、高水準のスレッドインタフェースを
より低水準な`thread' モジュールの上に構築しています。

また、`thread' がないために`threading' を使えないような
状況向けに`dummy_threading' を提供しています。

このモジュールでは以下のような関数とオブジェクトを定義しています:

`activeCount()'
     現在のアクティブな`Thread'オブジェクトの数を返します。 この数は
     `enumerate()' の返すリストの長さと同じです。

`Condition()'
     新しい条件変数 (condition variable)
     オブジェクトを返すファクトリ関数です。
     条件変数を使うと、ある複数のスレッドを別のスレッドの通知があるまで
     待機させられます。

`currentThread()'
     関数を呼び出している処理のスレッドに対応する `Thread'
     オブジェクトを 返します。関数を呼び出している処理のスレッドが
     `threading' モジュール
     で生成したものでない場合、限定的な機能しかもたないダミースレッドオブジェクト
     を返します。

`enumerate()'
     現在アクティブな `Thread' オブジェクト全てのリストを返します。
     リストには、デーモンスレッド (daemonic thread)、 `currentThread()'
     の生成するダミースレッドオブジェクト、
     そして主スレッドが入ります。終了したスレッドとまだ開始していないスレッド
     は入りません。

`Event()'
     新たなイベントオブジェクトを返すファクトリ関数です。 イベントは
     `set()' メソッドを使うと `True' に、 `clear()' メソッドを使うと
     `False' にセットされるような フラグを管理します。`wait()'
     メソッドは、全てのフラグが
     真になるまでブロックするようになっています。

`local'
     {} スレッドローカルデータ (thread-local data)
     を表現するためのクラスです。
     スレッドローカルデータとは、値が各スレッド固有になるようなデータです。
     スレッドローカルデータを管理するには、`local' (または`local'
     のサブクラス) のインスタンスを作成して、その属性に値を代入します:

          mydata = threading.local()
          mydata.x = 1

     インスタンスの値はスレッドごとに違った値になります。

     詳細と例題については、 `_threading_local'
     モジュールのドキュメンテーション文字列を 参照してください。

     _Added in Python version 2.4_

`Lock()'
     新しいプリミティブロック (primitive lock)
     オブジェクトを返すファクトリ 関数です。
     スレッドが一度プリミティブロックを獲得すると、それ以後のロック獲得の試みは
     ロックが解放されるまでブロックします。どのスレッドでもロックを解放できます。

`RLock()'
     新しい再入可能ロックオブジェクトを返すファクトリ関数です。
     再入可能ロックはそれを獲得したスレッドによって解放されなければなりません。
     いったんスレッドが再入可能ロックを獲得すると、
     同じスレッドはブロックされずにもう一度それを獲得できます;
     そのスレッドは獲得した回数だけ解放しなければいけません。

`Semaphore([value])'
     新しいセマフォ (semaphore) オブジェクトを返すファクトリ関数です。
     セマフォは、`release()'を呼び出した数から`acquire()'
     を呼び出した数を引き、初期値を足した値を表すカウンタを管理します。
     `acquire()'メソッドは、カウンタの値を負にせずに処理を戻せるまで
     必要ならば処理をブロックします。 VALUE
     を指定しない場合、デフォルトの値は 1 になります。

`BoundedSemaphore([value])'
     新しい有限セマフォ (bounded semaphore) オブジェクトを返す
     ファクトリ関数です。有限セマフォは、現在の値が初期値を超過しないよう
     チェックを行います。超過を起こした場合、`ValueError' を
     送出します。たいていの場合、セマフォは限られた容量のリソースを
     保護するために使われるものです。従って、あまりにも頻繁なセマフォの解放は
     バグが生じているしるしです。 VALUE
     を指定しない場合、デフォルトの値は 1 になります。

`Thread'
     {} 処理中のスレッドを表すクラスです。
     このクラスは制限のある範囲内で安全にサブクラス化できます。

`Timer'
     {} 指定時間経過後に関数を実行するスレッドです。

`settrace(func)'
     `threading' モジュールを使って開始した全てのスレッドに トレース関数  を設定します。
     FUNC は各スレッドの`run()' を呼び出す前に
     スレッドの`sys.settrace()' に渡されます。 _Added in Python version
     2.3_

`setprofile(func)'
     `threading' モジュールを使って開始した全てのスレッドに
     プロファイル関数  を設定します。 FUNC は各スレッドの`run()'
     を呼び出す前に スレッドの`sys.settrace()' に渡されます。 _Added in
     Python version 2.3_

`stack_size([size])'
     新しいスレッドが作られる際に使われるスレッドのスタックサイズを返します。
     オプションの SIZE 引数は次に作られるスレッドに対する
     スタックサイズを指定するものですが、0
     (プラットフォームまたは設定されたデフォルト) または少なくとも
     32,768 (32kB) であるような正の整数でなければなりません。
     もしスタックサイズの変更がサポートされていなければ `ThreadError'
     が送出されます。また指定されたスタックサイズが条件を満たしていなければ
     `ValueError' が送出されスタックサイズは変更されないままになります。
     32kB
     は今のところインタプリタ自体に十分なスタックスペースを保証するための値として
     サポートされる最小のスタックサイズです。プラットフォームによってはスタックサイズの
     値に固有の制限が課されることもあります。たとえば 32kB
     より大きな最小スタックサイズを
     要求されたり、システムメモリサイズの倍数の割り当てを要求されるなどです
     - より
     詳しい情報はプラットフォームごとの文書で確認してください(4kB
     ページは一般的ですので、 情報が見当たらないときには 4096
     の倍数を指定しておくといいかもしれません)。 利用可能: Windows,
     POSIX スレッドのあるシステム。 _Added in Python version 2.5_

オブジェクトの詳細なインターフェースを以下に説明します。

このモジュールのおおまかな設計は Java のスレッドモデルに基づいています。
とはいえ、Java がロックと条件変数を全てのオブジェクトの基本的な挙動に
しているのに対し、 Python ではこれらを別個のオブジェクトに分けています。
Python の `Thread' クラスがサポートしているのは Java の Thread
クラスの挙動のサブセットにすぎません; 現状では、優先度 (priority)や
スレッドグループがなく、スレッドの破壊 (destroy)、中断 (stop)、
一時停止 (suspend)、復帰 (resume)、割り込み (interrupt) は行えません。
Java の Thread クラスにおける静的メソッドに対応する機能が実装されている
場合には、、モジュールレベルの関数になっています。

以下に説明するメソッドは全て原子的 (atomic) に実行されます。

* Menu:

* Lock オブジェクト::
* RLock オブジェクト::
* Condition オブジェクト::
* Semaphore オブジェクト::
* Event オブジェクト::
* Thread オブジェクト::
* Timer オブジェクト::
* with 文でのロック・条件変数・セマフォの使い方::


File: python-lib-jp.info,  Node: Lock オブジェクト,  Next: RLock オブジェクト,  Prev: threading,  Up: threading

15.3.1 Lock オブジェクト
------------------------

プリミティブロックとは、ロックが生じた際に特定のスレッドによって
所有されない同期プリミティブです。 Python では現在のところ
拡張モジュール`thread' で直接実装されている
最も低水準の同期プリミティブを使えます。

プリミティブロックは2つの状態、 "ロック"または"アンロック"
があります。このロックはアンロック状態で作成されます。
ロックには基本となる二つのメソッド、`acquire()'と `release()'
があります。ロックの状態がアンロックである 場合、`acquire()'
は状態をロックに変更して即座に処理を
戻します。状態がロックの場合、`acquire()'は他のスレッドが `release()'
を呼出してロックの状態をアンロックに変更するまで
ブロックします。その後、状態をロックに再度設定してから処理を戻します。
`release()' メソッドを呼び出すのはロック状態のときでなければ
なりません; このメソッドはロックの状態をアンロックに変更し、即座に
処理を戻します。複数のスレッドにおいて `acquire()' が
アンロック状態への遷移を待っているためにブロックが起きている時に
`release()' を呼び出してロックの状態をアンロックにすると、
一つのスレッドだけが処理を進行できます。どのスレッドが処理を
進行できるのかは定義されておらず、実装によって異なるかもしれません。

全てのメソッドは原子的に実行されます。

`acquire([blocking` = 1'])'
     ブロックあり、またはブロックなしでロックを獲得します。

     引数なしで呼び出した場合、ロックの状態がアンロックになるまで
     ブロックし、その後状態をロックにセットして真値を返します。

     引数BLOCKING の値を真にして呼び出した場合、
     引数なしで呼び出したときと同じことを行ない、Trueを返します。

     引数BLOCKING の値を偽にして呼び出すとブロックしません。
     引数なしで呼び出した場合にブロックするような状況であった場合には
     直ちに偽を返します。それ以外の場合には、
     引数なしで呼び出したときと同じ処理を行い真を返します。


`release()'
     ロックを解放します。

     ロックの状態がロックのとき、状態をアンロックにリセットして処理を
     戻します。他のスレッドがロックがアンロック状態になるのを待って
     ブロックしている場合、ただ一つのスレッドだけが処理を継続できるように
     します。

     ロックがアンロック状態のとき、このメソッドを呼び出してはなりません。

     戻り値はありません。


File: python-lib-jp.info,  Node: RLock オブジェクト,  Next: Condition オブジェクト,  Prev: Lock オブジェクト,  Up: threading

15.3.2 RLock オブジェクト
-------------------------

再入可能ロック (reentrant lock)
とは、同じスレッドが複数回獲得できるような
同期プリミティブです。再入可能ロックの内部では、プリミティブロックの使う
ロック／アンロック状態に加え、 "所有スレッド (owning thread)" と
"再帰レベル (recursion level)" という概念を用いています。
ロック状態では何らかのスレッドがロックを所有しており、アンロック状態では
いかなるスレッドもロックを所有していません。

スレッドがこのロックの状態をロックにするには、ロックの`acquire()'
メソッドを呼び出します。このメソッドは、スレッドがロックを所有すると
処理を戻します。ロックの状態をアンロックにするには`release()'
メソッドを呼び出します。 `acquire()'/`release()'
からなるペアの呼び出しはネスト できます; 最後に呼び出した `release()'
(最も外側の呼び出しペア)
だけが、ロックの状態をアンロックにリセットし、`acquire()' で
ブロック中の別のスレッドの処理を進行させられます。

`acquire([blocking` = 1'])'
     ブロックあり、またはブロックなしでロックを獲得します。

     引数なしで呼び出した場合: スレッドが既にロックを所有している場合、
     再帰レベルをインクリメントして即座に処理を戻します。
     それ以外の場合、他のスレッドがロックを所有していれば、
     そのロックの状態がアンロックになるまでブロックします。その後、
     ロックの状態がアンロックになる
     (いかなるスレッドもロックを所有しない状態 になる)
     と、ロックの所有権を獲得し、再帰レベルを 1 にセットして処理を
     戻します。ロックの状態がアンロックになるのを待っているスレッドが複数
     ある場合、その中の一つだけがロックの所有権を獲得できます。この場合、
     戻り値はありません。

     BLOCKING 引数の値を真にした場合、引数なしで呼び出した場合と
     同じ処理を行って真を返します。

     BLOCKING 引数の値を偽にした場合、ブロックしません。
     引数なしで呼び出した場合にブロックするような状況であった場合には
     直ちに偽を返します。それ以外の場合には、
     引数なしで呼び出したときと同じ処理を行い真を返します。

`release()'
     再帰レベルをデクリメントしてロックを解放します。
     デクリメント後に再帰レベルがゼロになった場合、ロックの状態を
     アンロック (いかなるスレッドにも所有されていない状態)
     にリセットし、
     ロックの状態がアンロックになるのを待ってブロックしているスレッドが
     ある場合にはその中のただ一つだけが処理を進行できるようにします。
     デクリメント後も再帰レベルがゼロでない場合、ロックの状態はロックの
     ままで、呼び出し手のスレッドに所有されたままになります。

     呼び出し手のスレッドがロックを所有しているときにのみこのメソッドを
     呼び出してください。ロックの状態がアンロックの時にこのメソッドを
     呼び出してはなりません。

     戻り値はありません。


File: python-lib-jp.info,  Node: Condition オブジェクト,  Next: Semaphore オブジェクト,  Prev: RLock オブジェクト,  Up: threading

15.3.3 Condition オブジェクト
-----------------------------

条件変数(condition variable) は常にある種のロックに関連付けられています;
条件変数に関連付けるロックは明示的に引き渡したり、デフォルトで生成させたり
できます。 (複数の条件変数で同じロックを共有するような場合には、引渡し
による関連付けが便利です。)

条件変数には、`acquire()' メソッドおよび`release()'
があり、関連付けされているロックの対応するメソッドを呼び出すように
なっています。また、 `wait()', `notify()', `notifyAll()'
といったメソッドがあります。これら三つの
メソッドを呼び出せるのは、呼び出し手のスレッドがロックを獲得している
時だけです。

`wait()'メソッドは現在のスレッドのロックを解放し、他のスレッドが
同じ条件変数に対して`notify()'または`notifyAll()' を呼び
出して現在のスレッドを起こすまでブロックします。一度起こされると、
再度ロックを獲得して処理を戻します。`wait()' にはタイムアウトも
設定できます。

`notify()'メソッドは条件変数待ちのスレッドを1つ起こします。
`notifyAll()'メソッドは条件変数待ちの全てのスレッドを起こします。

注意: `notify()'と`notifyAll()'はロックを解放しません;
従って、スレッドが起こされたとき、`wait()' の呼び出しは即座に
処理を戻すわけではなく、`notify()' または`notifyAll()'
を呼び出したスレッドが最終的にロックの所有権を放棄したときに初めて
処理を返すのです。

豆知識: 条件変数を使う典型的なプログラミングスタイルでは、
何らかの共有された状態変数へのアクセスを同期させるためにロックを使います;
状態変数が特定の状態に変化したことを知りたいスレッドは、自分の望む
状態になるまで繰り返し `wait()' を呼び出します。その一方で、
状態変更を行うスレッドは、前者のスレッドが待ち望んでいる状態で
あるかもしれないような状態へ変更を行ったときに `notify()' や
`notifyAll()' を呼び出します。例えば、以下のコードは無制限の
バッファ容量のときの一般的な生産者-消費者問題です:

     # Consume one item
     cv.acquire()
     while not an_item_is_available():
         cv.wait()
     get_an_available_item()
     cv.release()

     # Produce one item
     cv.acquire()
     make_an_item_available()
     cv.notify()
     cv.release()

`notify()' と`notifyAll()' のどちらを使うかは、
その状態の変化に興味を持っている待ちスレッドが一つだけなのか、あるいは
複数なのかで考えます。例えば、典型的な生産者-消費者問題では、
バッファに 1 つの要素を加えた場合には消費者スレッドを 1 つしか
起こさなくてかまいません。

`Condition([lock])'
     LOCK を指定して、`None' の値にする場合、 `Lock' または`RLock'
     オブジェクトでなければなりません。 この場合、LOCK
     は根底にあるロックオブジェクトとして使われます。
     それ以外の場合には新しい `RLock' オブジェクトを生成して 使います。

`acquire(*args)'
     根底にあるロックを獲得します。
     このメソッドは根底にあるロックの対応するメソッドを呼び出します。
     そのメソッドの戻り値を返します。

`release()'
     根底にあるロックを解放します。
     このメソッドは根底にあるロックの対応するメソッドを呼び出します。
     戻り値はありません。

`wait([timeout])'
     通知 (notify) を受けるか、タイムアウトするまで待機します。
     このメソッドを呼び出してよいのは、呼び出し手のスレッドがロックを獲得
     しているときだけです。

     このメソッドは根底にあるロックを解放し、他のスレッドが同じ条件変数に
     対して`notify()'または`notifyAll()' を呼び出して現在の
     スレッドを起こすか、オプションのタイムアウトが発生するまでブロック
     します。一度スレッドが起こされると、再度ロックを獲得して処理を戻します。

     TIMEOUT引数を指定して、`None'以外の値にする場合、 タイムアウトを秒
     (または端数秒) を表す浮動小数点数でなければなりません。

     根底にあるロックが`RLock' である場合、`release()' メソッド
     ではロックは解放されません。というのも、ロックが再帰的に複数回獲得
     されている場合には、`release()' によって実際にアンロックが
     行われないかもしれないからです。その代わり、 ロックが再帰的に複数回
     獲得されていても確実にアンロックを行える`RLock' クラスの
     内部インタフェースを使います。その後ロックを再獲得する時に、
     もう一つの内部インタフェースを使ってロックの再帰レベルを復帰します。

`notify()'
     この条件変数を待っているスレッドがあれば、そのスレッドを起こします。
     このメソッドを呼び出してよいのは、呼び出し手のスレッドがロックを獲得
     しているときだけです。

     何らかの待機中スレッドがある場合、そのスレッドの一つを起こします。
     待機中のスレッドがなければ何もしません。

     現在の実装では、待機中のメソッドをただ一つだけ起こします。
     とはいえ、この挙動に依存するのは安全ではありません。
     将来、実装の最適化によって、複数のスレッドを起こすようになるかも
     しれないからです。

     注意: 起こされたスレッドは実際にロックを再獲得できるまで`wait()'
     呼出しから戻りません。`notify()'はロックを解放しないので、
     `notify()' 呼び出し手は明示的にロックを解放せねばなりません。

`notifyAll()'
     この条件を待っているすべてのスレッドを起こします。
     このメソッドは`notify()' のように動作しますが、 1
     つではなくすべての待ちスレッドを起こします。


File: python-lib-jp.info,  Node: Semaphore オブジェクト,  Next: Event オブジェクト,  Prev: Condition オブジェクト,  Up: threading

15.3.4 Semaphore オブジェクト
-----------------------------

セマフォ (semaphore)
は、計算機科学史上最も古い同期プリミティブの一つで、
草創期のオランダ計算機科学者 Edsger W. Dijkstra によって発明されました
(彼は`acquire()'と`release()'の代わりに `P()'と`V()'を使いました)。

セマフォは`acquire()' でデクリメントされ`release()'で
インクリメントされるような内部カウンタを管理します。
カウンタは決してゼロより小さくはなりません; `acquire()' は、
カウンタがゼロになっている場合、他のスレッドが`release()'
を呼び出すまでブロックします。

`Semaphore([value])'
     オプションの引数には、内部カウンタの初期値を指定します。
     デフォルトは`1'です。

`acquire([blocking])'
     セマフォを獲得します。

     引数なしで呼び出した場合: `acqure()' 処理に入ったときに
     内部カウンタがゼロより大きければ、カウンタを 1 デクリメントして
     即座に処理を戻します。`acqure()' 処理に入ったときに
     内部カウンタがゼロの場合、他のスレッドが `release()'
     を呼び出してカウンタをゼロより大きくするまでブロックします。
     この処理は、適切なインターロック (interlock) を介して行い、 複数の
     `acquire()' 呼び出しがブロックされた場合、 `release()'
     が正確に一つだけを起こせるようにします。
     この実装はランダムに一つ選択するだけでもよいので、ブロックされた
     スレッドがどの起こされる順番に依存してはなりません。
     この場合、戻り値はありません。

     BLOCKING 引数の値を真にした場合、引数なしで呼び出した場合と
     同じ処理を行って真を返します。

     BLOCKING 引数の値を偽にした場合、ブロックしません。
     引数なしで呼び出した場合にブロックするような状況であった場合には
     直ちに偽を返します。それ以外の場合には、
     引数なしで呼び出したときと同じ処理を行い真を返します。

`release()'
     内部カウンタを 1 インクリメントして、セマフォを解放します。
     `release()' 処理に入ったときにカウンタがゼロであり、
     カウンタの値がゼロより大きくなるのを待っている別のスレッドが
     あった場合、そのスレッドを起こします。

* Menu:

* Semaphore の例::


File: python-lib-jp.info,  Node: Semaphore の例,  Prev: Semaphore オブジェクト,  Up: Semaphore オブジェクト

15.3.4.1 `Semaphore' の例
.........................

セマフォはしばしば、容量に限りのある資源、例えばデータベースサーバなど
を保護するために使われます。リソースのサイズが固定の状況では、常に
有限セマフォを使わねばなりません。主スレッドは、作業スレッドを
立ち上げる前にセマフォを初期化します:

     maxconnections = 5
     ...
     pool_sema = BoundedSemaphore(value=maxconnections)

作業スレッドは、ひとたび立ち上がると、サーバへ接続する必要が
生じたときにセマフォの`acquire' および`release' メソッドを呼び出します:

     pool_sema.acquire()
     conn = connectdb()
     ... use connection ...
     conn.close()
     pool_sema.release()

有限セマフォを使うと、セマフォを獲得回数以上に解放してしまうという
プログラム上の間違いを見逃しにくくします。


File: python-lib-jp.info,  Node: Event オブジェクト,  Next: Thread オブジェクト,  Prev: Semaphore オブジェクト,  Up: threading

15.3.5 Event オブジェクト
-------------------------

イベントは、あるスレッドがイベントを発信し、他のスレッドはそれを
待つという、スレッド間で通信を行うための最も単純なメカニズムの一つです。

イベントオブジェクトは内部フラグを管理します。このフラグは`set()'
メソッドで値を真に、`clear()'メソッドで値を偽にリセットします。
`wait()'メソッドはフラグがTrueになるまでブロックします。

`Event()'
     内部フラグの初期値は偽です。

`isSet()'
     内部フラグの値が真である場合かつその場合にのみ真を返します。

`set()'
     内部フラグの値を真にセットします。
     フラグの値が真になるのを待っている全てのスレッドを起こします。
     一旦フラグが真になると、スレッドが`wait()' を呼び出しても
     全くブロックしなくなります。

`clear()'
     内部フラグの値を偽にリセットします。 以降は、`set()'
     を呼び出して再び内部フラグの値を真にセットするまで、 `wait()'
     を呼出したスレッドはブロックするようになります。

`wait([timeout])'
     内部フラグの値が真になるまでブロックします。 `wait()'
     処理に入った時点で内部フラグの値が真であれば、
     直ちに処理を戻します。そうでない場合、他のスレッドが`set()'を
     呼び出してフラグの値を真にセットするか、オプションのタイムアウトが
     発生するまでブロックします。

     TIMEOUT引数を指定して、`None'以外の値にする場合、 タイムアウトを秒
     (または端数秒) を表す浮動小数点数でなければなりません。


File: python-lib-jp.info,  Node: Thread オブジェクト,  Next: Timer オブジェクト,  Prev: Event オブジェクト,  Up: threading

15.3.6 Thread オブジェクト
--------------------------

このクラスは個別のスレッド中で実行される活動 (activity) を表現します。
活動を決める方法はは 2 つあり、一つは呼出し可能オブジェクトを
コンストラクタへ渡す方法、もう一つはサブクラスで`run()' メソッドを
オーバライドする方法です。(コンストラクタを除く) その他のメソッドは
一切サブクラスでオーバライドしてはなりません。言い換えるならば、
このクラスの`__init__()'と`run()'メソッド_だけ_を
オーバライドしてくださいということです。

ひとたびスレッドオブジェクトを生成すると、スレッドの`start()'
メソッドを呼び出して活動を開始せねばなりません。`start()'
メソッドはそれぞれのスレッドの `run()' メソッドを起動します。

スレッドの活動が始まると、スレッドは '生存中 (alive)' で、 '活動中
(active)' とみなされます (これら二つの概念はほとんど
同じですが、全く同じというわけではありません; これら二つは意図的に
曖昧に定義されているのです)。
スレッドの活動は、通常終了、あるいは処理されない例外が送出されたことで
`run()' メソッドが終了すると生存中でなくなり、かつ活動中で
なくなります。`isAlive()' メソッドはスレッドが生存中であるか
どうか調べます。

他のスレッドはスレッドの `join()' メソッドを呼び出せます。
このメソッドは、`join()' を呼び出されたスレッドが終了するまで、
メソッドの呼び出し手となるスレッドをブロックします。

スレッドには名前があります。名前はコンストラクタで渡したり、
`setName()' メソッドで設定したり、`getName()'
メソッドで取得したりできます。

スレッドには "デーモンスレッド (daemon thread)" であるというフラグを
立てられます。
このフラグには、残っているスレッドがデーモンスレッドだけになった時に
Python プログラム全体を終了させるという意味があります。フラグの初期値は
スレッドを生成する側のスレッドから継承します。フラグの値は
`setDaemon()'メソッドで設定でき、`isDaemon()'メソッドで 取得できます。

スレッドには "主スレッド (main thread)" オブジェクトがあります。
主スレッドは Python プログラムを最初に制御していたスレッドです。
主スレッドはデーモンスレッドではありません。

"ダミースレッド (dumm thread)" オブジェクトを作成できる場合があります。
ダミースレッドは、 "外来スレッド (alien thread)" に相当する
スレッドオブジェクトです。ダミースレッドは、C コードから直接生成された
スレッドのような、 `threading' モジュールの外で開始された
処理スレッドです。ダミースレッドオブジェクトには限られた機能しかなく、
常に生存中、活動中かつデーモンスレッドであるとみなされ、`join()'
できません。また、外来スレッドの終了を検出するのは不可能なので、
ダミースレッドは削除できません。

`Thread(group=None, target=None, name=None, args=(), kwargs={})'
     コンストラクタは常にキーワード引数を使って呼び出さねばなりません。
     各引数は以下の通りです:

     GROUP は`None' にせねばなりません。 将来`ThreadGroup'
     クラスが実装されたときの拡張用に予約されている 引数です。

     TARGET は`run()' メソッドによって起動される
     呼出し可能オブジェクトです。
     デフォルトでは何も呼び出さないことを示す `None' になっています。

     NAMEはスレッドの名前です。デフォルトでは、 N を小さな 10
     進数として、"Thread-N" という形式の一意な名前を生成します。

     ARGS はTARGET を呼び出すときの引数タプルです。
     デフォルトは`()'です。

     KWARGS はTARGET を呼び出すときのキーワード引数の辞書です。
     デフォルトは`@'です。

     サブクラスでコンストラクタをオーバライドした場合、
     必ずスレッドが何かを始める前に基底クラスのコンストラクタ
     (`Thread.__init__()') を呼び出しておかなくてはなりません。

`start()'
     スレッドの活動を開始します。

     このメソッドは、スレッドオブジェクトあたり一度しか呼び出しては
     なりません。`start()' は、オブジェクトの `run()'
     メソッドが個別の処理スレッド中で呼び出されるように調整します。

`run()'
     スレッドの活動をもたらすメソッドです。

     このメソッドはサブクラスでオーバライドできます。 標準の`run()'
     メソッドでは、オブジェクトのコンストラクタの TARGET
     引数に呼び出し可能オブジェクトを指定した場合、 ARGS
     およびKWARGSの引数列およびキーワード引数とともに 呼び出します。

`join([timeout])'
     スレッドが終了するまで待機します。 このメソッドは、`join()'
     を呼び出されたスレッドが、
     正常終了あるいは処理されない例外によって終了するか、オプションの
     タイムアウトが発生するまで、メソッドの呼び出し手となるスレッドを
     ブロックします。

     TIMEOUT引数を指定して、`None'以外の値にする場合、 タイムアウトを秒
     (または端数秒) を表す浮動小数点数でなければなりません。 `join()'
     はいつでも `None' を返すので、 `isAlive()'
     を呼び出してタイムアウトしたかどうかを確認しなければなりません。

     TIMEOUT が指定されないかまたは `None' であるときは、
     この操作はスレッドが終了するまでブロックします。

     一つのスレッドに対して何度でも `join()' できます。

     スレッドは自分自身を`join()' できません。デッドロックを引き起こす
     からです。

     スレッドを開始するまえに`join()' を試みるのは誤りです。

`getName()'
     スレッドの名前を返します。

`setName(name)'
     スレッドの名前を設定します。

     名前は識別のためだけに使われます。名前には機能上の意味づけ
     (semantics)
     はありません。複数のスレッドに同じ名前をつけてもかまいません。
     名前の初期値はコンストラクタで設定されます。

`isAlive()'
     スレッドが生存中かどうかを返します。

     大雑把な言い方をすると、スレッドは `start()' メソッドを呼び出した
     瞬間から `run()' メソッドが終了するまでの間生存しています。

`isDaemon()'
     スレッドのデーモンフラグを返します。

`setDaemon(daemonic)'
     スレッドのデーモンフラグをブール値DAEMONIC に設定します。
     このメソッドは `start()' を呼び出す前に呼び出さねばなりません。

     初期値は生成側のスレッドから継承されます。

     デーモンでない活動中のスレッドが全てなくなると、Python
     プログラム全体 が終了します。


File: python-lib-jp.info,  Node: Timer オブジェクト,  Next: with 文でのロック・条件変数・セマフォの使い方,  Prev: Thread オブジェクト,  Up: threading

15.3.7 Timer オブジェクト
-------------------------

このクラスは、一定時間経過後に実行される活動、すなわちタイマ活動
を表現します。`Timer' は`Thread' のサブクラスであり、
自作のスレッドを構築した一例でもあります。

タイマは `start()' メソッドを呼び出すとスレッドとして作動し始め
します。(活動を開始する前に) `cancel()' メソッドを呼び出すと、
タイマを停止できます。タイマが活動を実行するまでの待ち時間は、ユーザ
が指定した待ち時間と必ずしも厳密には一致しません。

例:
     def hello():
         print "hello, world"

     t = Timer(30.0, hello)
     t.start() # after 30 seconds, "hello, world" will be printed

`Timer(interval, function, args=[], kwargs={})'
     INTERVAL 秒後にFUNCTION を引数 ARGS、キーワード引数 KWARGS
     つきで実行するようなタイマを生成します。

`cancel()'
     タイマをストップして、その動作の実行をキャンセルします。
     このメソッドはタイマがまだ活動待ち状態にある場合にのみ動作します。


File: python-lib-jp.info,  Node: with 文でのロック・条件変数・セマフォの使い方,  Prev: Timer オブジェクト,  Up: threading

15.3.8 `with' 文でのロック・条件変数・セマフォの使い方
------------------------------------------------------

このモジュールのオブジェクトで `acquire()' と `release()' 両メソッドを
具えているものは全て `with'
文のコンテキストマネージャとして使うことができます。 `acquire()'
メソッドが `with' 文のブロックに入るときに呼び出され、
ブロック脱出時には `release()' メソッドが呼ばれます。

現在のところ、`Lock'、`RLock'、`Condition'、`Semaphore'、
`BoundedSemaphore' を `with' 文のコンテキストマネージャと
して使うことができます。以下の例を見てください。

     from __future__ import with_statement
     import threading

     some_rlock = threading.RLock()

     with some_rlock:
         print "some_rlock is locked while this executes"


File: python-lib-jp.info,  Node: dummy_thread,  Next: dummy_threading,  Prev: threading,  Up: オプションのオペレーティングシステムサービス

15.4 `thread' の代替モジュール
==============================

`thread' の代替モジュール。

このモジュールは `thread' モジュールのインターフェースをそっ
くりまねるものです。`thread' モジュールがサポートされていな
いプラットフォームで import することを意図して作られたものです。

使用例:

     try:
         import thread as _thread
     except ImportError:
         import dummy_thread as _thread

生成するスレッドが、他のブロックしたスレッドを待ち、デッドロック発生の
可能性がある場合には、このモジュールを使わないようにしてください。ブロッ
キング I/O を使っている場合によく起きます。


File: python-lib-jp.info,  Node: dummy_threading,  Next: mmap,  Prev: dummy_thread,  Up: オプションのオペレーティングシステムサービス

15.5 `threading' の代替モジュール
=================================

`threading'  の代替モジュール。

このモジュールは `threading' モジュールのインターフェースを
そっくりまねるものです。`threading' モジュールがサポートされ
ていないプラットフォームで import することを意図して作られたものです。

使用例:

     try:
         import threading as _threading
     except ImportError:
         import dummy_threading as _threading

生成するスレッドが、他のブロックしたスレッドを待ち、デッドロック発生の
可能性がある場合には、このモジュールを使わないようにしてください。ブロッ
キング I/O を使っている場合によく起きます。


File: python-lib-jp.info,  Node: mmap,  Next: readline,  Prev: dummy_threading,  Up: オプションのオペレーティングシステムサービス

15.6 メモリマップファイル
=========================

UNIX とWindowsのメモリマップファイルへのインターフェース

メモリにマップされたファイルオブジェクトは、
文字列とファイルオブジェクトの両方のように振舞います。
しかし通常の文字列オブジェクトとは異なり、これらは可変です。
文字列が期待されるほとんどの場所でmmapオブジェクトを利用できます。
例えば、メモリマップファイルを探索するために
`re'モジュールを使うことができます。 それらは可変なので、 `obj[INDEX] =
'a'' のように文字を 変換できますし、スライスを使うことで  `obj[I1:I2] =
'...'' のように 部分文字列を変換することができます。
現在のファイル位置をデータの始めとする読込みや書込み、
ファイルの異なる位置へ`seek()'することもできます。

メモリマップファイルはUNIX上とWindows上とでは異なる
`mmap()'関数によって作られます。
いずれの場合も、開いたファイルのディスクリプタを、
更新のために提供しなければなりません。
すでに存在するPythonファイルオブジェクトをマップしたい場合は、
FILENOパラメータのための現在値を手に入れるために、
`fileno()'メソッドを使用して下さい。
そうでなければ、ファイル・ディスクリプタを直接返す`os.open()'関数
(呼び出すときにはまだファイルが閉じている必要があります)を使って、
ファイルを開くことができます。

関数のUNIXバージョンとWindowsバージョンのために、
オプションのキーワード・パラメータとしてACCESSを指定する
ことになるかもしれません。 ACCESSは3つの値の内の1つを受け入れます。
`ACCESS_READ'は読み込み専用、 `ACCESS_WRITE'は書き込み可能、
`ACCESS_COPY'はコピーした上での書き込みです。
ACCESSはUNIXとWindowsの両方で使用することができます。
ACCESSが指定されない場合、Windowsのmmapは書き込み可能マップを返します。
3つのアクセス型すべてに対する初期メモリ値は、
指定されたファイルから得られます。
`ACCESS_READ'を割り当てたメモリマップは `TypeError'例外を送出します。
`ACCESS_WRITE'を割り当てたメモリマップは
メモリと元のファイルの両方に影響を与えます。
`ACCESS_COPY'を割り当てたメモリマップは
メモリに影響を与えますが、元のファイルを更新することはありません。
_Changed in Python version 2.5_

`mmap(fileno, length[, tagname[, access]])'
     *(Windows)*バージョンはファイルハンドルFILENOによって
     指定されたファイルからLENGTHバイトをマップして、
     mmapオブジェクトを返します。
     LENGTHが現在のファイルサイズより大きな場合、ファイルサイズは
     LENGTHを含む大きさにまで拡張されます。
     LENGTHが`0'の場合、マップの最大の長さは
     Windowsが空ファイルで例外を起こす(Windowsでは空のマップを作成すること
     ができません。)ことを除いては、
     `mmap()'が呼ばれたときのファイルサイズになります。

     TAGNAMEは、`None'以外で指定された場合、
     マップのタグ名を与える文字列となります。
     Windowsは同じファイルに対する様々なマップを持つことを可能にします。
     既存のタグの名前を指定すればそのタグがオープンされ、
     そうでなければこの名前の新しいタグが作成されます。
     もしこのパラメータを省略したり`None'を与えたりしたならば、
     マップは名前なしで作成されます。
     タグ・パラメータの使用の回避は、あなたのコードをUNIXとWindowsの間で
     移植可能にしておくのを助けてくれるでしょう。

`mmap(fileno, length[, flags[, prot[, access]]])'
     *(UNIX)*バージョンは、ファイル・ディスクリプタ FILENOに
     よって指定されたファイルからLENGTHバイトをマップし、
     mmapオブジェクトを返します。LENGTHが`0'の場合、
     そのマップの最大長が現在のファイルサイズになります。

     FLAGSはマップの種類を指定します。
     `MAP_PRIVATE'はプライベートなcopy-on-write(書込み時コピー)
     のマップを作成します。
     従って、mmapオブジェクトの内容への変更はこのプロセス内にのみ有効です。
     `MAP_SHARED'はファイルの同じ領域をマップする他のすべてのプロセス
     と共有されたマップを作成します。 デフォルトは`MAP_SHARED'です。

     PROTが指定された場合、希望のメモリ保護を与えます。
     2つの最も有用な値は、`PROT_READ'と`PROT_WRITE'です。
     これは、読込み可能または書込み可能を指定するものです。
     PROTのデフォルトは`PROT_READ | PROT_WRITE'です。

     ACCESSはオプションのキーワード・パラメータとして、
     FLAGSとPROTの代わりに指定してもかまいません。
     FLAGS,PROTとACCESSの両方を指定することは間違っています。
     このパラメーターを使用法についての情報は、
     ACCESSの記述を参照してください。

メモリマップフィイルオブジェクトは以下のメソッドをサポートしています:

`close()'
     ファイルを閉じます。
     この呼出しの後にオブジェクトの他のメソッドの呼出すことは、
     例外の送出を引き起こすでしょう。

`find(string[, start])'
     オブジェクト内で部分文字列STRINGが見つかった場所の最も小さい
     インデックスを返します。 失敗したとき`-1'を返します。
     STARTは探索を始めたい場所のインデックスで、デフォルトは0です。

`flush([offset, size])'
     ファイルのメモリコピー内での変更をディスクへフラッシュします。
     この呼出しを使わなかった場合、オブジェクトが破壊される前に
     変更が書き込まれる保証はありません。
     もしOFFSETとSIZEが指定された場合、与えられたバイトの範囲の
     変更だけがディスクにフラッシュされます。
     指定されない場合、マップ全体がフラッシュされます。

`move(DEST, SRC, COUNT)'
     オフセットSRCからインデックスDESTへCOUNTバイトだけ コピーします。
     もしmmapが`ACCESS_READ'で作成されていた場合、
     `TypeError'例外を送出します。

`read(NUM)'
     現在のファイル位置からNUMバイトの文字列を返します。
     ファイル位置は返したバイトの分だけ後ろの位置へ更新されます。

`read_byte()'
     現在のファイル位置から長さ1の文字列を返します。
     ファイル位置は1だけ進みます。

`readline()'
     現在のファイル位置から次の新しい行までの、1行を返します。

`resize(NEWSIZE)'
     マップと元ファイルのサイズを変更します。
     もしmmapが`ACCESS_READ'または`ACCESS_COPY'で
     作成されたならば、マップのリサイズは`TypeError'例外を送出します。

`seek(pos[, whence])'
     ファイルの現在位置をセットします。
     WHENCE引数はオプションであり、デフォルトは`0'(絶対位置)です。
     その他の値として、`1'(現在位置からの相対位置)と
     `2'(ファイルの終わりからの相対位置)があります。

`size()'
     ファイルの長さを返します。
     メモリマップ領域のサイズより大きいかもしれません。

`tell()'
     ファイル・ポインタの現在位置を返します。

`write(STRING)'
     メモリ内のファイル・ポインタの現在位置からSTRINGのバイト列を
     書き込みます。
     ファイル位置はバイト列が書き込まれた後の位置へ更新されます。
     もしmmapが`ACCESS_READ'で作成されていた場合、
     書き込み時に`TypeError'例外が送出されるでしょう。

`write_byte(BYTE)'
     メモリ内のファイル・ポインタの現在位置から
     単一文字の文字列BYTEを書き込みます。
     ファイル位置は`1'だけ進みます。
     もしmmapが`ACCESS_READ'で作成されていた場合、
     書き込み時に`TypeError'例外が送出されるでしょう。


File: python-lib-jp.info,  Node: readline,  Next: rlcompleter,  Prev: mmap,  Up: オプションのオペレーティングシステムサービス

15.7 GNU readline のインタフェース
==================================

Python のための GNU readline サポート。

`readline' モジュールでは、補完をしやすくしたり、 ヒストリファイルを
Python インタプリタから読み書きできるように
するためのいくつかの関数を定義しています。
このモジュールは直接使うことも `rlcompleter'
モジュールを介して使うこともできます。
このモジュールで利用される設定はインタプリタの対話プロンプトの振舞い、
組み込みの`raw_input()'と`input()'関数の振舞いに影響します。

`readline' モジュールでは以下の関数を定義しています:

`parse_and_bind(string)'
     readline 初期化ファイルの行を一行解釈して実行します。

`get_line_buffer()'
     行編集バッファの現在の内容を返します。

`insert_text(string)'
     コマンドラインにテキストを挿入します。

`read_init_file([filename])'
     readline 初期化ファイルを解釈します。
     標準のファイル名設定は最後に使われたファイル名です。

`read_history_file([filename])'
     readline ヒストリファイルを読み出します。 標準のファイル名設定は
     `~{}/.history' です。

`write_history_file([filename])'
     readline ヒストリファイルを保存します。 標準のファイル名設定は
     `~{}/.history' です。

`clear_history()'
     現在のヒストリをクリアします。 (注意:インストールされている GNU
     readline がサポートしていない場合、この関数は利用できません)
     _Added in Python version 2.4_

`get_history_length()'
     ヒストリファイルに必要な長さを返します。負の値はヒストリファイル
     のサイズに制限がないことを示します。

`set_history_length(length)'
     ヒストリファイルに必要な長さを設定します。この値は
     `write_history_file()' がヒストリを保存する際にファイルを
     切り詰めるために使います。負の値はヒストリファイルのサイズを制限
     しないことを示します。

`get_current_history_length()'
     現在のヒストリ行数を返します(この値は`get_history_length()'で取
     得する異なります。`get_history_length()'はヒストリファイルに書
     き出される最大行数を返します)。_Added in Python version 2.3_

`get_history_item(index)'
     現在のヒストリから、INDEX 番目の項目を返します。 _Added in Python
     version 2.3_

`remove_history_item(pos)'
     ヒストリから指定した位置にあるヒストリを削除します。 _Added in
     Python version 2.4_

`replace_history_item(pos, line)'
     指定した位置にあるヒストリを、指定した line で置き換えます。
     _Added in Python version 2.4_

`redisplay()'
     画面の表示を、現在のヒストリ内容によって更新します。 _Added in
     Python version 2.3_

`set_startup_hook([function])'
     startup_hook 関数を設定または除去します。FUNCTION が指定されて
     いれば、新たな startup_hook 関数として用いられます; 省略されるか
     `None' になっていれば、現在インストール
     されているフック関数は除去されます。 startup_hook 関数は readline
     が最初のプロンプトを出力する 直前に引数なしで呼び出されます。

`set_pre_input_hook([function])'
     pre_input_hook 関数を設定または除去します。FUNCTION が指定されて
     いれば、新たな pre_input_hook 関数として用いられます; 省略されるか
     `None' になっていれば、現在インストール
     されているフック関数は除去されます。 pre_input_hook 関数は
     readline が最初のプロンプトを出力した 後で、かつ readline
     が入力された文字を読み込み始める直前に 引数なしで呼び出されます。

`set_completer([function])'
     completer 関数を設定または除去します。FUNCTION が指定されて
     いれば、新たな completer 関数として用いられます; 省略されるか
     `None' になっていれば、現在インストール されている completer
     関数は除去されます。 completer 関数は `FUNCTION(TEXT, STATE)'
     の形式で、関数が文字列でない値を返すまで STATE を `0', `1', `2',
     ..., にして呼び出します。 この関数は TEXT
     から始まる文字列の補完結果として可能性の
     あるものを返さなくてはなりません。

`get_completer()'
     completer 関数を取得します。completer 関数が設定されていなければ
     `None'を返します。_Added in Python version 2.3_

`get_begidx()'
     readline タブ補完スコープの先頭のインデクスを取得します。

`get_endidx()'
     readline タブ補完スコープの末尾のインデクスを取得します。

`set_completer_delims(string)'
     タブ補完のための readline 単語区切り文字を設定します。

`get_completer_delims()'
     タブ補完のための readline 単語区切り文字を取得します。

`add_history(line)'
     1
     行をヒストリバッファに追加し、最後に打ち込まれた行のようにします。

See also:
     *Note rlcompleter:: 対話的プロンプトで Python
     識別子を補完する機能。

* Menu:

* 例 8::


File: python-lib-jp.info,  Node: 例 8,  Prev: readline,  Up: readline

15.7.1 例
---------

以下の例では、ユーザのホームディレクトリにある `.pyhist' という
名前のヒストリファイルを自動的に読み書きするために、`readline'
モジュールによるヒストリの読み書き関数をどのように使うかを例示しています。
以下のソースコードは通常、対話セッションの中で `PYTHONSTARTUP'
ファイルから読み込まれ自動的に実行されることになります。

     import os
     histfile = os.path.join(os.environ["HOME"], ".pyhist")
     try:
         readline.read_history_file(histfile)
     except IOError:
         pass
     import atexit
     atexit.register(readline.write_history_file, histfile)
     del os, histfile

次の例では `code.InteractiveConsole' クラスを拡張し、ヒストリの保
存・復旧をサポートします。

     import code
     import readline
     import atexit
     import os

     class HistoryConsole(code.InteractiveConsole):
         def __init__(self, locals=None, filename="<console>",
                      histfile=os.path.expanduser("~/.console-history")):
             code.InteractiveConsole.__init__(self)
             self.init_history(histfile)

         def init_history(self, histfile):
             readline.parse_and_bind("tab: complete")
             if hasattr(readline, "read_history_file"):
                 try:
                     readline.read_history_file(histfile)
                 except IOError:
                     pass
                 atexit.register(self.save_history, histfile)

         def save_history(self, histfile):
             readline.write_history_file(histfile)


File: python-lib-jp.info,  Node: rlcompleter,  Prev: readline,  Up: オプションのオペレーティングシステムサービス

15.8 GNU readline向け補完関数
=============================

GNU readline ライブラリ向けのPython識別子補完

`rlcompleter'モジュールではPythonの識別子やキーワードを定義した
`readline'モジュール向けの補完関数を定義しています。

このモジュールが UNIXプラットフォームでimportされ、`readline'
が利用できる ときには、`Completer'
クラスのインスタンスが自動的に作成され、 `complete'メソッドが
`readline'補完に設定されます。

使用例:

     >>> import rlcompleter
     >>> import readline
     >>> readline.parse_and_bind("tab: complete")
     >>> readline. <TAB PRESSED>
     readline.__doc__          readline.get_line_buffer  readline.read_init_file
     readline.__file__         readline.insert_text      readline.set_completer
     readline.__name__         readline.parse_and_bind
     >>> readline.

`rlcompleter'モジュールは Pythonの対話モードで利用する為にデザイ
ンされています。ユーザは以下の命令を初期化ファイル
(環境変数`PYTHONSTARTUP'によって定義されます)に書き込むことで、
<Tab>キーによる補完を利用できます:

     try:
         import readline
     except ImportError:
         print "Module readline not available."
     else:
         import rlcompleter
         readline.parse_and_bind("tab: complete")

`readline'のないプラットフォームでも、このモジュールで
定義される`Completer'クラスは独自の目的に使えます。

* Menu:

* Completerオブジェクト::


File: python-lib-jp.info,  Node: Completerオブジェクト,  Prev: rlcompleter,  Up: rlcompleter

15.8.1 Completerオブジェクト
----------------------------

Completerオブジェクトは以下のメソッドを持っています:

`complete(text, state)'
     TEXTのSTATE番目の補完候補を返します。

     もしTEXTがピリオド(`.')を含まない場合、
     `__main__'、`__builtin__'で定義されて いる名前か、キーワード (
     `keyword' モジュールで定義されている) から補完されます。

     ピリオドを含む名前の場合、副作用を出さずに名前を最後まで評価しようとしま
     す(関数を明示的に呼び出しはしませんが、`__getattr__()'を呼んでし
     まうことはあります)そして、`dir()'関数でマッチする語を見つけま す。


File: python-lib-jp.info,  Node: Unix独特のサービス,  Next: プロセス間通信とネットワーク,  Prev: オプションのオペレーティングシステムサービス,  Up: Top

16 Unix独特のサービス
*********************

本章に記述されたモジュールは、UNIXオペレーティングシステム、
あるいはそれから変形した多くのものに特有する機能のためのインター
フェイスを提供します。 その概要を以下に述べます。

* Menu:

* posix::
* pwd::
* spwd::
* grp::
* crypt::
* dl::
* termios::
* tty::
* pty::
* fcntl::
* pipes::
* posixfile::
* resource::
* nis::
* syslog::
* commands::


File: python-lib-jp.info,  Node: posix,  Next: pwd,  Prev: Unix独特のサービス,  Up: Unix独特のサービス

16.1 最も一般的な POSIX システムコール群
========================================

最も一般的な POSIX システムコール群 (通常は `os'
モジュールを介して利用されます)。

このモジュールはオペレーティングシステムの機能のうち、C 言語標準 および
POSIX 標準 (UNIX インタフェースをほんの少し隠蔽した)
で標準化されている機能に対するアクセス機構を提供します。

*このモジュールを直接 import しないで下さい。* その代わりに、
移植性のあるインタフェースを提供している `os' をインポート
してください。UNIXでは、 `os' モジュールが提供する インタフェースは
`posix' の内容を内包しています。 非 UNIX オペレーティングシステムでは
`posix' モジュール
を使うことはできませんが、その部分的な機能セットは、たいてい `os'
インタフェースを介して利用することができます。 `os' は、一度 import
してしまえば `posix' の代わり
であることによるパフォーマンス上のペナルティは _全くありません_。
その上、`os'  は `os.environ' の 内容が変更された際に自動的に
`putenv()' を呼ぶなど、 いくつかの追加機能を提供しています。

以下の説明は非常に簡潔なものです; 詳細については、 UNIX マニュアルの
(または POSIX) ドキュメントの) 対応する項目を 参照してください。PATH
で呼ばれる引数は文字列で与えられた パス名を表します。

エラーは例外として報告されます; よくある例外は型エラーです。
一方、システムコールから報告されたエラーは以下に述べるように `error'
(標準例外 `OSError' と同義です) を送出します。

* Menu:

* ラージファイルのサポート::
* モジュールの内容 3::


File: python-lib-jp.info,  Node: ラージファイルのサポート,  Next: モジュールの内容 3,  Prev: posix,  Up: posix

16.1.1 ラージファイルのサポート
-------------------------------

いくつかのオペレーティングシステム (AIX, HPIX, Irix および Solaris
が含まれます) は、`int' および `long' を 32 ビット値と する C
プログラムモデルで 2Gb を超えるサイズのファイルのサポート
を提供しています。このサポートは典型的には 64 ビット値のオフセット
値と、そこからの相対サイズを定義することで実現しています。この
ようなファイルは時にラージファイル ("large files") と呼ばれます。

Python では、`off_t' のサイズが `long' より大きく、 かつ `long long'
型を利用することができて、少なくとも `off_t'
型と同じくらい大きなサイズである場合、ラージファイルの
サポートが有効になります。この場合、ファイルのサイズ、オフセットおよび
Python の通常整数型の範囲を超えるような値の表現には Python の長整数型が
使われます。例えば、ラージファイルのサポートは Irix の最近のバージョン
では標準で有効ですが、Solaris 2.6 および 2.7 では、以下のように
する必要があります:

     CFLAGS="`getconf LFS_CFLAGS`" OPT="-g -O2 $CFLAGS" \
             ./configure

On large-file-capable Linux systems, this might work:

     CFLAGS='-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64' OPT="-g -O2 $CFLAGS" \
             ./configure


File: python-lib-jp.info,  Node: モジュールの内容 3,  Prev: ラージファイルのサポート,  Up: posix

16.1.2 モジュールの内容
-----------------------

`posix' では以下のデータ項目を定義しています:

`environ'
     インタプリタが起動した時点の環境変数文字列を表現する辞書です。
     例えば、`environ['HOME']' はホームディレクトリの パス名で、C
     言語の `getenv("HOME")' と等価です。

     この辞書を変更しても、`execv()'、`popen()' または `system()'
     などに渡される環境変数文字列には影響しません;
     そうした環境を変更するする必要がある場合、`environ' を `execve()'
     に渡すか、`system()' または `popen()' の命令文字列に変数の代入や
     export 文を 追加してください。

     _Note:_ `os' モジュールでは、もう一つの `environ'
     実装を提供しており、環境変数が変更された場合、その内容を更新する
     ようになっています。`os.environ' を更新した場合、この辞書は
     古い内容を表していることになってしまうので、このことにも注意
     してください。`posix' モジュール版を直接アクセスするよりも、 `os'
     モジュール版を使う方が推奨されています。

このモジュールのその他の内容は `os' モジュールからのみの
アクセスになっています; 詳しい説明は`os' モジュールの
ドキュメントを参照してください。


File: python-lib-jp.info,  Node: pwd,  Next: spwd,  Prev: posix,  Up: Unix独特のサービス

16.2 パスワードデータベースへのアクセスを提供する
=================================================

パスワードデータベースへのアクセスを提供する (`getpwnam()' など)。

このモジュールはUNIXのユーザアカウントとパスワードのデータベースへ
のアクセスを提供します。全てのUNIX系OSで利用できます。

パスワードデータベースの各エントリはタプルのようなオブジェクトで提供され、
それぞれの属性は`passwd'構造体のメンバに対応しています(下
の属性欄については、`<pwd.h>'を見てください)。

インデックス             属性                     意味
------                   -----                    -----
0                        `pw_name'                ログイン名
1                        `pw_passwd'              暗号化されたパスワード(optional))
2                        `pw_uid'                 ユーザID(UID)
3                        `pw_gid'                 グループID(GID)
4                        `pw_gecos'               実名またはコメント
5                        `pw_dir'                 ホームディレクトリ
6                        `pw_shell'               シェル

UIDとGIDは整数で、それ以外は全て文字列です。
検索したエントリが見つからないと`KeyError'が発生します。

_Note:_ 伝統的なUNIXでは、`pw_passwd'フィールドはDES由来のアルゴリ
ズムで暗号化されたパスワード(`crypy' モジュー
ルをごらんください)が含まれています。しかし、近代的なUNIX系OSでは_シャドウパスワード_とよばれる仕組みを利用しています。この場合には
PW_PASSWDフィールドにはアスタリスク(`'*'')か、`x'と
いう一文字だけが含まれており、暗号化されたパスワードは、一般には見えない
`/etc/shadow'というファイルに入っています。PW_PASSWDフィールド
に有用な値が入っているかはシステムに依存します。
利用可能なら、暗号化されたパスワードへのアクセスが必要なときには
`spwd'モジュールを利用してください。

このモジュールでは以下のものが定義されています:

`getpwuid(uid)'
     与えられたUIDに対応するパスワードデータベースのエントリを返します。

`getpwnam(name)'
     与えられたユーザ名に対応するパスワードデータベースのエントリを返します。

`getpwall()'
     パスワードデータベースの全てのエントリを、任意の順番で並べたリストを返し
     ます。

See also:
     *Note grp:: このモジュールに似た、グループデータベースへのアクセス
     を提供するモジュール。 *Note spwd::
     このモジュールに似た、シャドウパスワードデータベースへのアクセス
     を提供するモジュール。


File: python-lib-jp.info,  Node: spwd,  Next: grp,  Prev: pwd,  Up: Unix独特のサービス

16.3 シャドウパスワードデータベース
===================================

シャドウパスワードデータベース(`getspnam()' など _Added in Python
version 2.5_

このモジュールは UNIX
のシャドウパスワードデータベースへのアクセスを提供します。 様々な UNIX
環境で利用できます。

シャドウパスワードデータベースへアクセスできる権限が必要(大抵の場合
rootである必要があります)です。

シャドウパスワードデータベースのエントリはタプル状のオプジェクトで提供され、
その属性は `spwd'
構造のメンバーに対応しています（以下を参照してください。
`<shadow.h>を参照'):

Index                    Attribute                Meaning
------                   -----                    -----
0                        `sp_nam'                 ログイン名
1                        `sp_pwd'                 暗号化されたパスワード
2                        `sp_lstchg'              最終更新日
3                        `sp_min'                 パスワード変更が出来るようになるまでの最小日数
4                        `sp_max'                 パスワードを変更しなくても良い最大日数
5                        `sp_warn'                パスワードが期限切れになる前に、
                                                  期限切れが近づいている旨の警告をユーザに出しはじめる日数
6                        `sp_inact'               パスワードが期限切れになってから、
                                                  アカウントがinactiveとなり使用できなくなるまでの日数
7                        `sp_expire'              1970-01-01からアカウントが使用できなくなるまでの日数
8                        `sp_flag'                将来のために予約

SP_NAMとSP_PWDは文字列で、他は全て整数です。

エントリが見つからなかった時は`KeyError'が起きます。

このモジュールでは以下を定義しています:

`getspnam(name)'
     与えられたユーザ名に対応するシャドウパスワードデータベースのエントリを返します。

`getspall()'
     利用可能なシャドウパスワードデータベースの全エントリを任意の順番で返します。

See also:
     *Note grp::
     このモジュールに似たグループデータベースへのインタフェース *Note
     pwd::
     このモジュールに似た通常のパスワードデータベースへのインタフェース


File: python-lib-jp.info,  Node: grp,  Next: crypt,  Prev: spwd,  Up: Unix独特のサービス

16.4 グループデータベースへのアクセス
=====================================

グループデータベースへのアクセス (`getgrnam()' およびその仲間)。

このモジュールでは UNIX グループ (group) データベースへのアクセス機構を
提供します。全ての UNIX バージョンで利用可能です。

このモジュールはグループデータベースのエントリをタプルに似たオブジェクト
として報告されます。このオブジェクトの属性は `group' 構造体の各メンバ
(以下の属性フィールド、`<pwd.h>' を参照) に対応 します:

インデクス               属性                     意味
------                   -----                    -----
0                        gr_name                  グループ名
1                        gr_passwd                (暗号化された)
                                                  グループパスワード;
                                                  しばしば空文字列になります
2                        gr_gid                   数字のグループ ID
3                        gr_mem                   グループメンバの全てのユーザ名

gid は整数、名前およびパスワードは文字列、そしてメンバリストは
文字列からなるリストです。
(ほとんどのユーザは、パスワードデータベースで自分が入れられているグループ
のメンバとしてグループデータベース内では明示的に列挙されていないので
注意してください。完全なメンバ情報を取得するには両方のデータベースを
調べてください。)

このモジュールでは以下の内容を定義しています:

`getgrgid(gid)'
     与えられたグループ ID
     に対するグループデータベースエントリを返します。
     要求したエントリが見つからなかった場合、`KeyError' が
     送出されます。

`getgrnam(name)'
     与えられたグループ名に対するグループデータベースエントリを返します。
     要求したエントリが見つからなかった場合、`KeyError' が
     送出されます。

`getgrall()'
     全ての入手可能なグループエントリを返します。順番は決まっていません。

See also:
     *Note pwd::
     このモジュールと類似の、ユーザデータベースへのインタフェース。
     *Note spwd::
     このモジュールと類似の、シャドウパスワードデータベースへのインタフェース。


File: python-lib-jp.info,  Node: crypt,  Next: dl,  Prev: grp,  Up: Unix独特のサービス

16.5 UNIX パスワードをチェックするための関数
============================================

UNIX パスワードをチェックするための関数 `crypt()'。

このモジュールは DES  アルゴリズムに基づいた 一方向ハッシュ関数である
`crypt(3)' 

ルーチンを実装しています。詳細については UNIX マニュアルページ
を参照してください。このモジュールは、Python スクリプトが
ユーザから入力されたパスワードを受理できるようにしたり、UNIX
パスワードに (脆弱性検査のための) 辞書攻撃を試みるのに使えます。

このモジュールは実行環境の`crypt(3)' の実装に依
存しています。そのため、現在の実装で利用可能な拡張を、このモジュールで
もそのまま利用できます。

`crypt(word, salt)'
     WORD は通常はユーザのパスワードで、プロンプトやグラフィカル
     インタフェースからタイプ入力されます。SALT は通常ランダムな 2
     文字からなる文字列で、DES アルゴリズムに 4096 通りのうち 1 つの
     方法で外乱を与えるために使われます。SALT に使う文字は集合
     "[./a-zA-Z0-9]" の要素でなければなりません。
     ハッシュされたパスワードを文字列として返します。パスワード文字列
     は SALT と同じ文字集合に含まれる文字からなります (最初の 2 文字は
     SALT 自体です).

     いくつかの拡張された`crypt(3)' は異なる値と SALT
     の長さを許しているので、パスワードをチェックする際にはcrypt
     されたパスワード文字列全体をSALTとして渡すよう勧めます。


典型的な使用例のサンプルコード:

     import crypt, getpass, pwd

     def login():
         username = raw_input('Python login:')
         cryptedpasswd = pwd.getpwnam(username)[1]
         if cryptedpasswd:
             if cryptedpasswd == 'x' or cryptedpasswd == '*':
                 raise "Sorry, currently no support for shadow passwords"
             cleartext = getpass.getpass()
             return crypt.crypt(cleartext, cryptedpasswd) == cryptedpasswd
         else:
             return 1


File: python-lib-jp.info,  Node: dl,  Next: termios,  Prev: crypt,  Up: Unix独特のサービス

16.6 共有オブジェクトのC関数の呼び出し
======================================

共有オブジェクトのC関数の呼び出し

`dl'モジュールは`dlopen()'関数へのインターフェースを 定義します。
これはダイナミックライブラリにハンドルするための
UNIXプラットフォーム上の最も一般的なインターフェースです。
そのライブラリの任意の関数を呼ぶプログラムを与えます。

_`dl'モジュールはPythonの型システムとエラー処理をバイパス
しています。もし間違って使用すれば、セグメンテーションフォルト、
クラッシュ、その他の不正な動作を起こします。_

_Note:_ このモジュールは`sizeof(int) == sizeof(long) == sizeof(char *)'
でなければ働きません。
そうでなければimportするときに`SystemError'が送出されるでしょう。

`dl'モジュールは次の関数を定義します:

`open(name[, mode` = RTLD_LAZY'])'
     共有オブジェクトファイルを開いて、ハンドルを返します。
     モードは遅延結合(`RTLD_LAZY')または即時結合(`RTLD_NOW')
     を表します。 デフォルトは`RTLD_LAZY'です。
     いくつかのシステムは`RTLD_NOW'をサポートしていないことに
     注意してください。

     返り値は`dlobject'です。

`dl'モジュールは次の定数を定義します:

`RTLD_LAZY'
     `open()'の引数として使います。

`RTLD_NOW'
     `open()'の引数として使います。
     即時結合をサポートしないシステムでは、
     この定数がモジュールに現われないことに注意してください。
     最大のポータビリティを求めるならば、システムが即時結合をサポートする
     かどうかを決定するために`hasattr()'を使用してください。

`dl'モジュールは次の例外を定義します:

`error'
     動的なロードやリンクルーチンの内部でエラーが生じたときに送出される例外です。

例:

     >>> import dl, time
     >>> a=dl.open('/lib/libc.so.6')
     >>> a.call('time'), time.time()
     (929723914, 929723914.498)

この例はDebian GNU/Linuxシステム上で行なったもので、
このモジュールの使用はたいてい悪い選択肢であるという事実のよい例です。

* Menu:

* Dlオブジェクト::


File: python-lib-jp.info,  Node: Dlオブジェクト,  Prev: dl,  Up: dl

16.6.1 Dlオブジェクト
---------------------

`open()'によって返されたDlオブジェクトは次のメソッドを持っています:

`close()'
     メモリーを除く全てのリソースを解放します。

`sym(name)'
     NAMEという名前の関数が参照された共有オブジェクトに存在する場合、
     そのポインター(整数値)を返します。 存在しない場合`None'を返します。
     これは次のように使えます:

          >>> if a.sym('time'):
          ...     a.call('time')
          ... else:
          ...     time.time()

     (0は`NULL'ポインターであるので、この関数は0でない数を返すだろう
     ということに注意してください)

`call(name[, arg1[, arg2...]])'
     参照された共有オブジェクトのNAMEという名前の関数を呼出します。
     引数は、Python整数(そのまま渡される)、Python文字列(ポインターが渡される)、
     `None' (`NULL'として渡される) のどれかでなければいけません。
     Pythonはその文字列が変化させられるのを好まないので、
     文字列は`const char*'として関数に渡されるべきであることに
     注意してください。

     最大で10個の引数が渡すことができ、
     与えられない引数は`None'として扱われます。 関数の返り値はC
     `long'(Python整数である)です。


File: python-lib-jp.info,  Node: termios,  Next: tty,  Prev: dl,  Up: Unix独特のサービス

16.7 POSIX スタイルの端末制御
=============================

POSIX スタイルの端末制御。

このモジュールでは端末 I/O 制御のための POSIX 準拠の関数呼び出し
インタフェースを提供します。これら呼び出しのための完全な記述については、
POSIX または UNIX マニュアルページを参照してください。 POSIX _termios_
形式の端末制御をサポートする UNIX の バージョンで
(かつインストール時に指定した場合に) のみ利用可能です。

このモジュールの関数は全て、ファイル記述子 FD を最初の引数
としてとります。この値は、`sys.stdin.fileno()' が返すような
整数のファイル記述子でも、`sys.stdin' 自体のようなファイル
オブジェクトでもかまいません。

このモジュールではまた、モジュールで提供されている関数を使う上で
必要となる全ての定数を定義しています; これらの定数は C の対応
する関数と同じ名前を持っています。これらの端末制御インタフェース
を利用する上でのさらなる情報については、あなたのシステムの
ドキュメンテーションを参考にしてください。

このモジュールでは以下の関数を定義しています:

`tcgetattr(fd)'
     ファイル記述子 FD の端末属性を含むリストを返します。その形式は:
     `['IFLAG, OFLAG, CFLAG, LFLAG, ISPEED, OSPEED, CC`]' です。CC
     は端末特殊文字のリストです (それぞれ長さ 1
     の文字列です。ただしインデクス `VMIN' および `VTIME'
     の内容は、それらのフィールドが定義されていた場合整数
     の値となります)。

     端末設定フラグおよび端末速度の解釈、および配列 CC のインデクス
     検索は、`termios' で定義されているシンボル定数を使って行わなければ
     なりません。

`tcsetattr(fd, when, attributes)'
     ファイル記述子 FD の端末属性を ATTRIBUTES から取り出して
     設定します。ATTRIBUTES は `tcgetattr()' が返すような
     リストです。引数 WHEN は属性がいつ変更されるかを決定します:
     `TCSANOW' は即時変更を行い、`TCSAFLUSH' は現在
     キューされている出力を全て転送し、全てのキューされている入力を無視
     した後に変更を行います。

`tcsendbreak(fd, duration)'
     ファイル記述子 FD にブレークを送信します。DURATION をゼロ
     にすると、 0.25-0.5 秒間のブレークを送信します; DURATION の値が
     ゼロでない場合、その意味はシステム依存です。

`tcdrain(fd)'
     ファイル記述子 FD に書き込まれた全ての出力が転送されるまで
     待ちます。

`tcflush(fd, queue)'
     ファイル記述子 FD にキューされたデータを無視します。
     どのキューかはQUEUE セレクタで指定します: `TCIFLUSH'
     は入力キュー、 `TCOFLUSH' は出力キュー、`TCIOFLUSH'
     は両方のキューです。

`tcflow(fd, action)'
     ファイル記述子 FD の入力または出力をサスペンドしたりレジューム
     したりします。引数 ACTION は出力をサスペンドする `TCOOFF'、
     出力をレジュームする `TCOON' 、入力をサスペンドする `TCIOFF'
     、入力をレジュームする `TCION' をとることが できます。

See also:
     *Note tty:: 一般的な端末制御操作のための便利な関数。

* Menu:

* termios Example::


File: python-lib-jp.info,  Node: termios Example,  Prev: termios,  Up: termios

16.7.1 使用例
-------------

以下はエコーバックを切った状態でパスワード入力を促す関数です。
ユーザの入力に関わらず以前の端末属性を正確に回復するために、 二つの
`tcgetattr()' と `try' ... `finally' 文によるテクニックが使われています:

     def getpass(prompt = "Password: "):
         import termios, sys
         fd = sys.stdin.fileno()
         old = termios.tcgetattr(fd)
         new = termios.tcgetattr(fd)
         new[3] = new[3] & ~termios.ECHO          # lflags
         try:
             termios.tcsetattr(fd, termios.TCSADRAIN, new)
             passwd = raw_input(prompt)
         finally:
             termios.tcsetattr(fd, termios.TCSADRAIN, old)
         return passwd


File: python-lib-jp.info,  Node: tty,  Next: pty,  Prev: termios,  Up: Unix独特のサービス

16.8 端末制御のための関数群
===========================

一般的な端末制御操作のためのユーティリティ関数群。

`tty' モジュールは端末を cbreak および raw モードにする
ための関数を定義しています。

このモジュールは `termios' モジュールを必要とするため、
UNIXでしか動作しません。

`tty' モジュールでは、以下の関数を定義しています:

`setraw(fd[, when])'
     ファイル記述子 FD のモードを raw モードに変えます。 WHEN
     を省略すると標準の値は `termios.TCSAFLUSH' に
     なり、`termios.tcsetattr()' に渡されます。

`setcbreak(fd[, when])'
     ファイル記述子 FD のモードを cbreakモードに変えます。 WHEN
     を省略すると標準の値は `termios.TCSAFLUSH' に
     なり、`termios.tcsetattr()' に渡されます。

See also:
     *Note termios:: 低レベル端末制御インタフェース。


File: python-lib-jp.info,  Node: pty,  Next: fcntl,  Prev: tty,  Up: Unix独特のサービス

16.9 擬似端末ユーティリティ
===========================

SGIとLinux用の擬似端末を制御する

`pty'モジュールは擬似端末(他のプロセスを実行してその制御をしてい
る端末をプログラムで読み書きする)を制御する操作を定義しています。

擬似端末の制御はプラットフォームに強く依存するので、SGIとLinux用のコード
しか存在していません。(Linux用のコードは他のプラットフォームでも動作するよ
うに作られていますがテストされていません。)

`pty'モジュールでは以下の関数を定義しています:

`fork()'
     forkします。子プロセスの制御端末を擬似端末に接続します。
     返り値は`(PID, FD)'です。子プロセスはPIDとして0、
     、FDとして_invalid_ をそれぞれ受けとります。親プロセスは
     PIDとして子プロセスのPID、FDとして子プロセスの制御端末(子プ
     ロセスの標準入出力に接続されている)のファイルディスクリプタを受けとります。

`openpty()'
     新しい擬似端末のペアを開きます。
     利用できるなら`os.openpty()'を使い、
     利用できなければSGIと一般的なUNIXシステム用の
     エミュレーションコードを使います。
     マスター、スレーブそれぞれのためのファイルディスクリプタ、
     `(MASTER, SLAVE)'のタプルを返します。

`spawn(argv[, master_read[, stdin_read]])'
     プロセスを生成して制御端末を現在のプロセスの標準入出力に接続します。
     これは制御端末を読もうとするプログラムをごまかすために利用されます。

     MASTER_READとSTDIN_READにはファイルディスクリプタから読み込む
     関数を指定してください。デフォルトでは呼ばれるたびに1024バイトずつ読み
     込もうとします。


File: python-lib-jp.info,  Node: fcntl,  Next: pipes,  Prev: pty,  Up: Unix独特のサービス

16.10 `fcntl()' および `ioctl()' システムコール
===============================================

`fcntl()' および `ioctl()' システム コール。

このモジュールでは、ファイル記述子 (file descriptor) に基づいた
ファイル制御および I/O 制御を実現します。 このモジュールは、 UNIX
のルーチンである `fcntl()' および `ioctl()' へのインタフェースです。

このモジュール内の全ての関数はファイル記述子 FD を最初の引数に
取ります。この値は `sys.stdin.fileno()' が返すような
整数のファイル記述子でも、`sys.stdin' 自体のような、純粋に
ファイル記述子だけを返す `fileno()' メソッドを提供している
ファイルオブジェクトでもかまいません。

このモジュールでは以下の関数を定義しています:

`fcntl(fd, op[, arg])'
     要求された操作をファイル記述子 FD (または `fileno()'
     メソッドを提供しているファイルオブジェクト) に対して実行します。
     操作は OP で定義され、オペレーティングシステム依存です。
     これらの操作コードは `fcntl' モジュール内にもあります。 引数 ARG
     はオプションで、標準では整数値 `0' です。
     この引数を与える場合、整数か文字列の値をとります。
     引数が無いか整数値の場合、この関数の戻り値は C 言語の `fcntl()'
     を呼び出した際の整数の戻り値になります。
     引数が文字列の場合には、``struct'.pack()' で作られる
     ようなバイナリの構造体を表します。
     バイナリデータはバッファにコピーされ、そのアドレスが C 言語の
     `fcntl()' 呼び出しに渡されます。
     呼び出しが成功した後に戻される値はバッファの内容で、文字列
     オブジェクトに変換されています。返される文字列は ARG 引数
     と同じ長さになます。この値は 1024 バイトに制限されています。
     オペレーティングシステムからバッファに返される情報の長さが 1024
     バイトよりも大きい場合、大抵はセグメンテーション違反となるか、
     より不可思議なデータの破損を引き起こします。

     `fcntl()' が失敗した場合、`IOError' が 送出されます。

`ioctl(fd, op, arg)'
     この関数は `fcntl()' 関数と同じですが、操作が通常ライブラリ
     モジュール `termios' で定義されており、引数の扱いがより
     複雑であるところが異なります。

     パラメタ ARG は整数か、存在しない (整数 `0' と等価なもの
     として扱われます) か、(通常の Python 文字列のような) 読み出し専用の
     バッファインタフェースをサポートするオブジェクトか、読み書き
     バッファインタフェースをサポートするオブジェクトです。

     最後の型のオブジェクトを除き、動作は `fcntl()' 関数と 同じです。

     可変なバッファが渡された場合、動作は MUTATE_FLAG 引数の
     値で決定されます。

     この値が偽の場合、バッファの可変性は無視され、動作は読み出しバッファ
     の場合と同じになりますが、上で述べた 1024
     バイトの制限は回避されます -
     従って、オペレーティングシステムが希望するバッファ長までで
     あれば正しく動作します。

     MUTATE_FLAG が真の場合、バッファは (実際には) 根底にある `ioctl()'
     システムコールに渡され、後者の戻り値が 呼び出し側の Python
     に引き渡され、バッファの新たな内容は `ioctl()' の動作を反映します。
     この説明はやや単純化されています。というのは、与えられたバッファが
     1024 バイト長よりも短い場合、バッファはまず 1024 バイト長の
     静的なバッファにコピーされてから `ioctl()' に渡され、
     その後引数で与えたバッファに戻しコピーされるからです。

     MUTATE_FLAG が与えられなかった場合、2.3 ではこの値は偽となります。
     この仕様は今後のいくつかのバージョンを経た Python で変更される予定
     です: 2.4 では、 MUTATE_FLAG を提供し忘れると警告が出されますが
     同じ動作を行い、2.5 ではデフォルトの値が真となるはずです。

     以下に例を示します:

          >>> import array, fcntl, struct, termios, os
          >>> os.getpgrp()
          13341
          >>> struct.unpack('h', fcntl.ioctl(0, termios.TIOCGPGRP, "  "))[0]
          13341
          >>> buf = array.array('h', [0])
          >>> fcntl.ioctl(0, termios.TIOCGPGRP, buf, 1)
          0
          >>> buf
          array('h', [13341])


`flock(fd, op)'
     ファイル記述子 FD (`fileno()' メソッドを提供している
     ファイルオブジェクトも含む) に対してロック操作 OP を実行します。
     詳細は UNIX マニュアルの `flock(3)' を参照してください
     (システムによっては、この関数は `fcntl()' を使って
     エミュレーションされています)。

`lockf(fd, operation, [length, [start, [whence]]])'
     本質的に `fcntl()' によるロッキングの呼び出しをラップ
     したものです。FD はロックまたはアンロックするファイルの
     ファイル記述子で、OPERATION は以下の値:

        * `LOCK_UN' - アンロック

        * `LOCK_SH' - 共有ロックを取得

        * `LOCK_EX' - 排他的ロックを取得

     のうちいずれかになります。

     OPERATION が `LOCK_SH' または `LOCK_EX' の場合、`LOCK_NB' とビット
     OR にすることでロック取得時に
     ブロックしないようにすることができます。`LOCK_NB' が
     使われ、ロックが取得できなかった場合、`IOError' が送出
     され、例外は ERRNO 属性を持ち、その値は `EACCESS' または `EAGAIN'
     になります (オペレーティングシステムに 依存します;
     可搬性のため、両方の値をチェックしてください)。
     少なくともいくつかのシステムでは、 ファイル記述子が参照している
     ファイルが書き込みのために開かれている場合、`LOCK_EX'
     だけしか使うことができません。

     LENGTH はロックを行いたいバイト数、START は ロック領域先頭の
     WHENCE からの相対的なバイトオフセット、 WHENCE は `fileobj.seek()'
     と同じで、具体的には:

        * `0' - ファイル先頭からの相対位置 (`SEEK_SET')

        * `1' - 現在のバッファ位置からの相対位置 (`SEEK_CUR')

        * `2' - ファイルの末尾からの相対位置 (`SEEK_END')

     START の標準の値は 0 で、ファイルの先頭から開始することを
     意味します。WHENCE の標準の値も 0 です。

以下に (全ての SVR4 互換システムでの) 例を示します:

     import struct, fcntl, os

     f = open(...)
     rv = fcntl.fcntl(f, fcntl.F_SETFL, os.O_NDELAY)

     lockdata = struct.pack('hhllhh', fcntl.F_WRLCK, 0, 0, 0, 0, 0)
     rv = fcntl.fcntl(f, fcntl.F_SETLKW, lockdata)

最初の例では、戻り値 RV は整数値を保持しています; 二つ目の
例では文字列値を保持しています。LOCKDATA 変数の構造体
レイアウトはシステム依存です -- 従って `flock()' を 呼ぶ方がベターです。

See also:
     *Note os:: もし　`O_SHLOCK' と `O_EXLOCK'が　
     `os'モジュールに存在する場合、 `os.open()' 関数は `lockf()' や
     `flock()'関数よりも
     よりプラットフォーム独立なロック機構を提供します。


File: python-lib-jp.info,  Node: pipes,  Next: posixfile,  Prev: fcntl,  Up: Unix独特のサービス

16.11 シェルパイプラインへのインタフェース
==========================================

Python による UNIX シェルパイプラインへのインタフェース。

`pipes' モジュールでは、_'pipeline'_ の概念 -- ある
ファイルを別のファイルに変換する機構の直列接続 -- を抽象化する
ためのクラスを定義しています。

このモジュールは `/bin/sh' コマンドラインを利用するため、 `os.system()'
および `os.popen()' のための POSIX
準拠のシェル、または互換のシェルが必要です。

`pipes' モジュールでは、以下のクラスを定義しています:

`Template()'
     パイプラインを抽象化したクラス。

使用例:

     >>> import pipes
     >>> t=pipes.Template()
     >>> t.append('tr a-z A-Z', '--')
     >>> f=t.open('/tmp/1', 'w')
     >>> f.write('hello world')
     >>> f.close()
     >>> open('/tmp/1').read()
     'HELLO WORLD'

* Menu:

* テンプレートオブジェクト::


File: python-lib-jp.info,  Node: テンプレートオブジェクト,  Prev: pipes,  Up: pipes

16.11.1 テンプレートオブジェクト
--------------------------------

テンプレートオブジェクトは以下のメソッドを持っています:

`reset()'
     パイプラインテンプレートを初期状態に戻します。

`clone()'
     元のパイプラインテンプレートと等価の新しいオブジェクトを返します。

`debug(flag)'
     FLAG が真の場合、デバッグをオンにします。そうでない場合、
     デバッグをオフにします。デバッグがオンの時には、実行されるコマンド
     が印字され、より多くのメッセージを出力するようにするために、シェルに
     `set -x' 命令を与えます。

`append(cmd, kind)'
     新たなアクションをパイプラインの末尾に追加します。CMD 変数は
     有効な bourne shell 命令でなければなりません。KIND 変数は
     二つの文字からなります。

     最初の文字は `'-'' (コマンドが標準入力からデータを読み出すことを
     意味します)、`'f'' (コマンドがコマンドライン上で与えたファイルから
     データを読み出すことを意味します)、あるいは `'.'' (コマンドは
     入力を読まないことを意味します、従ってパイプラインの先頭になります)、の
     いずれかになります。

     同様に、二つ目の文字は `'-'' (コマンドが標準出力に結果を書き込む
     ことを意味します)、`'f'' (コマンドがコマンドライン上で指定した
     ファイルに結果を書き込むことを意味します)、あるいは `'.'' (コマンド
     はファイルを書き込まないことを意味し、パイプラインの末尾になります)、
     のいずれかになります。

`prepend(cmd, kind)'
     パイプラインの先頭に新しいアクションを追加します。引数の説明については
     `append()' を参照してください。

`open(file, mode)'
     ファイル類似のオブジェクトを返します。このオブジェクトは FILE
     を開いていますが、パイプラインを通して読み書きするようになっています。
     MODE には `'r'' または `'w'' のいずれか一つしか与える
     ことができないので注意してください。

`copy(infile, outfile)'
     パイプを通して INFILE を OUTFILE にコピーします。


File: python-lib-jp.info,  Node: posixfile,  Next: resource,  Prev: pipes,  Up: Unix独特のサービス

16.12 ロック機構をサポートするファイル類似オブジェクト
======================================================

ロック機構をサポートするファイル類似オブジェクト。

_This is deprecated in Python 1.5.  このモジュールが提供しているよりも
うまく処理ができ、可搬性も高いロック操作が ``fcntl'.lockf()'
で提供されています。 _

このモジュールでは、組み込みのファイルオブジェクトの上にいくつかの
追加機能を実装しています。特に、このオブジェクトはファイルのロック機構、
ファイルフラグへの操作、およびファイルオブジェクトを複製するための
簡単なインタフェースを実装しています。オブジェクトは全ての標準
ファイルオブジェクトのメソッドに加え、以下に述べるメソッドを持って
います。このモジュールはファイルのロック機構に `fcntl.fcntl()'
を用いるため、ある種の UNIXでしか動作しません。 

posixfile オブジェクトをインスタンス化するには、 `posixfile'
モジュールの `open()' 関数を使います。生成されるオブジェクト
は標準ファイルオブジェクトとだいたい同じルック& フィールです。

`posixfile' モジュールでは、以下の定数を定義しています:

`SEEK_SET'
     オフセットをファイルの先頭から計算します。

`SEEK_CUR'
     オフセットを現在のファイル位置から計算します。

`SEEK_END'
     オフセットをファイルの末尾から計算します。

`posixfile' モジュールでは以下の関数を定義しています:

`open(filename[, mode[, bufsize]])'
     指定したファイル名とモードで新しい posixfile オブジェクトを作成
     します。FILENAME、MODE および BUFSIZE 引数は 組み込みの `open()'
     関数と同じように解釈されます。

`fileopen(fileobject)'
     指定した標準ファイルオブジェクトで新しい posixfile オブジェクトを
     作成します。作成されるオブジェクトは元のファイルオブジェクトと
     同じファイル名およびモードを持っています。

posixfile オブジェクトでは以下の追加メソッドを定義しています:

`lock(fmt, [len[, start[, whence]]])'
     ファイルオブジェクトが参照しているファイルの指定部分にロックをかけます。
     指定の書式は下のテーブルで説明されています。 LEN
     引数にはロックする部分の長さを指定します。標準の値は `0' です。
     START にはロックする部分の先頭オフセットを指定し、その 標準値は
     `0' です。WHENCE 引数はオフセットをどこからの
     相対位置にするかを指定します。この値は定数 `SEEK_SET'、
     `SEEK_CUR'、または `SEEK_END' のいずれかになります。 標準の値は
     `SEEK_SET' です。引数についてのより詳しい情報は システムの
     `fcntl(2)' マニュアルページを参照してください。

`flags([flags])'
     ファイルオブジェクトが参照しているファイルに指定したフラグを設定
     します。新しいフラグは特に指定しない限り以前のフラグと OR
     されます。 指定書式は下のテーブルで説明されています。FLAGS
     引数なしの 場合、現在のフラグを示す文字列が返されます (`?'
     修飾子と同じ です) 。 フラグについてのより詳しい情報はシステムの
     `fcntl(2)' マニュアルページを参照してください。

`dup()'
     ファイルオブジェクトと、背後のファイルポインタおよびファイル記述子
     を複製します。返されるオブジェクトは新たに開かれたファイルのように
     振舞います。

`dup2(fd)'
     ファイルオブジェクトと、背後のファイルポインタおよびファイル記述子
     を複製します。新たなオブジェクトは指定したファイル記述子を持ちます。
     それ以外の点では、返されるオブジェクトは新たに開かれたファイルのように
     振舞います。

`file()'
     posixfile
     オブジェクトが参照している標準ファイルオブジェクトを返します。
     この関数は標準ファイルオブジェクトを使うよう強制している関数を使う
     場合に便利です。

全てのメソッドで、要求された操作が失敗した場合には `IOError'
が送出されます。

`lock()' の書式指定文字には以下のような意味があります:

書式指定                             意味
------                               -----
u                                    指定領域のロックを解除します
r                                    指定領域の読み出しロックを要求します
w                                    指定領域の書き込みロックを要求します

これに加え、以下の修飾子を書式に追加できます:

修飾子                   意味                     注釈
------                   -----                    -----
|                        ロック操作が処理されるまで待ちます
?                        要求されたロックと衝突している第一のロックを返すか、衝突がない場合には(1)
                         `None' を返します。      

注釈:

`(1)'
     返されるロックは `(MODE, LEN, START, WHENCE, PID)' の形式で、MODE
     はロックの形式を表す文字 ('r' または 'w') です。この修飾子は
     ロック要求の許可を行わせません; すなわち、問い合わせの目的にしか
     使えません。

`flags()' の書式指定文字には以下のような意味があります:

書式                                 意味
------                               -----
a                                    追記のみ (append only) フラグ
c                                    実行時クローズ (close on exec)
                                     フラグ
n                                    無遅延 (no delay) フラグ
                                     (非ブロック (non-blocking)
                                     フラグとも呼ばれます)
s                                    同期 (synchronization) フラグ

これに加え、以下の修飾子を書式に追加できます:

修飾子                   意味                     注釈
------                   -----                    -----
!                        指定したフラグを通常の   (1)
                         'オン' にせず 'オフ'     
                         にします                 
=                        フラグを標準の 'OR'      (1)
                         操作ではなく置換します。 
?                        設定されているフラグを表現する文字からなる文字列を返します。(2)

注釈:

`(1)'
     `!' および `=' 修飾子は互いに排他の関係にあります。

`(2)'
     この文字列が表すフラグは同じ呼び出しによってフラグが置き換えられた後のものです。


以下に例を示します:

     import posixfile

     file = posixfile.open('/tmp/test', 'w')
     file.lock('w|')
     ...
     file.lock('u')
     file.close()


File: python-lib-jp.info,  Node: resource,  Next: nis,  Prev: posixfile,  Up: Unix独特のサービス

16.13 リソース使用状態の情報
============================

現プロセスのリソース使用状態を提供するためのインタフェース。

このモジュールでは、プログラムによって使用されているシステムリソースを
計測したり制御するための基本的なメカニズムを提供します。

特定のシステムリソースを指定したり、現在のプロセスやその子プロセスの
リソース使用情報を要求するためにはシンボル定数が使われます。

エラーを表すための例外が一つ定義されています:

`error'
     下に述べる関数は、背後にあるシステムコールが予期せず失敗した場合、
     このエラーを送出するかもしれません。

* Menu:

* リソースの制限::
* リソースの使用状態::


File: python-lib-jp.info,  Node: リソースの制限,  Next: リソースの使用状態,  Prev: resource,  Up: resource

16.13.1 リソースの制限
----------------------

リソースの使用は下に述べる `setrlimit()' 関数を使って制限
することができます。各リソースは二つ組の制限値: ソフトリミット (soft
limit) 、およびハードリミット (hard limit) 、で制御されます。
ソフトリミットは現在の制限値で、時間とともにプロセスによって下げたり
上げたりできます。ソフトリミットはハードリミットを超えることは
できません。ハードリミットはソフトリミットよりも高い任意の値まで
下げることができますが、上げることはできません。(スーパユーザの 有効な
UID を持つプロセスのみがハードリミットを上げることができます。)

制限をかけるべく指定できるリソースはシステムに依存します。指定できる
リソースは `getrlimit(2)' マニュアルページで解説されています。
以下に列挙するリソースは背後のオペレーティングシステムがサポートする
場合にサポートされています; オペレーティングシステム側で値を調べたり
制御したりできないリソースは、そのプラットフォーム向けのこのモジュール
内では定義されていません。

`getrlimit(resource)'
     RESOURCE の現在のソフトおよびハードリミットを表すタプル `(SOFT,
     HARD)' を返します。無効なリソースが 指定された場合には
     `ValueError' が、背後のシステム コールが予期せず失敗した場合には
     `error' が送出されます。

`setrlimit(resource, limits)'
     RESOUCE の新たな消費制限を設定します。LIMITS 引数 には、タプル
     `(SOFT, HARD)' による二つの整数で、
     新たな制限を記述しなければなりません。現在指定可能な最大の制限
     を指定するために `-1' を使うことができます。

     無効なリソースが指定された場合、ソフトリミットの値がハードリミット
     の値を超えている場合、プロセスが (スーパユーザの有効な UID を持って
     いない状態で) ハードリミットを引き上げようとした場合には
     `ValueError' が送出されます。背後のシステムコールが予期せず
     失敗した場合には `error' が送出される可能性もあります。

以下のシンボルは、後に述べる関数 `setrlimit()' および `getrlimit()'
を使って消費量を制御することができるリソース
を定義しています。これらのシンボルの値は、C プログラムで使われて
いるシンボルと全く同じです。

`getrlimit(2)' の UNIX マニュアルページには、指定可能な
リソースが列挙されています。全てのシステムで同じシンボルが使われて
いるわけではなく、また同じリソースを表すために同じ値が使われて
いるとも限らないので注意してください。このモジュールはプラットフォーム
間の相違を隠蔽しようとはしていません -- あるプラットフォームで
定義されていないシンボルは、そのプラットフォーム向けの本モジュール
では利用することができません。

`RLIMIT_CORE'
     現在のプロセスが生成できるコアファイルの最大 (バイト) サイズです。
     プロセスの全体イメージを入れるためにこの値より大きなサイズのコア
     ファイルが要求された結果、部分的なコアファイルが生成される可能性が
     あります。

`RLIMIT_CPU'
     プロセッサが利用することができる最大プロセッサ時間 (秒) です。
     この制限を超えた場合、`SIGXCPU' シグナルがプロセスに送られ
     ます。(どのようにしてシグナルを捕捉したり、例えば開かれているファイルを
     ディスクにフラッシュするといった有用な処理を行うかについての情報は、
     `signal' モジュールのドキュメントを参照してください)

`RLIMIT_FSIZE'
     プロセスが生成できるファイルの最大サイズです。マルチスレッドプロセス
     の場合、この値は主スレッドのスタックにのみ影響します。

`RLIMIT_DATA'
     プロセスのヒープの最大 (バイト) サイズです。

`RLIMIT_STACK'
     現在のプロセスのコールスタックの最大 (バイト) サイズです。

`RLIMIT_RSS'
     プロセスが取りうる最大 RAM 常駐ページサイズ (resident set size)
     です。

`RLIMIT_NPROC'
     現在のプロセスが生成できるプロセスの上限です。

`RLIMIT_NOFILE'
     現在のプロセスが開けるファイル記述子の上限です。

`RLIMIT_OFILE'
     `RLIMIT_NOFILE' の BSD での名称です。

`RLIMIT_MEMLOCK'
     メモリ中でロックできる最大アドレス空間です。

`RLIMIT_VMEM'
     プロセスが占有できるマップメモリの最大領域です。

`RLIMIT_AS'
     アドレス空間でプロセスが占有できる最大領域 (バイト) です。


File: python-lib-jp.info,  Node: リソースの使用状態,  Prev: リソースの制限,  Up: resource

16.13.2 リソースの使用状態
--------------------------

以下の関数はリソース使用情報を取得するために使われます:

`getrusage(who)'
     この関数は、WHO 引数で指定される、現プロセスおよびその子プロセスに
     よって消費されているリソースを記述するオブジェクトを返します。 WHO
     引数は以下に記述される `RUSAGE_*' 定数のいずれかを
     使って指定します。

     返される値の各フィールドはそれぞれ、個々のシステムリソースがどれくらい
     使用されているか、例えばユーザモードでの実行に費やされた時間やプロセス
     が主記憶からスワップアウトされた回数、を示しています。幾つかの値、
     例えばプロセスが使用しているメモリ量は、内部時計の最小単位に依存します。

     以前のバージョンとの互換性のため、返される値は 16
     要素からなるタプル としてアクセスすることもできます。

     戻り値のフィールド `ru_utime' および `ru_stime' は
     浮動小数点数で、それぞれユーザモードでの実行に費やされた時間、および
     システムモードでの実行に費やされた時間を表します。それ以外の値は
     整数です。これらの値に関する詳しい情報は `getrusage(2)'
     を調べてください。以下に簡単な概要を示します:

     インデクス             フィールド名           リソース
     ------                 -----                  -----
     0                      `ru_utime'             ユーザモード実行時間
                                                   (float)
     1                      `ru_stime'             システムモード実行時間
                                                   (float)
     2                      `ru_maxrss'            最大常駐ページサイズ
     3                      `ru_ixrss'             共有メモリサイズ
     4                      `ru_idrss'             非共有メモリサイズ
     5                      `ru_isrss'             非共有スタックサイズ
     6                      `ru_minflt'            I/O
                                                   を必要とするページフォールト数
     7                      `ru_majflt'            I/O
                                                   を必要としないページフォールト数
     8                      `ru_nswap'             スワップアウト回数
     9                      `ru_inblock'           ブロック入力操作数
     10                     `ru_oublock'           ブロック出力操作数
     11                     `ru_msgsnd'            送信メッセージ数
     12                     `ru_msgrcv'            受信メッセージ数
     13                     `ru_nsignals'          受信シグナル数
     14                     `ru_nvcsw'             自発的な実行コンテキスト切り替え数
     15                     `ru_nivcsw'            非自発的な実行コンテキスト切り替え数

     この関数は無効な WHO 引数を指定した場合には `ValueError'
     を送出します。また、異常が発生 した場合には `error'
     例外が送出される可能性があります。

     _Changed in Python version 2.3_

`getpagesize()'
     システムページ内のバイト数を返します。(ハードウェアページサイズと
     同じとは限りません。) この関数はプロセスが使用しているメモリの
     バイト数を決定する上で有効です。`getrusage()' が 返すタプルの 3
     つ目の要素はページ数で数えたメモリ使用量です;
     ページサイズを掛けるとバイト数になります。

以下の `RUSAGE_*' シンボルはどのプロセスの情報を提供させるか
を指定するために関数 `getrusage()' に渡されます。

`RUSAGE_SELF'
     `RUSAGE_SELF' はプロセス自体に属する情報を要求するために
     使われます。

`RUSAGE_CHILDREN'
     `getrusage()' に渡すと呼び出し側プロセスの子プロセスのリソース
     情報を要求します。

`RUSAGE_BOTH'
     `getrusage()' に渡すと現在のプロセスおよび子プロセスの両方が
     消費しているリソースを要求します。全てのシステムで利用可能なわけでは
     ありません。


File: python-lib-jp.info,  Node: nis,  Next: syslog,  Prev: resource,  Up: Unix独特のサービス

16.14 Sun の NIS (Yellow Pages) へのインタフェース
==================================================

Sun の NIS (Yellow Pages) ライブラリへのインタフェース。

`nis' モジュールは複数のホストを集中管理する上で便利な NIS
ライブラリを薄くラップします。

NIS は UNIX システム上にしかないので、このモジュールは
UNIXでしか利用できません。

`nis' モジュールでは以下の関数を定義しています:

`match(key, mapname[, domain=default_domain])'
     MAPNAME 中で KEY に一致するものを返すか、見つからない
     場合にはエラー (`nis.error') を送出します。
     両方の引数とも文字列で、 KEY は 8 ビットクリーンです。
     返される値は (`NULL' その他を含む可能性のある) 任意のバイト列
     です。

     MAPNAME は他の名前の別名になっていないか最初にチェックされます。

     _Changed in Python version 2.5_

`cat(mapname[, domain=default_domain])'
     `match(KEY, MAPNAME)==VALUE' となる KEY を VALUE
     に対応付ける辞書を返します。
     辞書内のキーと値は共に任意のバイト列なので注意してください。

     MAPNAME は他の名前の別名になっていないか最初にチェックされます。

     _Changed in Python version 2.5_

`maps()'
     有効なマップのリストを返します。

`get_default_domain()'
     システムのデフォルトNISドメインをかえします。 _Added in Python
     version 2.5_

`nis' モジュールは以下の例外を定義しています:

`error'
     NIS 関数がエラーコードを返した場合に送出されます。


File: python-lib-jp.info,  Node: syslog,  Next: commands,  Prev: nis,  Up: Unix独特のサービス

16.15 UNIX syslog ライブラリルーチン群
======================================

UNIX syslog ライブラリルーチン群へのインタフェース。

このモジュールでは UNIX `syslog' ライブラリルーチン群への
インタフェースを提供します。`syslog' の便宜レベルに関する詳細な記述 は
UNIX マニュアルページを参照してください。

このモジュールでは以下の関数を定義しています:

`syslog([priority,] message)'
     文字列 MESSAGE をシステムログ機構に送信します。末尾の改行文字
     は必要に応じて追加されます。各メッセージは FACILITY および LEVEL
     からなる優先度でタグ付けされます。オプションの PRIORITY
     引数はメッセージの優先度を定義します。標準の 値は `LOG_INFO'
     です。PRIORITY 中に、便宜レベルが (`LOG_INFO | LOG_USER' のように)
     論理和を使ってコード化されて いない場合、`openlog()'
     を呼び出した際の値が使われます。

`openlog(ident[, logopt[, facility]])'
     標準以外のログオプションは、`syslog()' の呼び出しに先立って
     `openlog()'
     でログファイルを開く際、明示的に設定することができます。
     標準の値は (通常) INDENT = `'syslog''、 LOGOPT = `0'、FACILITY =
     `LOG_USER' です。 IDENT
     引数は全てのメッセージの先頭に付加する文字列です。 オプションの
     LOGOPT 引数はビットフィールドの値になります -
     とりうる組み合わせ値については以下を参照してください。
     オプションの FACILITY 引数は、便宜レベルコードの設定が
     明示的になされていないメッセージに対する、標準の便宜レベルを設定します。

`closelog()'
     ログファイルを閉じます。

`setlogmask(maskpri)'
     優先度マスクを MASKPRI に設定し、以前のマスク値を返します。
     MASKPRI に設定されていない優先度レベルを持った `syslog()'
     の呼び出しは無視されます。標準では全ての優先度をログ出力します。
     関数 `LOG_MASK(PRI)' は個々の優先度 PRI に対する
     優先度マスクを計算します。関数 `LOG_UPTO(PRI)' は優先度 PRI
     までの全ての優先度を含むようなマスクを計算します。

このモジュールでは以下の定数を定義しています:

`優先度 (高い優先度順):'
     `LOG_EMERG'、 `LOG_ALERT'、 `LOG_CRIT'、 `LOG_ERR'、
     `LOG_WARNING'、 `LOG_NOTICE'、 `LOG_INFO'、 `LOG_DEBUG'。

`便宜レベル:'
     `LOG_KERN'、 `LOG_USER'、 `LOG_MAIL'、 `LOG_DAEMON'、 `LOG_AUTH'、
     `LOG_LPR'、 `LOG_NEWS'、 `LOG_UUCP'、 `LOG_CRON'、および
     `LOG_LOCAL0' から `LOG_LOCAL7'。

`ログオプション:'
     `<syslog.h>' で定義されている場合、 `LOG_PID'、 `LOG_CONS'、
     `LOG_NDELAY'、 `LOG_NOWAIT'、および `LOG_PERROR'。



File: python-lib-jp.info,  Node: commands,  Prev: syslog,  Up: Unix独特のサービス

16.16 コマンド実行ユーティリティ
================================

外部コマンドを実行するためのユーティリティです。

`commands'は、システムへコマンド文字列を渡して実行する
`os.popen()'のラッパー関数を含んでいるモジュールです。
外部で実行したコマンドの結果や、その終了ステータスを扱います。

`commands'モジュールは以下の関数を定義しています。

`getstatusoutput(cmd)'
     文字列CMDを`os.popen()'を使いシェル上で実行し、 タプル`(STATUS,
     OUTPUT)'を返します。 実際には`{ CMD ; } 2>&1'と実行されるため、
     標準出力とエラー出力が混合されます。
     また、出力の最後の改行文字は取り除かれます。
     コマンドの終了ステータスはC言語関数の`wait()'の規則に従って
     解釈することができます。

`getoutput(cmd)'
     `getstatusoutput()'に似ていますが、
     終了ステータスは無視され、コマンドの出力のみを返します。

`getstatus(file)'
     `ls -ld FILE'の出力を文字列で返します。
     この関数は`getoutput()'を使い、引数内の
     バックスラッシュ記号「$\$」とドル記号「$」を適切にエスケープします。

例:

     >>> import commands
     >>> commands.getstatusoutput('ls /bin/ls')
     (0, '/bin/ls')
     >>> commands.getstatusoutput('cat /bin/junk')
     (256, 'cat: /bin/junk: No such file or directory')
     >>> commands.getstatusoutput('/bin/junk')
     (256, 'sh: /bin/junk: not found')
     >>> commands.getoutput('ls /bin/ls')
     '/bin/ls'
     >>> commands.getstatus('/bin/ls')
     '-rwxr-xr-x  1 root        13352 Oct 14  1994 /bin/ls'


File: python-lib-jp.info,  Node: プロセス間通信とネットワーク,  Next: インターネットプロトコルとその支援,  Prev: Unix独特のサービス,  Up: Top

17 プロセス間通信とネットワーク
*******************************

この章で解説されるモジュールは他のプロセスと通信するメカニズムを提供し
ます。

いくつかのモジュール、たとえば `signal' や `subprocess'は
同じマシン上での2つのプロセス間でだけ動作します。
他のモジュールはネットワークプロトコルをサポートし、2つかそれ以上のプ
ロセスがマシンをまたいで通信するために利用できます。

この章で解説されるモジュールの一覧は:

* Menu:

* subprocess::
* socket::
* signal::
* popen2::
* asyncore::
* asynchat::


File: python-lib-jp.info,  Node: subprocess,  Next: socket,  Prev: プロセス間通信とネットワーク,  Up: プロセス間通信とネットワーク

17.1 サブプロセス管理
=====================

サブプロセス管理

_Added in Python version 2.4_

`subprocess' モジュールは、新しくプロセスを開始したり、
それらの標準入出力/エラー出力に対してパイプで接続したり、
それらの終了ステータスを取得したりします。このモジュールは以下のような
古いいくつかのモジュールを置き換えることを目的としています:

     os.system
     os.spawn*
     os.popen*
     popen2.*
     commands.*

これらのモジュールや関数の代わりに、`subprocess' モジュールを
どのように使うかについては以下の節で説明します。

* Menu:

* subprocess モジュールを使う::
* Popen オブジェクト::
* 古い関数を subprocess モジュールで置き換える::


File: python-lib-jp.info,  Node: subprocess モジュールを使う,  Next: Popen オブジェクト,  Prev: subprocess,  Up: subprocess

17.1.1 subprocess モジュールを使う
----------------------------------

このモジュールでは `Popen' と呼ばれるクラスを定義しています:

`Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0)'
     各引数の説明は以下のとおりです:

     ARGS は文字列か、あるいはプログラムへの引数のシーケンスである
     必要があります。実行するプログラムは通常 args
     シーケンスあるいは文字列の 最初の要素ですが、executable
     引数を使うことにより明示的に指定することもできます。

     UNIX で SHELL=FALSE の場合 (デフォルト): この場合、 Popen
     クラスは子プログラムを実行するのに `os.execvp()' を使います。 ARGS
     は通常シーケンスでなければなりません。文字列の場合は
     ひとつだけの文字列要素 (= 実行するプログラム名)
     をもったシーケンスとして 扱われます。

     UNIX で SHELL=TRUE の場合: args が文字列の場合、これは
     シェルを介して実行されるコマンドライン文字列を指定します。ARGS が
     シーケンスの場合、その最初の要素はコマンドライン文字列となり、
     それ以降の要素はすべてシェルへの追加の引数として扱われます。

     Windows の場合: `Popen' クラスは子プログラムを実行するのに
     文字列の扱える CreateProcess() を使います。ARGS が
     シーケンスの場合、これは `list2cmdline' メソッドをつかって
     コマンドライン文字列に変換されます。注意: すべての MS Windows
     アプリケーションがコマンドライン引数を同じやりかたで
     解釈するとは限りません。`list2cmdline' は MS C ランタイムと
     同じやりかたで文字列を解釈するアプリケーション用に設計されています。

     BUFSIZE は、もしこれが与えられた場合、ビルトインの open()
     関数の該当する引数と同じ意味をもちます: `0'
     はバッファされないことを意味し、 `1'
     は行ごとにバッファされることを、それ以外の正の値は (ほぼ)
     その大きさのバッファが使われることを意味します。 負の BUFSIZE
     はシステムのデフォルト値が使われることを意味し、
     通常これはバッファがすべて有効となります。BUFSIZE のデフォルト値は
     `0' (バッファされない) です。

     EXECUTABLE 引数には実行するプログラムを指定します。
     これはほとんど必要ありません: ふつう、実行するプログラムは ARGS
     引数で指定されるからです。`shell=True' の場合、 EXECUTABLE
     引数は使用するシェルを指定します。 UNIX では、デフォルトのシェルは
     `/bin/sh' です。Windows では、デフォルトのシェルは `COMSPEC'
     環境変数で指定されます。

     STDIN、 STDOUT および STDERR には、
     実行するプログラムの標準入力、標準出力、および標準エラー出力の
     ファイルハンドルをそれぞれ指定します。とりうる値は `PIPE'
     、既存のファイル記述子 (正の整数) 、
     既存のファイルオブジェクト、そして `None' です。 `PIPE'
     を指定すると新しいパイプが子プロセスに向けて作られます。 `None'
     を指定するとリダイレクトは起こりません。子プロセスの
     ファイルハンドルはすべて親から受け継がれます。 加えて、STDERR を
     `STDOUT' にすると、アプリケーションの stderr からの出力は stdout
     と同じファイルハンドルに出力されます。

     PREEXEC_FN に callable オブジェクトが指定されている場合、
     このオブジェクトは子プロセスが起動されてから、プログラムが exec
     される直前に呼ばれます。(UNIXのみ)

     CLOSE_FDS が真の場合、子プロセスが実行される前に `0'、 `1' および
     `2' をのぞくすべてのファイル記述子が 閉じられます。(UNIXのみ)

     SHELL が `True' の場合、
     指定されたコマンドはシェルを介して実行されます。

     CWD が `None' 以外の場合、子プロセスの
     カレントディレクトリが実行される前に CWD に変更されます。
     このディレクトリは実行ファイルを探す段階では考慮されませんので、
     プログラムのパスを CWD に対する相対パスで指定することはできない、
     ということに注意してください。

     ENV が `None' 以外の場合、これは新しいプロセスでの
     環境変数を定義します。

     UNIVERSAL_NEWLINES が `True' の場合、 stdout および stderr
     のファイルオブジェクトはテキストファイルとして open
     されますが、行の終端は UNIX形式の行末 `'\n'' か、 Macintosh
     形式の行末 `'\r'' か、あるいは Windows 形式の行末 `'\r\n''
     のいずれも許されます。これらすべての外部表現は Python
     プログラムには `'\n'' として認識されます。 _Note:_ この機能は
     Python に universal newline がサポートされている場合 (デフォルト)
     にのみ 有効です。また、 `stdout', `stdin' および `stderr' の
     ファイルオブジェクトの newlines 属性は communicate() メソッドでは
     更新されません。

     STARTUPINFO および CREATIONFLAGS が与えられた場合、
     これらは内部で呼びだされる CreateProcess() 関数に渡されます。
     これらはメインウインドウの形状や新しいプロセスの優先度などを
     指定することができます。  (Windows のみ)

* Menu:

* 便利な関数::
* 例外 4::
* セキュリティ::


File: python-lib-jp.info,  Node: 便利な関数,  Next: 例外 4,  Prev: subprocess モジュールを使う,  Up: subprocess モジュールを使う

17.1.1.1 便利な関数
...................

このモジュールは二つのショートカット関数も定義しています:

`call(*popenargs, **kwargs)'
     コマンドを指定された引数で実行し、そのコマンドが完了するのを待って、
     `returncode' 属性を返します。

     この引数は Popen コンストラクタの引数と同じです。 使用例:

              retcode = call(["ls", "-l"])


`check_call(*popenargs, **kwargs)'
     コマンドを引数付きで実行します。コマンドが完了するのを待ちます。終了コードがゼロ
     ならば終わりますが、そうでなければ `CalledProcessError'
     例外を送出します。 `CalledProcessError'
     オブジェクトにはリターンコードが `returncode'
     属性として収められています。

     引数は Popen のコンストラクタと一緒です。使用例:

              check_call(["ls", "-l"])



File: python-lib-jp.info,  Node: 例外 4,  Next: セキュリティ,  Prev: 便利な関数,  Up: subprocess モジュールを使う

17.1.1.2 例外
.............

子プロセス内で raise
した例外は、新しいプログラムが実行される前であれば、 親プロセスでも
raise されます。さらに、この例外オブジェクトには `child_traceback'
という属性が追加されており、これには 子プロセスの視点からの traceback
情報が格納されています。

もっとも一般的に起こる例外は `OSError' です。
これは、たとえば存在しないファイルを実行しようとしたときなどに
発生します。アプリケーションは `OSError' 例外には
あらかじめ準備しておく必要があります。

不適当な引数で `Popen' が呼ばれた場合は、 `ValueError' が発生します。

`check_call()' は
もし呼び出されたプロセスがゼロでないリターンコードを返したならば
`CalledProcessError' を送出します。


File: python-lib-jp.info,  Node: セキュリティ,  Prev: 例外 4,  Up: subprocess モジュールを使う

17.1.1.3 セキュリティ
.....................

ほかの popen 関数とは異なり、この実装は決して暗黙のうちに /bin/sh を
実行しません。これはシェルのメタ文字をふくむすべての文字が
安全に子プロセスに渡されるということを意味しています。


File: python-lib-jp.info,  Node: Popen オブジェクト,  Next: 古い関数を subprocess モジュールで置き換える,  Prev: subprocess モジュールを使う,  Up: subprocess

17.1.2 Popen オブジェクト
-------------------------

`Popen' クラスのインスタンスには、以下のようなメソッドがあります:

`poll()'
     子プロセスが終了しているかどうかを検査します。 returncode
     属性を返します。

`wait()'
     子プロセスが終了するまで待ちます。 returncode 属性を返します。

`communicate(input=None)'
     プロセスと通信します: end-of-file に到達するまで データを stdin
     に送信し、stdout および stderr からデータを受信します。
     プロセスが終了するまで待ちます。オプション引数 INPUT には
     子プロセスに送られる文字列か、あるいはデータを送らない場合は
     `None' を指定します。

     communicate() はタプル (stdout, stderr) を返します。

     _Note:_ 受信したデータはメモリ中にバッファされます。
     そのため、返されるデータが大きいかあるいは制限がないような場合は
     このメソッドを使うべきではありません。

以下の属性も利用できます:

`stdin'
     STDIN 引数が `PIPE' の場合、この属性には
     子プロセスの入力に使われるファイルオブジェクトになります。
     そうでない場合は `None' です。

`stdout'
     STDOUT 引数が `PIPE' の場合、この属性には
     子プロセスの出力に使われるファイルオブジェクトになります。
     そうでない場合は `None' です。

`stderr'
     STDERR 引数が `PIPE' の場合、この属性には
     子プロセスのエラー出力に使われるファイルオブジェクトになります。
     そうでない場合は `None' です。

`pid'
     子プロセスのプロセス ID が入ります。

`returncode'
     子プロセスの終了ステータスが入ります。 `None'
     はまだその子プロセスが終了していないことを示し、 負の値 -N
     は子プロセスがシグナル N により中止させられたことを示します (UNIX
     のみ)。


File: python-lib-jp.info,  Node: 古い関数を subprocess モジュールで置き換える,  Prev: Popen オブジェクト,  Up: subprocess

17.1.3 古い関数を subprocess モジュールで置き換える
---------------------------------------------------

以下、この節では、"a ==> b" と書かれているものは a の代替として b
が使えるということを表します。

_Note:_ この節で紹介されている関数はすべて、実行するプログラムが
見つからないときは (いくぶん) 静かに終了します。このモジュールは
`OSError' 例外を発生させます。

以下の例では、 subprocess モジュールは "from subprocess import *" で
インポートされたと仮定しています。

* Menu:

* /bin/sh シェルのバッククォートを置き換える::
* シェルのパイプラインを置き換える::
* ossystem を置き換える::
* osspawn* を置き換える::
* ospopen* を置き換える::
* popen2* を置き換える::


File: python-lib-jp.info,  Node: /bin/sh シェルのバッククォートを置き換える,  Next: シェルのパイプラインを置き換える,  Prev: 古い関数を subprocess モジュールで置き換える,  Up: 古い関数を subprocess モジュールで置き換える

17.1.3.1 /bin/sh シェルのバッククォートを置き換える
...................................................

     output=`mycmd myarg`
     ==>
     output = Popen(["mycmd", "myarg"], stdout=PIPE).communicate()[0]


File: python-lib-jp.info,  Node: シェルのパイプラインを置き換える,  Next: ossystem を置き換える,  Prev: /bin/sh シェルのバッククォートを置き換える,  Up: 古い関数を subprocess モジュールで置き換える

17.1.3.2 シェルのパイプラインを置き換える
.........................................

     output=`dmesg | grep hda`
     ==>
     p1 = Popen(["dmesg"], stdout=PIPE)
     p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
     output = p2.communicate()[0]


File: python-lib-jp.info,  Node: ossystem を置き換える,  Next: osspawn* を置き換える,  Prev: シェルのパイプラインを置き換える,  Up: 古い関数を subprocess モジュールで置き換える

17.1.3.3 os.system() を置き換える
.................................

     sts = os.system("mycmd" + " myarg")
     ==>
     p = Popen("mycmd" + " myarg", shell=True)
     sts = os.waitpid(p.pid, 0)

注意:

   * このプログラムは普通シェル経由で呼び出す必要はありません。

   * 終了状態を見るよりも `returncode' 属性を見るほうが簡単です。

より現実的な例ではこうなるでしょう:

     try:
         retcode = call("mycmd" + " myarg", shell=True)
         if retcode < 0:
             print >>sys.stderr, "子プロセスがシグナルによって中止されました", -retcode
         else:
             print >>sys.stderr, "子プロセスが終了コードを返しました", retcode
     except OSError, e:
         print >>sys.stderr, "実行に失敗しました:", e


File: python-lib-jp.info,  Node: osspawn* を置き換える,  Next: ospopen* を置き換える,  Prev: ossystem を置き換える,  Up: 古い関数を subprocess モジュールで置き換える

17.1.3.4 os.spawn* を置き換える
...............................

P_NOWAIT の例:

     pid = os.spawnlp(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg")
     ==>
     pid = Popen(["/bin/mycmd", "myarg"]).pid

P_WAIT の例:

     retcode = os.spawnlp(os.P_WAIT, "/bin/mycmd", "mycmd", "myarg")
     ==>
     retcode = call(["/bin/mycmd", "myarg"])

シーケンスを使った例:

     os.spawnvp(os.P_NOWAIT, path, args)
     ==>
     Popen([path] + args[1:])

環境変数を使った例:

     os.spawnlpe(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg", env)
     ==>
     Popen(["/bin/mycmd", "myarg"], env={"PATH": "/usr/bin"})


File: python-lib-jp.info,  Node: ospopen* を置き換える,  Next: popen2* を置き換える,  Prev: osspawn* を置き換える,  Up: 古い関数を subprocess モジュールで置き換える

17.1.3.5 os.popen* を置き換える
...............................

     pipe = os.popen(cmd, mode='r', bufsize)
     ==>
     pipe = Popen(cmd, shell=True, bufsize=bufsize, stdout=PIPE).stdout

     pipe = os.popen(cmd, mode='w', bufsize)
     ==>
     pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin

     (child_stdin, child_stdout) = os.popen2(cmd, mode, bufsize)
     ==>
     p = Popen(cmd, shell=True, bufsize=bufsize,
               stdin=PIPE, stdout=PIPE, close_fds=True)
     (child_stdin, child_stdout) = (p.stdin, p.stdout)

     (child_stdin,
      child_stdout,
      child_stderr) = os.popen3(cmd, mode, bufsize)
     ==>
     p = Popen(cmd, shell=True, bufsize=bufsize,
               stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)
     (child_stdin,
      child_stdout,
      child_stderr) = (p.stdin, p.stdout, p.stderr)

     (child_stdin, child_stdout_and_stderr) = os.popen4(cmd, mode, bufsize)
     ==>
     p = Popen(cmd, shell=True, bufsize=bufsize,
               stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
     (child_stdin, child_stdout_and_stderr) = (p.stdin, p.stdout)


File: python-lib-jp.info,  Node: popen2* を置き換える,  Prev: ospopen* を置き換える,  Up: 古い関数を subprocess モジュールで置き換える

17.1.3.6 popen2.* を置き換える
..............................

_Note:_ popen2 に対するコマンド引数が文字列の場合、 そのコマンドは
/bin/sh 経由で実行されます。いっぽうこれが
リストの場合、そのコマンドは直接実行されます。

     (child_stdout, child_stdin) = popen2.popen2("somestring", bufsize, mode)
     ==>
     p = Popen(["somestring"], shell=True, bufsize=bufsize,
               stdin=PIPE, stdout=PIPE, close_fds=True)
     (child_stdout, child_stdin) = (p.stdout, p.stdin)

     (child_stdout, child_stdin) = popen2.popen2(["mycmd", "myarg"], bufsize, mode)
     ==>
     p = Popen(["mycmd", "myarg"], bufsize=bufsize,
               stdin=PIPE, stdout=PIPE, close_fds=True)
     (child_stdout, child_stdin) = (p.stdout, p.stdin)

popen2.Popen3 および popen2.Popen4 は基本的には subprocess.Popen
と同様です。 ただし、違う点は:

   * subprocess.Popen は実行できなかった場合に例外を発生させます。

   * CAPTURESTDERR 引数は STDERR 引数に代わりました。

   * stdin=PIPE および stdout=PIPE を指定する必要があります。

   * popen2
     はデフォルトですべてのファイル記述子を閉じますが、subprocess.Popen
     では 明示的に close_fds=True を指定する必要があります。


File: python-lib-jp.info,  Node: socket,  Next: signal,  Prev: subprocess,  Up: プロセス間通信とネットワーク

17.2 低レベルネットワークインターフェース
=========================================

低レベルネットワークインターフェース。

このモジュールは、PythonでBSD _ソケット_ インターフェースを利用する
ために使用します。最近のUNIXシステム、Windows, MacOS, BeOS, OS/2な
ど、多くのプラットフォームで利用可能です。 _Note:_
いくつかの振る舞いはプラットフォームに依存します。これはオペレーティングシステム
のソケットAPIを呼び出しているためです。

C言語によるソケットプログラミングの基礎については、以下の資料を参照して
ください。

(Stuart Sechrest),

(Samuel J. Leffler他), (PS1:7章 PS1:8章)。ソケットの詳細については、
各プラットフォームのソケット関連システムコールに関するドキュメント(UNIX
では マニュアルページ、WindowsではWinSock(またはWinSock2)仕様書)も参照し
てください。IPv6対応のAPIについては、RFC 2553 

を参照してくださ い。

Pythonインターフェースは、UNIXのソケット用システムコールとライブラリ
を、そのままPythonのオブジェクト指向スタイルに変換したものです。各種ソケ
ット関連のシステムコールは、`socket()'関数で生成する "ソケット
オブジェクト" のメソッドとして実装されてい
ます。メソッドのパラメータはCのインターフェースよりも多少高水準で、例え
ば`read()'や`write()'メソッドではファイルオブジェクトと同
様、受信時のバッファ確保や送信時の出力サイズなどは自動的に処理されます。

ソケットのアドレスは以下のように指定します:単一の文字列は、
`AF_UNIX'アドレスファミリを示します。`(HOST,
PORT)'のペアは`AF_INET'アドレスファミリを示し、HOST
は`'daring.cwi.nl''のようなインターネットドメイン形式または
`'100.50.200.5''のようなIPv4アドレスを文字列で、PORTはポート
番号を整数で指定します。`AF_INET6'アドレスファミリは `(HOST, PORT,
FLOWINFO, SCOPEID)'の長さ4の
タプルで示し、FLOWINFOとSCOPEIDにはそれぞれCの `struct
sockaddr_in6'における`sin6_flowinfo'と
`sin6_scope_id'の値を指定します。後方互換性のため、`socket'
モジュールのメソッドでは`sin6_flowinfo'と`sin6_scope_id'を省略
する事ができますが、SCOPEIDを省略するとスコープを持ったIPv6アドレ
スの処理で問題が発生する場合があります。現在サポートされているアドレスフ
ァミリは以上です。ソケットオブジェクトで利用する事のできるアドレス形式
は、ソケットオブジェクトの作成時に指定したアドレスファミリで決まります。

IPv4アドレスのホストアドレスが空文字列の場合、`INADDR_ANY'とし
て処理されます。また、`'<broadcast>''の場合は
`INADDR_BROADCAST'として処理されます。IPv6では後方互換性のため
この機能は用意されていませんので、IPv6をサポートするPythonプログラムでは
利用しないで下さい。

IPv4/v6ソケットのHOST部にホスト名を指定すると、処理結果が一定では
ない場合があります。これはPythonはDNSから取得したアドレスのうち最初のア
ドレスを使用するので、DNSの処理やホストの設定によって異なるIPv4/6アドレ
スを取得する場合があるためです。常に同じ結果が必要であれば、HOSTに
数値のアドレスを指定してください。

_Added in Python version 2.5_

エラー時には例外が発生します。引数型のエラーやメモリ不足の場合には通常の
例外が発生し、ソケットやアドレス関連のエラーの場合は
`socket.error'が発生します。

`setblocking()'メソッドで、非ブロッキングモードを使用することがで
きます。また、より汎用的に`settimeout()'メソッドでタイムアウトを
指定する事ができます。

`socket'モジュールでは、以下の定数と関数を提供しています。

`error'
     この例外は、ソケット関連のエラーが発生した場合に送出されます。例外の値は
     障害の内容を示す文字列か、または`os.error'と同様な `(ERRNO,
     STRING)'のペアとなります。オペレーティングシス
     テムで定義されているエラーコードについては`errno' を参照してください。

`herror'
     この例外は、C APIの`gethostbyname_ex()'や
     `gethostbyaddr()'などで、H_ERRNOのようなアドレス関連のエ
     ラーが発生した場合に送出されます。

     例外の値は`(H_ERRNO, STRING)'のペアで、ライブラリの呼び
     出し結果を返します。STRINGはC関数`hstrerror()'で取得し
     た、H_ERRNOの意味を示す文字列です。

`gaierror'
     この例外は`getaddrinfo()'と`getnameinfo()'でアドレス関
     連のエラーが発生した場合に送出されます。

     例外の値は`(ERROR, STRING)'のペアで、ライブラリの呼び出
     し結果を返します。STRINGはC関数`gai_strerror()'で取得し
     た、H_ERRNOの意味を示す文字列です。
     ERRORの値は、このモジュールで定義される `EAI_*' 定数の何れか
     となります。

`timeout'
     この例外は、あらかじめ `settimeout()' を呼び出してタイムアウトを
     有効にしてあるソケットでタイムアウトが生じた際に送出されます。
     例外に付属する値は文字列で、その内容は現状では常に "timed out"
     となります。 _Added in Python version 2.3_

`AF_UNIX'

`AF_INET'

`AF_INET6'
     アドレス（およびプロトコル）ファミリを示す定数で、`socket()'の
     最初の引数に指定することができます。`AF_UNIX'ファミリをサポート
     しないプラットフォームでは、`AF_UNIX'は未定義となります。

`SOCK_STREAM'

`SOCK_DGRAM'

`SOCK_RAW'

`SOCK_RDM'

`SOCK_SEQPACKET'
     ソケットタイプを示す定数で、`socket()'の2番目の引数に指定するこ
     とができます。(ほとんどの場合、`SOCK_STREAM'と
     `SOCK_DGRAM'以外は必要ありません。)

`SO_*'

`SOMAXCONN'

`MSG_*'

`SOL_*'

`IPPROTO_*'

`IPPORT_*'

`INADDR_*'

`IP_*'

`IPV6_*'

`EAI_*'

`AI_*'

`NI_*'

`TCP_*'
     UNIXのソケット・IPプロトコルのドキュメントで定義されている各種定数。
     ソケットオブジェクトの`setsockopt()'や`getsockopt()'で使用
     します。ほとんどのシンボルはUNIXのヘッダファイルに従っています。一部
     のシンボルには、デフォルト値を定義してあります。

`has_ipv6'
     現在のプラットフォームでIPv6がサポートされているか否かを示す真偽値。
     _Added in Python version 2.3_

`getaddrinfo(host, port[, family[, socktype[, proto[, flags]]]])'
     HOST/PORT 引数の指すアドレス情報を解決して、
     ソケット操作に必要な全ての引数が入った 5 要素のタプルを返します。
     HOSTはドメイン名、IPv4/v6アドレスの文字列、または`None' です。PORT
     は`'http''のようなサービス名文字列、ポート番号
     を表す数値、または`None' です。

     これ以外の引数は省略可能で、指定する場合には数値でなければなりません。
     HOSTとPORT に空文字列か`None' を指定すると C APIに
     `NULL'を渡せます。 `getattrinfo()' 関数は以下の構造をとる 5
     要素のタプルを返します:

     `(FAMILY, SOCKTYPE, PROTO, CANONNAME, SOCKADDR)'

     FAMILY・SOCKTYPE・PROTOは、`socket()'関数を呼
     び出す際に指定する値と同じ整数です。CANONNAMEはHOSTの規準名
     を示す文字列です。`AI_CANONNAME'を指定した場合、数値によるIPv4/
     v6アドレスを返します。SOCKADDRは、ソケットアドレスを上述の形式で表
     すタプルです。この関数の使い方については、`httplib'モジュール
     などのソースを参考にしてください。

     _Added in Python version 2.2_

`getfqdn([name])'
     NAMEの完全修飾ドメイン名を返します。NAMEが空または省略された
     場合、ローカルホストを指定したとみなします。完全修飾ドメイン名の取得には
     まず`gethostbyaddr()'でチェックし、次に可能であればエイリアスを
     調べ、名前にピリオドを含む最初の名前を値として返します。完全修飾ドメイ
     ン名を取得できない場合、`gethostname()'で返されるホスト名を返します。
     _Added in Python version 2.0_

`gethostbyname(hostname)'
     ホスト名を`'100.50.200.5''のようなIPv4形式のアドレスに変換します。
     ホスト名としてIPv4アドレスを指定した場合、その値は変換せずにそのまま返り
     ます。`gethostbyname()' APIへのより完全なインターフェースが必要
     であれば、`gethostbyname_ex()'を参照してください。
     `gethostbyname()'は、IPv6名前解決をサポートしていません。IPv4/
     v6のデュアルスタックをサポートする場合は`getaddrinfo()'を使用し
     ます。

`gethostbyname_ex(hostname)'
     ホスト名から、IPv4形式の各種アドレス情報を取得します。戻り値は
     `(HOSTNAME, ALIASLIST, IPADDRLIST)'のタプルで、HOSTNAMEは
     IP_ADDRESSで指定したホストの正式名、ALIASLISTは同じアドレス
     の別名のリスト(空の場合もある)、IPADDRLISTは同じホスト上の同一イ
     ンターフェースのIPv4アドレスのリスト(ほとんどの場合は単一のアドレスのみ)
     を示します。`gethostbyname()'は、IPv6名前解決をサポートしていま
     せん。IPv4/v6のデュアルスタックをサポートする場合は
     `getaddrinfo()'を使用します。

`gethostname()'
     Pythonインタープリタを現在実行中のマシンのホスト名を示す文字列を取得しま
     す。実行中マシンのIPアドレスが必要であれば、
     `gethostbyname(gethostname())'を使用してください。この処理は実行中
     ホストのアドレス-ホスト名変換が可能であることを前提としていますが、常に
     変換可能であるとは限りません。注意: `gethostname()'は完全修飾ド
     メイン名を返すとは限りません。完全修飾ドメイン名が必要であれば、
     `gethostbyaddr(gethostname())'としてください(下記参照)。

`gethostbyaddr(ip_address)'
     `(HOSTNAME, ALIASLIST, IPADDRLIST)'のタプルを返
     し、HOSTNAMEはIP_ADDRESSで指定したホストの正式名、
     `aliaslist'は同じアドレスの別名のリスト(空の場合もある)、
     `ipaddrlist'は同じホスト上の同一インターフェースのIPv4アドレスのリ
     スト(ほとんどの場合は単一のアドレスのみ)を示します。完全修飾ドメイン名が
     必要であれば、`getfqdn()'を使用してください。
     `gethostbyaddr'は、IPv4/IPv6の両方をサポートしています。

`getnameinfo(sockaddr, flags)'
     ソケットアドレスSOCKADDRから、`(HOST, PORT)'のタ
     プルを取得します。FLAGSの設定に従い、HOSTは完全修飾ドメイン
     名または数値形式アドレスとなります。同様に、PORTは文字列のポート名
     または数値のポート番号となります。 _Added in Python version 2.2_

`getprotobyname(protocolname)'
     `'icmp''のようなインターネットプロトコル名を、`socket()'の
     第三引数として指定する事ができる定数に変換します。これは主にソケットを"
     raw"モード(`SOCK_RAW')でオープンする場合には必要ですが、通常の
     ソケットモードでは第三引数に0を指定するか省略すれば正しいプロトコルが自
     動的に選択されます。

`getservbyname(servicename[, protocolname])'
     インターネットサービス名とプロトコルから、そのサービスのポート番号を取得
     します。省略可能なプロトコル名として、`'tcp''か`'udp''のどちら
     かを指定することができます。指定がなければどちらのプロトコルにもマッチ
     します。

`getservbyport(port[, protocolname])'
     インターネットポート番号とプロトコル名から、サービス名を取得します。
     省略可能なプロトコル名として、`'tcp''か`'udp''のどちら
     かを指定することができます。指定がなければどちらのプロトコルにもマッチ
     します。

`socket([family[, type[, proto]]])'
     アドレスファミリ、ソケットタイプ、プロトコル番号を指定してソケットを作成
     します。アドレスファミリには`AF_INET'(デフォルト値)・`AF_INET6'・
     `AF_UNIX'を指定することができます。ソケットタイプには
     `SOCK_STREAM'(デフォルト値)・`SOCK_DGRAM'・または他の
     `SOCK_'定数の何れかを指定します。プロトコル番号は通常省略するか、
     または0を指定します。

`ssl(sock[, keyfile, certfile])'
     ソケットSOCKによるSSL接続を初期化します。KEYFILEには、PEMフ
     ォーマットのプライベートキーファイル名を指定します。CERTFILEには、
     PEMフォーマットの認証チェーンファイル名を指定します。処理が成功すると、
     新しい`SSLObject'が返ります。

     _証明書の認証は全く行いません。_

`socketpair([family[, type[, proto]]])'
     指定されたアドレスファミリ、ソケットタイプ、プロトコル番号から、
     接続されたソケットのペアを作成します。
     アドレスファミリ、ソケットタイプ、プロトコル番号は `socket()'関
     数と同様に指定します。
     デフォルトのアドレスファミリは、プラットフォームで定義されていれば
     `AF_UNIX'、そうでなければ`AF_INET'が使われます。

     利用可能: UNIX.  _Added in Python version 2.4_

`fromfd(fd, family, type[, proto])'
     ファイルディスクリプタ (ファイルオブジェクトの`fileno()'で返る
     整数) FD を複製して、ソケットオブジェクトを構築します。アドレス
     ファミリとプロトコル番号は`socket()'と同様に指定します。
     ファイルディスクリプタ
     はソケットを指していなければなりませんが、実際にソケットであるかどうかの
     チェックは行っていません。このため、ソケット以外のファイルディスクリプタ
     を指定するとその後の処理が失敗する場合があります。この関数が必要な事はあ
     まりありませんが、UNIXのinetデーモンのようにソケットを標準入力や標準
     出力として使用するプログラムで使われます。この関数で使用するソケットは、
     ブロッキングモードと想定しています。 利用可能:UNIX


`ntohl(x)'
     32ビット整数のバイトオーダを、ネットワークバイトオーダからホストバイト
     オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致す
     るマシンでは、この関数は何もしません。それ以外の場合は4バイトのスワップ
     を行います。

`ntohs(x)'
     16ビット整数のバイトオーダを、ネットワークバイトオーダからホストバイト
     オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致す
     るマシンでは、この関数は何もしません。それ以外の場合は2バイトのスワップ
     を行います。

`htonl(x)'
     32ビット整数のバイトオーダを、ホストバイトオーダからネットワークバイト
     オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致す
     るマシンでは、この関数は何もしません。それ以外の場合は4バイトのスワップ
     を行います。

`htons(x)'
     16ビット整数のバイトオーダを、ホストバイトオーダからネットワークバイト
     オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致す
     るマシンでは、この関数は何もしません。それ以外の場合は2バイトのスワップ
     を行います。

`inet_aton(ip_string)'
     ドット記法によるIPv4アドレス(`'123.45.67.89''など)を32ビットにパッ
     クしたバイナリ形式に変換し、長さ4の文字列として返します。この関数が返す
     値は、標準Cライブラリの`struct in_addr'型を使用する関数に渡す事がで
     きます。

     IPv4アドレス文字列が不正であれば、`socket.error'が発生します。
     このチェックは、この関数で使用しているCの実装 `inet_aton()'で
     行われます。

     `inet_aton()'は、IPv6をサポートしません。IPv4/v6のデュアルスタ
     ックをサポートする場合は`getnameinfo()'を使用します。

`inet_ntoa(packed_ip)'
     32ビットにパックしたバイナリ形式のIPv4アドレスを、ドット記法による文字列
     (`'123.45.67.89''など)に変換します。この関数が返す値は、標準Cライブ
     ラリの`struct in_addr'型を使用する関数に渡す事ができます。

     この関数に渡す文字列の長さが4バイト以外であれば、
     `socket.error'が発生します。
     `inet_ntoa()'は、IPv6をサポートしません。IPv4/v6のデュアルスタ
     ックをサポートする場合は`getnameinfo()'を使用します。

`inet_pton(address_family, ip_string)'
     IPアドレスを、アドレスファミリ固有の文字列からパックしたバイナリ形式に変
     換します。`inet_pton()'は、`struct in_addr'型
     (`inet_aton()'と同様)や`struct in6_addr'を使用するライブ
     ラリやネットワークプロトコルを呼び出す際に使用することができます。

     現在サポートされているADDRESS_FAMILYは、`AF_INET'と
     `AF_INET6'です。IP_STRINGに不正なIPアドレス文字列を指定す
     ると、`socket.error'が発生します。有効なIP_STRINGは、
     ADDRESS_FAMILYと`inet_pton()'の実装によって異なります。

     利用可能: UNIX (サポートしていないプラットフォームもあります)
     _Added in Python version 2.3_

`inet_ntop(address_family, packed_ip)'
     パックしたIPアドレス(数文字の文字列)を、`'7.10.0.5''や
     `'5aef:2b::8''などの標準的な、アドレスファミリ固有の文字列形式に変
     換します。`inet_ntop()'は(`inet_ntoa()'と同様に) `struct
     in_addr'型や`struct in6_addr'型のオブジェクトを返す
     ライブラリやネットワークプロトコル等で使用することができます。

     現在サポートされているADDRESS_FAMILYは、`AF_INET'と
     `AF_INET6'です。PACKED_IPの長さが指定したアドレスファミリ
     で適切な長さでなければ、`ValueError'が発生します。
     `inet_ntop()'でエラーとなると、`socket.error'が発生し ます。

     利用可能: UNIX (サポートしていないプラットフォームもあります)
     _Added in Python version 2.3_

`getdefaulttimeout()'
     新規に生成されたソケットオブジェクトの、デフォルトのタイムアウト値を浮動
     小数点形式の秒数で返します。タイプアウトを使用しない場合には`None'
     を返します。最初にsocketモジュールがインポートされた時の初期値は
     `None'です。

     _Added in Python version 2.3_

`setdefaulttimeout(timeout)'
     新規に生成されたソケットオブジェクトの、デフォルトのタイムアウト値を浮動
     小数点形式の秒数で指定します。タイムアウトを使用しない場合には
     `None'を指定します。最初にsocketモジュールがインポートされた時の初
     期値は`None'です。

     _Added in Python version 2.3_

`SocketType'
     ソケットオブジェクトの型を示す型オブジェクト。`type(socket(...))'と
     同じです。

See also:
     *Note SocketServer:: ネットワークサーバの開発を省力化するためのク
     ラス群。

* Menu:

* socket オブジェクト::
* SSL オブジェクト::
* 例 9::


File: python-lib-jp.info,  Node: socket オブジェクト,  Next: SSL オブジェクト,  Prev: socket,  Up: socket

17.2.1 socket オブジェクト
--------------------------

ソケットオブジェクトは以下のメソッドを持ちます。`makefile()'以外
のメソッドは、UNIXのソケット用システムコールに対応しています。

`accept()'
     接続を受け付けます。ソケットはアドレスにbind済みで、listen中である必要が
     あります。戻り値は`(CONN, ADDRESS)'のペアで、CONN
     は接続を通じてデータの送受信を行うための_新しい_ソケットオブジェク
     ト、ADDRESSは接続先でソケットにbindしているアドレスを示します。

`bind(address)'
     ソケットをADDRESSにbindします。bind済みのソケットを再バインドする
     事はできません。ADDRESSのフォーマットはアドレスファミリによって異
     なります(前述)。 _Note:_
     本来、このメソッドは単一のタプルのみを引数として受け付けますが、
     以前は`AF_INET'アドレスを示す二つの値を指定する事ができました。
     これは本来の仕様ではなく、Python
     2.0以降では使用することはできません。

`close()'
     ソケットをクローズします。以降、このソケットでは全ての操作が失敗します。
     リモート端点ではキューに溜まったデータがフラッシュされた後はそれ以上の
     データを受信しません。ソケットはガベージコレクション時に自動的にクローズ
     されます。

`connect(address)'
     ADDRESSで示されるリモートソケットに接続します。ADDRESSのフ
     ォーマットはアドレスファミリによって異なります(前述)。 _Note:_
     本来、このメソッドは単一のタプルのみを引数として受け付けますが、
     以前は`AF_INET'アドレスを示す二つの値を指定する事ができました。
     これは本来の仕様ではなく、Python
     2.0以降では使用することはできません。

`connect_ex(address)'
     `connect(ADDRESS)'と同様ですが、C言語の`connect()'
     関数の呼び出しでエラーが発生した場合には例外を送出せずにエラーを戻り値と
     して返します。(これ以外の、"host not
     found,"等のエラーの場合には例外が
     発生します。)処理が正常に終了した場合には`0'を返し、エラー時には
     `errno'の値を返します。この関数は、非同期接続をサポートする場合な
     どに使用することができます。 _Note:_
     本来、このメソッドは単一のタプルのみを引数として受け付けますが、
     以前は`AF_INET'アドレスを示す二つの値を指定する事ができました。
     これは本来の仕様ではなく、Python
     2.0以降では使用することはできません。

`fileno()'
     ソケットのファイルディスクリプタを整数型で返します。ファイルディスクリプ
     タは、`select.select()'などで使用します。

     Windowsではこのメソッドで返された小整数をファイルディスクリプタを扱う箇
     所(`os.fdopen()'など)で利用できません。 UNIX
     にはこの制限はありません。

`getpeername()'
     ソケットが接続しているリモートアドレスを返します。この関数は、リモート
     IPv4/v6ソケットのポート番号を調べる場合などに使用します。ADDRESSの
     フォーマットはアドレスファミリによって異なります(前述)。この関数をサポー
     トしていないシステムも存在します。

`getsockname()'
     ソケット自身のアドレスを返します。この関数は、IPv4/v6ソケットのポート番
     号を調べる場合などに使用します。ADDRESSのフォーマットはアドレスフ
     ァミリによって異なります(前述)。

`getsockopt(level, optname[, buflen])'
     ソケットに指定されたオプションを返します(UNIXのマニュアルページ
     `getsockopt(2)'を参照)。`SO_*'等のシンボルは、このモジ
     ュールで定義しています。BUFLENを省略した場合、取得するオブションは
     整数とみなし、整数型の値を戻り値とします。BUFLENを指定した場合、長
     さBUFLENのバッファでオプションを受け取り、このバッファを文字列とし
     て返します。このバッファは、呼び出し元プログラムで`struct' モジュール等を利用して内容を読み取ることができま
     す。

`listen(backlog)'
     ソケットをListenし、接続を待ちます。引数BACKLOGには接続キューの最
     大の長さ(1以上)を指定します。BACKLOGの最大数はシステムに依存します
     (通常は5)。

`makefile([mode[, bufsize]])'
     ソケットに関連付けられた"ファイルオブジェクト"を返します(ファイルオ
     ブジェクトについては*Note
     ファイルオブジェクト::の"ファイルオブジェクト"を
     参照)。ファイルオブジェクトはソケットを`dup()'したファイルディ
     スクリプタを使用しており、ソケットオブジェクトとファイルオブジェクトは
     別々にクローズしたりガベージコレクションで破棄したりする事ができます。ソ
     ケットはブロッキングモードでなければなりません。 オプション引数のMODEとBUFSIZE
     には、`file()'組み込み関数と同じ値を指定します。 *Note
     組み込み関数::の"組み込み関数"を参照してください。

`recv(bufsize[, flags])'
     ソケットからデータを受信し、文字列として返します。受信する最大バイト数
     は、BUFSIZEで指定します。FLAGSのデフォルト値は0です。値の意
     味についてはUNIXマニュアルページの`recv(2)'を参照してくださ い。
     _Note:_
     ハードウェアおよびネットワークの現実に最大限マッチするように、
     BUFSIZEの値は比較的小さい2の累乗、たとえば 4096、にすべきです。

`recvfrom(bufsize[, flags])'
     ソケットからデータを受信し、結果をタプル`(STRING,
     ADDRESS)'として返します。STRINGは受信データの文字列で、
     ADDRESSは送信元のアドレスを示します。オプション引数FLAGSの意
     味は、上記`recv()'と同じです。ADDRESSのフォーマットはアドレ
     スファミリによって異なります(前述)。

`send(string[, flags])'
     ソケットにデータを送信します。ソケットはリモートソケットに接続済みでなけ
     ればなりません。オプション引数FLAGSの意味は、上記`recv()'と
     同じです。戻り値として、送信したバイト数を返します。アプリケーションで
     は、必ず戻り値をチェックし、全てのデータが送られた事を確認する必要があり
     ます。データの一部だけが送信された場合、アプリケーションで残りのデータを
     再送信してください。

`sendall(string[, flags])'
     ソケットにデータを送信します。ソケットはリモートソケットに接続済みでなけ
     ればなりません。オプション引数FLAGSの意味は、上記`recv()'と
     同じです。`send()'と異なり、このメソッドはSTRINGの全データ
     を送信するか、エラーが発生するまで処理を継続します。正常終了の場合は
     `None'を返し、エラー発生時には例外が発生します。エラー発生時、送信
     されたバイト数を調べる事はできません。

`sendto(string[, flags], address)'
     ソケットにデータを送信します。このメソッドでは接続先をADDRESSで指
     定するので、接続済みではいけません。オプション引数FLAGSの意味は、
     上記`recv()'と同じです。戻り値として、送信したバイト数を返しま
     す。ADDRESSのフォーマットはアドレスファミリによって異なります(前
     述)。

`setblocking(flag)'
     ソケットのブロッキング・非ブロッキングモードを指定します。FLAGが0
     の場合は非ブロッキングモード、0以外の場合はブロッキングモードとなりま
     す。全てのソケットは、初期状態ではブロッキングモードです。非ブロッキング
     モードでは、`recv()'メソッド呼び出し時に読み込みデータが無かった
     り`send()'メソッド呼び出し時にデータを処理する事ができないような
     場合に`error'例外が発生します。しかし、ブロッキングモードでは
     呼び出しは処理が行われるまでブロックされます。`s.setblocking(0)'は
     `s.settimeout(0)'と、`s.setblocking(1)'は
     `s.settimeout(None)'とそれぞれ同じ意味を持ちます。

`settimeout(value)'
     ソケットのブロッキング処理のタイムアウト値を指定します。VALUEに
     は、正の浮動小数点で秒数を指定するか、もしくは`None'を指定します。
     浮動小数点値を指定した場合、操作が完了する前にVALUEで指定した秒数
     が経過すると`timeout'が発生します。タイムアウト値に`None'を
     指定すると、ソケットのタイムアウトを無効にします。
     `s.settimeout(0.0)'は`s.setblocking(0)'と、
     `s.settimeout(None)'は`s.setblocking(1)'とそれぞれ同じ意味を持
     ちます。 _Added in Python version 2.3_

`gettimeout()'
     ソケットに指定されたタイムアウト値を取得します。タイムアウト値が設定され
     ている場合には浮動小数点型で秒数が、設定されていなければ`None'が返
     ります。この値は、最後に呼び出された`setblocking()'または
     `settimeout()'によって設定されます。_Added in Python version 2.3_

ソケットのブロッキングとタイムアウトについて:ソケットオブジェクトのモー
ドは、ブロッキング・非ブロッキング・タイムアウトの何れかとなります。初期
状態では常にブロッキングモードです。ブロッキングモードでは、処理が完了す
るまでブロックされます。非ブロッキングモードでは、処理を行う事ができなけ
れば(不幸にもシステムによって異なる値の)エラーとなります。タイムアウト
モードでは、ソケットに指定したタイムアウトまでに完了しなければ処理は失敗
となります。`setblocking()'メソッドは、`settimeout()'の省 略形式です。

内部的には、タイムアウトモードではソケットを非ブロッキングモードに設定し
ます。ブロッキングとタイムアウトの設定は、ソケットと同じネットワーク端点
へ接続するファイルディスクリプタにも反映されます。この結果、
`makefile()'で作成したファイルオブジェクトはブロッキングモードで
のみ使用することができます。これは非ブロッキングモードとタイムアウトモー
ドでは、即座に完了しないファイル操作はエラーとなるためです。

註: `connect()'はタイムアウト設定に従います。一般的に、
`settimeout()'を`connect()'の前に呼ぶことをおすすめします。

`setsockopt(level, optname, value)'
     ソケットのオプションを設定します(UNIXのマニュアルページ
     `setsockopt(2)'を参照)。`SO_*'等のシンボルは、このモジ
     ュールで定義しています。`value'には、整数または文字列をバッファとし
     て指定する事ができます。文字列を指定する場合、文字列には適切なビットを設
     定するようにします。(`struct' モジュール
     を利用すれば、Cの構造体を文字列にエンコードする事ができます。)

`shutdown(how)'
     接続の片方向、または両方向を切断します。HOWが`SHUT_RD'の場合、以降
     は受信を行えません。HOWが`SHUT_WR'の場合、以降は送信を行えません。
     HOWが`SHUT_RDWR'の場合、以降は送受信を行えません。

`read()'メソッドと`write()'メソッドは存在しませんので注意
してください。代わりにFLAGSを省略した`recv()'と
`send()'を使うことができます。

ソケットオブジェクトには以下の `socket' コンストラクタに
渡された値に対応した(読み出し専用)属性があります。

`family'
     ソケットファミリー。 _Added in Python version 2.5_

`type'
     ソケットタイプ。 _Added in Python version 2.5_

`proto'
     ソケットプロトコル。 _Added in Python version 2.5_


File: python-lib-jp.info,  Node: SSL オブジェクト,  Next: 例 9,  Prev: socket オブジェクト,  Up: socket

17.2.2 SSL オブジェクト
-----------------------

SSLオブジェクトには、以下のメソッドがあります。

`write(s)'
     文字列SをSSL接続で出力します。戻り値として、送信したバイト数を返し
     ます。

`read([n])'
     SSL接続からデータを受信します。Nを指定した場合は指定したバイト数の
     データを受信し、省略時はEOFまで読み込みます。戻り値として、受信したバイ
     ト列の文字列を返します。

`server()'
     サーバの証明書を特定するための ASN.1 識別名(distinguished
     name)を含む文字列を
     返します。(下の例を見ると識別名がどう見えるものか判ります。)

`issuer()'
     サーバの証明書の発行者を特定するための ASN.1 識別名(distinguished
     name)を含む文字列を返します。


File: python-lib-jp.info,  Node: 例 9,  Prev: SSL オブジェクト,  Up: socket

17.2.3 例
---------

以下はTCP/IPプロトコルの簡単なサンプルとして、受信したデータをクライアン
トにそのまま返送するサーバ(接続可能なクライアントは一件のみ)と、サーバに
接続するクライアントの例を示します。サーバでは、`socket()'・
`bind()'・`listen()'・`accept()'を実行し(複数のクラ
イアントからの接続を受け付ける場合、`accept()'を複数回呼び出しま
す)、クライアントでは`socket()'と`connect()'だけを呼び出
しています。サーバでは`send()'/`recv()'メソッドはlisten中
のソケットで実行するのではなく、`accept()'で取得したソケットに対
して実行している点にも注意してください。

次のクライアントとサーバは、IPv4のみをサポートしています。

     # Echo server program
     import socket

     HOST = ''                 # Symbolic name meaning the local host
     PORT = 50007              # Arbitrary non-privileged port
     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     s.bind((HOST, PORT))
     s.listen(1)
     conn, addr = s.accept()
     print 'Connected by', addr
     while 1:
         data = conn.recv(1024)
         if not data: break
         conn.send(data)
     conn.close()

     # Echo client program
     import socket

     HOST = 'daring.cwi.nl'    # The remote host
     PORT = 50007              # The same port as used by the server
     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     s.connect((HOST, PORT))
     s.send('Hello, world')
     data = s.recv(1024)
     s.close()
     print 'Received', repr(data)

次のサンプルは上記のサンプルとほとんど同じですが、IPv4とIPv6の両方をサ
ポートしています。サーバでは、IPv4/v6の両方ではなく、利用可能な最初のア
ドレスファミリだけをlistenしています。ほとんどのIPv6対応システムではIPv6
が先に現れるため、サーバはIPv4には応答しません。クライアントでは名前解決
の結果として取得したアドレスに順次接続を試み、最初に接続に成功したソケッ
トにデータを送信しています。

     # Echo server program
     import socket
     import sys

     HOST = ''                 # Symbolic name meaning the local host
     PORT = 50007              # Arbitrary non-privileged port
     s = None
     for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM, 0, socket.AI_PASSIVE):
         af, socktype, proto, canonname, sa = res
         try:
     	s = socket.socket(af, socktype, proto)
         except socket.error, msg:
     	s = None
     	continue
         try:
     	s.bind(sa)
     	s.listen(1)
         except socket.error, msg:
     	s.close()
     	s = None
     	continue
         break
     if s is None:
         print 'could not open socket'
         sys.exit(1)
     conn, addr = s.accept()
     print 'Connected by', addr
     while 1:
         data = conn.recv(1024)
         if not data: break
         conn.send(data)
     conn.close()

     # Echo client program
     import socket
     import sys

     HOST = 'daring.cwi.nl'    # The remote host
     PORT = 50007              # The same port as used by the server
     s = None
     for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM):
         af, socktype, proto, canonname, sa = res
         try:
     	s = socket.socket(af, socktype, proto)
         except socket.error, msg:
     	s = None
     	continue
         try:
     	s.connect(sa)
         except socket.error, msg:
     	s.close()
     	s = None
     	continue
         break
     if s is None:
         print 'could not open socket'
         sys.exit(1)
     s.send('Hello, world')
     data = s.recv(1024)
     s.close()
     print 'Received', repr(data)

次の例ではSSLサーバに接続し、サーバおよび発行者の識別名(distinguished
name) を表示し、いくらかのバイトを送り、レスポンスの一部を読みます:

     import socket

     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     s.connect(('www.verisign.com', 443))

     ssl_sock = socket.ssl(s)

     print repr(ssl_sock.server())
     print repr(ssl_sock.issuer())

     # Set a simple HTTP request -- use httplib in actual code.
     ssl_sock.write("""GET / HTTP/1.0\r
     Host: www.verisign.com\r\n\r\n""")

     # Read a chunk of data.  Will not necessarily
     # read all the data returned by the server.
     data = ssl_sock.read()

     # Note that you need to close the underlying socket, not the SSL object.
     del ssl_sock
     s.close()

執筆時点で、このSSL実行例は次のような出力を表示しました
(読み易いように改行は入れてあります):

     '/C=US/ST=California/L=Mountain View/
      O=VeriSign, Inc./OU=Production Services/
      OU=Terms of use at www.verisign.com/rpa (c)00/
      CN=www.verisign.com'
     '/O=VeriSign Trust Network/OU=VeriSign, Inc./
      OU=VeriSign International Server CA - Class 3/
      OU=www.verisign.com/CPS Incorp.by Ref. LIABILITY LTD.(c)97 VeriSign'


File: python-lib-jp.info,  Node: signal,  Next: popen2,  Prev: socket,  Up: プロセス間通信とネットワーク

17.3 非同期イベントにハンドラを設定する
=======================================

非同期イベントにハンドラを設定します。

このモジュールでは Python でシグナルハンドラを使うための機構を
提供します。シグナルとハンドラを扱う上では、一般的なルールが
いくつかあります:

   * 特定のシグナルに対するハンドラが一度設定されると、明示的に
     リセットしないかぎり設定されたままになります (Python は背後の実装系
     に関係なく BSD 形式のインタフェースをエミュレートします)。 例外は
     `SIGCHLD' のハンドラで、この場合は背後の実装系の 仕様に従います。

   * クリティカルセクションから一時的にシグナルを"ブロック"することは
     できません。この機能をサポートしないUNIX系システムも存在するた
     めです。

   * Python のシグナルハンドラは Python のユーザが望む限り非同期で呼び
     出されますが、呼び出されるのは Python インタプリタの "原子的な
     (atomic)" 命令実行単位の間です。従って、
     (巨大なサイズのテキストに対する正規表現の一致検索のような) 純粋に
     C 言語のレベルで実現されている時間のかかる処理中に
     到着したシグナルは、不定期間遅延する可能性があります。

   * シグナルが I/O 操作中に到着すると、シグナルハンドラが処理を返した
     後に I/O 操作が例外を送出する可能性があります。 これは背後にある
     UNIX システムが割り込みシステムコールにどういう
     意味付けをしているかに依存します。

   * C 言語のシグナルハンドラは常に処理を返すので、`SIGFPE' や
     `SIGSEGV' のような同期エラーの捕捉はほとんど意味が ありません。

   * Python は標準でごく小数のシグナルハンドラをインストールしています:
     `SIGPIPE' は無視されます (従って、パイプやソケットに対する
     書き込みで生じたエラーは通常の Python 例外として報告されます)
     `SIGINT' は `KeyboardInterrupt' 例外に変換されます。
     これらはどれも上書きすることができます。

   * シグナルとスレッドの両方を同じプログラムで使用する場合にはいくつか
     注意が必要です。シグナルとスレッドを同時に利用する上で基本的に注意
     すべきことは: 常に `signal()' 命令は主スレッド (main thread)の
     処理中で実行するということです。どのスレッドも `alarm()'、
     `getsignal()'、あるいは `pause()' を実行する ことができます;
     しかし、主スレッドだけが新たなシグナルハンドラを
     設定することができ、従ってシグナルを受け取ることができるのは主スレッド
     だけです
     (これは、背後のスレッド実装が個々のスレッドに対するシグナル
     送信をサポートしているかに関わらず、Python `signal' モジュール
     が強制している仕様です)。従って、シグナルをスレッド間通信の手段として
     使うことはできません。代わりにロック機構を使ってください。

以下に `signal' モジュールで定義されている変数を示します:

`SIG_DFL'
     二つある標準シグナル処理オプションのうちの一つです; 単にシグナルに
     対する標準の関数を実行します。例えば、ほとんどのシステムでは、
     `SIGQUIT' に対する標準の動作はコアダンプと終了で、 `SIGCLD'
     に対する標準の動作は単にシグナルの無視です。

`SIG_IGN'
     もう一つの標準シグナル処理オプションで、単に受け取ったシグナルを
     無視します。

`SIG*'
     全てのシグナル番号はシンボル定義されています。例えば、ハングアップ
     シグナルは `signal.SIGHUP' で定義されています; 変数名は C
     言語のプログラムで使われているのと同じ名前で、`<signal.h>'
     にあります。 ``signal()'' に関する UNIX マニュアルページでは、
     システムで定義されているシグナルを列挙しています
     (あるシステムではリストは `signal(2)' に、別のシステムでは
     `signal(7)' に列挙されています)。
     全てのシステムで同じシグナル名のセットを定義しているわけではないので
     注意してください;
     このモジュールでは、システムで定義されているシグナル
     名だけを定義しています。

`NSIG'
     最も大きいシグナル番号に 1 を足した値です。

`signal' モジュールでは以下の関数を定義しています:

`alarm(time)'
     TIME がゼロでない値の場合、この関数は TIME 秒後頃に `SIGALRM'
     をプロセスに送るように要求します。
     それ以前にスケジュールしたアラームはキャンセルされます (常に一つの
     アラームしかスケジュールできません)。この場合、戻り値は以前に設定
     されたアラームシグナルが通知されるまであと何秒だったかを示す値です。
     TIME がゼロの場合、アラームは一切スケジュールされず、現在
     スケジュールされているアラームがキャンセルされます。
     戻り値は以前にスケジュールされたアラームが通知される予定時刻までの
     残り時間です。戻り値がゼロの場合、現在アラームがスケジュールされて
     いないことを示します。(UNIX マニュアルページ `alarm(2)'
     を参照してください)。 利用可能: UNIX。

`getsignal(signalnum)'
     シグナル SIGNALNUM に対する現在のシグナルハンドラを返します。
     戻り値は呼び出し可能な Python オブジェクトか、`signal.SIG_IGN'、
     `signal.SIG_DFL'、および `None' といった特殊な値
     のいずれかです。ここで `signal.SIG_IGN' は以前そのシグナルが
     無視されていたことを示し、`signal.SIG_DFL' は以前そのシグナルの
     標準の処理方法が使われていたことを示し、`None' はシグナルハンドラが
     まだ Python によってインストールされていないことを示します。

`pause()'
     シグナルを受け取るまでプロセスを一時停止します; その後、適切な
     ハンドラが呼び出されます。戻り値はありません。Windows では利用
     できません。(UNIX マニュアルページ `signal(2)' を
     参照してください。)

`signal(signalnum, handler)'
     シグナル SIGNALNUM に対するハンドラを関数 HANDLER にします。
     HANDLER は二つの引数 (下記参照) を取る呼び出し可能な Python
     オブジェクトにするか、`signal.SIG_IGN' あるいは `signal.SIG_DFL'
     といった特殊な値にすることができます。
     以前に使われていたシグナルハンドラが返されます (上記の
     `getsignal()' の記述を参照してください)。 (UNIX マニュアルページ
     `signal(2)' を参照してください。)

     複数スレッドの使用が有効な場合、この関数は主スレッドからのみ呼び出す
     ことができます; 主スレッド以外のスレッドで呼び出そうとすると、例外
     `ValueError' が送出されます。

     HANDLER は二つの引数: シグナル番号、および現在のスタックフレーム
     (`None' またはフレームオブジェクト; フレームオブジェクトに
     ついての記述はリファレンスマニュアルの標準型の階層 か、
     `inspect'モジュールの属性の説明を参照してください)、
     とともに呼び出されます。 

* Menu:

* Simple Example::


File: python-lib-jp.info,  Node: Simple Example,  Prev: signal,  Up: signal

17.3.1 例
---------

以下は最小限のプログラム例です。この例では `alarm()'
を使って、ファイルを開く処理を待つのに費やす時間を制限します;
これはそのファイルが電源の入れられていないシリアルデバイスを
表している場合に有効で、通常こうした場合には `os.open()'
は未定義の期間ハングアップしてしまいます。ここではファイルを開く まで 5
秒間のアラームを設定することで解決しています; ファイルを
開く処理が長くかかりすぎると、アラームシグナルが送信され、
ハンドラが例外を送出するようになっています。

     import signal, os

     pdef handler(signum, frame):
         print 'Signal handler called with signal', signum
         raise IOError, "Couldn't open device!"

     # Set the signal handler and a 5-second alarm
     signal.signal(signal.SIGALRM, handler)
     signal.alarm(5)

     # This open() may hang indefinitely
     fd = os.open('/dev/ttyS0', os.O_RDWR)

     signal.alarm(0)          # Disable the alarm


File: python-lib-jp.info,  Node: popen2,  Next: asyncore,  Prev: signal,  Up: プロセス間通信とネットワーク

17.4 アクセス可能な I/O ストリームを持つ子プロセス生成
======================================================

アクセス可能な I/O ストリームを持つ子プロセス生成。

このモジュールにより、UNIX および Windows でプロセスを起動し、
その入力／出力／エラー出力パイプに接続し、そのリターンコード
を取得することができます。

Python 2.0 から、この機能は `os' モジュールにある
関数を使って得ることができるので注意してください。 `os'
にある関数はこのモジュールにおけるファクトリ関数
と同じ名前を持ちますが、戻り値に関する取り決めは `os'
の関数の方がより直感的です。

このモジュールで提供されている第一のインタフェースは 3 つの
ファクトリ関数です。これらの関数のいずれも、BUFSIZE を 指定した場合、
I/O パイプのバッファサイズを決定します。 MODE
を指定する場合、文字列`'b'' または `'t'' でなければなりません; Windows
では、ファイルオブジェクトを
バイナリあるいはテキストモードのどちらで開くかを決めなければ
なりません。MODE の標準の値は `'t'' です。

UNIXではCMDはシーケンスでもよく、その場合には
(`os.spawnv()'のように)引数はプログラムシェルを経由せず直接渡 されます。
CMDが文字列の場合、(`os.system()'のように)シェルに渡されます。

子プロセスからのリターンコードを取得するには、`Popen3' および `Popen4'
クラスの `poll()' あるいは `wait()' メソッドを使うしかありません;
これらの機能は UNIXでしか利用できません。この情報は `popen2()'、
`popen3()'、および `popen4()' 関数、 あるいは `os'
モジュールにおける同等の関数の 使用によっては得ることができません。
(`os'モジュールの関数から返されるタプルは`popen2'モ
ジュールの関数から返されるものとは違う順序です。)

`popen2(cmd[, bufsize[, mode]])'
     CMD をサブプロセスとして実行します。ファイルオブジェクト
     `(CHILD_STDOUT, CHILD_STDIN)' を返します。

`popen3(cmd[, bufsize[, mode]])'
     CMD をサブプロセスとして実行します。ファイルオブジェクト
     `(CHILD_STDOUT, CHILD_STDIN, CHILD_STDERR)' を返します。

`popen4(cmd[, bufsize[, mode]])'
     CMD をサブプロセスとして実行します。ファイルオブジェクト
     `(CHILD_STDOUT_AND_STDERR, CHILD_STDIN)'.  _Added in Python
     version 2.0_

UNIXでは、ファクトリ関数によって返されるオブジェクトを定義している
クラスも利用することができます。これらのオブジェクトは Windows 実装
で使われていないため、そのプラットフォーム上で使うことはできません。

`Popen3(cmd[, capturestderr[, bufsize]])'
     このクラスは子プロセスを表現します。通常、 `Popen3'
     インスタンスは上で述べた `popen2()' および `popen3()'
     ファクトリ関数を使って生成されます。

     `Popen3' オブジェクトを生成するためにいずれかのヘルパー関数を
     使っていないのなら、CMD パラメタは子プロセスで実行する
     シェルコマンドになります。CAPTURESTDERR フラグが真であれば、
     このオブジェクトが子プロセスの標準エラー出力を捕獲しなければならない
     ことを意味します。標準の値は偽です。BUFSIZE パラメタが存在
     する場合、子プロセスへの／からの I/O バッファのサイズを指定します。

`Popen4(cmd[, bufsize])'
     `Popen3' に似ていますが、標準エラー出力を標準出力と同じファイル
     オブジェクトで捕獲します。このオブジェクトは通常 `popen4()' で
     生成されます。 _Added in Python version 2.0_

* Menu:

* Popen3 および Popen4 オブジェクト::
* フロー制御の問題::


File: python-lib-jp.info,  Node: Popen3 および Popen4 オブジェクト,  Next: フロー制御の問題,  Prev: popen2,  Up: popen2

17.4.1 Popen3 および Popen4 オブジェクト
----------------------------------------

`Popen3' および `Popen4' クラスのインスタンスは以下の
メソッドを持ちます:

`poll()'
     子プロセスがまだ終了していない際には `-1' を、そうでない場合には
     リターンコードを返します。

`wait()'
     子プロセスの状態コード出力を待機して返します。状態コードでは
     子プロセスのリターンコードと、プロセスが `exit()' によって
     終了したか、あるいはシグナルによって死んだかについての情報を
     符号化しています。状態コードの解釈を助けるための関数は `os'
     モジュールで定義されています; *Note プロセス管理:: 節の `W*()'
     関数ファミリを 参照してください。

以下の属性も利用可能です:

`fromchild'
     子プロセスからの出力を提供するファイルオブジェクトです。 `Poepn4'
     インスタンスの場合、この値は標準出力と標準
     エラー出力の両方を提供するオブジェクトになります。

`tochild'
     子プロセスへの入力を提供するファイルオブジェクトです。

`childerr'
     コンストラクタに CAPTURESTDERR を渡した際には子プロセスからの
     標準エラー出力を提供するファイルオブジェクトで、そうでない場合
     `None' になります。 `Popen4' インスタンスでは、この値は常に `None'
     になります。

`pid'
     子プロセスのプロセス番号です。


File: python-lib-jp.info,  Node: フロー制御の問題,  Prev: Popen3 および Popen4 オブジェクト,  Up: popen2

17.4.2 フロー制御の問題
-----------------------

何らかの形式でプロセス間通信を利用している際には常に、制御フローに
ついて注意深く考える必要があります。これはこのモジュール (あるいは `os'
モジュールにおける等価な機能) で生成される
ファイルオブジェクトの場合にもあてはまります。

親プロセスが子プロセスの標準出力を読み出している一方で、子プロセスが
大量のデータを標準エラー出力に書き込んでいる場合、この子プロセスから
出力を読み出そうとするとデッドロックが発生します。
同様の状況は読み書きの他の組み合わせでも生じます。本質的な要因は、
一方のプロセスが別の
プロセスでブロック型の読み出しをしている際に、`_PC_PIPE_BUF'
バイトを超えるデータがブロック型の入出力を行うプロセスによって書き込ま
れることにあります。

こうした状況を扱うには幾つかのやりかたがあります。

多くの場合、もっとも単純なアプリケーションに対する変更は、
親プロセスで以下のようなモデル:

     import popen2

     r, w, e = popen2.popen3('python slave.py')
     e.readlines()
     r.readlines()
     r.close()
     e.close()
     w.close()

に従うようにし、子プロセスで以下:

     import os
     import sys

     # note that each of these print statements
     # writes a single long string

     print >>sys.stderr, 400 * 'this is a test\n'
     os.close(sys.stderr.fileno())
     print >>sys.stdout, 400 * 'this is another test\n'

のようなコードにすることでしょう。

とりわけ、`sys.stderr' は全てのデータを書き込んた後に閉じ
られなければならないということに注意してください。さもなければ、
`readlines()' は返ってきません。また、 `sys.stderr.close()' が `stderr'
を閉じないように `os.close()'
を使わなければならないことにも注意してください。
(そうでなく、`sys.stderr' に関連付けると、暗黙のうちに閉じられて
しまうので、それ以降のエラーが出力されません)。

より一般的なアプローチををサポートする必要があるアプリケーションでは、
パイプ経由の I/O を `select()' ループでまとめるか、 個々の `popen*()'
関数や `Popen*'
クラスが提供する各々のファイルに対して、個別のスレッドを使って
読み出しを行います。


File: python-lib-jp.info,  Node: asyncore,  Next: asynchat,  Prev: popen2,  Up: プロセス間通信とネットワーク

17.5 非同期ソケットハンドラ
===========================

非同期なソケット制御サービスのためのベースクラス

このモジュールは、非同期ソケットサービスのクライアント・サーバを開発する
ための基盤として使われます。

CPUが一つしかない場合、プログラムが"二つのことを同時に"実行する方法は
二つしかありません。もっとも簡単で一般的なのはマルチスレッドを利用する方
法ですが、これとはまったく異なるテクニックで、一つのスレッドだけでマルチ
スレッドと同じような効果を得られるテクニックがあります。このテクニックは
I/O処理が中心である場合にのみ有効で、CPU負荷の高いプログラムでは効果が無
く、この場合にはプリエンプティブなスケジューリングが可能なスレッドが有効
でしょう。しかし、多くの場合、ネットワークサーバではCPU負荷よりはIO負荷
が問題となります。

もしOSのI/Oライブラリがシステムコール `select()' をサポートし
ている場合（ほとんどの場合はサポートされている）、I/O処理は"バックグラ
ウンド"で実行し、その間に他の処理を実行すれば、複数の通信チャネルを同時
にこなすことができます。一見、この戦略は奇妙で複雑に思えるかもしれません
が、いろいろな面でマルチスレッドよりも理解しやすく、制御も容易です。
`asyncore'は多くの複雑な問題を解決済みなので、洗練され、パフォー
マンスにも優れたネットワークサーバとクライアントを簡単に開発することがで
きます。とくに、`asynchat'のような、対話型のアプリケーションや
プロトコルには非常に有効でしょう。

基本的には、この二つのモジュールを使う場合は一つ以上のネットワーク
_チャネル_を`asyncore.dispatcher'クラス、または
`asynchat.async_chat'のインスタンスとして作成します。作成されたチ
ャネルはグローバルマップに登録され、`loop()'関数で参照されま
す。`loop()'には、専用のマップを渡す事も可能です。

チャネルを生成後、`loop()'を呼び出すとチャネル処理が開始し、最
後のチャネル（非同期処理中にマップに追加されたチャネルを含む）が閉じるま
で継続します。

`loop([timeout[, use_poll[, map[,count]]]])'
     ポーリングループを開始し、count回が過ぎるか、全てのオープン済みチャ
     ネルがクローズされた場合のみ終了します。全ての引数はオプションです。
     引数COUNTのデフォルト値はNoneで、ループは全てのチャネルがクロー
     ズされた場合のみ終了します。 引数TIMEOUTは
     `select()'または`poll()'の引数timeoutとして渡され、
     秒単位で指定します。デフォルト値は30秒です。引数USE_POLLが真のと
     き、`select()'ではなく`poll()'が使われます。デフォル
     ト値は`False'です。

     引数MAPには、監視するチャネルをアイテム
     として格納した辞書を指定します。MAPが省略された場合、グローバル
     なマップが使用されます。


`dispatcher()'
     `dispatcher'クラスは、低レベルソケットオブジェクトの薄いラッ
     パーです。便宜上、非同期ループから呼び出されるイベント処理メソッドを
     追加していますが、これ以外の点では、non-blockingなソケットと同様で
     す。

     `dispatcher'クラスには二つのクラス属性があり、パフォーマンス向上
     やメモリの削減のために更新する事ができます。

    `ac_in_buffer_size'
          非同期入力バッファのサイズ(デフォルト `4096')

    `ac_out_buffer_size'
          非同期出力バッファのサイズ(デフォルト `4096')

     非同期ループ内で低レベルイベントが発生した場合、発生のタイミングやコネ
     クションの状態から特定の高レベルイベントへと置き換えることができます。
     例えばソケットを他のホストに接続する場合、最初の書き込み可能イベントが
     発生すれば接続が完了した事が分かります(この時点で、ソケットへの書き込
     みは成功すると考えられる)。このように判定できる高レベルイベントを以下
     に示します：

     イベント                           解説
     ------                             -----
     handle_connect()                   最初にwriteイベントが発生した時
     handle_close()                     読み込み可能なデータなしでreadイベントが発生
                                        した時
     handle_accept()                    listen中のソケットでreadイベントが発生した時

     非同期処理中、マップに登録されたチャネルの`readable()'メソッド
     と`writable()'メソッドが呼び出され、`select()'か
     `poll()'でread/writeイベントを検出するリストに登録するか否か
     を判定します。


このようにして、チャネルでは低レベルなソケットイベントの種類より多くの種
類のイベントを検出する事ができます。以下にあげるイベントは、サブクラスで
オーバライドすることが可能です：

`handle_read()'
     非同期ループで、チャネルのソケットの`read()'メソッドの呼び出しが
     成功した時に呼び出されます。

`handle_write()'
     非同期ループで、書き込み可能ソケットが実際に書き込み可能になった時に呼
     び出される。このメソッドは、パフォーマンスの向上のためバッファリングを
     行う場合などに利用できます。例：
          def handle_write(self):
              sent = self.send(self.buffer)
              self.buffer = self.buffer[sent:]


`handle_expt()'
     out of band
     (OOB)データが検出された時に呼び出されます。OOBはあまりサポー
     トされておらず、また滅多に使われないので、`handle_expt()'が呼び
     出されることはほとんどありません。

`handle_connect()'
     ソケットの接続が確立した時に呼び出されます。"welcome"バナーの送信、プ
     ロトコルネゴシエーションの初期化などを行います。

`handle_close()'
     ソケットが閉じた時に呼び出されます。

`handle_error()'
     捕捉されない例外が発生した時に呼び出されます。デフォルトでは、短縮したト
     レースバック情報が出力されます。

`handle_accept()'
     listen中のチャネルがリモートホストからの`connect()'で接続され、
     接続が確立した時に呼び出されます。

`readable()'
     非同期ループ中に呼び出され、readイベントの監視リストに加えるか否かを決
     定します。デフォルトのメソッドでは`True'を返し、readイベントの発
     生を監視します。

`writable()'
     非同期ループ中に呼び出され、writeイベントの監視リストに加えるか否かを
     決定します。デフォルトのメソッドでは`True'を返し、writeイベントの
     発生を監視します。

さらに、チャネルにはソケットのメソッドとほぼ同じメソッドがあり、チャネル
はソケットのメソッドの多くを委譲・拡張しており、ソケットとほぼ同じメソッ
ドを持っています。

`create_socket(family, type)'
     引数も含め、通常のソケット生成と同じ。`socket'モジュールを参
     照のこと。

`connect(address)'
     通常のソケットオブジェクトと同様、ADDRESSには一番目の値が接続先
     ホスト、2番目の値がポート番号であるタプルを指定します。

`send(data)'
     リモート側の端点にDATAを送出します。

`recv(buffer_size)'
     リモート側の端点より、最大BUFFER_SIZEバイトのデータを読み込みま
     す。長さ0の文字列が返ってきた場合、チャネルはリモートから切断された事
     を示します。

`listen(backlog)'
     ソケットへの接続を待つ。引数BACKLOGは、キューイングできるコネク
     ションの最大数を指定します(1以上)。最大数はシステムに依存でします（通
     常は5)

`bind(address)'
     ソケットをADDRESSにバインドします。ソケットはバインド済みであっ
     てはなりません。(ADDRESSの形式は、アドレスファミリに依存します。
     `socket'モジュールを参照のこと。)

`accept()'
     接続を受け入れます。ソケットはアドレスにバインド済みであり、
     `listen()'で接続待ち状態でなければなりません。戻り値は `(CONN,
     ADDRESS)'のペアで、CONNはデータの送受信
     を行うソケットオブジェクト、ADDRESSは接続先ソケットがバインドさ
     れているアドレスです。

`close()'
     ソケットをクローズします。以降の全ての操作は失敗します。リモート端点で
     は、キューに溜まったデータ以外、これ以降のデータ受信は行えません。ソケ
     ットはガベージコレクト時に自動的にクローズされます。

* Menu:

* asyncoreの例：簡単なHTTPクライアント::


File: python-lib-jp.info,  Node: asyncoreの例：簡単なHTTPクライアント,  Prev: asyncore,  Up: asyncore

17.5.1 asyncoreの例：簡単なHTTPクライアント
-------------------------------------------

基本的なサンプルとして、以下に非常に単純なHTTPクライアントを示します。こ
のHTTPクライアントは`dispatcher'クラスでソケットを利用しています。

     import asyncore, socket

     class http_client(asyncore.dispatcher):

         def __init__(self, host, path):
             asyncore.dispatcher.__init__(self)
             self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
             self.connect( (host, 80) )
             self.buffer = 'GET %s HTTP/1.0\r\n\r\n' % path

         def handle_connect(self):
             pass

         def handle_close(self):
             self.close()

         def handle_read(self):
             print self.recv(8192)

         def writable(self):
             return (len(self.buffer) > 0)

         def handle_write(self):
             sent = self.send(self.buffer)
             self.buffer = self.buffer[sent:]

     c = http_client('www.python.org', '/')

     asyncore.loop()


File: python-lib-jp.info,  Node: asynchat,  Prev: asyncore,  Up: プロセス間通信とネットワーク

17.6 非同期ソケット コマンド/レスポンス ハンドラ
================================================

非同期コマンド/レスポンスプロトコルの開発サポート

`asynchat'を使うと、`asyncore'を基盤とした非同期な
サーバ・クライアントをより簡単に開発する事ができます。
`asynchat'では、プロトコルの要素が任意の文字列で終了するか、ま
たは可変長の文字列であるようなプロトコルを容易に制御できるようになってい
ます。`asynchat'は、抽象クラス`async_chat'を定義してお
り、`async_chat'を継承して`collect_incoming_data()'メソッド
と`found_terminator()'メソッドを実装すれば使うことができます。
`async_chat'と`asyncore'は同じ非同期ループを使用してお
り、`asyncore.dispatcher'も`asynchat.async_chat'も同じチャネ
ルマップに登録する事ができます。通常、`asyncore.dispatcher'はサー
バチャネルとして使用し、リクエストの受け付け時に
`asynchat.async_chat'オブジェクトを生成します。

`async_chat()'
     このクラスは、`asyncore.dispatcher'から継承した抽象クラスです。
     使用する際には`async_chat'のサブクラスを作成し、
     `collect_incoming_data()'と`found_terminator()'を定義し
     なければなりません。`asyncore.dispatcher'のメソッドを使用する事
     もできますが、メッセージ/レスポンス処理を中心に行う場合には使えないメ
     ソッドもあります。

     `asyncore.dispatcher'と同様に、`async_chat'も
     `select()'呼出し後のソケットの状態からイベントを生成します。
     ポーリングループ開始後、イベント処理フレームワークが自動的に
     `async_chat'のメソッドを呼び出しますので、プログラマが処理を記述
     する必要はありません。

     `asyncore.dispatcher'と違い、`async_chat'では _プロデューサ_の
     first-in-first-outキュー(fifo)を作成する事ができ
     ます。プロデューサは`more()'メソッドを必ず持ち、このメソッドで
     チャネル上に送出するデータを返します。プロデューサが枯渇状態
     (_i.e._ これ以上のデータを持たない状態)にある場合、
     `more()'は空文字列を返します。この時、`async_chat'は枯渇
     状態にあるプロデューサをfifoから除去し、次のプロデューサが存在すればそ
     のプロデューサを使用します。fifoにプロデューサが存在しない場合、
     `handle_write()'は何もしません。リモート端点からの入力の終了や
     重要な中断点を検出する場合は、`set_terminator()'に記述します。

     `async_chat'のサブクラスでは、入力メソッド
     `collect_incoming_data()'と`found_terminator()'を定義
     し、チャネルが非同期に受信するデータを処理します。以下にメソッドの解説
     を示します。


`close_when_done()'
     プロデューサfifoのトップに`None'をプッシュします。このプロデュー
     サがポップされると、チャネルがクローズします。

`collect_incoming_data(data)'
     チャネルが受信した不定長のデータをDATAに指定して呼び出されます。
     このメソッドは必ずオーバライドする必要があり、デフォルトの実装では、
     `NotImplementedError' 例外を送出します。

`discard_buffers()'
     非常用のメソッドで、全ての入出力バッファとプロデューサfifoを廃棄します。

`found_terminator()'
     入力データストリームが、`set_terminator'で指定した終了条件と一
     致した場合に呼び出されます。このメソッドは必ずオーバライドする必要があ
     り、デフォルトの実装では、`NotImplementedError' 例外を送出し
     ます。入力データを参照する必要がある場合でも引数としては与えられないた
     め、入力バッファをインスタンス属性として参照しなければなりません。

`get_terminator()'
     現在のチャネルの終了条件を返します。

`handle_close()'
     チャネル閉じた時に呼び出されます。デフォルトの実装では単にチャネルのソ
     ケットをクローズします。

`handle_read()'
     チャネルの非同期ループでreadイベントが発生した時に呼び出され、デフォル
     トの実装では、`set_terminator()'で設定された終了条件をチェック
     します。終了条件として、特定の文字列か受信文字数を指定する事ができま
     す。終了条件が満たされている場合、`handle_read'は終了条件が成立
     するよりも前のデータを引数として`collect_incoming_data()'を呼び
     出し、その後`found_terminator()'を呼び出します。

`handle_write()'
     アプリケーションがデータを出力する時に呼び出され、デフォルトの実装では
     `initiate_send()'を呼び出します。`initiate_send()'では
     `refill_buffer()'を呼び出し、チャネルのプロデューサfifoからデー
     タを取得します。

`push(data)'
     dataを持つ`simple_producer'(_後述_)オブジェクトを生成し、チ
     ャネルの`producer_fifo'にプッシュして転送します。データをチャネル
     に書き出すために必要なのはこれだけですが、データの暗号化やチャンク化な
     どを行う場合には独自のプロデューサを使用する事もできます。

`push_with_producer(producer)'
     指定したプロデューサオブジェクトをチャネルのfifoに追加します。これより
     前にpushされたプロデューサが全て枯渇した後、チャネルはこのプロデューサ
     から`more()'メソッドでデータを取得し、リモート端点に送信しま す。

`readable()'
     `select()'ループでこのチャネルの読み込み可能チェックを行う場
     合には、`True'を返します。

`refill_buffer()'
     fifoの先頭にあるプロデューサの`more()'メソッドを呼び出し、出力
     バッファを補充します。先頭のプロデューサが枯渇状態の場合にはfifoからポ
     ップされ、その次のプロデューサがアクティブになります。アクティブなプロ
     デューサが`None'になると、チャネルはクローズされます。

`set_terminator(term)'
     チャネルで検出する終了条件を設定します。`term'は入力プロトコルデー
     タの処理方式によって以下の3つの型の何れかを指定します。

     term                               説明
     ------                             -----
     _string_                           入力ストリーム中でstringが検出された時、
                                        `found_terminator()'を呼び出します。
     _integer_                          指定された文字数が読み込まれた時、
                                        `found_terminator()'を呼び出します。
     `None'                             永久にデータを読み込みます。

     終了条件が成立しても、その後に続くデータは、
     `found_terminator()'の呼出し後に再びチャネルを読み込めば取得す
     る事ができます。


`writable()'
     Should return `True' as long as items remain on the producer fifo,
     or the channel is connected and the channel's output buffer is
     non-empty.

     プロデューサfifoが空ではないか、チャネルが接続中で出力バッファが空でな
     い場合、`True'を返します。

* Menu:

* asynchat - 補助クラスと関数::
* asynchat 使用例::


File: python-lib-jp.info,  Node: asynchat - 補助クラスと関数,  Next: asynchat 使用例,  Prev: asynchat,  Up: asynchat

17.6.1 asynchat - 補助クラスと関数
----------------------------------

`simple_producer(data[, buffer_size=512])'
     `simple_producer'には、一連のデータと、オプションとしてバッファ
     サイズを指定する事ができます。`more()'が呼び出されると、その都
     度BUFFER_SIZE以下の長さのデータを返します。

`more()'
     プロデューサから取得した次のデータか、空文字列を返します。

`fifo([list=None])'
     各チャネルは、アプリケーションからプッシュされ、まだチャネルに書き出さ
     れていないデータを`fifo'に保管しています。`fifo'では、必
     要なデータとプロデューサのリストを管理しています。引数LISTには、
     プロデューサかチャネルに出力するデータを指定する事ができます。

`is_empty()'
     fifoが空のとき`True'を返します。

`first()'
     fifoに`push()'されたアイテムのうち、最も古いアイテムを返します。

`push(data)'
     データ(文字列またはプロデューサオブジェクト)をプロデューサfifoに追加します。

`pop()'
     fifoが空でなければ、`(True, first())'を返し、ポップされたアイテム
     を削除します。fifoが空であれば`(False, None)'を返します。

`asynchat'は、ネットワークとテキスト分析操作で使えるユーティリテ
ィ関数を提供しています。

`find_prefix_at_end(haystack, needle)'
     文字列HAYSTACKの末尾がNEEDLEの先頭と一致したとき、`True'
     を返します。

