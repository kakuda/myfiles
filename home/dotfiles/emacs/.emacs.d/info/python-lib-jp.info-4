これは python-lib-jp.info、python-lib-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-lib-jp.info,  Node: xmldomminidom,  Next: xmldompulldom,  Prev: xmldom,  Up: 構造化マークアップツール

8.7 軽量な DOM 実装
===================

軽量な文書オブジェクトモデルの実装。

_Added in Python version 2.0_

`xml.dom.minidom' は、軽量な文書オブジェクトモデルインタフェース
の実装です。この実装では、完全な DOM よりも
単純で、かつ十分に小さくなるよう意図しています。

DOM アプリケーションは典型的に、XML を DOM に解析 (parse) することで
開始します。`xml.dom.minidom' では、以下のような解析用の関数
を介して行います:

     from xml.dom.minidom import parse, parseString

     dom1 = parse('c:\\temp\\mydata.xml') # parse an XML file by name

     datasource = open('c:\\temp\\mydata.xml')
     dom2 = parse(datasource)   # parse an open file

     dom3 = parseString('<myxml>Some data<empty/> some more data</myxml>')

`parse()' 関数はファイル名か、開かれたファイルオブジェクト
を引数にとることができます。

`parse(filename_or_file{, parser})'
     与えられた入力から `Document' を返します。 FILENAME_OR_FILE
     はファイル名でもファイルオブジェクトでもかまいません。PARSER
     を指定する場合、SAX2 パーザオブジェクトでなければなりません。
     この関数はパーザの文書ハンドラを変更し、名前空間サポートを有効に
     します; (エンティティリゾルバ (entity resolver) のような)
     他のパーザ設定 は前もっておこなわなければなりません。

XML データを文字列で持っている場合、`parseString()' を
代わりに使うことができます:

`parseString(string[, parser])'
     STRING を表現する `Document' を返します。このメソッドは
     文字列に対する `StringIO' オブジェクトを生成して、その
     オブジェクトを `parse' に渡します。

これらの関数は両方とも、文書の内容を表現する `Document' オブジェクトを
返します。

`parse()' や `parseString()' といった関数が行うのは、 XML
パーザを、何らかの SAX パーザからくる解析イベント (parse event)
を受け取って DOM ツリーに変換できるような "DOM ビルダ (DOM builder)"
に結合することです。関数は誤解を招くような名前になっているかも
しれませんが、インタフェースについて学んでいるときには理解しやすい
でしょう。文書の解析はこれらの関数が戻るより前に完結します; 要するに、
これらの関数自体はパーザ実装を提供しないということです。

"DOM 実装" オブジェクトのメソッドを呼び出して `Document' を
生成することもできます。このオブジェクトは、`xml.dom'
パッケージ、または`xml.dom.minidom' モジュールの
`getDOMImplementation()' 関数を呼び出して取得できます。
`xml.dom.minidom' モジュールの実装を使うと、常に minidom 実装の
`Document' インスタンスを返します。一方、 `xml.dom'
版の関数では、別の実装によるインスタンスを 返すかもれません (PyXML
package がインストールされているとそうなるでしょう)。`Document'
を取得したら、DOM を構成するために子ノードを追加していくことができます:

     from xml.dom.minidom import getDOMImplementation

     impl = getDOMImplementation()

     newdoc = impl.createDocument(None, "some_tag", None)
     top_element = newdoc.documentElement
     text = newdoc.createTextNode('Some textual content.')
     top_element.appendChild(text)

DOM 文書オブジェクトを手にしたら、XML 文書のプロパティやメソッドを
使って、文書の一部にアクセスすることができます。これらのプロパティは
DOM 仕様で定義されています。文書オブジェクトの主要なプロパティは
`documentElement' プロパティです。このプロパティは XML
文書の主要な要素: 他の全ての要素を保持する要素、を与えます。
以下にプログラム例を示します:

     dom3 = parseString("<myxml>Some data</myxml>")
     assert dom3.documentElement.tagName == "myxml"

DOM を使い終えたら、後片付けを行わなければなりません。 Python
のバージョンによっては、循環的に互いを参照するオブジェクト
に対するガベージコレクションをサポートしていないため、この操作が
必要となります。この制限が全てのバージョンの Python から除去される
までは、循環参照オブジェクトが消去されないものとしてコードを
書くのが無難です。

DOM を片付けるには、 `unlink()' メソッドを呼び出します:

     dom1.unlink()
     dom2.unlink()
     dom3.unlink()

`unlink()' は、 DOM API に対する `xml.dom.minidom'
特有の拡張です。ノードに対して `unlink()' を呼び出した後は、
ノードとその下位ノードは本質的には無意味なものとなります。

See also:
     `Document Object Model (DOM) Level 1 Specification'
     {`xml.dom.minidom' でサポートされている DOM の W3C 勧告。}

* Menu:

* DOM オブジェクト::
* DOM の例::
* minidom と DOM 標準::


File: python-lib-jp.info,  Node: DOM オブジェクト,  Next: DOM の例,  Prev: xmldomminidom,  Up: xmldomminidom

8.7.1 DOM オブジェクト
----------------------

Python の DOM API 定義は `xml.dom' モジュールドキュメント
の一部として与えられています。この節では、`xml.dom' の API と
`xml.dom.minidom' との違いについて列挙します。

`unlink()'
     DOM との内部的な参照を破壊して、循環参照ガベージコレクションを
     持たないバージョンの Python でもガベージコレクションされるように
     します。循環参照ガベージコレクションが利用できても、このメソッドを
     使えば、大量のメモリをすぐに使えるようにできるため、必要なくなったら
     すぐにこのメソッドを DOM オブジェクトに対して呼ぶのが良い習慣です。
     このメソッドは `Document' オブジェクトに対してだけ呼び出せば
     よいのですが、あるノードの子ノードを放棄するために子ノードに対して
     呼び出してもかまいません。

`writexml(writer[,indent=""[,addindent=""[,newl=""]]])'
     XML を WRITER オブジェクトに書き込みます。 WRITER
     は、ファイルオブジェクトインタフェースの `write()' に該当する
     メソッドを持たなければなりません。 INDENT
     パラメタには現在のノードのインデントを指定します。 ADDINDENT
     パラメタには現在のノードの下にサブノードを
     追加する際のインデント増分を指定します。 NEWL
     には、改行時に行末を終端する文字列を指定します。

     _Changed in Python version 2.1_

     _Changed in Python version 2.3_

`toxml([encoding])'
     DOM が表現している XML を文字列にして返します。

     引数がなければ、 XML ヘッダは encoding を指定せず、
     文書内の全ての文字をデフォルトエンコード方式で表示できない場合、
     結果は Unicode 文字列となります。この文字列を UTF-8 以外の
     エンコード方式でエンコードするのは不正であり、なぜなら UTF-8 が
     XML のデフォルトエンコード方式だからです。

     明示的な ENCODING 引数があると、結果は指定されたエンコード
     方式によるバイト文字列となります。引数を常に指定するよう推奨します。
     表現不可能なテキストデータの場合に `UnicodeError' が送出されるのを
     避けるため、encoding 引数は "utf-8" に指定するべきです。

     _Changed in Python version 2.3_

`toprettyxml([indent[, newl]])'
     美しく出力されたバージョンの文書を返します。INDENT は
     インデントを行うための文字で、デフォルトはタブです; NEWL
     には行末で出力される文字列を指定し、デフォルトは `\n' です。

     _Added in Python version 2.1_ _Changed in Python version 2.3_

以下の標準 DOM メソッドは、`xml.dom.minidom' では特別な
注意をする必要があります:

`cloneNode(deep)'
     このメソッドは Python 2.0 にパッケージされているバージョンの
     `xml.dom.minidom' にはありましたが、これには深刻な
     障害があります。以降のリリースでは修正されています。


File: python-lib-jp.info,  Node: DOM の例,  Next: minidom と DOM 標準,  Prev: DOM オブジェクト,  Up: xmldomminidom

8.7.2 DOM の例
--------------

以下のプログラム例は、かなり現実的な単純なプログラムの例です。
特にこの例に関しては、DOM の柔軟性をあまり活用してはいません。

`minidom-example.py'


File: python-lib-jp.info,  Node: minidom と DOM 標準,  Prev: DOM の例,  Up: xmldomminidom

8.7.3 minidom と DOM 標準
-------------------------

`xml.dom.minidom' モジュールは、本質的には DOM 1.0 互換の DOM
に、いくつかの DOM 2 機能 (主に名前空間 機能) を追加したものです。

Python における DOM インタフェースは率直なものです。以下の
対応付け規則が適用されます:

   * インタフェースはインスタンスオブジェクトを介してアクセスされます。
     アプリケーション自身から、クラスをインスタンス化してはなりません;
     `Document' オブジェクト上で利用可能な生成関数 (creator function)
     を使わなければなりません。導出インタフェースでは基底インタフェースの
     全ての演算 (および属性) に加え、新たな演算をサポートします。

   * 演算はメソッドとして使われます。DOM では `in' パラメタ
     のみを使うので、引数は通常の順番 (左から右へ) で渡されます。
     オプション引数はありません。`void' 演算は`None' を返します。

   * IDL 属性はインスタンス属性に対応付けられます。OMG IDL 言語
     における Python への対応付けとの互換性のために、属性 `foo'
     はアクセサメソッド `_get_foo()' および `_set_foo()'
     でもアクセスできます。 `readonly' 属性は変更しては なりません;
     とはいえ、これは実行時には強制されません。

   * `short int' 、 `unsigned int' 、 `unsigned long long' 、および
     `boolean' 型は、全て Python 整数 オブジェクトに対応付けられます。

   * `DOMString' 型は Python 文字列型に対応付けられます。
     `xml.dom.minidom' ではバイト文字列 (byte string) および Unicode
     文字列のどちらかに対応づけられますが、通常 Unicode 文字列
     を生成します。`DOMString' 型の値は、W3C の DOM 仕様で、IDL `null'
     値になってもよいとされている場所では `None' に なることもあります。

   * `const' 宣言を行うと、
     (`xml.dom.minidom.Node.PROCESSING_INSTRUCTION_NODE' のように)
     対応するスコープ内の変数に対応付けを行います;
     これらは変更してはなりません。

   * `DOMException' は現状では `xml.dom.minidom'
     でサポートされていません。その代わり、`xml.dom.minidom'
     は、`TypeError' や `AttributeError' といった 標準の Python
     例外を使います。

   * `NodeList' オブジェクトは Python の組み込みリスト型を
     使って実装されています。 Python 2.2 からは、これらのオブジェクトは
     DOM 仕様で定義されたインタフェースを提供していますが、それ以前の
     バージョンの Python では、公式の API をサポートしていません。
     しかしながら、これらの API は W3C 勧告で定義されたインタフェース
     よりも "Python 的な" ものになっています。

以下のインタフェースは `xml.dom.minidom' では全く実装 されていません:

   * `DOMTimeStamp'

   * `DocumentType' (added in Python 2.1)

   * `DOMImplementation' (added in Python 2.1)

   * `CharacterData'

   * `CDATASection'

   * `Notation'

   * `Entity'

   * `EntityReference'

   * `DocumentFragment'

これらの大部分は、ほとんどの DOM のユーザにとって一般的な用途として有用
とはならないような XML 文書内の情報を反映しています。


File: python-lib-jp.info,  Node: xmldompulldom,  Next: xmlsax,  Prev: xmldomminidom,  Up: 構造化マークアップツール

8.8 部分的な DOM ツリー構築のサポート
=====================================

SAX イベントからの部分的な DOM ツリー構築のサポート。

_Added in Python version 2.0_

`xml.dom.pulldom' では、SAX イベントから、文書の文書オブジェクト
モデル表現の選択された一部分だけを構築できるようにします。

`PullDOM([documentFactory])'
     `xml.sax.handler.ContentHandler' 実装です ...

`DOMEventStream(stream, parser, bufsize)'
     ...

`SAX2DOM([documentFactory])'
     `xml.sax.handler.ContentHandler' 実装です ...

`parse(stream_or_string[, parser[, bufsize]])'
     ...

`parseString(string[, parser])'
     ...

`default_bufsize'
     `parse()' の BUFSIZE パラメタのデフォルト値です。 _Changed in
     Python version 2.1_

* Menu:

* DOMEventStream オブジェクト::


File: python-lib-jp.info,  Node: DOMEventStream オブジェクト,  Prev: xmldompulldom,  Up: xmldompulldom

8.8.1 DOMEventStream オブジェクト
---------------------------------

`getEvent()'
     ...

`expandNode(node)'
     ...

`reset()'
     ...


File: python-lib-jp.info,  Node: xmlsax,  Next: xmlsaxhandler,  Prev: xmldompulldom,  Up: 構造化マークアップツール

8.9 SAX2 パーサのサポート
=========================

SAX2 基底クラスと有用な関数のパッケージ

_Added in Python version 2.0_

`xml.sax' パッケージはPython 用の Simple API for XML (SAX) イン
ターフェースを実装した数多くのモジュールを提供しています。またパッケー
ジには SAX 例外と SAX API 利用者が頻繁に利用するであろう有用な関数群も
含まれています。

その関数群は以下の通りです:

`make_parser([parser_list])'
     SAX `XMLReader' オブジェクトを作成して返します。パーサには最初
     に見つかったものが使われます。PARSER_LIST を指定する場合は、
     `create_parser()' 関数を含んでいるモジュール名のシーケンス
     を与える必要があります。PARSER_LIST のモジュールはデフォルトの
     パーサのリストに優先して使用されます。

`parse(filename_or_stream, handler[, error_handler])'
     SAX パーサを作成してドキュメントをパースします。
     FILENAME_OR_STREAM として指定するドキュメントはファイル名、ファ
     イル・オブジェクトのいずれでもかまいません。HANDLER パラメータ
     には SAX `ContentHandler' のインスタンスを指定します。
     ERROR_HANDLER には SAX `ErrorHandler' のインスタンスを指
     定します。これが指定されていないときは、すべてのエラーで
     `SAXParseException' 例外が発生します。関数の戻り値はなく、
     すべての処理は HANDLER に渡されます。

`parseString(string, handler[, error_handler])'
     `parse()' に似ていますが、こちらはパラメータ STRING
     で指定されたバッファをパースします。

典型的な SAX アプリケーションでは3種類のオブジェクト(リーダ、ハンドラ、
入力元)が用いられます(ここで言うリーダとはパーサを指しています)。言い
換えると、プログラムはまず入力元からバイト列、あるいは文字列を読み込み、
一連のイベントを発生させます。発生したイベントはハンドラ・オブジェクト
によって振り分けられます。さらに言い換えると、リーダがハンドラのメソッ
ドを呼び出すわけです。つまり SAX アプリケーションには、リーダ・オブジェ
クト、(作成またはオープンされる)入力元のオブジェクト、ハンドラ・オブジェ
クト、そしてこれら3つのオブジェクトを連携させることが必須なのです。前
処理の最後の段階でリーダは入力をパースするために呼び出されます。パース
の過程で入力データの構造、構文にもとづいたイベントにより、ハンドラ・オ
ブジェクトのメソッドが呼び出されます。

これらのオブジェクトは(通常アプリケーション側でインスタンスを作成しな
い)インターフェースに相当するものです。Python はインターフェースという
明確な概念を提供していないため、形としてはクラスが用いられています。し
かし提供されるクラスを継承せずに、アプリケーション側で独自に実装するこ
とも可能です。`InputSource'、`Locator'、`Attributes'、
`AttributesNS'、`XMLReader' の各インターフェースは `xml.sax.xmlreader'
モジュールで定義されています。ハンドラ・ インターフェースは
`xml.sax.handler' で定義されています。し
ばしばアプリケーション側で直接インスタンスが作成される `InputSource'
とハンドラ・クラスは利便性のため `xml.sax'
にも含まれています。これらのインターフェースに関しては後に解説します。

このほかに `xml.sax' は次の例外クラスも提供しています。

`SAXException(msg[, exception])'
     XML エラーと警告をカプセル化します。このクラスには XML パーサとアプ
     リケーションで発生するエラーおよび警告の基本的な情報を持たせることが
     できます。また機能追加や地域化のためにサブクラス化することも可能です。
     なお `ErrorHandler' で定義されているハンドラがこの例外のインス
     タンスを受け取ることに注意してください。実際に例外を発生させることは
     必須でなく、情報のコンテナとして利用されることもあるからです。

     インスタンスを作成する際 MSG はエラー内容を示す可読データにし
     てください。オプションの EXCEPTION パラメータは `None' も
     しくはパース用コードで補足、渡って来る情報でなければなりません。

     このクラスはSAX 例外の基底クラスになります。

`SAXParseException(msg, exception, locator)'
     パースエラー時に発生する `SAXException' のサブクラスです。
     パースエラーに関する情報として、このクラスのインスタンスが SAX
     `ErrorHandler' インターフェースのメソッドに渡されます。このク
     ラスは `SAXException' 同様 SAX `Locator' インターフェー
     スもサポートしています。

`SAXNotRecognizedException(msg[, exception])'
     SAX `XMLReader' が認識できない機能やプロパティに遭遇したとき発
     生させる `SAXException' のサブクラスです。SAX アプリケーショ
     ンや拡張モジュールにおいて同様の目的にこのクラスを利用することもでき
     ます。

`SAXNotSupportedException(msg[, exception])'
     SAX `XMLReader' が要求された機能をサポートしていないとき発生さ
     せる `SAXException' のサブクラスです。SAX アプリケーション
     や拡張モジュールにおいて同様の目的にこのクラスを利用することもできま
     す。

See also:
     `SAX: The Simple API for XML'{SAX API
     定義に関し中心となっているサイトです。Java に
     よる実装とオンライン・ドキュメントが提供されています。実装 と SAX
     API の歴史に関する情報のリンクも掲載されています。}

     *Note xmlsaxhandler:: アプリケーションが提供するオブジェクトの
     インターフェース定義

     *Note xmlsaxsaxutils:: SAX アプリケーション向けの有用な関数群

     *Note xmlsaxxmlreader:: パーサが提供するオブジェクトのインター
     フェース定義

* Menu:

* SAXException オブジェクト::


File: python-lib-jp.info,  Node: SAXException オブジェクト,  Prev: xmlsax,  Up: xmlsax

8.9.1 SAXException オブジェクト
-------------------------------

`SAXException' 例外クラスは以下のメソッドをサポートしています。

`getMessage()'
     エラー状態を示す可読メッセージを返します。

`getException()'
     カプセル化した例外オブジェクトまたは `None' を返します。


File: python-lib-jp.info,  Node: xmlsaxhandler,  Next: xmlsaxsaxutils,  Prev: xmlsax,  Up: 構造化マークアップツール

8.10 SAX ハンドラの基底クラス
=============================

SAX イベント・ハンドラの基底クラス

_Added in Python version 2.0_

SAX API はコンテント・ハンドラ、DTD ハンドラ、エラー・ハンドラ、エンティ
ティ・リゾルバという4つのハンドラを規定しています。通常アプリケーショ
ン側で実装する必要があるのは、これらのハンドラが発生させるイベントのう
ち、処理したいものへのインターフェースだけです。インターフェースは1つ
のオブジェクトにまとめることも、複数のオブジェクトに分けることも可能で
す。ハンドラはすべてのメソッドがデフォルトで実装されるように、
`xml.sax.handler' で提供される基底クラスを継承しなくてはなりません。

`ContentHandler'
     アプリケーションにとって最も重要なメインの SAX
     コールバック・インター
     フェースです。このインターフェースで発生するイベントの順序はドキュメ
     ント内の情報の順序を反映しています。

`DTDHandler'
     DTD イベントのハンドラです。

     未構文解析エンティティや属性など、パースに必要な DTD イベントの抽出
     だけをおこなうインターフェースです。

`EntityResolver'
     エンティティ解決用の基本インターフェースです。このインターフェースを
     実装したオブジェクトを作成しパーサに登録することで、パーサはすべての
     外部エンティティを解決するメソッドを呼び出すようになります。

`ErrorHandler'
     エラーや警告メッセージをアプリケーションに通知するためにパーサが使用
     するインターフェースです。このオブジェクトのメソッドが、エラーをただ
     ちに例外に変換するか、あるいは別の方法で処理するかの制御をしています。

これらのクラスに加え、`xml.sax.handler' は機能やプロパティ名の
シンボル定数を提供しています。

`feature_namespaces'
     値: `"http://xml.org/sax/features/namespaces"'\ true:
     名前空間の処理を有効にする。\ false:
     オプションで名前空間の処理を無効にする (暗黙に namespace-prefixes
     も無効にする - デフォルト )。\ アクセス: (パース時)
     リードオンリー; (パース時以外) 読み書き可

`feature_namespace_prefixes'
     値: `"http://xml.org/sax/features/namespace-prefixes"'\ true:
     名前空間宣言で用いられているオリジナルのプリフィックス名と属性
     を通知する。\ false: 名前空間宣言で用いられている属性を通知しない。
     オプションでオリジナルのプリフィックス名も通知しない(デフォルト)。\
     アクセス: (パース時) リードオンリー; (パース時以外) 読み書き可

`feature_string_interning'
     値: `"http://xml.org/sax/features/string-interning"'\ true:
     すべての要素名、プリフィックス、属性、名前、名前空間、URI、
     ローカル名を組込みの intern 関数を使ってシンボルに登録する。\
     false: 名前のすべてを必ずしもシンボルに登録しない(デフォルト)。\
     アクセス: (パース時) リードオンリー; (パース時以外) 読み書き可

`feature_validation'
     値: `"http://xml.org/sax/features/validation"'\ true:
     すべての妥当性検査エラーを通知する(external-general-entities
     とexternal-parameter-entities が暗黙の前提になっている)。\ false:
     妥当性検査エラーを通知しない。\ アクセス: (パース時)
     リードオンリー; (パース時以外) 読み書き可

`feature_external_ges'
     値: `"http://xml.org/sax/features/external-general-entities"'\
     true: 外部一般(テキスト)エンティティの取り込みをおこなう。\ false:
     外部一般エンティティを取り込まない。\ アクセス: (パース時)
     リードオンリー; (パース時以外) 読み書き可

`feature_external_pes'
     値: `"http://xml.org/sax/features/external-parameter-entities"'\
     true: 外部 DTD サブセットを含むすべての外部パラメータ・エンティティ
     の取り込みをおこなう。\ false:
     外部パラーメタ・エンティティおよび外部 DTD サブセットを取り込
     まない。\ アクセス: (パース時) リードオンリー; (パース時以外)
     読み書き可

`all_features'
     すべての機能の一覧。

`property_lexical_handler'
     値: `"http://xml.org/sax/properties/lexical-handler"'\ data type:
     xml.sax.sax2lib.LexicalHandler (Python 2 では未サポート)\
     description:
     コメントなど字句解析イベント用のオプション拡張ハンドラ。\
     アクセス: 読み書き可

`property_declaration_handler'
     Value: `"http://xml.org/sax/properties/declaration-handler"'\ data
     type: xml.sax.sax2lib.DeclHandler (Python 2 では未サポート)\
     description: ノーテーションや未解析エンティティをのぞく DTD
     関連イベン ト用のオプション拡張ハンドラ。\ access: read/write

`property_dom_node'
     Value: `"http://xml.org/sax/properties/dom-node"'\ data type:
     org.w3c.dom.Node (Python 2 では未サポート) \ description:
     パース時は DOM イテレータにおけるカレント DOM ノード、
     非パース時はルート DOM ノードを指す。\ アクセス: (パース時)
     リードオンリー; (パース時以外) 読み書き可

`property_xml_string'
     値: `"http://xml.org/sax/properties/xml-string"'\ データ型: 文字列\
     説明: カレント・イベントの元になったリテラル文字列\ アクセス:
     リードオンリー

`all_properties'
     既知のプロパティ名の全リスト。

* Menu:

* ContentHandler オブジェクト::
* DTDHandler オブジェクト::
* EntityResolver オブジェクト::
* ErrorHandler オブジェクト::


File: python-lib-jp.info,  Node: ContentHandler オブジェクト,  Next: DTDHandler オブジェクト,  Prev: xmlsaxhandler,  Up: xmlsaxhandler

8.10.1 ContentHandler オブジェクト
----------------------------------

`ContentHandler' はアプリケーション側でサブクラス化して利用する
ことが前提になっています。パーサは入力ドキュメントのイベントにより、そ
れぞれに対応する以下のメソッドを呼び出します。

`setDocumentLocator(locator)'
     アプリケーションにドキュメント・イベントの発生位置を通知するためにパー
     サから呼び出されます。

     SAX パーサによるロケータの提供は強く推奨されています(必須ではありま
     せん)。もし提供する場合は、DocumentHandler インターフェースのどのメ
     ソッドよりも先にこのメソッドが呼び出されるようにしなければなりません。

     アプリケーションはパーサがエラーを通知しない場合でもロケータによって、
     すべてのドキュメント関連イベントの終了位置を知ることが可能になります。
     典型的な利用方法としては、アプリケーション側でこの情報を使い独自のエ
     ラーを発生させること(文字コンテンツがアプリケーション側で決めた規則
     に沿っていない場合等)があげられます。しかしロケータが返す情報は検索
     エンジンなどで利用するものとしてはおそらく不充分でしょう。

     ロケータが正しい情報を返すのは、インターフェースからイベントの呼出し
     が実行されている間だけです。それ以外のときは使用すべきでありません。

`startDocument()'
     ドキュメントの開始通知を受け取ります。

     SAX パーサはこのインターフェースやDTDHandler のどのメソッド
     (`setDocumentLocator()'を除く)よりも先にこのメソッドを一度だ
     け呼び出します。


`endDocument()'
     ドキュメントの終了通知を受け取ります。

     SAX
     パーサはこのメソッドを一度だけ、パース過程の最後に呼び出します。
     パーサは(回復不能なエラーで)パース処理を中断するか、あるいは入力の
     最後に到達するまでこのメソッドを呼び出しません。

`startPrefixMapping(prefix, uri)'
     プリフィックスと URI の名前空間の関連付けを開始します。

     このイベントから返る情報は通常の名前空間処理では使われません。SAX
     XML リーダは `feature_namespaces' 機能が有効になっている場合(デ
     フォルト)、要素と属性名のプリフィックスを自動的に置換するようになっ
     ています。

     しかしアプリケーション側でプリフィックスを文字データや属性値の中で扱
     う必要が生じることもあります。この場合プリフィックスの自動展開は保証
     されないため、必要に応じ `startPrefixMapping()' や
     `endPrefixMapping()' イベントからアプリケーションに提供される
     情報を用いてプリフィックスの展開をおこないます。

     `startPrefixMapping()' と `endPrefixMapping()' イベン
     トは相互に正しい入れ子関係になることが保証されていないので注意が必要
     です。すべての `startPrefixMapping()' は対応する `startElement()'
     の前に発生し、`endPrefixMapping()' イ ベントは対応する
     `endElement()' の後で発生しますが、その順序 は保証されていません。

`endPrefixMapping(prefix)'
     プリフィックスと URI の名前空間の関連付けを終了します。

     詳しくは `startPrefixMapping()' を参照してください。このイベ
     ントは常に対応する `endElement()' の後で発生しますが、複数の
     `endPrefixMapping()' イベントの順序は特に保証されません。

`startElement(name, attrs)'
     非名前空間モードで要素の開始を通知します。

     NAME パラーメータには要素型の raw XML 1.0名を文字列として、 ATTRS
     パラメータには要素の属性を保持する `Attributes' インターフェース
     オブジェクトをそれぞれ指定します。ATTRS として渡されたオブジェ
     クトはパーサで再利用することも可能ですが、属性のコピーを保持するた
     めにこれを参照し続けるのは確実な方法ではありません。属性のコピーを保
     持したいときは ATTRS オブジェクトの `copy()' メソッドを
     用いてください。

`endElement(name)'
     非名前空間モードで要素の終了を通知します。

     NAME パラメータには `startElement()' イベント同様の要素
     型名を指定します。

`startElementNS(name, qname, attrs)'
     名前空間モードで要素の開始を通知します。

     NAME パラーメータには要素型を `(URI, LOCALNAME)'
     のタプルとして、QNAME パラメータにはソース・
     ドキュメントで用いられている raw XML 1.0名、ATTRS には要素の属
     性を保持する `AttributesNS' インターフェース
     のインスタンスをそれぞれ指定します。要
     素に関連付けられた名前空間がないときは、NAME コンポーネントの URI
     が `None' になります。ATTRS として渡されたオブジェ
     クトはパーサで再利用することも可能ですが、属性のコピーを保持するた
     めにこれを参照し続けるのは確実な方法ではありません。属性のコピーを保
     持したいときは ATTRS オブジェクトの `copy()' メソッドを
     用いてください。

     `feature_namespace_prefixes' 機能が有効になっていなければ、パー
     サで QNAME を `None' にセットすることも可能です。

`endElementNS(name, qname)'
     非名前空間モードで要素の終了を通知します。

     NAME パラメータには `startElementNS()' イベント同様の要素
     型を指定します。QNAME パラメータも同じです。

`characters(content)'
     文字データの通知を受け取ります。

     パーサは文字データのチャンクごとにこのメソッドを呼び出して通知します。
     SAX
     パーサは一連の文字データを単一のチャンクとして返す場合と複数のチャ
     ンクに分けて返す場合がありますが、ロケータの情報が正しく保たれるよう
     に、一つのイベントの文字データは常に同じ外部エンティティのものでなけ
     ればなりません。

     CONTENT はユニコード文字列、バイト文字列のどちらでもかまいませ
     んが、`expat' リーダ・モジュールは常にユニコード文字列を生成す
     るようになっています。

     _Note:_ Python XML SIG が提供していた初期 SAX 1
     では、このメソッドにもっ と JAVA
     風のインターフェースが用いられています。しかし Python で採用
     されている大半のパーサでは古いインターフェースを有効に使うことができ
     ないため、よりシンプルなものに変更されました。古いコードを新しいイン
     ターフェースに変更するには、古い OFFSET と LENGTH パラメー
     タでスライスせずに、CONTENT を指定するようにしてください。

`ignorableWhitespace(whitespace)'
     要素コンテンツに含まれる無視可能な空白文字の通知を受け取ります。

     妥当性検査をおこなうパーサは無視可能な空白文字(W3C XML 1.0 勧告のセ
     クション 2.10 参照)のチャンクごとに、このメソッドを使って通知しなけ
     ればなりません。妥当性検査をしないパーサもコンテンツモデルの利用とパー
     スが可能な場合、このメソッドを利用することが可能です。

     SAX
     パーサは一連の空白文字を単一のチャンクとして返す場合と複数のチャ
     ンクに分けて返す場合がありますが、ロケータの情報が正しく保たれるよう
     に、一つのイベントの文字データは常に同じ外部エンティティのものでなけ
     ればなりません。

`processingInstruction(target, data)'
     処理命令の通知を受け取ります。

     パーサは処理命令が見つかるたびにこのメソッドを呼び出します。処理命令
     はメインのドキュメント要素の前や後にも発生することがあるので注意して
     ください。

     SAX パーサがこのメソッドを使って XML 宣言(XML 1.0 のセクション
     2.8)や テキスト宣言(XML 1.0 のセクション
     4.3.1)の通知をすることはありません。

`skippedEntity(name)'
     スキップしたエンティティの通知を受け取ります。

     パーサはエンティティをスキップするたびにこのメソッドを呼び出します。
     妥当性検査をしないプロセッサは(外部 DTD
     サブセットで宣言されているな
     どの理由で)宣言が見当たらないエンティティをスキップします。すべての
     プロセッサは `feature_external_ges' および `feature_external_pes'
     属性の値によっては外部エンティティをスキッ プすることがあります。


File: python-lib-jp.info,  Node: DTDHandler オブジェクト,  Next: EntityResolver オブジェクト,  Prev: ContentHandler オブジェクト,  Up: xmlsaxhandler

8.10.2 DTDHandler オブジェクト
------------------------------

`DTDHandler' インスタンスは以下のメソッドを提供します。

`notationDecl(name, publicId, systemId)'
     表記法宣言イベントの通知を捕捉します。

`unparsedEntityDecl(name, publicId, systemId, ndata)'
     未構文解析エンティティ宣言イベントの通知を受け取ります Handle an
     unparsed entity declaration event.


File: python-lib-jp.info,  Node: EntityResolver オブジェクト,  Next: ErrorHandler オブジェクト,  Prev: DTDHandler オブジェクト,  Up: xmlsaxhandler

8.10.3 EntityResolver オブジェクト
----------------------------------

`resolveEntity(publicId, systemId)'
     エンティティのシステム識別子を解決し、文字列として読み込んだシステム
     識別子あるいは InputSource オブジェクトのいずれかを返します。デフォ
     ルトの実装では SYSTEMID を返します。


File: python-lib-jp.info,  Node: ErrorHandler オブジェクト,  Prev: EntityResolver オブジェクト,  Up: xmlsaxhandler

8.10.4 ErrorHandler オブジェクト
--------------------------------

このインターフェースのオブジェクトは `XMLReader' からのエラーや
警告の情報を受け取るために使われます。このインターフェースを実装したオ
ブジェクトを作成し `XMLReader' に登録すると、パーサは警告やエラー
の通知のためにそのオブジェクトのメソッドを呼び出すようになります。エラー
には警告、回復可能エラー、回復不能エラーの3段階があります。すべてのメ
ソッドは `SAXParseException' だけをパラメータとして受け取り
ます。受け取った例外オブジェクトを raise することで、エラーや警告は例
外に変換されることもあります。

`error(exception)'
     パーサが回復可能なエラーを検知すると呼び出されます。このメソッドが例
     外を raise しないとパースは継続されますが、アプリケーション側では
     エラー以降のドキュメント情報を期待していないこともあります。パー
     サが処理を継続した場合、入力ドキュメント内のほかのエラーを見つけるこ
     とができます。

`fatalError(exception)'
     パーサが回復不能なエラーを検知すると呼び出されます。このメソッドが
     return した後、すぐにパースを停止することが求められています。

`warning(exception)'
     パーサが軽微な警告情報をアプリケーションに通知するために呼び出されま
     す。このメソッドが return
     した後もパースを継続し、ドキュメント情報を
     アプリケーションに送り続けるよう求められています。このメソッドで例外
     を発生させた場合、パースは中断されてしまいます。


File: python-lib-jp.info,  Node: xmlsaxsaxutils,  Next: xmlsaxxmlreader,  Prev: xmlsaxhandler,  Up: 構造化マークアップツール

8.11 SAX ユーティリティ
=======================

SAX とともに使う有用な関数とクラスです。

_Added in Python version 2.0_

モジュール `xml.sax.saxutils' には SAX アプリケーションの作成に
役立つ多くの関数やクラスも含まれており、直接利用したり、基底クラスとし
て使うことができます。

`escape(data[, entities])'
     文字列データ内の `&'、`<'、`>' をエス ケープします。

     オプションの ENTITIES パラメータに辞書を渡すことで、そのほ
     かの文字をエスケープさせることも可能です。辞書のキーと値はすべて文字列
     で、キーに指定された文字は対応する値に置換されます。

`unescape(data[, entities])'
     エスケープされた文字列 `&amp;'、`&lt;'、 `&gt;'
     を元の文字に戻します。

     オプションの ENTITIES パラメータに辞書を渡すことで、そのほ
     かの文字をエスケープさせることも可能です。辞書のキーと値はすべて文字列
     で、キーに指定された文字は対応する値に置換されます。 _Added in
     Python version 2.3_

`quoteattr(data[, entities])'
     `escape()' に似ていますが、DATA は属性値の作成に使わ
     れます。戻り値はクォート済みの DATA で、置換する文字の追加も可
     能です。`quoteattr()' はクォートすべき文字を DATA の
     文脈から判断し、クォートすべき文字を残さないように文字列をエンコード
     します。

     DATA の中にシングル・クォート、ダブル・クォートがあれば、両方
     ともエンコードし、全体をダブルクォートで囲みます。戻り値の文字列はその
     ままで属性値として利用できます。:

          >>> print "<element attr=%s>" % quoteattr("ab ' cd \" ef")
          <element attr="ab ' cd &quot; ef">

     この関数は参照具象構文を使って、 HTML や SGML
     の属性値を生成するのに 便利です。 _Added in Python version 2.2_

`XMLGenerator([out[, encoding]])'
     このクラスは `ContentHandler' インターフェースの実装で、SAX イ
     ベントを XML ドキュメントに書き戻します。つまり、 `XMLGenerator'
     をコンテント・ハンドラとして用いると、パースし
     たオリジナル・ドキュメントの複製が作れるのです。OUT に指定する
     のはファイル風のオブジェクトで、デフォルトは SYS.STDOUT です。
     ENCODING は出力ストリームのエンコーディングで、デフォルトは
     `'iso-8859-1'' です。

`XMLFilterBase(base)'
     このクラスは `XMLReader' とクライアント・アプリケーションのイ
     ベント・ハンドラとの間に位置するものとして設計されています。デフォル
     トでは何もせず、ただリクエストをリーダに、イベントをハンドラに、それ
     ぞれ加工せず渡すだけです。しかし、サブクラスでメソッドをオーバーライ
     ドすると、イベント・ストリームやリクエストを加工してから渡すように変
     更可能です。

`prepare_input_source(source[, base])'
     この関数は引き数に入力ソース、オプションとして URL を取り、読み取り
     可能な解決済み `InputSource' オブジェクトを返します。入力ソー
     スは文字列、ファイル風オブジェクト、`InputSource' のいずれでも
     良く、この関数を使うことで、パーサは様々な SOURCE パラメータを
     `parse()' に渡すことが可能になります。


File: python-lib-jp.info,  Node: xmlsaxxmlreader,  Next: xmletreeElementTree,  Prev: xmlsaxsaxutils,  Up: 構造化マークアップツール

8.12 XML パーサのインターフェース
=================================

SAX 準拠の XML パーサが実装すべきインターフェースです。

_Added in Python version 2.0_

各 SAX パーサは Python モジュールとして `XMLReader' インターフェー
スを実装しており、関数 `create_parser()' を提供しています。こ
の関数は新たなパーサ・オブジェクトを生成する際、
`xml.sax.make_parser()' から引き数なしで呼び出されます。

`XMLReader()'
     SAX パーサが継承可能な基底クラスです。

`IncrementalParser()'
     入力ソースをパースする際、すべてを一気に処理しないで、途中でドキュメ
     ントのチャンクを取得したいことがあります。SAX
     リーダは通常、ファイル
     全体を一気に読み込まずチャンク単位で処理するのですが、全体の処理が終
     わるまで `parse()' は return しません。つまり、 IncrementalParser
     インターフェースは `parse()' にこのような排
     他的挙動を望まないときに使われます。

     パーサのインスタンスが作成されると、feed
     メソッドを通じてすぐに、デー
     タを受け入れられるようになります。close
     メソッドの呼出しでパースが終
     わると、パーサは新しいデータを受け入れられるように、reset
     メソッドを 呼び出されなければなりません。

     これらのメソッドをパース処理の途中で呼び出すことはできません。つまり、
     パースが実行された後で、パーサから return
     する前に呼び出す必要がある のです。

     なお、SAX 2.0 ドライバを書く人のために、XMLReader
     インターフェースの parse メソッドがデフォルトで、IncrementalParser
     の feed、close、 reset メソッドを使って実装されています。


`Locator()'
     SAX イベントとドキュメントの位置を関連付けるインターフェースです。
     locator オブジェクトは DocumentHandler メソッドを呼び出している間
     だけ正しい情報を返し、それ以外とのときに呼び出すと、予測できない結果
     が返ります。情報を取得できない場合、メソッドは `None' を返すこ
     ともあります。


`InputSource([systemId])'
     `XMLReader' がエンティティを読み込むために必要な情報をカプセ
     ル化します。

     このクラスには公開識別子、システム識別子、(場合によっては文字エンコー
     ディング情報を含む)バイト・ストリーム、そしてエンティティの文字スト
     リームなどの情報が含まれます。

     アプリケーションは `XMLReader.parse()' メソッドに渡す引き数、
     または EntityResolver.resolveEntity
     の戻り値としてこのオブジェトを作 成します。

     `InputSource' はアプリケーション側に属します。 `XMLReader'
     はアプリケーションから渡された `InputSource'
     オブジェクトの変更を許していませんが、コピーを作り、それを変更するこ
     とは可能です。

`AttributesImpl(attrs)'
     `Attributes' interface (~*Note Attributes インターフェース::
     参照)の実装です。辞書風のオブジェクトで、 `startElement()'
     内で要素の属性表示をおこないます。多くの辞書
     風オブジェクト操作に加え、ほかにもインターフェースに記述されているメ
     ソッドを、多数サポートしています。このクラスのオブジェクトはリーダ
     によってインスタンスを作成しなければなりません。また、ATTRS は
     属性名と属性値を含む辞書風オブジェクトでなければなりません。

`AttributesNSImpl(attrs, qnames)'
     `AttributesImpl' を名前空間認識型に改良したクラスで、
     `startElementNS()' に渡されます。`AttributesImpl' の派
     生クラスですが、NAMESPACEURI と LOCALNAME、この2つのタプ
     ルを解釈します。さらに、元のドキュメントに出てくる修飾名を返す多くの
     メソッドを提供します。このクラスは `AttributesNS' interface (
     section~*Note xmletreeElementTree:: 参照) の実装です。

* Menu:

* XMLReader オブジェクト::
* IncrementalParser オブジェクト::
* Locator オブジェクト::
* InputSource オブジェクト::
* Attributes インターフェース::
* AttributesNS インターフェース::


File: python-lib-jp.info,  Node: XMLReader オブジェクト,  Next: IncrementalParser オブジェクト,  Prev: xmlsaxxmlreader,  Up: xmlsaxxmlreader

8.12.1 XMLReader オブジェクト
-----------------------------

`XMLReader' は次のメソッドをサポートします。:

`parse(source)'
     入力ソースを処理し、SAX イベントを発生させます。SOURCE オブジェ
     クトにはシステム識別子(入力ソースを特定する文字列 - 一般にファイル
     名やURL)、ファイル風オブジェクト、または `InputSource' オブジェ
     クトを指定できます。`parse()' から return された段階で、入力
     データの処理は完了、パーサ・オブジェクトは破棄ないしリセットされます。
     なお、現在の実装はバイト・ストリームのみをサポートしており、文字スト
     リームの処理は将来の課題になっています。

`getContentHandler()'
     現在の `ContentHandler' を返します。

`setContentHandler(handler)'
     現在の `ContentHandler' をセットします。`ContentHandler'
     がセットされていない場合、コンテント・イベントは破棄されます。

`getDTDHandler()'
     現在の `DTDHandler' を返します。

`setDTDHandler(handler)'
     現在の `DTDHandler' をセットします。`DTDHandler' がセッ
     トされていない場合、DTD イベントは破棄されます。

`getEntityResolver()'
     現在の `EntityResolver' を返します。

`setEntityResolver(handler)'
     現在の `EntityResolver' をセットします。`EntityResolver'
     がセットされていない場合、外部エンティティとして解決されるべきものが、
     システム識別子として解釈されてしまうため、該当するものがなければ結果
     的にエラーとなります。

`getErrorHandler()'
     現在の `ErrorHandler' を返します。

`setErrorHandler(handler)'
     現在のエラー・ハンドラをセットします。`ErrorHandler' がセット
     されていない場合、エラーは例外を発生し、警告が表示されます。

`setLocale(locale)'
     アプリケーションにエラーや警告のロカール設定を許可します。

     SAX
     パーサにとって、エラーや警告の地域化は必須ではありません。しかし、
     パーサは要求されたロカールをサポートしていない場合、SAX
     例外を発生さ
     せなければなりません。アプリケーションはパースの途中でロカールを変更
     することもできます。

`getFeature(featurename)'
     機能 FEATURENAME の現在の設定を返します。その機能が認識できな
     いときは、`SAXNotRecognizedException' を発生させます。広く
     使われている機能名の一覧はモジュール `xml.sax.handler' に書か
     れています。

`setFeature(featurename, value)'
     機能名 FEATURENAME に値 VALUE をセットします。その機能が
     認識できないときは、`SAXNotRecognizedException' を発生させ
     ます。また、パーサが指定された機能や設定をサポートしていないとき
     は、SAXNOTSUPPORTEDEXCEPTION を発生させます。

`getProperty(propertyname)'
     属性名 PROPERTYNAME の現在の値を返します。その属性が認識でき
     ないときは、 `SAXNotRecognizedException' を発生させます。
     広く使われている属性名の一覧はモジュール `xml.sax.handler' に
     書かれています。

`setProperty(propertyname, value)'
     属性名 PROPERTYNAME に値 VALUE をセットします。その機能
     が認識できないときは、`SAXNotRecognizedException' を発生さ
     せます。また、パーサが指定された機能や設定をサポートしていないときは、
     SAXNOTSUPPORTEDEXCEPTION is raised を発生させます。


File: python-lib-jp.info,  Node: IncrementalParser オブジェクト,  Next: Locator オブジェクト,  Prev: XMLReader オブジェクト,  Up: xmlsaxxmlreader

8.12.2 IncrementalParser オブジェクト
-------------------------------------

`IncrementalParser' のインスタンスは次の追加メソッドを提供します。:

`feed(data)'
     DATA のチャンクを処理します。

`close()'
     ドキュメントの終わりを決定します。終わりに達した時点でドキュメントが
     整形式であるかどうかを判別、ハンドラを起動後、パース時に使用した資源
     を解放します。

`reset()'
     このメソッドは close が呼び出された後、次のドキュメントをパース可能
     にするため、パーサのリセットするのに呼び出されます。close 後、reset
     を呼び出さずに parse や feed を呼び出した場合の戻り値は未定義です。


File: python-lib-jp.info,  Node: Locator オブジェクト,  Next: InputSource オブジェクト,  Prev: IncrementalParser オブジェクト,  Up: xmlsaxxmlreader

8.12.3 Locator オブジェクト
---------------------------

`Locator' のインスタンスは次のメソッドを提供します。:

`getColumnNumber()'
     現在のイベントが終了する列番号を返します。

`getLineNumber()'
     現在のイベントが終了する行番号を返します。

`getPublicId()'

現在の文書イベントの公開識別子を返します。

`getSystemId()'
     現在のイベントのシステム識別子を返します。


File: python-lib-jp.info,  Node: InputSource オブジェクト,  Next: Attributes インターフェース,  Prev: Locator オブジェクト,  Up: xmlsaxxmlreader

8.12.4 InputSource オブジェクト
-------------------------------

`setPublicId(id)'
     この `InputSource' の公開識別子をセットします。

`getPublicId()'
     この `InputSource' の公開識別子を返します。

`setSystemId(id)'
     この `InputSource' のシステム識別子をセットします。

`getSystemId()'
     この `InputSource' のシステム識別子を返します。

`setEncoding(encoding)'
     この `InputSource' の文字エンコーディングをセットします。

     指定するエンコーディングは XML エンコーディング宣言として定義された
     文字列でなければなりません(セクション 4.3.3 の XML 勧告を参照)。

     `InputSource' のエンコーディング属性は、`InputSource' が
     たとえ文字ストリームを含んでいたとしても、無視されます。

`getEncoding()'
     この `InputSource' の文字エンコーディングを取得します。

`setByteStream(bytefile)'
     この入力ソースのバイトストリーム(Python
     のファイル風オブジェクトです
     が、バイト列と文字の相互変換はサポートしません)を設定します。

     なお、文字ストリームが指定されてもSAX
     パーサは無視し、バイト・ストリー ムを使って指定された URI
     に接続しようとします。

     アプリケーション側でバイト・ストリームの文字エンコーディングを知って
     いる場合は、setEncoding メソッドを使って指定する必要があります。

`getByteStream()'
     この入力ソースのバイトストリームを取得します。

     getEncoding
     メソッドは、このバイト・ストリームの文字エンコーディング
     を返します。認識できないときは None を返します。

`setCharacterStream(charfile)'
     この入力ソースの文字ストリームをセットします(ストリームは Python
     1.6 の Unicode-wrapped
     なファイル風オブジェクトで、ユニコード文字列への
     変換をサポートしていなければなりません)。

     なお、文字ストリームが指定されても SAX パーサは無視、システム識別子
     とみなし、バイト・ストリームを使って URI に接続しようとします。

`getCharacterStream()'
     この入力ソースの文字ストリームを取得します。


File: python-lib-jp.info,  Node: Attributes インターフェース,  Next: AttributesNS インターフェース,  Prev: InputSource オブジェクト,  Up: xmlsaxxmlreader

8.12.5 The `Attributes' インターフェース
----------------------------------------

`Attributes' オブジェクトは `copy()'、`get()'、
`has_key()'、`items()'、 `keys()'、 `values()'
などを含む、マッピング・プロトコルの一部を実装したも
のです。さらに次のメソッドも提供されています。:

`getLength()'
     属性の数を返す。

`getNames()'
     属性の名前を返す。

`getType(name)'
     属性名 NAME のタイプを返す。通常は `'CDATA''。

`getValue(name)'
     属性 NAME の値を返す。


File: python-lib-jp.info,  Node: AttributesNS インターフェース,  Prev: Attributes インターフェース,  Up: xmlsaxxmlreader

8.12.6 `AttributesNS' インターフェース
--------------------------------------

このインターフェースは `Attributes' interface (セクション~*Note
Attributes インターフェース::参照) のサブタイプです。 Attributes
インターフェー スがサポートしているすべてのメソッドは `AttributesNS'
オブジェク トでも利用可能です。

そのほか、次のメソッドがサポートされています。:

`getValueByQName(name)'
     修飾名の値を返す。

`getNameByQName(name)'
     修飾名 NAME に対応する `(NAMESPACE, LOCALNAME)' のペアを返す。

`getQNameByName(name)'
     `(NAMESPACE, LOCALNAME)' のペアに対応する修飾名を返す。

`getQNames()'
     すべての属性の修飾名を返す。


File: python-lib-jp.info,  Node: xmletreeElementTree,  Prev: xmlsaxxmlreader,  Up: 構造化マークアップツール

8.13 ElementTree XML API
========================

Implementation of the ElementTree API.

_Added in Python version 2.5_

エレメント型は柔軟性のあるコンテナオブジェクトで、階層的データ構造をメモ
リーに格納するようにデザインされています。この型は言わばリストと辞書の
間の子のようなものです。

各エレメントは関連する多くのプロパティを具えています:

   * このエレメントがどういう種類のデータを表現しているかを同定する
     文字列であるタグ(別の言い方をすればエレメントの型)

   * 幾つもの属性(Python 辞書に収められます)

   * テキスト文字列

   * オプションの末尾文字列

   * 幾つもの子エレメント(Python シーケンスに収められます)

エレメントのインスタンスを作るには、Element や SubElement
といったファクトリー 関数を使います。

`ElementTree' クラスはエレメントの構造を包み込み、それと XML を行き来す
るのに使えます。

この API の C 実装である `xml.etree.cElementTree' も使用可能です。

* Menu:

* 関数 2::
* ElementTree オブジェクト::
* QName オブジェクト::
* TreeBuilder オブジェクト::
* XMLTreeBuilder オブジェクト::


File: python-lib-jp.info,  Node: 関数 2,  Next: ElementTree オブジェクト,  Prev: xmletreeElementTree,  Up: xmletreeElementTree

8.13.1 関数
-----------

`Comment([text])'
     コメント・エレメントのファクトリーです。このファクトリー関数は XML
     コメントにシリアライズ される特別な要素を作ります。
     コメント文字列は、8-bit ASCII 文字列でも Unicode
     文字列でも構いません。 TEXT
     はそのコメント文字列を含んだ文字列です。

    `戻り値:'
          コメントを表わすエレメントのインスタンス。


`dump(elem)'
     エレメントの木もしくはエレメントの構造を sys.stdout
     に書き込みます。この関数は デバグ目的でだけ使用してください。

     出力される形式の正確なところは実装依存です。このバージョンでは、
     通常の XML ファイルとして書き込まれます。

     ELEM はエレメントの木もしくは個別のエレメントです。

`Element(tag[, attrib][, **extra])'
     エレメントのファクトリー。この関数は標準エレメント・インタフェースを実装した
     オブジェクトを返します。このオブジェクトのクラスや型が正確に何であるかは
     実装に依存しますが、いつでもこのモジュールにある
     {_}ElementInterface クラスと 互換性があります。

     エレメント名、アトリビュート名およびアトリビュート値は8-bit ASCII
     文字列でも Unicode 文字列でも構いません。 TAG はエレメント名です。
     ATTRIB
     はオプションの辞書で、エレメントのアトリビュートを含んでいます。
     EXTRA
     は追加のアトリビュートで、キーワード引数として与えられたものです。

    `戻り値:'
          エレメント・インスタンス。


`fromstring(text)'
     文字列定数で与えられた XML 断片を構文解析します。XML
     関数と同じです。 TEXT は XML データを含んだ文字列です。

    `戻り値:'
          エレメント・インスタンス。


`iselement(element)'
     オブジェクトが正当なエレメント・オブジェクトであるかをチェックします。
     ELEMENT はエレメント・インスタンスです。

    `戻り値:'
          引数がエレメント・オブジェクトならば真値。


`iterparse(source[, events])'
     XML 断片を構文解析してエレメントの木を漸増的に作っていき、その間
     進行状況をユーザーに報告します。 SOURCE は XML
     データを含むファイル名またはファイル風オブジェクト。 EVENTS
     は報告すべきイベントのリスト。省略された場合は "end"
     イベントだけが報告されます。

    `戻り値:'
          (イベント, エレメント) イテレータ。


`parse(source[, parser])'
     XML 断片を構文解析してエレメントの木にしていきます。 SOURCE は XML
     データを含むファイル名またはファイル風オブジェクト。 PARSER
     はオプションの構文解析器インスタンスです。これが与えられない場合、
     標準の XMLTreeBuilder 構文解析器が使われます。

    `戻り値:'
          ElementTree インスタンス。


`ProcessingInstruction(target[, text])'
     PI エレメントのファクトリー。このファクトリー関数は XML の
     処理命令(processing instruction)
     としてシリアライズされる特別なエレメントを作ります。 TARGET は PI
     ターゲットを含んだ文字列です。 TEXT は与えられるならば PI
     コンテンツを含んだ文字列です。

    `戻り値:'
          PI を表わすエレメント・インスタンス。


`SubElement(parent, tag[, attrib] [, **extra])'
     部分エレメントのファクトリー。この関数はエレメント・インスタンスを作り、それを
     既存のエレメントに追加します。

     エレメント名、アトリビュート名およびアトリビュート値は8-bit ASCII
     文字列でも Unicode 文字列でも構いません。 PARENT
     は親エレメントです。 TAG はエレメント名です。 ATTRIB
     はオプションの辞書で、エレメントのアトリビュートを含んでいます。
     EXTRA
     は追加のアトリビュートで、キーワード引数として与えられたものです。

    `戻り値:'
          エレメント・インスタンス。


`tostring(element[, encoding])'
     XML
     エレメントを全ての子エレメントを含めて表現する文字列を生成します。
     ELEMENT はエレメント・インスタンス。 ENCODING
     は出力エンコーディング(デフォルトは US-ASCII)です。

    `戻り値:'
          XML データを含んだエンコードされた文字列。


`XML(text)'
     文字列定数で与えられた XML 断片を構文解析します。この関数は Python
     コードに 「XML リテラル」を埋め込むのに使えます。 TEXT は XML
     データを含んだ文字列です。

    `戻り値:'
          エレメント・インスタンス。


`XMLID(text)'
     文字列定数で与えられた XML 断片を構文解析し、エレメント ID
     からエレメント へのマッピングを与える辞書も同時に返します。 TEXT
     は XML データを含んだ文字列です。

    `戻り値:'
          エレメント・インスタンスと辞書のタプル。



File: python-lib-jp.info,  Node: ElementTree オブジェクト,  Next: QName オブジェクト,  Prev: 関数 2,  Up: xmletreeElementTree

8.13.2 ElementTree オブジェクト
-------------------------------

`ElementTree([element,] [file])'
     ElementTree
     ラッパー・クラス。このクラスはエレメントの全階層を表現し、
     さらに標準 XML との相互変換を追加しています。

     ELEMENT は根エレメントです。 木はもし FILE が与えられればその XML
     の内容により初期化されます。

`_setroot(element)'
     この木の根エレメントを置き換えます。したがって現在の木の内容は破棄され、
     与えられたエレメントが代わりに使われます。注意して使ってください。
     ELEMENT はエレメント・インスタンスです。

`find(path)'
     子孫エレメントの中で与えられたタグを持つ最初のものを見つけます。
     getroot().find(path) と同じです。 PATH は探したいエレメントです。

    `戻り値:'
          最初に条件に合ったエレメント、または見つからない時は None。


`findall(path)'
     子孫エレメントの中で与えられたタグを持つものを全て見つけます。
     getroot().findall(path) と同じです。 PATH
     は探したいエレメントです。

    `戻り値:'
          全ての条件に合ったエレメントのリストまたはイテレータで、セクション順です。


`findtext(path[, default])'
     子孫エレメントの中で与えられたタグを持つ最初のもののテキストを見つけます。
     getroot().findtext(path) と同じです。 PATH
     は探したい直接の子エレメントです。 DEFAULT
     はエレメントが見つからなかった場合に返される値です。

    `戻り値:'
          条件に合った最初のエレメントのテキスト、または見つからなかった場合にはデフォルト値。
          もしエレメントが見つかったもののテキストがなかった場合には、このメソッドは空文字列を返す、
          ということに気をつけてください。


`getiterator([tag])'
     根エレメントに対する木を巡るイテレータを作ります。イテレータは木の全てのエレメントに
     渡ってセクション順にループします。 TAG
     は探したいタグです(デフォルトでは全てのエレメントを返します)。

    `戻り値:'
          イテレータ。


`getroot()'
     この木の根エレメントを返します。

    `戻り値:'
          エレメント・インスタンス。


`parse(source[, parser])'
     外部の XML 断片をこのエレメントの木に読み込みます。 SOURCE は XML
     データを含むファイル名またはファイル風オブジェクト。 PARSER
     はオプションの構文解析器インスタンスです。これが与えられない場合、
     標準の XMLTreeBuilder 構文解析器が使われます。

    `戻り値:'
          断片の根エレメント。


`write(file[, encoding])'
     エレメントの木をファイルに XML として書き込みます。 FILE
     はファイル名またはファイル風オブジェクトで書き込み用に開かれたもの。
     ENCODING は出力エンコーディング(デフォルトは US-ASCII)です。


File: python-lib-jp.info,  Node: QName オブジェクト,  Next: TreeBuilder オブジェクト,  Prev: ElementTree オブジェクト,  Up: xmletreeElementTree

8.13.3 QName オブジェクト
-------------------------

`QName(text_or_uri[, tag])'
     QName ラッパー。このクラスは QName
     アトリビュート値をラップし、出力時に
     真っ当な名前空間の扱いを得るために使われます。 TEXT_OR_URI は
     {uri}local という形式の QName 値を含む文字列、 または tag
     引数が与えられた場合には QName の URI 部分の文字列です。 TAG
     が与えられた場合、一つめの引数は URI と解釈され、この引数は
     ローカル名と解釈されます。

    `戻り値:'
          QName を表わす不透明オブジェクト。



File: python-lib-jp.info,  Node: TreeBuilder オブジェクト,  Next: XMLTreeBuilder オブジェクト,  Prev: QName オブジェクト,  Up: xmletreeElementTree

8.13.4 TreeBuilder オブジェクト
-------------------------------

`TreeBuilder([element_factory])'
     汎用のエレメント構造ビルダー。 これは start、data、end
     のメソッド呼び出しの
     列を整形式のエレメント構造に変換します。このクラスを使うと、
     好みの XML 構文解析器、または他の XML
     に似た形式の構文解析器を使って、
     エレメント構造を作り出すことができます。 ELEMENT_FACTORY
     が与えられた場合には新しいエレメント・インスタンスを
     作る際にこれを呼び出します。

`close()'
     構文解析器のバッファをフラッシュし、最上位の文書エレメントを返します。

    `戻り値:'
          エレメント・インスタンス。


`data(data)'
     現在のエレメントにテキストを追加します。 DATA は文字列です。8-bit
     ASCII 文字列もしくは Unicode 文字列でなければなりません。

`end(tag)'
     現在のエレメントを閉じます。 TAG はエレメントの名前です。

    `戻り値:'
          閉じられたエレメント。


`start(tag, attrs)'
     新しいエレメントを開きます。 TAG はエレメントの名前です。 ATTRS
     はエレメントのアトリビュートを保持した辞書です。

    `戻り値:'
          開かれたエレメント。



File: python-lib-jp.info,  Node: XMLTreeBuilder オブジェクト,  Prev: TreeBuilder オブジェクト,  Up: xmletreeElementTree

8.13.5 XMLTreeBuilder オブジェクト
----------------------------------

`XMLTreeBuilder([html,] [target])'
     XML ソースからエレメント構造を作るもので、expat
     構文解析器に基づいています。 HTML は前もって定義された HTML
     エンティティです。このオプションは
     現在の実装ではサポートされていません。 TARGET
     はターゲットとなるオブジェクトです。省略された場合、標準の
     TreeBuilder クラスのインスタンスが使われます。

`close()'
     構文解析器にデータを供給するのを終わりにします。

    `戻り値:'
          エレメント構造。


`doctype(name, pubid, system)'
     doctype 宣言を扱います。 NAME は doctype の名前です。 PUBID
     は公開識別子です。 SYSTEM はシステム識別子です。

`feed(data)'
     構文解析器にデータを供給します。

     DATA はエンコードされたデータです。


File: python-lib-jp.info,  Node: File Formats,  Next: 暗号関連のサービス,  Prev: 構造化マークアップツール,  Up: Top

9 File Formats
**************

The modules described in this chapter parse various miscellaneous file
formats that aren't markup languages or are related to e-mail.

この章で説明されるモジュールは様々な(マークアップやでないものやEメール
の)ファイルフォーマットを構文解析します。

* Menu:

* csv::
* ConfigParser::
* robotparser::
* netrc::
* xdrlib::


File: python-lib-jp.info,  Node: csv,  Next: ConfigParser,  Prev: File Formats,  Up: File Formats

9.1 CSV ファイルの読み書き
==========================

デリミタで区切られた形式のファイルに対するテーブル状データ読み書き。

_Added in Python version 2.3_ 

CSV (Comma Separated Values、カンマ区切り値列) と呼ばれる形式は、
スプレッドシートやデータベース間でのデータのインポートやエクスポート
における最も一般的な形式です。"CSV 標準" は存在しないため、 CSV
形式はデータを読み書きする多くのアプリケーション上の操作に応じて
定義されているにすぎません。標準がないということは、異なるアプリケーション
によって生成されたり取り込まれたりするデータ間では、しばしば微妙な
違いが発生するということを意味します。こうした違いのために、複数の
データ源から得られた CSV ファイルを処理する作業が鬱陶しいものになる
ことがあります。とはいえ、デリミタ (delimiter) やクオート文字の
相違はあっても、全体的な形式は十分似通っているため、こうしたデータを
効率的に操作し、データの読み書きにおける細々としたことをプログラマ
から隠蔽するような単一のモジュールを書くことは可能です。

`csv' モジュールでは、CSV 形式で書かれたテーブル状の
データを読み書きするためのクラスを実装しています。
このモジュールを使うことで、プログラマは Excel で使われている CSV
形式に関して詳しい知識をもっていなくても、 "このデータを Excel で
推奨されている形式で書いてください" とか、 "データを Excel で
作成されたこのファイルから読み出してください" と言うことができます。
プログラマはまた、他のアプリケーションが解釈できる CSV
形式を記述したり、 独自の特殊な目的をもった CSV
形式を定義することができます。

`csv' モジュールの `reader' および `writer'
オブジェクトはシーケンス型を読み書きします。プログラマは `DictReader'
や `DictWriter' クラスを使うことで、
データを辞書形式で読み書きすることもできます。

_Notice:_ このバージョンの `csv' モジュールは Unicode 入力をサポート
していません。また、現在のところ、 ASCII NUL 文字に関連したいくつかの
問題があります。従って、安全を期すには、全ての入力を UTF-8
または印字可能な ASCII にしなければなりません。これについては*Note
ConfigParser::節の
例を参照してください。これらの制限は将来取り去られることになっています。

See also:
    *PEP305 CSV File API*
          Python へのこのモジュールの追加を提案している Python 改良案
          (PEP: Python Enhancement Proposal)


* Menu:

* モジュールの内容 2::
* Dialect クラスと書式化パラメタ::
* reader オブジェクト::
* writer オブジェクト::
* 使用例 4::


File: python-lib-jp.info,  Node: モジュールの内容 2,  Next: Dialect クラスと書式化パラメタ,  Prev: csv,  Up: csv

9.1.1 モジュールの内容
----------------------

`csv' モジュールでは以下の関数を定義しています:

`reader(csvfile[, dialect=`'excel''][, fmtparam])'
     与えられた {}CSVFILE 内の行を反復処理するような reader
     オブジェクトを返します。CSVFILE はイテレータプロトコル
     をサポートし、`next' メソッドが呼ばれた際に常に文字列を
     返すような任意のオブジェクトにすることができます --
     ファイルオブジェクトでも リストでも構いません。 CSVFILE
     がファイルオブジェクトの場合、ファイルオブジェクトの
     形式に違いがあるようなプラットフォームでは 'b' フラグを付けて
     開かなければなりません。 オプションとして DIALECT
     パラメタを与えることができ、 特定の CSV 表現形式 (dialect)
     特有のパラメタの集合を定義するために 使われます。DIALECT
     パラメタは `Dialect' クラスのサブクラス
     のインスタンスか、`list_dialects' 関数が返す文字列
     の一つにすることができます。別のオプションである {}FMTPARAM
     キーワード引数は、現在の表現形式における個々の書式パラメタを上書きする
     ために与えることができます。表現形式および書式化パラメタの詳細
     については、~*Note writer オブジェクト:: 節、 "Dialect
     クラスと書式化パラメタ" を参照してください。

     読み出されたデータは全て文字列として返されます。データ型の変換が
     自動的に行われることはありません。

     _Changed in Python version 2.5_


`writer(csvfile[, dialect=`'excel''][, fmtparam])'
     ユーザが与えたデータをデリミタで区切られた文字列に変換し、与えられた
     ファイルオブジェクトにするための writer オブジェクトを返します。
     CSVFILE は `write' メソッドを持つ任意のオブジェクトで
     かまいません。 CSVFILE
     がファイルオブジェクトの場合、ファイルオブジェクトの
     形式に違いがあるようなプラットフォームでは 'b' フラグを付けて
     開かなければなりません。 オプションとして DIALECT
     パラメタを与えることができ、 特定の CSV 表現形式 (dialect)
     特有のパラメタの集合を定義するために 使われます。DIALECT
     パラメタは `Dialect' クラスのサブクラス
     のインスタンスか、`list_dialects' 関数が返す文字列
     の一つにすることができます。別のオプションである {}FMTPARAM
     キーワード引数は、現在の表現形式における個々の書式パラメタを上書きする
     ために与えることができます。表現形式および書式化パラメタの詳細
     については、~*Note writer オブジェクト:: 節、 "Dialect
     クラスと書式化パラメタ" を参照してください。 DB API
     を実装するモジュールとのインタフェースを可能な限り容易に
     するために、`None' は空文字列として書き込まれます。
     この処理は可逆な変換ではありませんが、SQL で NULL データ値を CSV
     にダンプする処理を、`cursor.fetch*()' 呼び出しによって
     返されたデータを前処理することなく簡単に行うことができます。
     他の非文字データは、書き出される前に `str()' を使って
     文字列に変換されます。

`register_dialect(name[, dialect][, fmtparam])'
     DIALECT を NAME と関連付けます。NAME は文字列か Unicode
     オブジェクトでなければなりません。 表現形式(dialect)は `Dialect'
     のサブクラスを渡すか、 またはキーワード引数
     FMTPARAM、もしくは両方で指定できますが、
     キーワード引数の方が優先されます。表現形式と書式化パラメタについてより詳しいことは
     *Note writer オブジェクト::節「Dialect
     クラスと書式化パラメタ」を参照してください。

`unregister_dialect(name)'
     NAME に関連づけられた表現形式を表現形式レジストリから削除します。
     NAME が表現形式名でない場合には `Error' を送出します。

`get_dialect(name)'
     NAME に関連づけられた表現形式を返します。 NAME
     が表現形式名でない場合には `Error' を送出します。

`list_dialects()'
     登録されている全ての表現形式を返します。

`field_size_limit([new_limit])'
     パーサが許容する現在の最大フィールドサイズを返します。 NEW_LIMIT
     が渡されたときは、その値が新しい上限になります。 _Added in Python
     version 2.5_

`csv' モジュールでは以下のクラスを定義しています:

`DictReader(csvfile[, fieldnames=`None',[, restkey=`None'[, restval=`None'[, dialect=`'excel''[, *args, **kwds]]]]])'
     省略可能なFIELDNAMES パラメタで与えられたキーを読み出された情報
     に対応付ける他は正規の reader
     のように動作するオブジェクトを生成します。
     FIELDNAMESパラメタが無い場合には、CSVFILEの最初の行の値が
     フィールド名として利用されます。 読み出された行が FIELDNAMES
     のシーケンスよりも多くのフィールドを
     持っていた場合、残りのフィールドデータは RESTKEY の値をキーと
     するシーケンスに追加されます。読み出された行が FIELDNAMES
     のシーケンス
     よりも少ないフィールドしか持たない場合、残りのキーはオプションの
     RESTVAL パラメタに指定された値を取ります。その他の省略可能また
     はキーワード形式のパラメタはベースになっている `reader' のインス
     タンスに渡されます。

`DictWriter(csvfile, fieldnames[, restval=""[, extrasaction=`'raise''[, dialect=`'excel''[, *args, **kwds]]]])'
     辞書を出力行に対応付ける他は正規の writer のように動作する
     オブジェクトを生成します。FIELDNAMES パラメタには、 辞書中の
     `writerow()' メソッドに渡される値がどの順番で CSVFILE
     に書き出されるかを指定します。 オプションの RESTVAL
     パラメタは、FIELDNAMES 内の
     キーが辞書中にない場合に書き出される値を指定します。 `writerow()'
     メソッドに渡された辞書に、 FIELDNAMES 内には
     存在しないキーが入っている場合、オプションの EXTRAACTION
     パラメタでどのような動作を行うかを指定します。この値が `'raise''
     に設定されている場合 `ValueError' が送出されます。 `'ignore''
     に設定されている場合、辞書の余分の値は無視されます。
     その他のパラメタはベースになっている `writer' のインスタンスに渡
     されます。

     `DictReader'クラスとは違い、`DictWriter'のFIELDNAMES
     パラメータは省略可能ではありません。Pythonの`dict'オブジェクトは
     整列されていないので、列がCSVFILEに書かれるべき順序を推定するた
     めの十分な情報はありません。

`Dialect'
     {} `Dialect' クラスはコンテナクラスで、基本的な用途としては、
     その属性を特定の `reader' や `writer' インスタンスの
     パラメタを定義するために用います。

`excel()'
     `excel' クラスは Excel で生成される CSV ファイルの通常の
     プロパティを定義します。

`excel_tab()'
     `excel' クラスは Excel で生成されるタブ分割ファイルの通常の
     プロパティを定義します。

`Sniffer([sample=16384])'
     `Sniffer' クラスは CSV ファイルの書式を推理するために用いられる
     クラスです。

`Sniffer' クラスではメソッドを二つ提供しています:

`sniff(fileobj)'
     与えられた SAMPLE を解析し、発見されたパラメタを 反映した
     `Dialect' サブクラスを返します。 オプションの DELIMITERS
     パラメタを与えた場合、
     有効なデリミタ文字を含んでいるはずの文字列として解釈されます。

`has_header(sample)'
     (CSV 形式と仮定される) サンプルテキストを解析して、
     最初の行がカラムヘッダの羅列のように推察される場合 `True'
     を返します。

`csv' モジュールでは以下の定数を定義しています:

`QUOTE_ALL'
     `writer' オブジェクトに対し、全てのフィールドをクオートするように
     指示します。

`QUOTE_MINIMAL'
     `writer' オブジェクトに対し、DELIMITER、QUOTECHAR または
     LINETERMINATOR に含まれる任意の文字のような特別な文字
     を含むフィールドだけをクオートするように指示します。

`QUOTE_NONNUMERIC'
     `writer' オブジェクトに対し、全ての非数値フィールドをクオート
     するように指示します。

     `reader' に対しては、クオートされていない全てのフィールドを FLOAT
     型に 変換するよう指示します。

`QUOTE_NONE'
     `writer' オブジェクトに対し、フィールドを決してクオートしない
     ように指示します。現在の DELIMITER が出力データ中に現れた
     場合、現在設定されている ESCAPECHAR 文字が前に付けられます。
     ESCAPECHAR がセットされていない場合、エスケープが必要な文字に
     遭遇した writer は `Error' を送出します。

     `reader'
     に対しては、クオート文字の特別扱いをしないように指示します。

`csv' モジュールでは以下の例外を定義しています:

`Error'
     全ての関数において、エラーが検出された際に送出される例外です。


File: python-lib-jp.info,  Node: Dialect クラスと書式化パラメタ,  Next: reader オブジェクト,  Prev: モジュールの内容 2,  Up: csv

9.1.2 Dialect クラスと書式化パラメタ
------------------------------------

レコードに対する入出力形式の指定をより簡単にするために、
特定の書式化パラメタは表現形式 (dialect) にまとめてグループ化されます。
表現形式は `Dialect' クラスのサブクラスで、様々なクラス特有の
メソッドと、`validate()' メソッドを一つ持っています。 `reader' または
`writer' オブジェクトを生成するとき、 プログラマは文字列または
`Dialect' クラスのサブクラスを表現形式
パラメタとして渡さなければなりません。さらに、DIALECT パラメタ
の代りに、プログラマは上で定義されている属性と同じ名前を持つ
個々の書式化パラメタを `Dialect' クラスに指定することができます。

Dialect は以下の属性をサポートしています:

`delimiter'
     フィールド間を分割するのに用いられる 1 文字からなる文字列です。
     デフォルトでは `','' です。

`doublequote'
     フィールド内に現れた QUOTECHAR のインスタンスで、クオートではない
     その文字自身でなければならない文字をどのようにクオートするかを制御します。
     `True' の場合、この文字は二重化されます。 `False' の場合、
     ESCAPECHAR は QUOTECHAR の前に置かれます。デフォルトでは `True'
     です。

     出力においては、DOUBLEQUOTE が `False' で ESCAPECHAR
     がセットされていない場合、フールド内に QUOTECHAR が現れると
     `Error' が送出されます。

`escapechar'
     writer が、 QUOTING が `QUOTE_NONE' に設定されている場合に
     DELIMITER をエスケープするため、および、 DOUBLEQUOTE が `False'
     の場合に QUOTECHAR をエスケープするために用いられる、 1
     文字からなる文字列です。 読み込み時には ESCAPECHAR
     はそれに引き続く文字の特別な意味を取り除きます。 デフォルトでは
     `None' で、エスケープを行ないません。

`lineterminator'
     `writer' が作り出す各行を終端する際に用いられる文字列です。
     デフォルトでは `'\r\n'' です。

     _Note:_ `reader' は `'\r'' または `'\n'' のどちらかを行末と
     認識するようにハードコードされており、 LINETERMINATOR
     を無視します。 この振る舞いは将来変更されるかもしれません。

`quotechar'
     DELIMITER や QUOTECHAR といった特殊文字を含むか、
     改行文字を含むフィールドをクオートする際に 用いられる 1
     文字からなる文字列です。デフォルトでは `'"'' です。

`quoting'
     クオートがいつ writer によって生成されるか、また reader
     によって認識されるかを制御します。 `QUOTE_*' 定数のいずれか (*Note
     モジュールの内容 2:: 節参照) を
     とることができ、デフォルトでは`QUOTE_MINIMAL' です。

`skipinitialspace'
     `True' の場合、DELIMITER の直後に続く空白は無視されます。
     デフォルトでは `False' です。


File: python-lib-jp.info,  Node: reader オブジェクト,  Next: writer オブジェクト,  Prev: Dialect クラスと書式化パラメタ,  Up: csv

9.1.3 reader オブジェクト
-------------------------

reader オブジェクト(`DictReader' インスタンス、および `reader()'
関数によって返されたオブジェクト) は、以下の public
なメソッドを持っています:

`next()'
     reader の反復可能なオブジェクトから、現在の表現形式に基づいて
     次の行を解析して返します。

reader オブジェクトには以下の公開属性があります:

`dialect'
     パーサで使われる表現形式の読み取り専用の記述です。

`line_num'
     ソースイテレータから読んだ行数です。この数は返されるレコードの数とは、
     レコードが複数行に亘ることがあるので、一致しません。


File: python-lib-jp.info,  Node: writer オブジェクト,  Next: 使用例 4,  Prev: reader オブジェクト,  Up: csv

9.1.4 writer オブジェクト
-------------------------

`Writer' オブジェクト(`DictWriter' インスタンス、および `writer()'
関数によって返されたオブジェクト) は、以下の public
なメソッドを持っています:

`Writer' オブジェクト(`writer()' で生成される `DictWriter'
クラスのインスタンス）は、以下の公開メソッドを持っています。 {}ROW
には、`Writer' オブジェクトの場合には文字列か数値のシーケンスを
指定し、{}`DictWriter'
オブジェクトの場合はフィールド名をキーとして対応する
文字列か数値を格納した辞書オブジェクトを指定します(数値は `str()'で変換
されます)。
複素数を出力する場合、値をかっこで囲んで出力します。このため、CSV
ファイルを読み込むアプリケーションで（そのアプリケーションが複素数をサポートして
いたとしても）問題が発生する場合があります。

`writerow(row)'
     ROW パラメタを現在の表現形式に基づいて書式化し、 writer のファイル
     オブジェクトに書き込みます。

`writerows(rows)'
     ROWS パラメタ(上記 ROW
     のリスト)全てを現在の表現形式に基づいて書式化し、 writer
     のファイルオブジェクトに書き込みます。

writer オブジェクトには以下の公開属性があります:

`dialect'
     writer で使われる表現形式の読み取り専用の記述です。


File: python-lib-jp.info,  Node: 使用例 4,  Prev: writer オブジェクト,  Up: csv

9.1.5 使用例
------------

最も簡単な CSV ファイル読み込みの例です:

     import csv
     reader = csv.reader(file("some.csv", "rb"))
     for row in reader:
         print row

別の書式での読み込み:

     import csv
     reader = csv.reader(open("passwd", "rb"), delimiter=':', quoting=csv.QUOTE_NONE)
     for row in reader:
         print row

上に対して、単純な書き込みのプログラム例は以下のようになります。

     import csv
     writer = csv.writer(file("some.csv", "wb"))
     writer.writerows(someiterable)

新しい表現形式の登録:

     import csv

     csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)

     reader = csv.reader(open("passwd", "rb"), 'unixpwd')

もう少し手の込んだ reader の使い方 -- エラーを捉えてレポートします。

     import csv, sys
     filename = "some.csv"
     reader = csv.reader(open(filename, "rb"))
     try:
         for row in reader:
             print row
     except csv.Error, e:
         sys.exit('file %s, line %d: %s' % (filename, reader.line_num, e))

このモジュールは文字列の解析は直接サポートしませんが、簡単にできます。

     import csv
     for row in csv.reader(['one,two,three']):
         print row

`csv' モジュールは直接は Unicode の読み書きをサポートしませんが、 ASCII
NUL 文字に関わる問題のために8ビットクリーンに書き込みます。
ですから、NUL を使う UTF-16 のようなエンコーディングを避ける限り
エンコード・デコードを行なう関数やクラスを書くことができます。 UTF-8
がお勧めです。

以下の `unicode_csv_reader' は Unicode の CSV データ (Unicode
文字列のリスト)を扱うための `csv.reader' をラップする
ジェネレータです。`utf_8_encoder' は一度に 1 文字列(または行) ずつ
Unicode 文字列を UTF-8 としてエンコードするジェネレータです。
エンコードされた文字列は CSV reader により分解され、
`unicode_csv_reader' が UTF-8 エンコードの分解された文字列を
デコードして Unicode に戻します。

     import csv

     def unicode_csv_reader(unicode_csv_data, dialect=csv.excel, **kwargs):
         # csv.py doesn't do Unicode; encode temporarily as UTF-8:
         csv_reader = csv.reader(utf_8_encoder(unicode_csv_data),
                                 dialect=dialect, **kwargs)
         for row in csv_reader:
             # decode UTF-8 back to Unicode, cell by cell:
             yield [unicode(cell, 'utf-8') for cell in row]

     def utf_8_encoder(unicode_csv_data):
         for line in unicode_csv_data:
             yield line.encode('utf-8')

その他のエンコーディングには以下の `UnicodeReader' クラスと
`UnicodeWriter' クラスが使えます。二つのクラスは ENCODING
パラメータをコンストラクタで取り、本物の reader や writer
に渡されるデータが UTF-8 でエンコードされていることを保証します。

     import csv, codecs, cStringIO

     class UTF8Recoder:
         """
         Iterator that reads an encoded stream and reencodes the input to UTF-8
         """
         def __init__(self, f, encoding):
             self.reader = codecs.getreader(encoding)(f)

         def __iter__(self):
             return self

         def next(self):
             return self.reader.next().encode("utf-8")

     class UnicodeReader:
         """
         A CSV reader which will iterate over lines in the CSV file "f",
         which is encoded in the given encoding.
         """

         def __init__(self, f, dialect=csv.excel, encoding="utf-8", **kwds):
             f = UTF8Recoder(f, encoding)
             self.reader = csv.reader(f, dialect=dialect, **kwds)

         def next(self):
             row = self.reader.next()
             return [unicode(s, "utf-8") for s in row]

         def __iter__(self):
             return self

     class UnicodeWriter:
         """
         A CSV writer which will write rows to CSV file "f",
         which is encoded in the given encoding.
         """

         def __init__(self, f, dialect=csv.excel, encoding="utf-8", **kwds):
             # Redirect output to a queue
             self.queue = cStringIO.StringIO()
             self.writer = csv.writer(self.queue, dialect=dialect, **kwds)
             self.stream = f
             self.encoder = codecs.getincrementalencoder(encoding)()

         def writerow(self, row):
             self.writer.writerow([s.encode("utf-8") for s in row])
             # Fetch UTF-8 output from the queue ...
             data = self.queue.getvalue()
             data = data.decode("utf-8")
             # ... and reencode it into the target encoding
             data = self.encoder.encode(data)
             # write to the target stream
             self.stream.write(data)
             # empty queue
             self.queue.truncate(0)

         def writerows(self, rows):
             for row in rows:
                 self.writerow(row)


File: python-lib-jp.info,  Node: ConfigParser,  Next: robotparser,  Prev: csv,  Up: File Formats

9.2 設定ファイルの構文解析器
============================

Configuration file parser.

このモジュールでは， `ConfigParser'クラスを定義しています。 `ConfigParser'
クラスは，Microsoft Windows の INI ファイルに
見られるような構造をもつ，基礎的な設定ファイルを実装しています．
このモジュールを使って，エンドユーザーが簡単にカスタマイズできるような
Python プログラムを書くことができます。

_Notice:_ [warning]
このライブラリでは、Windowsのレジストリ用に拡張された INI 文法はサポート
_していません_。

設定ファイルは 1 つ以上のセクションからなり、セクションは `[section]'
ヘッダとそれに続くRFC 822 形式の `name: value'
エントリからなっています。 `name=value' という形式も使えます。
値の先頭にある空白文字は削除されるので注意してください．
オプションの値には，同じセクションか `DEFAULT' セクションに
ある値を参照するような書式化文字列を含めることができます．
初期化時や検索時に別のデフォルト値を与えることもできます． `#'か`;'
ではじまる行は無視され，コメントを書く ために利用できます。

例:

     [My Section]
     foodir: %(dir)s/whatever
     dir=frob

この場合`%(dir)s'は変数`dir' (この場合は`frob')に展開さ れます。
参照の展開は必要に応じて実行されます。

デフォルト値は
`ConfigParser'のコンストラクタに辞書として渡すことで設定できます。
追加の(他の値をオーバーライドする)デフォルト値は`get()'メソッドに
渡すことができます。

`RawConfigParser([defaults])'
     基本的な設定オブジェクトです。
     DEFAULTSが与えられた場合、オブジェクト
     に固有のデフォルト値がその値で初期化されます。
     このクラスは値の置換をサポートしません。 _Added in Python version
     2.3_

`ConfigParser([defaults])'
     `RawConfigParser'の派生クラスで値の置換を実装しており、
     `get()'メソッドと`items()'メソッドに省略可能な引数を追加し
     ています。 DEFAULTSに含まれる値は`%()s'による値の置換に
     適当なものである必要があります。
     __NAME__は組み込みのデフォルト値で、セクション名が含まれるので
     DEFAULTSで設定してもオーバーライドされます。

     置換で使われるすべてのオプション名は、ほかのオプション名への参照と同様に
     `optionxform()' メソッドを介して渡されます。たとえば、
     `optionxform()' のデフォルト実装
     (これはオプション名を小文字に変換します) を 使うと、値 `foo
     %(bar)s' および `foo %(BAR)s' は同一になります。

`SafeConfigParser([defaults])'
     `ConfigParser'の派生クラスでより安全な値の置換を実装しています。
     この実装のはより予測可能性が高くなっています。
     新規に書くアプリケーションでは、古いバージョンのPythonと互換性を持たせる
     必要がない限り、このバージョンを利用することが望ましいです。
     _Added in Python version 2.3_

`NoSectionError'
     指定したセクションが見つからなかった時に起きる例外です。

`DuplicateSectionError'
     すでに存在するセクション名に対して `add_section()' が
     呼び出された際に起きる例外です。


`NoOptionError'
     指定したオプションが指定したセクションに存在しなかった時に起きる例外です。

`InterpolationError'
     文字列の置換中に問題が起きた時に発生する例外の基底クラスです。

`InterpolationDepthError'
     `InterpolationError'の派生クラスで、文字列の置換回数が
     `MAX_INTERPOLATION_DEPTH'を越えたために完了しなかった場合に
     発生する例外です。

`InterpolationMissingOptionError'
     `InterpolationError'の派生クラスで、値が参照しているオプションが
     見つからない場合に発生する例外です。

`InterpolationSyntaxError'
     `InterpolationError'の派生クラスで、指定された構文で値を置換
     することができなかった場合に発生する例外です。 _Added in Python
     version 2.3_


`MissingSectionHeaderError'
     セクションヘッダを持たないファイルを構文解析しようとした時に起きる例外です。

`ParsingError'
     ファイルの構文解析中にエラーが起きた場合に発生する例外です。

`MAX_INTERPOLATION_DEPTH'
     RAWが偽だった場合の`get()'による再帰的な文字列置換の繰り返
     しの最大値です。`ConfigParser'クラスだけに関係します。

See also:
     *Note shlex::  UNIX のシェルに似た，アプリケーションの設定ファイル
     用フォーマットとして使えるもう一つの小型言語です．

* Menu:

* RawConfigParser オブジェクト::
* ConfigParser オブジェクト::
* SafeConfigParser オブジェクト::


File: python-lib-jp.info,  Node: RawConfigParser オブジェクト,  Next: ConfigParser オブジェクト,  Prev: ConfigParser,  Up: ConfigParser

9.2.1 RawConfigParser オブジェクト
----------------------------------

`RawConfigParser'クラスのインスタンスは以下のメソッドを持ちます:

`defaults()'
     インスタンス全体で使われるデフォルト値の辞書を返します。

`sections()'
     利用可能なセクションのリストを返します。`DEFAULT'はこのリストに含まれ
     ません。

`add_section(section)'
     SECTIONという名前のセクションをインスタンスに追加します。
     同名のセク ションが存在した場合、`DuplicateSectionError'が発生
     します。

`has_section(section)'
     指定したセクションがコンフィグレーションファイルに存在するかを返します。
     `DEFAULT'セクションは存在するとみなされません。

`options(section)'
     SECTIONで指定したセクションで利用できるオプションのリストを返し
     ます。

`has_option(section, option)'
     与えられたセクションが存在してかつオプションが与えられていれば
     `True' を返し、 そうでなければ `False' を返します。 _Added in
     Python version 1.6_

`read(filenames)'
     ファイル名のリストを読んで解析をこころみ、
     うまく解析できたファイル名のリストを返します。
     もしFILENAMESが文字列かユニコード文字列なら、1つのファイル名として
     扱われます。FILENAMESで指定されたファイルが開けない場合、そのファイ
     ルは無視されます。この挙動は設定ファイルが置かれる可能性のある場所(例えば、
     カレントディレクトリ、ホームディレクトリ、システム全体の設定を行うディ
     レクトリ)を設定して、そこに存在する設定ファイルを読むことを想定して設計
     されています。 設定ファイルが存在しなかった場合、`ConfigParser'
     のインスタンスは
     空のデータセットを持ちます。初期値の設定ファイルを先に読み込んでおく
     必要があるアプリケーションでは、`readfp())'を
     `read()'の前に呼び出すことでそのような動作を実現できます:

          import ConfigParser, os

          config = ConfigParser.ConfigParser()
          config.readfp(open('defaults.cfg'))
          config.read(['site.cfg', os.path.expanduser('~/.myapp.cfg')])

     _Changed in Python version 2.4_

`readfp(fp[, filename])'
     FPで与えられるファイルかファイルのようなオブジェクトを読み込んで構
     文解析します(`readline()'メソッドだけを使います)。もし
     FILENAMEが省略されてFPが`name'属性を持っていれば
     FILENAMEの代わりに使われます。ファイル名の初期値は`<???>'です。

`get(section, option)'
     SECTIONのOPTION変数を取得します。

`getint(section, option)'
     SECTIONのOPTIONを整数として評価する関数です。

`getfloat(section, option)'
     SECTIONのOPTIONを浮動小数点数として評価する関数です。

`getboolean(section, option)'
     指定した SECTION の OPTION 値をブール値に型強制する
     便宜メソッドです。OPTION として受理できる値は、真 (True) としては
     `"1"'、 `"yes"'、 `"true"'、 `"on"' 、偽 (False) としては `"0"'、
     `"no"'、 `"false"'、 `"off"' です。
     これらの文字列値に対しては大文字小文字の区別をしません。
     その他の値の場合には `ValueError' を送出します。

`items(section)'
     与えられたSECTIONのそれぞれのオプションについて `(NAME,
     VALUE)'ペアのリストを返します。

`set(section, option, value)'
     与えられたセクションが存在していれば、オプションを指定された値に設定します。
     セクションが存在しなければ `NoSectionError' を発生させます。
     `RawConfigParser' (あるいはRAW パラメータをセットした
     `ConfigParser') を文字列型でない値の _内部的な_ 格納場所として
     使うことは可能ですが、すべての機能 (置換やファイルへの出力を含む)
     が サポートされるのは文字列を値として使った場合だけです。 _Added
     in Python version 1.6_

`write(fileobject)'
     設定を文字列表現に変換してファイルオブジェクトに書き出します。この
     文字列表現は`read()'で読み込むことができます。 _Added in Python
     version 1.6_

`remove_option(section, option)'
     指定されたSECTIONから指定されたOPTIONを削除します。
     セクションが存在しなければ、`NoSectionError' を起こします。
     存在するオプションを削除した時は `True' を、 そうでない時は
     `False' を返します。 _Added in Python version 1.6_

`remove_section(section)'
     指定されたSECTIONを設定から削除します。
     もし指定されたセクションが存在すれば`True'、そうでなければ
     `False'を返します。

`optionxform(option)'
     入力ファイル中に見つかったオプション名か，
     クライアントコードから渡されたオプション名 OPTION を，
     内部で利用する形式に変換します。デフォルトではOPTIONを
     全て小文字に変換した名前が返されます。サブルクラスではこの関数をオーバー
     ライドすることでこの振舞いを替えることができます。たとえば、このメソッ
     ドを`str()'に設定することで大小文字の差を区別するように
     変更することができます。


File: python-lib-jp.info,  Node: ConfigParser オブジェクト,  Next: SafeConfigParser オブジェクト,  Prev: RawConfigParser オブジェクト,  Up: ConfigParser

9.2.2 ConfigParser オブジェクト
-------------------------------

`ConfigParser'クラスは`RawConfigParser'のインターフェースを
いくつかのメソッドについて拡張し、省略可能な引数を追加しています。

`get(section, option[, raw[, vars]])'
     SECTIONのOPTION変数を取得します。
     RAWが真でない時には、全ての`%'置換は
     コンストラクタに渡されたデフォルト値か、VARS が与えられていれば
     それを元にして展開されてから返されます。

`items(section[, raw[, vars]])'
     指定したSECTION 内の各オプションに対して、 `(NAME, VALUE)'
     のペアからなるリストを返します。
     省略可能な引数は`get()'メソッドと同じ意味を持ちます。 _Added in
     Python version 2.3_


File: python-lib-jp.info,  Node: SafeConfigParser オブジェクト,  Prev: ConfigParser オブジェクト,  Up: ConfigParser

9.2.3 SafeConfigParser オブジェクト
-----------------------------------

`SafeConfigParser' は `ConfigParser' と同様の拡張インターフェイスを
もっていますが、以下のような機能が追加されています:

`set(section, option, value)'
     もし与えられたセクションが存在している場合は、指定された値を
     与えられたオプションに設定します。そうでない場合は
     `NoSectionError' を 発生させます。  VALUE は文字列  (`str' または
     `unicode') でなければならず、 そうでない場合には `TypeError'
     が発生します。

     _Added in Python version 2.4_


File: python-lib-jp.info,  Node: robotparser,  Next: netrc,  Prev: ConfigParser,  Up: File Formats

9.3 robots.txt のためのパーザ
=============================

`robots.txt' ファイルを読み出し、 他の URL
に対する取得可能性の質問に答えるクラス。

このモジュールでは単一のクラス、`RobotFileParser' を提供します。
このクラスは、特定のユーザエージェントが `robots.txt' ファイルを
公開している Web サイトのある URL を取得可能かどうかの質問に答えます。
`robots.txt' ファイルの構造に関する詳細は
`http://www.robotstxt.org/wc/norobots.html' を参照してください。

`RobotFileParser()'
     このクラスでは単一の `robots.txt' ファイルを読み出し、解釈し、
     ファイルの内容に関する質問の回答を得るためのメソッドを定義しています。

    `set_url(url)'
          `robots.txt' ファイルを参照するための URL を設定します。

    `read()'
          `robots.txt' URL を読み出し、パーザに入力します。

    `parse(lines)'
          引数 LINES の内容を解釈します。

    `can_fetch(useragent, url)'
          解釈された `robots.txt'
          ファイル中に記載された規則に従ったとき、 USERAGENT が URL
          を取得してもよい場合には `True' を 返します。

    `mtime()'
          `robots.txt' ファイルを最後に取得した時刻を返します。この
          値は、定期的に新たな `robots.txt' をチェックする必要がある、
          長時間動作する Web
          スパイダープログラムを実装する際に便利です。

    `modified()'
          `robots.txt'
          ファイルを最後に取得した時刻を現在の時刻に設定します。


以下にRobotFileParser クラスの利用例を示します。

     >>> import robotparser
     >>> rp = robotparser.RobotFileParser()
     >>> rp.set_url("http://www.musi-cal.com/robots.txt")
     >>> rp.read()
     >>> rp.can_fetch("*", "http://www.musi-cal.com/cgi-bin/search?city=San+Francisco")
     False
     >>> rp.can_fetch("*", "http://www.musi-cal.com/")
     True


File: python-lib-jp.info,  Node: netrc,  Next: xdrlib,  Prev: robotparser,  Up: File Formats

9.4 netrc ファイルの処理
========================

`.netrc' ファイル群の読み出し。

_Added in Python version 1.5.2_

`netrc' クラスは、UNIX `ftp' プログラムや他の FTP
クライアントで用いられる netrc ファイル形式を解析し、カプセル化
(encapsulate) します。

`netrc([file])'
     `netrc' のインスタンスやサブクラスのインスタンスは netrc
     ファイルのデータをカプセル化します。初期化の際の引数が存在する
     場合、解析対象となるファイルの指定になります。引数がない場合、
     ユーザのホームディレクトリ下にある `.netrc' が読み出されます。
     解析エラーが発生した場合、ファイル名、行番号、解析を中断したトークン
     に関する情報の入った `NetrcParseError' を送出します。

`NetrcParseError'
     ソースファイルのテキスト中で文法エラーに遭遇した場合に `netrc'
     クラスによって送出される例外です。この例外のインスタンスは 3 つの
     インスタンス変数を持っています: `msg' はテキストによる
     エラーの説明で、`filename' はソースファイルの名前、 そして
     `lineno' はエラーが発見された行番号です。

* Menu:

* netrc オブジェクト::


File: python-lib-jp.info,  Node: netrc オブジェクト,  Prev: netrc,  Up: netrc

9.4.1 netrc オブジェクト
------------------------

`netrc' インスタンスは以下のメソッドを持っています:

`authenticators(host)'
     HOST の認証情報として、三要素のタプル `(LOGIN, ACCOUNT, PASSWORD)'
     を返します。 与えられた host に対するエントリが netrc
     ファイルにない場合、 `default'
     エントリに関連付けられたタプルが返されます。 host
     に対応するエントリがなく、default エントリもない場合、 `None'
     を返します。

`__repr__()'
     クラスの持っているデータを netrc ファイルの書式に従った文字列で
     出力します。(コメントは無視され、エントリが並べ替えられる可能性
     があります。)

`netrc' のインスタンスは以下の公開されたインスタンス変数 を持っています:

`hosts'
     ホスト名を `(LOGIN, ACCOUNT, PASSWORD)' から
     なるタプルに対応づけている辞書です。`default' エントリがある場合、
     その名前の擬似ホスト名として表現されます。

`macros'
     マクロ名を文字列のリストに対応付けている辞書です。

_Note:_
利用可能なパスワードの文字セットは、ASCIIのサブセットのみです。2.3より前の
バージョンでは厳しく制限されていましたが、2.3以降ではASCIIの記号を使用することが
できます。しかし、空白文字と印刷不可文字を使用することはできません。この制限は
.netrcファイルの解析方法によるものであり、将来解除されます。


File: python-lib-jp.info,  Node: xdrlib,  Prev: netrc,  Up: File Formats

9.5 XDR データのエンコードおよびデコード
========================================

外部データ表現 (XDR, External Data Representation)
データのエンコードおよびデコード。

`xdrlib' モジュールは外部データ表現標準 (External Data Representation
Standard) のサポートを実現します。この標準は 1987 年に Sun
Microsystems, Inc. によって書かれ、 RFC 1014 

で定義されています。このモジュールでは RFC で記述されている
ほとんどのデータ型をサポートしています。

`xdrlib' モジュールでは 2 つのクラスが定義されています。 一つは変数を
XDR 表現にパックするためのクラスで、もう一方は XDR
表現からアンパックするためのものです。2 つの例外クラスが
同様にして定義されています。

`Packer()'
     `Packer' はデータを XDR 表現にパックするためのクラスです。
     `Packer' クラスのインスタンス生成は引数なしで行われます。

`Unpacker(data)'
     `Unpacker' は Packer と対をなしていて、文字列バッファから XDR
     をアンパックするためのクラスです。入力バッファ DATA
     を引数に与えてインスタンスを生成します。

See also:
    *RFC1014 XDR: External Data Representation Standard*
          この RFC が、かつてこのモジュールが最初に書かれた当時に XDR
          標準でであったデータのエンコード方法を定義していました。
          現在は RFC 1832 に更新されているようです。

    *RFC1832 XDR: External Data Representation Standard*
          こちらが 新しい方のRFCで、XDR の改訂版が定義されています。


* Menu:

* Packer オブジェクト::
* Unpacker オブジェクト::
* 例外 3::


File: python-lib-jp.info,  Node: Packer オブジェクト,  Next: Unpacker オブジェクト,  Prev: xdrlib,  Up: xdrlib

9.5.1 Packer オブジェクト
-------------------------

`Packer' インスタンスには以下のメソッドがあります:

`get_buffer()'
     現在のパック処理用バッファを文字列で返します。

`reset()'
     パック処理用バッファをリセットして、空文字にします。

一般的には、適切な `pack_TYPE()' メソッドを使えば、
一般に用いられているほとんどの XDR データをパックすることができます。
各々のメソッドは一つの引数をとり、パックしたい値を与えます。
単純なデータ型をパックするメソッドとして、以下のメソッド: `pack_uint()'
、`pack_int()' 、 `pack_enum()' 、 `pack_bool()' 、`pack_uhyper()'
そして `pack_hyper()' がサポートされています。

`pack_float(value)'
     単精度 (single-precision) の浮動小数点数 VALUE をパックします。

`pack_double(value)'
     倍精度 (double-precision) の浮動小数点数 VALUE をパックします。

以下のメソッドは文字列、バイト列、不透明データ (opaque data) のパック
処理をサポートします:

`pack_fstring(n, s)'
     固定長の文字列、S をパックします。 N は文字列の長さ
     ですが、この値自体はデータバッファにはパック _されません_ 。 4
     バイトのアラインメントを保証するために、文字列は必要に応じて null
     バイト列でパディングされます。

`pack_fopaque(n, data)'
     `pack_fstring()' と同じく、固定長の不透明データストリームを
     パックします。

`pack_string(s)'
     可変長の文字列 S をパックします。文字列の長さが最初に符号なし
     整数でパックされ、続いて `pack_fstring()' を使って文字列データが
     パックされます。

`pack_opaque(data)'
     `pack_string()'
     と同じく、可変長の不透明データ文字列をパックします。

`pack_bytes(bytes)'
     `pack_string()' と同じく、可変長のバイトストリームをパックします。

以下のメソッドはアレイやリストのパック処理をサポートします:

`pack_list(list, pack_item)'
     一様な項目からなる LIST をパックします。このメソッドは
     サイズ不定、すなわち、全てのリスト内容を網羅するまでサイズが
     分からないリストに対して有用です。リストのすべての項目に対し、
     最初に符号無し整数 `1' がパックされ、続いてリスト中の
     データがパックされます。PACK_ITEM は個々の項目をパック
     するために呼び出される関数です。リストの末端に到達すると、
     符号無し整数 `0' がパックされます。

     例えば、整数のリストをパックするには、コードは以下のようになるはず
     です:

          import xdrlib
          p = xdrlib.Packer()
          p.pack_list([1, 2, 3], p.pack_int)


`pack_farray(n, array, pack_item)'
     一様な項目からなる固定長のリスト (ARRAY) をパックします。 N
     はリストの長さです。この値はデータバッファにパック _されません_
     が、`len(ARRAY)' が N と 等しくない場合、例外 `ValueError'
     が送出されます。 上と同様に、PACK_ITEM
     は個々の要素をパック処理するための 関数です。

`pack_array(list, pack_item)'
     一様の項目からなる可変長の LIST をパックします。
     まず、リストの長さが符号無し整数でパックされ、つづいて各
     要素が上の `pack_farray()' と同じやり方でパックされます。


File: python-lib-jp.info,  Node: Unpacker オブジェクト,  Next: 例外 3,  Prev: Packer オブジェクト,  Up: xdrlib

9.5.2 Unpacker オブジェクト
---------------------------

`Unpacker' クラスは以下のメソッドを提供します:

`reset(data)'
     文字列バッファを DATA でリセットします。

`get_position()'
     データバッファ中の現在のアンパック処理位置を返します。

`set_position(position)'
     データバッファ中のアンパック処理位置を POSITION に設定します。
     `get_position()' および `set_position()' は注意して
     使わなければなりません。

`get_buffer()'
     現在のアンパック処理用データバッファを文字列で返します。

`done()'
     アンパック処理を終了させます。全てのデータがまだアンパックされて
     いなければ、例外 `Error' が送出されます。

上のメソッドに加えて、`Packer' でパック処理できるデータ型はいずれも
`Unpacker' でアンパック処理できます。アンパック処理メソッドは
`unpack_TYPE()' の形式をとり、引数をとりません。
これらのメソッドはアンパックされたデータオブジェクトを返します。

`unpack_float()'
     単精度の浮動小数点数をアンパックします。

`unpack_double()'
     `unpack_float()' と同様に、倍精度の浮動小数点数をアンパックします。

上のメソッドに加えて、文字列、バイト列、不透明データをアンパックする
以下のメソッドが提供されています:

`unpack_fstring(n)'
     固定長の文字列をアンパックして返します。N は予想される文字列の
     長さです。4 バイトのアラインメントを保証するために null
     バイトによる パディングが行われているものと仮定して処理を行います。

`unpack_fopaque(n)'
     `unpack_fstring()' と同様に、固定長の不透明データストリームを
     アンパックして返します。

`unpack_string()'
     可変長の文字列をアンパックして返します。最初に文字列の長さが符号無し
     整数としてアンパックされ、次に `unpack_fstring()' を使って
     文字列データがアンパックされます。

`unpack_opaque()'
     `unpack_string()' と同様に、可変長の不透明データ文字列をアンパック
     して返します。

`unpack_bytes()'
     `unpack_string()' と同様に、可変長のバイトストリームをアンパック
     して返します。

以下メソッドはアレイおよびリストのアンパック処理をサポートします。

`unpack_list(unpack_item)'
     一様な項目からなるリストをアンパック処理してかえします。リストは
     一度に 1
     要素づつアンパック処理されます、まず符号無し整数によるフラグ
     がアンパックされます。もしフラグが `1' なら、要素はアンパックされ、
     返り値のリストに追加されます。フラグが `0' であれば、リストの終端
     を示します。 UNPACK_ITEM は個々の項目をアンパック処理するために
     呼び出される関数です。

`unpack_farray(n, unpack_item)'
     一様な項目からなる固定長のアレイをアンパックして（リストとして）返します。
     N はバッファ内に存在すると期待されるリストの要素数です。
     上と同様に、 UNPACK_ITEM は各要素をアンパックするために使われる
     関数です。

`unpack_array(unpack_item)'
     一様な項目からなる可変長の LIST をアンパックして返します。
     まず、リストの長さが符号無し整数としてアンパックされ、続いて各要素が
     上の `unpack_farray()' のようにしてアンパック処理されます。


File: python-lib-jp.info,  Node: 例外 3,  Prev: Unpacker オブジェクト,  Up: xdrlib

9.5.3 例外
----------

このモジュールでの例外はクラスインスタンスとしてコード されています:

`Error'
     ベースとなる例外クラスです。`Error' public なデータメンバ として
     `msg' を持ち、エラーの詳細が収められています。

`ConversionError'
     `Error' から導出されたクラスです。インスタンス変数は塚されて
     いません。

これらの例外を補足する方法を以下の例に示します:

     import xdrlib
     p = xdrlib.Packer()
     try:
         p.pack_double(8.01)
     except xdrlib.ConversionError, instance:
         print 'packing the double failed:', instance.msg


File: python-lib-jp.info,  Node: 暗号関連のサービス,  Next: ファイルとディレクトリへのアクセス,  Prev: File Formats,  Up: Top

10 暗号関連のサービス
*********************

この章で記述されているモジュールでは、暗号の本質に関わる様々な
アルゴリズムを実装しています。これらは必要に応じてインストール
することで使えます。概要を以下に示します:

あなたがハードコアなサイファーパンクなら、 A.M. Kuchling
の書いた暗号化モジュールに興味を持つかもしれません。このパッケージ
はAESをはじめとする様々な暗号化アルゴリズムのモジュールを含みます。
これらのモジュールは Python と一緒には配布されず、別に入手できます。
詳細は `http://www.amk.ca/python/code/crypto.html' を見てください。 

* Menu:

* hashlib::
* hmac::
* md5::
* sha::


File: python-lib-jp.info,  Node: hashlib,  Next: hmac,  Prev: 暗号関連のサービス,  Up: 暗号関連のサービス

10.1 セキュアハッシュおよびメッセージダイジェスト
=================================================

セキュアハッシュおよびメッセージダイジェストのアルゴリズム

_Added in Python version 2.5_

このモジュールは、セキュアハッシュやメッセージダイジェスト用のさまざまな
アルゴリズムを実装したものです。FIPSのセキュアなハッシュアルゴリズムであ
るSHA1、SHA224、SHA256、SHA384およびSHA512 (FIPS 180-2 で定義されている
もの) だけでなくRSAのMD5アルゴリズム (Internet RFC 1321 で定義されてい
ます)も実装しています。「セキュアなハッシュ」と「メッセージダイジェスト」
はどちらも同じ意味です。古くからあるアルゴリズムは「メッセージダイジェス
ト」と呼ばれていますが、最近は「セキュアハッシュ」という用語が用いられて
います。

_中には、ハッシュの衝突の脆弱性をかかえているアルゴリズムもあり
ます。最後のFAQをごらんください。_

"hash" のそれぞれの型の名前をとったコンストラクタメソッドがひとつず
つあります。返されるハッシュオブジェクトは、どれも同じシンプルなインター
フェイスを持っています。たとえば `sha1()' を使用するとSHA1ハッ
シュオブジェクトが作成されます。このオブジェクトの`update()'メソ
ッドに、任意の文字列を渡すことができます。それまでに渡した文字列の
"digest"を知りたければ、`digest()'メソッドあるいは
`hexdigest()'メソッドを使用します。

このモジュールで常に使用できるハッシュアルゴリズムのコンストラクタは
`md5()'、`sha1()'、`sha224()'、
`sha256()'、`sha384()'および`sha512()'です。
それ以外のアルゴリズムが使用できるかどうかは、Pythonが使用している
OpenSSLライブラリに依存します。 

たとえば、`'Nobody inspects the spammish repetition''という文字列の
ダイジェストを取得するには次のようにします。

     >>> import hashlib
     >>> m = hashlib.md5()
     >>> m.update("Nobody inspects")
     >>> m.update(" the spammish repetition")
     >>> m.digest()
     '\xbbd\x9c\x83\xdd\x1e\xa5\xc9\xd9\xde\xc9\xa1\x8d\xf0\xff\xe9'

もっと簡潔に書くと、このようになります。

     >>> hashlib.sha224("Nobody inspects the spammish repetition").hexdigest()
     'a4337bc45a8fc544c03f52dc550cd6e1e87021bc896588bd79e901e2'

汎用的なコンストラクタ`new()'も用意されています。このコンストラ
クタの最初のパラメータとして、使いたいアルゴリズムの名前を指定します。ア
ルゴリズム名として指定できるのは、先ほど説明したアルゴリズムかOpenSSLラ
イブラリが提供するアルゴリズムとなります。しかし、アルゴリズム名のコンス
トラクタのほうが`new()'よりずっと高速なので、そちらを使うことを
お勧めします。

`new()'にOpenSSLのアルゴリズムを指定する例です。

     >>> h = hashlib.new('ripemd160')
     >>> h.update("Nobody inspects the spammish repetition")
     >>> h.hexdigest()
     'cc4a5ce1b3df48aec5d22d1f16b894a0b894eccc'

コンストラクタが返すハッシュオブジェクトには、次のような定数属性が用意さ
れています。

`digest_size'
     作成されたダイジェストのバイト数。

ハッシュオブジェクトには次のようなメソッドがあります。

`update(arg)'
     ハッシュオブジェクトを文字列ARGで更新します。繰り返してコールする
     のは、すべての引数を連結して1回だけコールするのと同じ意味になります。つ
     まり、`m.update(a); m.update(b)'と`m.update(a+b)'は同じ意味だ
     ということです。

`digest()'
     これまでに`update()'メソッドに渡した文字列のダイジェストを返しま
     す。これは`digest_size'バイトの文字列であり、非ASCII文字やnull
     バイトを含むこともあります。

`hexdigest()'
     `digest()'と似ていますが、返される文字列は倍の長さとなり、16進形
     式となります。これは、電子メールなどの非バイナリ環境で値を交換する場合に
     便利です。

`copy()'
     ハッシュオブジェクトのコピー ("クローン")
     を返します。これは、共通部分
     を持つ複数の文字列のダイジェストを効率的に計算するために使用します。

See also:
     *Note hmac:: ハッシュを用いてメッセージ認証コードを生成するモジュ
     ールです。 *Note base64::
     バイナリハッシュを非バイナリ環境用にエンコードする
     もうひとつの方法です。

    `http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf'
          FIPS 180-2 のセキュアハッシュアルゴリズムについての説明。

    `http://www.cryptography.com/cnews/hash.html'
          Hash Collision
          FAQ。既知の問題を持つアルゴリズムとその使用上の注意点
          に関する情報があります。



File: python-lib-jp.info,  Node: hmac,  Next: md5,  Prev: hashlib,  Up: 暗号関連のサービス

10.2 メッセージ認証のための鍵付きハッシュ化
===========================================

Python で実装された、メッセージ認証のための鍵付き ハッシュ化 (HMAC:
Keyed-Hashing for Message Authentication) アルゴリズム。

_Added in Python version 2.2_

このモジュールでは RFC 2104 で記述されている HMAC アルゴリズム
を実装しています。

`new(key[, msg[, digestmod]])'
     新たな hmac オブジェクトを返します。MSG が存在すれば、
     メソッド呼び出し `updateMSG' を行います。 DIGESTMOD は HMAC
     オブジェクトが使うダイジェストコンストラクタある
     いはモジュールです。標準では ``hashlib'.md5' コンストラク
     タになっています。_Note:_
     md5ハッシュには既知の脆弱性がありますが、後方互
     換性を考慮してデフォルトのままにしています。使用するアプリケーションにあ
     わせてよりよいものを選択してください。

HMAC オブジェクトは以下のメソッドを持っています:

`update(msg)'
     hmac オブジェクトを文字列 MSG で更新します。繰り返し呼び出し
     を行うと、それらの引数を全て結合した引数で単一の呼び出しをした
     際と同じに等価になります: すなわち `m.update(a); m.update(b)' は
     `m.update(a + b)' と等価です。

`digest()'
     これまで `update()' メソッドに渡された文字列のダイジェスト値
     を返します。これは`digest_size'バイトの文字列で、NULL バイトを含む
     非 ASCII 文字が含まれることがあります。

`hexdigest()'
     `digest()'と似ていますが、返される文字列は倍の長さとなり、16進形
     式となります。これは、電子メールなどの非バイナリ環境で値を交換する場合に
     便利です。

`copy()'
     hmac オブジェクトのコピー ("クローン") を返します。このコピー
     は最初の部分文字列が共通になっている文字列のダイジェスト値を効率
     よく計算するために使うことができます。

See also:
     *Note hashlib::
     セキュアハッシュ関数を提供するpythonモジュールです。


File: python-lib-jp.info,  Node: md5,  Next: sha,  Prev: hmac,  Up: 暗号関連のサービス

10.3 MD5 メッセージダイジェストアルゴリズム
===========================================

RSA's MD5 message digest algorithm.

_This is deprecated in Python 2.5.  代わりにモジュール `hashlib'
を使ってくださ い。_

このモジュールは RSA 社の MD5 メッセージダイジェスト アルゴリズムへのインタフェースを実装しています。
(Internet RFC 1321 も参照してください)。利用方法は極めて単純 です。まず
md5 オブジェクトを `new()' を使って生成します。 後は `update()'
メソッドを使って、生成されたオブジェクトに
任意の文字列データを入力します。オブジェクトに入力された文字列
データ全体の "digest" ("fingerprint" として知られる強力な 128-bit
チェックサム) は `digest()' を使っていつでも調べる ことができます。 

例えば、文字列 `'Nobody inspects the spammish repetition''
のダイジェストを得るためには以下のようにします:

     >>> import md5
     >>> m = md5.new()
     >>> m.update("Nobody inspects")
     >>> m.update(" the spammish repetition")
     >>> m.digest()
     '\xbbd\x9c\x83\xdd\x1e\xa5\xc9\xd9\xde\xc9\xa1\x8d\xf0\xff\xe9'

もっと詰めて書くと以下のようになります:

     >>> md5.new("Nobody inspects the spammish repetition").digest()
     '\xbbd\x9c\x83\xdd\x1e\xa5\xc9\xd9\xde\xc9\xa1\x8d\xf0\xff\xe9'

以下の値はモジュールの中で定数として与えられており、`new()' で返される
md5 オブジェクトの属性としても与えられます:

`digest_size'
     返されるダイジェスト値のバイト数で表した長さ。常に `16' です。

md5 クラスオブジェクトは以下のメソッドをサポートします:

`new([arg])'
     新たな md5 オブジェクトを返します。もし ARG が存在するなら、
     `update(ARG)' を呼び出します。

`md5([arg])'
     下位互換性のために、`new()' の別名として提供されています。

md5 オブジェクトは以下のメソッドをサポートします:

`update(arg)'
     文字列 ARG を入力として md5 オブジェクトを更新します。
     このメソッドを繰り返して呼び出す操作は、それぞれの呼び出し時の引数
     ARG を結合したデータを引数として一回の呼び出す操作と同等
     になります: つまり、`m.update(a); m.update(b)' は `m.update(a+b)'
     と同等です。

`digest()'
     これまで `update()' で与えてきた文字列入力のダイジェストを
     返します。返り値は 16 バイトの文字列で、null バイトを含む非 ASCII
     文字が入っているかもしれません。

`hexdigest()'
     `digest()' に似ていますが、ダイジェストは長さ 32 の文字列
     になり、16 進表記文字しか含みません。この文字列は電子メールやその
     他のバイナリを受け付けない環境でダイジェストを安全にやりとりする
     ために使うことができます。

`copy()'
     md5 オブジェクトのコピー ("クローン")
     を返します。冒頭の部分文字列が
     共通な複数の文字列のダイジェストを効率よく計算する際に使うことができます。

See also:
     *Note sha:: Secure Hash Algorithm (SHA)
     を実装した類似のモジュール。 SHA
     アルゴリズムはより安全なハッシュアルゴリズムだと考えられています。


File: python-lib-jp.info,  Node: sha,  Prev: md5,  Up: 暗号関連のサービス

10.4 SHA-1 メッセージダイジェストアルゴリズム
=============================================

NISTのセキュアハッシュアルゴリズム、SHA。

_This is deprecated in Python 2.5.  かわりにモジュール `hashlib'
を使ってくださ い。_

このモジュールは、 SHA-1 として知られている、 NISTの  セキュアハッシュアルゴリズムへのインターフェースを
実装しています。SHA-1 はオリジナルの SHA ハッシュアルゴリズムを改善した
バージョンです。`md5' モジュールと同じように使用します。: sha
オブジェクトを生成するために `new()' を使い、 `update()'
メソッドを使って、このオブジェクトに任意の文字列を入力し、
それまでに入力した文字列全体の "digest" をいつでも調べることができます。  SHA-1
のダイジェストは MD5 の 128 bit とは異なり、 160 bit です。

`new([string])'
     新たな sha オブジェクトを返します。もし STRING
     が存在するなら、`update(STRING)' を呼び出します。

以下の値はモジュールの中で定数として与えられており、`new()' で返される
sha オブジェクトの属性としても与えられます:

`blocksize'
     ハッシュ関数に入力されるブロックのサイズ。 このサイズは常に `1'
     です。
     このサイズは、任意の文字列をハッシュできるようにするために使われます。

`digest_size'
     返されるダイジェスト値をバイト数で表した長さ。常に 20 です。

sha オブジェクトには md5 オブジェクトと同じメソッドがあります。

`update(arg)'
     文字列 ARG を入力として sha オブジェクトを更新します。
     このメソッドを繰り返し呼び出す(操作は、それぞれの呼び出し時の引数を結合した
     データを引数として一回の呼び出す操作と同等になります。つまり、
     `m.update(a); m.update(b)' は `m.update(a+b)' と同等です。

`digest()'
     これまで update() メソッド
     で与えてきた文字列のダイジェストを返します。 戻り値は 20
     バイトの文字列で、nullバイトを含む非 ASCII 文字が入っているか
     もしれません。

`hexdigest()'
     `digits()'
     と似ていますが、ダイジェストは長さ40の文字列になり、16進表記数字しか含みません。
     電子メールやその他のバイナリを受け付けない環境で安全に値をやりとりするために使うことができます。

`copy()'
     sha オブジェクトのコピー("クローン")を返します。
     冒頭の部分文字列が共通な複数の文字列のダイジェストを効率よく計算する際に使う
     ことができます。

See also:
     `セキュアハッシュスタンダード' {セキュアハッシュアルゴリズムは
     NIST のドキュメント FIPS PUB 180-2 で定義されています。 ,
     2002年8月出版。}

     `暗号ツールキット (セキュアハッシュ)'
     {NISTからはられているセキュアハッシュに関するさまざまな情報へのリンク}


File: python-lib-jp.info,  Node: ファイルとディレクトリへのアクセス,  Next: データ圧縮とアーカイブ,  Prev: 暗号関連のサービス,  Up: Top

11 ファイルとディレクトリへのアクセス
*************************************

この章で説明されるモジュールはディスクのファイルやディレクトリを扱いま
す。たとえば、ファイルの属性を読むためのモジュール、ファイルパスを移植
可能な方式で操作する、テンポラリファイルを作成するためのモジュールです。
この章の完全な一覧は:

Python組み込みのファイルオブジェクトについては *Note
ファイルオブジェクト::をごらんください。

See also:
     *Note os:: オペレーティングシステムのインタフェース、組み込み
     のファイルオブジェクトより低レベルでのファイル操作を含む。

* Menu:

* ospath::
* fileinput::
* stat::
* statvfs::
* filecmp::
* tempfile::
* glob::
* fnmatch::
* linecache::
* shutil::
* dircache::


File: python-lib-jp.info,  Node: ospath,  Next: fileinput,  Prev: ファイルとディレクトリへのアクセス,  Up: ファイルとディレクトリへのアクセス

11.1 共通のパス名操作
=====================

共通のパス名操作。

このモジュールには、パス名を操作する便利な関数が定義されています。

_これらの関数の多くはWindowsの一律命名規則（UNCパス名）を正しく
サポートしていません。`splitunc()'と`ismount()'は正し
くUNCパス名を操作できます。_

`abspath(path)'
     PATHの標準化された絶対パスを返します。
     たいていのプラットフォームでは、 `normpath(join(os.getcwd(),
     PATH))'と同じ結果になります。 _Added in Python version 1.5.2_

`basename(path)'
     パス名PATHの末尾のファイル名を返します。
     これは`split(PATH)'で返されるペアの２番目の要素です。
     この関数が返す値はUNIXの `basename'とは異なります；
     UNIXの`basename'は`'/foo/bar/''に対して
     `'bar''を返しますが、`basename()'は空文字列(`''') を返します。

`commonprefix(list)'
     パスのLISTの中の共通する最長のプレフィックスを（パス名の１文字１文
     字を判断して）返します。
     もしLISTが空なら、空文字列(`''')を返します。
     これは一度に１文字を扱うため、不正なパスを返すことがあるかもしれませんの
     で注意して下さい。

`dirname(path)'
     パスPATHのディレクトリ名を返します。
     これは`split(PATH)'で返されるペアの最初の要素です。

`exists(path)'
     PATHが存在するなら、`True'を返します。
     壊れたシンボリッックリンクについては`False'を返します。
     いくつかのプラットフォームでは、 たとえ PATH
     が物理的に存在していたとしても、 リクエストされたファイルに対する
     `os.stat()' の実行が許可されなければ この関数が `False'
     を返すことがあります。

`lexists(path)'
     PATH が存在するパスなら`True' を返す。
     壊れたシンボリッックリンクについては`True'を返します。
     `os.lstat()'がない環境では`exists()'と同じです。 _Added in Python
     version 2.4_

`expanduser(path)'
     UNIXでは、 与えられた引数の先頭のパス要素`~'または`~USER'を、
     USERのホームディレクトリのパスに置き換えて返します。
     先頭の`~'は、環境変数`HOME'が設定されているならその値に置き換えられます。
     そうでなければ、現在のユーザのホームディレクトリをビルトインモジュール
     `pwd' を使ってパスワードディレクトリ から探して置き換えます。
     先頭の`~USER'については、直接パスワードディレクトリから探します。

     Windows では`~'だけがサポートされ、環境変数`HOME'または
     `HOMEDRIVE'と`HOMEPATH'の組み合わせで置き換えられます。

     もし置き換えに失敗したり、引数のパスがチルダで始まっていなかったら、パス
     をそのまま返します。

`expandvars(path)'
     引数のパスを環境変数に展開して返します。
     引数の中の`$NAME'または`${NAME}'の文字列が
     環境変数のNAMEに置き換えられます。
     不正な変数名や存在しない変数名の場合には変換されず、そのまま返します。

`getatime(path)'
     PATHに最後にアクセスした時刻を、エポック（`time'モジュール
     を参照）からの経過時間を示す秒数で返します。
     ファイルが存在しなかったりアクセスできない場合は`os.error'を発
     生します。 _Changed in Python version 2.3_ _Added in Python
     version 1.5.2_

`getmtime(path)'
     PATHの最終更新時刻を、エポック（`time'モジュールを参照）
     からの経過時間を示す秒数で返します。
     ファイルが存在しなかったりアクセスできない場合は`os.error'を発
     生します。 _Changed in Python version 2.3_ _Added in Python
     version 1.5.2_

`getctime(path)'
     システムによって、ファイルの最終変更時刻 (UNIX のような システム)
     や 作成時刻 (Windows のようなシステム) をシステムの ctime
     で返します。
     戻り値はエポック（`time'モジュールを参照）からの経過秒数を
     示す数値です。
     ファイルが存在しなかったりアクセスできない場合は`os.error'を発
     生します。 _Added in Python version 2.3_

`getsize(path)'
     ファイルPATHのサイズをバイト数で返します。
     ファイルが存在しなかったりアクセスできない場合は`os.error'を発
     生します。 _Added in Python version 1.5.2_

`isabs(path)'
     PATHが絶対パス（スラッシュで始まる）なら、`True'を返します。

`isfile(path)'
     PATHが存在する正しいファイルなら、TRUEを返します。
     シンボリックリンクの場合にはその実体をチェックするので、同じパスに対して
     `islink()'と`isfile()'の両方がTRUEを返すことがあ ります。

`isdir(path)'
     PATHが存在するなら、`True'を返します。
     シンボリックリンクの場合にはその実体をチェックするので、同じパスに対して
     `islink()'と`isfile()'の両方がTRUEを返すことがあ ります。

`islink(path)'
     PATHがシンボリックリンクなら、`True'を返します。
     シンボリックリンクがサポートされていないプラットフォームでは、常に
     `False'を返します。

`ismount(path)'
     パス名PATHがマウントポイント"mount point"（ファイルシステムの
     中で異なるファイルシステムがマウントされているところ）なら、`True'
     を返します： この関数はPATHの親ディレクトリである`PATH/..'が
     PATHと異なるデバイス上にあるか、あるいは`PATH/..'と
     PATHが同じデバイス上の同じi-nodeを指しているかをチェックします--
     これによって全てのUNIXとPOSIX標準でマウントポイントが検出できま
     す。

`join(path1[, path2[, ...]])'
     １つあるいはそれ以上のパスの要素をうまく結合します。
     付け加える要素に絶対パスがあれば、それより前の要素は(Windows
     ではドライブ名
     があればそれも含めて)全て破棄され、以降の要素を結合します。
     戻り値はPATH1と省略可能なPATH2以降を結合したもので、
     PATH2が空文字列でないなら、ディレクトリの区切り文字(`os.sep')
     が各要素の間に挿入されます。
     Windowsでは各ドライブに対してカレントディレクトリがあるので、
     `os.path.join("c:", "foo")'によって、
     `c:\\foo'ではなく、ドライブ`C:'上の
     カレントディレクトリからの相対パス（`c:foo'）が返されます。

`normcase(path)'
     パス名の大文字、小文字をシステムの標準にします。
     UNIXではそのまま返します。大文字、小文字を区別しないファイルシステム
     ではパス名を小文字に変換します。
     Windowsでは、スラッシュをバックスラッシュに変換します。

`normpath(path)'
     パス名を標準化します。
     余分な区切り文字や上位レベル参照を削除し、`A//B'、
     `A/./B'、`A/foo/../B'が全て`A/B'になるようにします。
     大文字、小文字は標準化しません（それには`normcase()'を使って下
     さい）。 Windowsでは、スラッシュをバックスラッシュに変換します。
     パスがシンボリックリンクを含んでいるかによって意味が変わることに注意し
     てください。

`realpath(path)'
     パスの中のシンボリックリンク(もしそれが当該オペレーティングシステムで
     サポートされていれば)を取り除いて、標準化したパスを返します。
     _Added in Python version 2.2_

`samefile(path1, path2)'
     ２つの引数であるパス名が同じファイルあるいはディレクトリを指していれば（
     同じデバイスナンバーとi-nodeナンバーで示されていれば）、`True'を返
     します。
     どちらかのパス名で`os.stat()'の呼び出しに失敗した場合には、例外
     が発生します。 利用可能：Macintosh、UNIX

`sameopenfile(fp1, fp2)'
     ファイルディスクリプタFP1とFP2が同じファイルを指していたら、
     `True'を返します。 利用可能：Macintosh、UNIX

`samestat(stat1, stat2)'
     statタプルSTAT1とSTAT2が同じファイルを指していたら、
     `True'を返します。 これらのタプルは`fstat()'、`lstat()'や
     `stat()'で返されたものでかまいません。
     この関数は、`samefile()'と`sameopenfile()'で使われるの
     と同様なものを背後に実装しています。 利用可能：Macintosh、UNIX

`split(path)'
     パス名PATHを`(HEADとTAIL)'のペアに分割します。
     TAILはパスの構成要素の末尾で、HEADはそれより前の部分です。
     TAILはスラッシュを含みません；もしPATHの最後にスラッシュがあ
     れば、TAILは空文字列になります。
     もしPATHにスラッシュがなければ、HEADは空文字列になります。
     PATHが空文字列なら、HEADとTAILのどちらも空文字列になり ます。
     HEADの末尾のスラッシュは、HEADがルートディレクトリ（１つ以上
     のスラッシュのみ）でない限り、取り除かれます。
     ほとんど全ての場合、`join(HEAD, TAIL)'の結果が
     PATHと等しくなります（ただ１つの例外は、複数のスラッシュが
     HEADとTAILを分けている時です）。

`splitdrive(path)'
     パス名PATHを`(DRIVE,TAIL)'のペアに分割します。
     DRIVEはドライブ名か、空文字列です。
     ドライブ名を使用しないシステムでは、DRIVEは常に空文字列です。
     全ての場合に`DRIVE + TAIL'はPATHと等しくなりま す。 _Added in
     Python version 1.3_

`splitext(path)'
     パス名PATHを`(ROOT, EXT)'のペアにします。 `ROOT + EXT ==
     PATH'になります。
     EXTは空文字列か１つのピリオドで始まり、多くても１つのピリオドを含
     みます。

`splitunc(path)'
     パス名PATHをペア `(UNC, REST)' に分割します。
     ここでUNCは(`r'\\host\mount''のような)UNCマウントポイント、
     そしてRESTは(`r'\path\file.ext''のような)パスの残りの部分です。
     ドライブ名を含むパスでは常にUNCが空文字列になります。 利用可能:
     Windows。

`walk(path, visit, arg)'
     PATHをルートとする各ディレクトリに対して（もしPATHがディレク
     トリならPATHも含みます）、`(ARG, DIRNAME,
     NAMES)'を引数として関数VISITを呼び出します。
     引数DIRNAMEは訪れたディレクトリを示し、引数NAMESはそのディレ
     クトリ内のファイルのリスト（`os.listdir(DIRNAME)'で得られる）
     です。 関数VISITによってNAMESを変更して、DIRNAME以下の対象と
     なるディレクトリのセットを変更することもできます。例えば、あるディレクト
     リツリーだけ関数を適用しないなど。
     （NAMESで参照されるオブジェクトは、`del'あるいはスライスを
     使って正しく変更しなければなりません。）

     _Notice:_
     ディレクトリへのシンボリックリンクはサブディレクトリとして扱われないの
     で、`walk()'による操作対象とはされません。
     ディレクトリへのシンボリックリンクを操作対象とするには、
     `os.path.islink(FILE)'と`os.path.isdir(FILE)'
     で識別して、`walk()'で必要な操作を実行しなければなりません。

     _Note:_ 新たに追加された``os'.walk()' ジェネレータを
     使用すれば、同じ処理をより簡単に行う事ができます。

`supports_unicode_filenames'
     任意のユニコード文字列を（ファイルシステムの制限内で）
     ファイルネームに使うことが可能で、`os.listdir'がユニコード文字列の
     引数に対してユニコードを返すなら、真を返します。 _Added in Python
     version 2.3_


File: python-lib-jp.info,  Node: fileinput,  Next: stat,  Prev: ospath,  Up: ファイルとディレクトリへのアクセス

11.2 複数の入力ストリームをまたいだ行の繰り返し処理をサポートする。
===================================================================

Perlのような複数の入力ストリームをまたいだ行の繰り返し処理をサポートする
(その場で保存する機能つき)。

このモジュールは標準入力やファイルの並びにまたがるループを素早く書くため
のヘルパークラスと関数を提供しています。

典型的な使い方は以下の通りです:

     import fileinput
     for line in fileinput.input():
         process(line)

このプログラムは`sys.argv[1:]'に含まれる全てのファイルをまたいで繰
り返します。もし該当するものがなければ、`sys.stdin'がデフォルトとし
て扱われます。ファイル名として`'-''が与えられた場合も、
`sys.stdin'に置き換えられます。別のファイル名リストを使いたい時には、
`input()'の最初の引数にリストを与えます。単一ファイル名の文字列
も受け付けます。

全てのファイルはデフォルトでテキストモードでオープンされます。しかし、
`input()' や `FileInput()' をコールする際に MODE
パラメータを指定すれば、これをオーバーライドすることができます。
オープン中あるいは読み込み中にI/Oエラーが発生した場合には、
`IOError'が発生します。

`sys.stdin'が2回以上使われた場合は、2回目以降は行を返しません。
ただしインタラクティブに利用している時や明示的にリセット
(`sys.stdin.seek(0))'を使う)を行った場合はその限りではありません。

空のファイルは開いた後すぐ閉じられます。
空のファイルはファイル名リストの最後にある場合にしか外部に影響を与えませ
ん。

ファイルの最後が改行文字で終っていない場合には、最後に改行文字を追加して
返します。

ファイルのオープン方法を制御するためのオープン時フックは、 `input()'
あるいは `FileInput()' の OPENHOOK
パラメータで設定します。このフックは、ふたつの引数 FILENAME と MODE
をとる関数でなければなりません。そしてその関数の返り値は
オープンしたファイルオブジェクトとなります。このモジュールには、便利な
フックが既に用意されています。

以下の関数がこのモジュールの基本的なインタフェースです:

`input([files[, inplace[, backup[, mode[, openhook]]]]])'
     `FileInput'クラスのインスタンスを作ります。生成されたインスタンス
     は、このモジュールの関数群が利用するグローバルな状態として利用されます。
     この関数への引数は`FileInput'クラスのコンストラクタへ渡されます。

     _Changed in Python version 2.5_

以下の関数は`input()'関数によって作られたグローバルな状態を利用
します。アクティブな状態が無い場合には、`RuntimeError'が発生し ます。

`filename()'
     現在読み込み中のファイル名を返します。一行目が読み込まれる前は
     `None'を返します。

`fileno()'
     現在のファイルの "ファイルデスクリプタ" を整数値で返します。ファイ
     ルがオープンされていない場合 (最初の行の前、ファイルとファイルの間)
     は `-1' を返します。 _Added in Python version 2.5_

`lineno()'
     最後に読み込まれた行の、累積した行番号を返します。1行目が読み込まれる前
     は`0'を返します。最後のファイルの最終行が読み込まれた後には、その
     行の行番号を返します。

`filelineno()'
     現在のファイル中での行番号を返します。1行目が読み込まれる前は`0'を
     返します。最後のファイルの最終行が読み込まれた後には、その
     行のファイル中での行番号を返します。


`isfirstline()'
     最後に読み込まれた行がファイルの1行目ならTrue、そうでなければFalseを返します。


`isstdin()'
     最後に読み込まれた行が`sys.stdin'から読まれていればTrue、そうでなけ
     ればFalseを返します。

`nextfile()'
     現在のファイルを閉じます。次の繰り返しでは(存在すれば)次のファイルの最初
     の行が読み込まれます。閉じたファイルの読み込まれなかった行は、累積の行
     数にカウントされません。ファイル名は次のファイルの最初の行が読み込まれ
     るまで変更されません。最初の行の読み込みが行われるまでは、この関数は呼
     び出されても何もしませんので、最初のファイルをスキップするために利用す
     ることはできません。最後のファイルの最終行が読み込まれた後にも、この関
     数は呼び出されても何もしません。


`close()'
     シーケンスを閉じます。

このモジュールのシーケンスの振舞いを実装しているクラスの
サブクラスを作ることもできます。

`FileInput([files[, inplace[, backup[, mode[, openhook]]]]])'
     `FileInput'クラスはモジュールの関数に対応するメソッド
     `filename()'、`fileno()'、`lineno()'、
     `fileline()'、`isfirstline()'、`isstdin()'、 `nextfile()' および
     `close()' を実装しています。それに加えて、次の入力行を返す
     `readline()'メソッドと、シーケンスの振舞
     いの実装をしている`__getitem__()'メソッドがあります。
     シーケンスはシーケンシャルに読み込むことしかできません。つまりランダムア
     クセスと`readline()'を混在させることはできません。

     MODE を使用すると、`open()' に渡すファイルモードを指
     定することができます。これは `'r''、`'rU''、`'U'' お よび `'rb''
     のうちのいずれかとなります。

     OPENHOOK を指定する場合は、ふたつの引数 FILENAME と MODE
     をとる関数でなければなりません。この関数の返り値は、オー
     プンしたファイルオブジェクトとなります。INPLACE と OPENHOOK
     を同時に使うことはできません。

     _Changed in Python version 2.5_

*その場で保存するオプション機能:*

キーワード引数 `INPLACE=1' が `input()'か
`FileInput'クラスのコンストラクタに渡された場合には、
入力ファイルはバックアップファイルに移動され、標準出力が入力ファイルに設
定されます(バックアップファイルと同じ名前のファイルが既に存在していた
場合には、警告無しに置き替えられます)。
これによって入力ファイルをその場で書き替えるフィルタを書くことができます。
キーワード引数`BACKUP='.<拡張子>''も与えられていれば、バック
アップファイルの拡張子を決めることができます。デフォルトでは
`'.bak''になっています。出力先のファイルが閉じられればバックアップ
ファイルは消されます。その場で保存する機能は、標準入力を読み込んでいる間
は無効にされます。

*警告:* 現在の実装はMS-DOSの8+3ファイルシステムでは動作しません。

このモジュールには、次のふたつのオープン時フックが用意されています。

`hook_compressed(filename, mode)'
     gzipやbzip2で圧縮された(拡張子が`'.gz''や`'.bz2''の)
     ファイルを、`gzip'モジュールや`bz2'モジュールを使って
     透過的にオープンします。ファイルの拡張子が`'.gz''や
     `'.bz2''でない場合は、通常通りファイルをオープンします
     (つまり、`open()' をコールする際に伸長を行いません)。

     使用例: `fi =
     fileinput.FileInput(openhook=fileinput.hook_compressed)'

     _Added in Python version 2.5_

`hook_encoded(encoding)'
     各ファイルを`codecs.open()'でオープンするフックを返します。
     指定したENCODINGでファイルを読み込みます。

     使用例: `fi =
     fileinput.FileInput(openhook=fileinput.hook_encoded("iso-8859-1"))'

     _Note:_ このフックでは、指定したENCODINGによっては
     `FileInput'がUnicode文字列を返す可能性があります。 _Added in
     Python version 2.5_


File: python-lib-jp.info,  Node: stat,  Next: statvfs,  Prev: fileinput,  Up: ファイルとディレクトリへのアクセス

11.3 `stat()' の返す内容を解釈する
==================================

`os.stat()'、`os.lstat()' および `os.fstat()'
の返す内容を解釈するためのユーティリティ群。

`stat' モジュールでは、`os.stat()'、 `os.lstat()' および `os.fstat()'
(存在すれば) の返す
内容を解釈するための定数や関数を定義しています。`stat()'、
`fstat()'、および `lstat()' の関数呼び出しについての
完全な記述はシステムのドキュメントを参照してください。

`stat' モジュールでは、特殊なファイル型を判別するための以下の
関数を定義しています:

`S_ISDIR(mode)'
     ファイルのモードがディレクトリの場合にゼロでない値を返します。

`S_ISCHR(mode)'
     ファイルのモードがキャラクタ型の特殊デバイスファイルの場合にゼロでない値を返します。

`S_ISBLK(mode)'
     ファイルのモードがブロック型の特殊デバイスファイルの場合にゼロでない値を返します。

`S_ISREG(mode)'
     ファイルのモードが通常ファイルの場合にゼロでない値を返します。

`S_ISFIFO(mode)'
     ファイルのモードが FIFO (名前つきパイプ)
     の場合にゼロでない値を返します。

`S_ISLNK(mode)'
     ファイルのモードがシンボリックリンクの場合にゼロでない値を返します。

`S_ISSOCK(mode)'
     ファイルのモードがソケットの場合にゼロでない値を返します。

より一般的なファイルのモードを操作するための二つの関数が定義されています:

`S_IMODE(mode)'
     `os.chmod()' で設定することのできる一部のファイルモード --
     すなわち、ファイルの許可ビット (permission bits) に加え、
     (サポートされているシステムでは) スティッキービット (sticky bit)、
     実行グループ ID 設定 (set-group-id) および 実行ユーザ ID 設定
     (set-user-id) ビット -- を返します。

`S_IFMT(mode)'
     ファイルの形式を記述しているファイルモードの一部 (上記の `S_IS*()'
     関数で使われます) を返します。

通常、ファイルの形式を調べる場合には `os.path.is*()' 関数
を使うことになります; ここで挙げた関数は同じファイルに対して
複数のテストを同時に行いたいが、`stat()' システムコール
を何度も呼び出してオーバヘッドが生じるのを避けたい場合に便利です。
これらはまた、ブロック型およびキャラクタ型デバイスに対するテスト
のように、`os.path' で扱うことのできないファイルの
情報を調べる際にも便利です。

以下の全ての変数は、`os.stat()'、 `os.fstat()'、または `os.lstat()'
が返す 10 要素のタプルにおけるインデクスを単に
シンボル定数化したものです。

`ST_MODE'
     I ノードの保護モード。

`ST_INO'
     I ノード番号。

`ST_DEV'
     I ノードが存在するデバイス。

`ST_NLINK'
     該当する I ノードへのリンク数。

`ST_UID'
     ファイルの所持者のユーザ ID。

`ST_GID'
     ファイルの所持者のグループ ID。

`ST_SIZE'
     通常ファイルではバイトサイズ; いくつかの特殊ファイルでは処理待ちの
     データ量。

`ST_ATIME'
     最後にアクセスした時刻。

`ST_MTIME'
     最後に変更された時刻。

`ST_CTIME'
     オペレーティングシステムから返される"ctime"。あるOS(UNIXなど)では最
     後にメタデータが更新された時間となり、別のOS(Windowsなど)では作成時間と
     なります(詳細については各プラットフォームのドキュメントを参照してください)。

"ファイルサイズ" の解釈はファイルの型によって異なります。
通常のファイルの場合、サイズはファイルの大きさをバイトで表した
ものです。ほとんどの UNIX 系 (特に Linux) における FIFO やソケット
の場合、"サイズ" は `os.stat()'、 `os.fstat()'、 あるいは `os.lstat()'
を呼び出した時点で読み出し待ちであった データのバイト数になります;
この値は時に有用で、特に上記の特殊なファイル
を非ブロックモードで開いた後にポーリングを行いたいといった場合に
便利です。他のキャラクタ型およびブロック型デバイスにおけるサイズ
フィーるの意味はさらに異なっていて、背後のシステムコールの実装に
よります。

例を以下に示します:

     import os, sys
     from stat import *

     def walktree(top, callback):
         '''recursively descend the directory tree rooted at top,
            calling the callback function for each regular file'''

         for f in os.listdir(top):
             pathname = os.path.join(top, f)
             mode = os.stat(pathname)[ST_MODE]
             if S_ISDIR(mode):
                 # It's a directory, recurse into it
                 walktree(pathname, callback)
             elif S_ISREG(mode):
                 # It's a file, call the callback function
                 callback(pathname)
             else:
                 # Unknown file type, print a message
                 print 'Skipping %s' % pathname

     def visitfile(file):
         print 'visiting', file

     if __name__ == '__main__':
         walktree(sys.argv[1], visitfile)


File: python-lib-jp.info,  Node: statvfs,  Next: filecmp,  Prev: stat,  Up: ファイルとディレクトリへのアクセス

11.4 `os.statvfs()' で使われる定数群
====================================

`os.statvfs()' の返す値を解釈するために使われる定数群。

`statvfs' モジュールでは、`os.statvfs()' の返す値
を解釈するための定数を定義しています。`os.statvfs()' は
"マジックナンバ" を記憶せずにタプルを生成して返します。
このモジュールで定義されている各定数は `os.statvfs()' が
返すタプルにおいて、特定の情報が収められている各エントリへの
_インデクス_ です。

`F_BSIZE'
     選択されているファイルシステムのブロックサイズです。

`F_FRSIZE'
     ファイルシステムの基本ブロックサイズです。

`F_BLOCKS'
     ブロック数の総計です。

`F_BFREE'
     空きブロック数の総計です。

`F_BAVAIL'
     非スーパユーザが利用できる空きブロック数です。

`F_FILES'
     ファイルノード数の総計です。

`F_FFREE'
     空きファイルノード数の総計です。

`F_FAVAIL'
     非スーパユーザが利用できる空きノード数です。

`F_FLAG'
     フラグで、システム依存です: `statvfs()' マニュアルページを
     参照してください。

`F_NAMEMAX'
     ファイル名の最大長です。


File: python-lib-jp.info,  Node: filecmp,  Next: tempfile,  Prev: statvfs,  Up: ファイルとディレクトリへのアクセス

11.5 ファイルおよびディレクトリの比較
=====================================

ファイル群を効率的に比較します。

`filecmp' モジュールでは、ファイルおよびディレクトリを
比較するため、様々な時間／正確性のトレードオフに関するオプションを
備えた関数を定義しています。

`filecmp' モジュールでは以下の関数を定義しています:

`cmp(f1, f2[, shallow])'
     名前が F1 および F2 のファイルを比較し、二つのファイルが
     同じらしければ `True' を返し、そうでなければ `false' を 返します。

     SHALLOW が与えられておりかつ偽でなければ、`os.stat()'
     の返すシグネチャが一致するファイルは同じであると見なされます。

     この関数で比較されたファイルは `os.stat()' シグネチャが
     変更されるまで再び比較されることはありません。USE_STATCACHE
     を真にすると、キャッシュ無効化機構を失敗させます -- そのため、
     `statcache' のキャッシュから古いファイル stat 値が 使われます。

     可搬性と効率のために、個の関数は外部プログラムを一切呼び出さないので
     注意してください。

`cmpfiles(dir1, dir2, common[, shallow])'
     ファイル名からなる 3つのリスト: MATCH、MISMATCH、 ERRORS
     を返します。MATCH には双方のディレクトリで
     一致したファイルのリストが含まれ、MISMATCH にはそうでない
     ファイル名のリストが入ります。そして ERRORS は比較されなかった
     ファイルが列挙されます。ファイルによっては、ユーザにそのファイル
     を読む権限がなかったり、比較を完了することができなかった場合以外
     のその他諸々の理由により、 ERRORS に列挙されることがあります。

     引数 COMMON は両方のディレクトリにあるファイルのリストです。 引数
     SHALLOW はその意味も標準 の設定も `filecmp.cmp()' と同じです。

例:

     >>> import filecmp
     >>> filecmp.cmp('libundoc.tex', 'libundoc.tex')
     True
     >>> filecmp.cmp('libundoc.tex', 'lib.tex')
     False

* Menu:

* dircmp クラス::


File: python-lib-jp.info,  Node: dircmp クラス,  Prev: filecmp,  Up: filecmp

11.5.1 `dircmp' クラス
----------------------

`dircmp' のインスタンスは以下のコンストラクタで生成されます:

`dircmp(a, b[, ignore[, hide]])'
     ディレクトリ A および B を比較するための新しいディレクトリ
     比較オブジェクトを生成します。IGNORE は比較の際に無視する
     ファイル名のリストで、標準の設定では `['RCS', 'CVS', 'tags']'
     です。HIDE は表示しない名前のリストで、標準の設定では `[os.curdir,
     os.pardir]' です。

`dircmp' クラスは以下のメソッドを提供しています:

`report()'
     A および B の間の比較結果を (`sys.stdout' に) 出力します。

`report_partial_closure()'
     A および B およびそれらの直下にある共通のサブディレクトリ
     間での比較結果を出力します。

`report_full_closure()'
     A および B およびそれらの共通のサブディレクトリ間での 比較結果を
     (再帰的に比較して) 出力します。

`dircmp' は、比較しているディレクトリツリーに関する様々な
種類の情報を取得するために使えるような、多くの興味深い属性を提供
しています。

`__getattr__()' フックを経由すると、全ての属性を
のろのろと計算するため、速度上のペナルティを受けないのは
計算処理の軽い属性を使ったときだけなので注意してください。

`left_list'
     A にあるファイルおよびサブディレクトリです。 HIDE および IGNORE
     でフィルタされています。

`right_list'
     B にあるファイルおよびサブディレクトリです。 HIDE および IGNORE
     でフィルタされています。

`common'
     A および B の両方にあるファイルおよびサブディレクトリです。

`left_only'
     A だけにあるファイルおよびサブディレクトリです。

`right_only'
     B だけにあるファイルおよびサブディレクトリです。

`common_dirs'
     A および B の両方にあるサブディレクトリです。

`common_files'
     A および B の両方にあるファイルです。

`common_funny'
     A および B の両方にあり、ディレクトリ間で
     タイプが異なるか、`os.stat()' がエラーを報告するような 名前です。

`same_files'
     A および B 両方にあり、一致するファイルです。

`diff_files'
     A および B 両方にあるが、一致しないファイルです。

`funny_files'
     A および B 両方にあるが、比較されなかったファイルです。

`subdirs'
     `common_dirs' のファイル名を `dircmp' オブジェクトに
     対応付けた辞書です。


File: python-lib-jp.info,  Node: tempfile,  Next: glob,  Prev: filecmp,  Up: ファイルとディレクトリへのアクセス

11.6 一時的なファイルやディレクトリの生成
=========================================

一時的なファイルやディレクトリを生成。

このモジュールを使うと、一時的なファイルやディレクトリを生成できます。
このモジュールはサポートされている全てのプラットフォームで利用可能
です。

バージョン 2.3 の Python では、このモジュールに対してセキュリティを
高める為の見直しが行われました。現在では新たに 3 つの関数、
`NamedTemporaryFile()'、 `mkstemp()'、および `mkdtemp()'
が提供されており、安全でない `mktemp' を使いつづける必要をなくしました。
このモジュールで生成される一時ファイルはもはやプロセス番号を
含みません; その代わり、6 桁のランダムな文字からなる文字列が
使われます。

また、ユーザから呼び出し可能な関数は全て、一時ファイルの場所や
名前を直接操作できるようにするための追加の引数をとるように
なりました。もはや変数 TEMPDIR および TEMPLATE を
使う必要はありません。以前のバージョンとの互換性を維持するために、
引数の順番は多少変です; 明確さのためにキーワード引数を使うことを
お勧めします。

このモジュールではユーザから呼び出し可能な以下の関数を定義しています:

`TemporaryFile([mode=`'w+b''[, bufsize=`-1'[, suffix[, prefix[, dir]]]]])'
     一時的な記憶領域として使うことができるファイル
     (またはファイル類似の) オブジェクトを返します。ファイルは
     `mkstemp' を使って 生成されます。このファイルは閉じられると
     (オブジェクトが
     ガーベジコレクションされた際に、暗黙のうちに閉じられる場合を含みます)
     すぐに消去されます。UNIX環境では、ファイルが生成されるとすぐに
     そのファイルのディレクトリエントリは除去されてしまいます。一方、他の
     プラットフォームではこの機能はサポートされていません; 従って、
     コードを書くときには、この関数で作成した一時ファイルをファイルシステム上で見る
     ことができる、あるいはできないということをあてにすべきではありません。

     生成されたファイルを一旦閉じなくてもファイルを読み書きできるように
     するために、MODE パラメタは標準で `'w+b'' に設定されています。
     ファイルに記録するデータが何であるかに関わらず全てのプラットフォームで
     一貫性のある動作をさせるために、バイナリモードが使われています。
     BUFSIZE の値は標準で `-1' で、これはオペレーティングシステム
     における標準の値を使うことを意味しています。

     DIR、PREFIX および SUFFIX パラメタは `mkstemp()' に渡されます。

`NamedTemporaryFile([mode=`'w+b''[, bufsize=`-1'[, suffix[, prefix[, dir]]]]])'
     この関数はファイルがファイルシステム上で見ることができるよう保証
     されている点を除き、`TemporaryFile()' と全く同じに働きます。
     (UNIXでは、ディレクトリ エントリはunlinkされません)
     ファイル名はファイルオブジェクトの `name' メンバから
     取得することができます。このファイル名を使って一時ファイルをもう一度
     開くとことができるかどうかは、プラットフォームによって異なります。
     (UNIXでは可能でしたが、Windows NT以降では開く事ができません。)

     _Added in Python version 2.3_

`mkstemp([suffix[, prefix[, dir[, text]]]])'
     可能な限り最も安全な手段で一時ファイルを生成します。
     使用するプラットフォームで`os.open()' の `O_EXCL'
     フラグが正しく実装されている限り、ファイルの生成で競合条件が起こる
     ことはありません。このファイルは、ファイルを生成したユーザのユーザ
     ID からのみ読み書き可能です。使用するプラットフォームにおいて、
     ファイルを実行可能かどうかを示す許可ビットが使われている場合、
     ファイルは誰からも実行不可なように設定されます。
     このファイルのファイル記述子は子プロセスに継承されません。

     `TemporaryFile()' と違って、`mkstemp()' で生成された
     ファイルが用済みになったときにファイルを消去するのはユーザの責任です。

     SUFFIX が指定された場合、ファイル名は指定された
     拡張子で終わります。そうでない場合には拡張子は付けられません。
     `mkstemp()' はファイル名と拡張子の間にドットを追加 しません;
     必要なら、SUFFIX の先頭につけてください。

     PREFIX が指定された場合、ファイル名は指定された
     プレフィクス(接頭文字列) で始まります; そうでない場合、標準の
     プレフィクスが使われます。

     DIR が指定された場合、一時ファイルは指定されたディレクトリ
     下に作成されます; そうでない場合、標準のディレクトリが使われます。

     TEXT が指定された場合、ファイルをバイナリモード (標準の設定)
     かテキストモードで開くかを示します。使用するプラットフォームによっては
     この値を設定しても変化はありません。

     `mkstemp()' は開かれたファイルを扱うための OS レベルの値
     とファイルの絶対パス名が順番に並んだタプルを返します。 _Added in
     Python version 2.3_

`mkdtemp([suffix[, prefix[, dir]]])'
     可能な限り安全な方法で一時ディレクトリを作成します。
     ディレクトリの生成で競合条件は発生しません。
     ディレクトリを作成したユーザ ID だけが、このディレクトリ
     に対して内容を読み出したり、書き込んだり、検索したりすることが
     できます。

     `mkdtemp()' によって作られたディレクトリとその内容が用済みに
     なった時、にそれを消去するのはユーザの責任です。

     PREFIX、SUFFIX、および DIR 引数は `mkstemp()' のものと同じです。

     `mkdtemp()' は新たに生成されたディレクトリの絶対パス名を 返します。
     _Added in Python version 2.3_

`mkdtemp([suffix[, prefix[, dir]]])'
     _This is deprecated in Python 2.3.  Use `mkstemp()' instead._

     一時ファイルの絶対パス名を返します。このパス名は少なくともこの関数が
     呼び出された時点ではファイルシステム中に存在しなかったパス名です。
     PREFIX、PREFIX、 SUFFIX、および DIR 引数は `mkstemp()'
     のものと同じです。

     _この関数を使うとプログラムのセキュリティホールになる可能性
     があります。この関数が返したファイル名を返した後、あなたがそのファイル名
     を使って次に何かをしようとする段階に至る前に、誰か他の人間が
     あなたにパンチをくらわせてしまうかもしれません。_

このモジュールでは、一時的なファイル名の作成方法を指定する 2 つの
グローバル変数を使います。これらの変数は上記のいずれかの関数を最初
に呼び出した際に初期化されます。関数呼び出しをおこなうユーザは
これらの値を変更することができますが、これはお勧めできません;
その代わりに関数に適切な引数を指定してください。

`tempdir'
     この値が `None' 以外に設定された場合、このモジュールで定義されて
     いる関数全てのDIR 引数に対する標準の設定値となります。

     TEMPDIR が設定されていないか `None' の場合、上記のいずれかの
     関数を呼び出した際は常に、Python は標準的なディレクトリ候補のリスト
     を検索し、関数を呼び出しているユーザの権限でファイルを作成できる
     最初のディレクトリ候補を TEMPDIR に設定します。リストは以下の
     ようになっています:

       1. 環境変数 `TMPDIR' で与えられているディレクトリ名。

       2. 環境変数 `TEMP' で与えられているディレクトリ名。

       3. 環境変数 `TMP' で与えられているディレクトリ名。

       4. プラットフォーム依存の場所:
             * RiscOS では環境変数 `Wimp$ScrapDir' で与えられて
               いるディレクトリ名。

             * Windows ではディレクトリ `C:\TEMP'、 `C:\TMP'、
               `\TEMP'、および `\TMP' の順。

             * その他の全てのプラットフォームでは、`/tmp'、
               `/var/tmp'、および `/usr/tmp' の順。

       5. 最後の手段として、現在の作業ディレクトリ。

`gettempdir()'
     現在選択されている、テンポラリファイルを作成するためのディレクトリ
     を返します。TEMPDIR が `None' でない場合、単にその内容 を返します;
     そうでない場合には上で記述されている検索が実行され、
     その結果が返されます。

`template'
     _This is deprecated in Python 2.0.  代わりに `gettempprefix()'
     を使ってください。_

     この値に `None' 以外の値を設定した場合、`mktemp()'
     が返すファイル名のディレクトリ部を含まない先頭部分 (プレフィクス)
     を 定義します。ファイル名を一意にするために、 6
     つのランダムな文字および
     数字がこのプレフィクスの後に追加されます。Windows では、標準の
     プレフィクスは`~T' です; 他のシステムでは `tmp' です。

     このモジュールの古いバージョンでは、`os.fork()' を呼び出した 後に
     `template' を `None' に設定することが必要でした;
     この仕様はバージョン 1.5.2 からは必要なくなりました。

`gettempprefix()'
     一時ファイルを生成する際に使われるファイル名の先頭部分を返します。
     この先頭部分にはディレクトリ部は含まれません。変数 TEMPLATE
     を直接読み出すよりもこの関数を使うことを勧めます。 _Added in
     Python version 1.5.2_


File: python-lib-jp.info,  Node: glob,  Next: fnmatch,  Prev: tempfile,  Up: ファイルとディレクトリへのアクセス

11.7 UNIX 形式のパス名のパターン展開
====================================

UNIX シェル形式のパス名のパターン展開。

`glob' モジュールはUNIX シェルで使われているルールに従って指定され
たパターンにマッチするすべてのパス名を見つけ出します。
チルダ展開は使えませ んが、`*'、 `?'と
`[]'で表される文字範囲には正しくマッチしま す。これは`os.listdir()'
関数と `fnmatch.fnmatch()'関数を 一緒に使って実行されていて、 実際に
subshell を呼び出しているわけではありま
せん。(チルダ展開とシェル変数展開を利用したければ、
`os.path.expantion()' と`os.path.expandvars()'を 使ってください。) 

`glob(pathname)'
     PATHNAME
     (パスの指定を含んだ文字列でなければいけません。)にマッチする
     空の可能性のあるパス名のリストを返します。

     PATHNAME は( `/usr/src/Python-1.5/Makefile'のように)絶対パスでも
     いいし、(`../../Tools/*/*.gif'のように)相対パスでもよくて、シェル形式の
     ワイルドカードを含んでいてもかまいません。
     結果には(シェルと同じく)壊れたシンボリックリンクも含まれます。

`iglob(pathname)'
     全ての値を一度に格納することなく`glob()'と同じ値を生成するすイ
     テレータを返します。 _Added in Python version 2.5_

`iglob(pathname)'
     実際には一度に全てを格納せずに、`glob()'と同じ値を順に生成するイテレータを返します。
     _Added in Python version 2.5_

たとえば、次のファイルだけがあるディレクトリを考えてください: `1.gif'、
`2.txt'、 and `card.gif'。`glob()'は次のような結果になり ます。
パスに接頭するどの部分が保たれているかに注意してください。

     >>> import glob
     >>> glob.glob('./[0-9].*')
     ['./1.gif', './2.txt']
     >>> glob.glob('*.gif')
     ['1.gif', 'card.gif']
     >>> glob.glob('?.gif')
     ['1.gif']

See also:
     *Note fnmatch:: シェル形式の(パスではない)ファイル名展開


File: python-lib-jp.info,  Node: fnmatch,  Next: linecache,  Prev: glob,  Up: ファイルとディレクトリへのアクセス

11.8 UNIX ファイル名のパターンマッチ
====================================

UNIX シェル形式のファイル名のパターンマッチ。

このモジュールは UNIX のシェル形式のワイルドカードへの対応を提供します
が、(`re'  モジュールでドキュメント化されている)
正規表現と同じでは_ありません_。シェル形式のワイルドカードで使われる特
別な文字は、

Pattern                              Meaning
------                               -----
*                                    すべてにマッチします
?                                    任意の一文字にマッチします
[SEQ]                                SEQにある任意の文字にマッチします
[!SEQ]                               SEQにない任意の文字にマッチします

ファイル名のセパレーター(UNIXでは`'/'')はこのモジュールに固有なもので
は _ない_ ことに注意してください。パス名展開については、 `glob' モジュールを参照してください
(`glob'はパス名の部分にマッチさせるのに`fnmatch()'を使っ
ています)。同様に、ピリオドで始まるファイル名はこのモジュールに固有ではなく
て、`*' と`?' のパターンでマッチします。

`fnmatch(filename, pattern)'
     filenameの文字列がpatternの文字列にマッチするかテストして、真、偽のいずれか
     を返します。
     オペレーティングシステムが大文字、小文字を区別しない場合、
     比較を行う前に、両方のパラメタを全て大文字、または全て小文字に揃えます。
     オペレーティングシステムが標準でどうなっているかに関係なく、大小文字を
     区別して比較したい場合には、`fnmatchcase()' を代わりに使って
     ください。


`fnmatchcase(filename, pattern)'
     FILENAME が PATTERN にマッチするかテストして、真、偽を返します。
     比較は大文字、小文字を区別します。

`filter(names, pattern)'
     PATTERN にマッチする NAMES のリストの部分集合を返します。 `[n for
     n in names if fnmatch(n, pattern)]'と同じですが、もっと効率よく
     実装しています。 _Added in Python version 2.2_

See also:
     *Note glob:: UNIX シェル形式のパス展開。


File: python-lib-jp.info,  Node: linecache,  Next: shutil,  Prev: fnmatch,  Up: ファイルとディレクトリへのアクセス

11.9 テキストラインにランダムアクセスする
=========================================

このモジュールによりテキストファイルの各行にランダムアクセスできます。

`linecache' モジュールは、キャッシュ
(一つのファイルから何行も読んでおくのが一般的です)を使って、
内部で最適化を図りつつ、任意のファイルの任意の行を取得するのを可能にします。

このモジュールは `traceback' モジュールで、インクルードしたソースを
フォーマットされたトレースバックで復元するのに使われています。

`linecache' モジュールでは次の関数が定義されています:

`getline(filename, lineno[, module_globals])'
     FILENAME という名前のファイルから LINENO 行目を取得します。
     この関数は決して例外を投げません -- エラーの際には `'''
     を返します。 (行末の改行文字は、見つかった行に含まれます。)

     FILENAME という名前のファイルが見つからなかった場合、 モジュールの  、つまり、
     `sys.path' で そのファイルを探します。

     zipfileやその他のファイルシステムでないimport元に対応するため まず
     MODULES_GLOBALS の PEP 302 `__loader__' をチェックし、そのあと
     `sys.path' を探索します。

     _Added in Python version 2.5_


`clearcache()'
     キャッシュをクリアします。 それまでに `getline()'
     を使って読み込んだファイルの行が必要でなくなったら、
     この関数を使ってください。

`checkcache([filename])'
     キャッシュが有効かチェックします。
     キャッシュしたファイルにディスク上で変更があったかもしれなくて、更新
     が必要なときにこの関数を使ってください。もしFILENAMEがなければ、
     全てのキャッシュエントリをチェックします。

サンプル:

     >>> import linecache
     >>> linecache.getline('/etc/passwd', 4)
     'sys:x:3:3:sys:/dev:/bin/sh\n'


File: python-lib-jp.info,  Node: shutil,  Next: dircache,  Prev: linecache,  Up: ファイルとディレクトリへのアクセス

11.10 高レベルなファイル操作
============================

コピーを含む高レベルなファイル操作。

`shutil'モジュールはファイルやファイルの収集に関する多くの高レベ
ルな操作方法を提供します。特にファイルのコピーや削除のための関数が用意さ
れています。

*注意:* MacOSにおいてはリソースフォークや他のメタデータは取り扱う
ことができません。

つまり、ファイルをコピーする際にこれらのリソースは失われたり、ファイルタ
イプや作成者コードは正しく認識されないことを意味します。

`copyfile(src, dst)'
     SRCで指定されたファイル内容をDSTで指定されたファイルへとコ
     ピーします。
     コピー先は書き込み可能である必要があります。そうでなければ
     `IOError'を発生します。 もしDSTが存在したら、置き換えられます。
     キャラクタやブロックデバイス、パイプ等の特別なファイルはこの関数ではコ
     ピーできません。 SRCとDSTにはパス名を文字列で与えられます。

`copyfileobj(fsrc, fdst[, length])'
     ファイル形式のオブジェクトFSRCの内容をFDSTへコピーします。
     整数値LENGTHはバッファサイズを表します。特に負のLENGTHは
     チャンク内のソースデータを繰り返し操作することなくコピーします。
     つまり標準ではデータは制御不能なメモリ消費を避けるためにチャンク内
     に読み込まれます。

`copymode(src, dst)'
     SRCからDSTへパーミッションをコピーします。ファイル内容や所
     有者、グループは影響を受けません。
     SRCとDSTには文字列としてパス名を与えられます。

`copystat(src, dst)'
     SRCからDSTへパーミッション最終アクセス時間、最終更新時間を
     コピーします。ファイル内容や所有者、グループは影響を受けません。
     SRCとDSTには文字列としてパス名を与えられます。

`copy(src, dst)'
     ファイルSRCをファイルまたはディレクトリDISTへコピーします。
     もし、DSTがディレクトリであればファイル名はSRCと同じものが
     指定されたディレクトリ内に作成（または上書き）されます。
     パーミッションはコピーされます。
     SRCとDSTには文字列としてパス名を与えられます。

`copy2(src, dst)'
     `copy()'と類似していますが、最終アクセス時間や最終更新時間も同
     様にコピーされます。これは  UNIX コマンドの `cp'
     `-p'と同様の働きをします。

`copytree(src, dst[, symlinks])'
     SRCを起点としてディレクトリーに既存のものは使えません。
     存在しない親ディレクトリも含めて作成されます。
     パーミッションと時刻は `copystat()'関数でコピーされます。
     個々のファイルは`copy2()'によってコピー されます。If
     SYMLINKSが真であれば、元のディレクトリ内の
     シンボリックリンクはコピー先のディレクトリ内へシンボリックリンクとして
     コピーされます。偽が与えられたり省略された場合は元のディレクトリ内のリ
     ンクの対象となっているファイルがコピー先のディレクトリ内へコピーされま
     す。エラーが発生したときはエラー理由のリストを持った`Error'を起こします。

     この関数のソースコードは道具としてよりも使用例として捉えられるべきでしょう。

     _Changed in Python version 2.3_

     _Changed in Python version 2.5_


`rmtree(path[, ignore_errors[, onerror]])'
     ディレクトリツリー全体を削除します。もしIGNORE_ERRORSが真であれば
     削除に失敗したことによるエラーは無視され、偽が与えられたり省略された場
     合はこれらのエラーはONERRORで与えられたハンドラを呼び出して処理
     され、これが省略された場合は例外を引き起こします。

     ONERRORが与えられた場合、それは3つのパラメータFUNCTION,
     PATHおよびEXCINFOを受け入れて呼び出し可能のものでなくてはな
     りません。最初のパラメータFUNCTIONは例外を引き起こす関数で
     `os.listdir()'、`os.remove()'または
     `os.rmdir()'が用いられるでしょう。
     二番目のパラメータはPATHはFUNCTIONへ渡らせるパス名です。
     三番目のパラメータEXCINFOは`sys.exc_info()'で返されるよ
     うな例外情報になるでしょう。ONERRORが引き起こす例外はキャッチでき
     ません。

`move(src, dst)'
     再帰的にファイルやディレクトリを別の場所へ移動します。

     もし移動先が現在のファイルシステム上であれば単純に名前を変更します。
     そうでない場合はコピーを行い、その後コピー元は削除されます。

     _Added in Python version 2.3_

`Error'
     この例外は複数ファイルの操作を行っているときに生じる例外をまとめたもの
     です。`copytree'に対しては例外の引数は3つのタプル(SRCNAME,
     DSTNAME, EXCEPTION)からなるリストです。

     _Added in Python version 2.3_

* Menu:

* 使用例 5::


File: python-lib-jp.info,  Node: 使用例 5,  Prev: shutil,  Up: shutil

11.10.1 使用例
--------------

以下は前述の`copytree()'関数のドキュメント文字列を省略した実装 例です。
本モジュールで提供される他の関数の使い方を示しています。

     def copytree(src, dst, symlinks=0):
         names = os.listdir(src)
         os.mkdir(dst)
         for name in names:
             srcname = os.path.join(src, name)
             dstname = os.path.join(dst, name)
             try:
                 if symlinks and os.path.islink(srcname):
                     linkto = os.readlink(srcname)
                     os.symlink(linkto, dstname)
                 elif os.path.isdir(srcname):
                     copytree(srcname, dstname, symlinks)
                 else:
                     copy2(srcname, dstname)
             except (IOError, os.error), why:
                 print "Can't copy %s to %s: %s" % (`srcname`, `dstname`, str(why))


File: python-lib-jp.info,  Node: dircache,  Prev: shutil,  Up: ファイルとディレクトリへのアクセス

11.11 キャッシュされたディレクトリ一覧の生成
============================================

キャッシュメカニズムを備えたディレクトリ一覧生成。

`durcache' モジュールはキャッシュされた情報を使って
ディレクトリ一覧を読み出すための関数を定義しています。
キャッシュはディレクトリの MTIME に応じて無効化されます。
さらに、一覧中のディレクトリにスラッシュ ('/') を追加することで
ディレクトリであると分かるようにするための関数も定義しています。

`dircache' モジュールは以下の関数を定義しています:

`reset()'
     ディレクトリキャッシュをリセットします。

`listdir(path)'
     `os.listdir()' によって得た PATH のディレクトリ一覧を
     返します。PATH を変えない限り、以降の `listdir()'
     を呼び出してもディレクトリ構造を読み込みなおすことはしないので
     注意してください。

     返されるリストは読み出し専用であると見なされるので注意してください
     (おそらく将来のバージョンではタプルを返すように変更されるはず ?
     です)。

`opendir(path)'
     `listdir()' と同じです。以前のバージョンとの互換性のために
     定義されています。

`annotate(head, list)'
     LIST を HEAD の相対パスからなるリストとして、
     各パスがディレクトリを指す場合には `/' をパス名の後ろ
     に追加したものに置き換えます。

     >>> import dircache
     >>> a = dircache.listdir('/')
     >>> a = a[:] # Copy the return value so we can change 'a'
     >>> a
     ['bin', 'boot', 'cdrom', 'dev', 'etc', 'floppy', 'home', 'initrd', 'lib', 'lost+
     found', 'mnt', 'proc', 'root', 'sbin', 'tmp', 'usr', 'var', 'vmlinuz']
     >>> dircache.annotate('/', a)
     >>> a
     ['bin/', 'boot/', 'cdrom/', 'dev/', 'etc/', 'floppy/', 'home/', 'initrd/', 'lib/
     ', 'lost+found/', 'mnt/', 'proc/', 'root/', 'sbin/', 'tmp/', 'usr/', 'var/', 'vm
     linuz']


File: python-lib-jp.info,  Node: データ圧縮とアーカイブ,  Next: データの永続化,  Prev: ファイルとディレクトリへのアクセス,  Up: Top

12 データ圧縮とアーカイブ
*************************

この章で説明されるモジュールは zlib, gzip, bzip2 アルゴリズムによるデー
タの圧縮と、 ZIP, tar フォーマットのアーカイブ作成をサポートする。

* Menu:

* zlib::
* gzip::
* bz2::
* zipfile::
* tarfile::


File: python-lib-jp.info,  Node: zlib,  Next: gzip,  Prev: データ圧縮とアーカイブ,  Up: データ圧縮とアーカイブ

12.1 `gzip' 互換の圧縮
======================

`gzip' 互換の圧縮／解凍ルーチンへの低レベル インタフェース

このモジュールでは、データ圧縮を必要とするアプリケーションが zlib
ライブラリ を使って圧縮および解凍を行えるようにします。 zlib
ライブラリ自体の Web ホームページは `http://www.zlib.net' です。
Pythonモジュールと zlib ライブラリの1.1.3より前のバージョンには互換性
のない部分があることが知られています。1.1.3にはセキュリティホールが存
在しますので、1.1.4以降のバージョンを利用することをお勧めします。

zlib
の関数にはたくさんのオプションがあり、しばしば特定の順番で使う必要があります。
このドキュメントでは順番のことについて全てを説明し尽くそうとはしていません。
信頼できる情報が必要ならば `http://www.zlib.net/manual.html' にある
zlib の マニュアルを参照するようにしてください。

このモジュールで利用可能な例外と関数を以下に示します:

`error'
     圧縮および解凍時のエラーによって送出される例外。

`adler32(string[, value])'
     STRING のAdler-32 チェックサムを計算します。 （Adler-32
     チェックサムは、おおむね CRC32 と同等の信頼性を持ちながら
     はるかに高速に計算することができます。） VALUE
     が与えられていれば、VALUE はチェックサム計算の
     初期値として使われます。それ以外の場合には固定のデフォルト値が
     使われます。この機能によって、複数の入力文字列を結合したデータ全体
     にわたり、通しのチェックサムを計算することができます。
     このアルゴリズムは暗号法論的には強力とはいえないので、認証やデジタル
     署名などに用いるべきではありません。このアルゴリズムはチェックサム
     アルゴリズムとして用いるために設計されたものなので、汎用的な
     ハッシュアルゴリズムには向きません。

`compress(string[, level])'
     STRING で与えられた文字列を圧縮し、圧縮されたデータを含む
     文字列を返します。 LEVEL は `1' から `9' までの
     整数をとる値で、圧縮のレベルを制御します。 `1' は最も高速
     で最小限の圧縮を行います。`9' はもっとも低速になりますが
     最大限の圧縮を行います。デフォルトの値は `6' です。
     圧縮時に何らかのエラーが発生した場合、 `error' 例外を 送出します。

`compressobj([level])'
     一度にメモリ上に置くことができないようなデータストリームを圧縮
     するための圧縮オブジェクトを返します。LEVEL は `1' から `9'
     までの整数で、圧縮レベルを制御します。`1' は
     もっとも高速で最小限の圧縮を、`9' はもっとも低速になりますが
     最大限の圧縮を行います。デフォルトの値は `6' です。

`crc32(string[, value])'
     STRING の CRC (Cyclic Redundancy Check, 巡回符号方式) チェックサムを計算します。VALUE
     が与えられていれば、チェックサム
     計算の初期値として使われます。与えられていなければデフォルトの初期値
     が使われます。VALUE を与えることで、複数の入力文字列を結合した
     データ全体にわたり、通しのチェックサムを計算することができます。
     このアルゴリズムは暗号法論的には強力ではなく、認証やデジタル署名
     に用いるべきではありません。アルゴリズムはチェックサムアルゴリズムと
     して設計されてえいるので、汎用のハッシュアルゴリズムには向きません。

`decompress(string[, wbits[, bufsize]])'
     STRING 内のデータを解凍して、解凍されたデータを含む文字列を
     返します。WBITS パラメタはウィンドウバッファの大きさを制御
     します。 BUFSIZE が与えられていれば、出力バッファの書記サイズ
     として使われます。解凍処理に何らかのエラーが生じた場合、 `error'
     例外を送出します。

     WBITS の絶対値は、データを圧縮する際に用いられるヒストリ
     バッファのサイズ (ウィンドウサイズ) に対し、 2 を底とする対数を
     とったものです。最近のほとんどのバージョンの zlib ライブラリを
     使っているなら、WBITS の絶対値は 8 から 15 とするべきです。
     より大きな値はより良好な圧縮につながりますが、より多くのメモリ
     を必要とします。デフォルトの値は 15 です。WBITS の値が
     負の場合、標準的な `gzip' ヘッダを出力しません。 これは zlib
     ライブラリの非公開仕様であり、`unzip' の
     圧縮ファイル形式に対する互換性のためのものです。

     BUFSIZE は解凍されたデータを保持するためのバッファサイズの
     初期値です。バッファの空きは必要に応じて必要なだけ増加するので、
     なれば、必ずしも正確な値を指定する必要はありません。この値の
     チューニングでできることは、 `malloc()' が呼ばれる回数を
     数回減らすことぐらいです。デフォルトのサイズは 16384 です。


`decompressobj([wbits])'
     メモリ上に一度に展開できないようなデータストリームを解凍するために
     用いられる解凍オブジェクトを返します。WBITS パラメタは
     ウィンドウバッファのサイズを制御します。

圧縮オブジェクトは以下のメソッドをサポートします:

`compress(string)'
     STRING を圧縮し、圧縮されたデータを含む文字列を返します。この
     文字列は少なくとも STRING に相当します。このデータは以前に呼んだ
     `compress()' が返した出力と結合することができます。入力の一部は
     以後の処理のために内部バッファに保存されることもあります。

`flush([mode])'
     未処理の入力データが処理され、この未処理部分を圧縮したデータを含む
     文字列が返されます。MODE は定数 `Z_SYNC_FLUSH' 、 `Z_FULL_FLUSH'
     、または `Z_FINISH' のいずれかをとり、 デフォルト値は `Z_FINISH'
     です。`Z_SYNC_FLUSH' および `Z_FULL_FLUSH'
     ではこれ以後にもデータ文字列を圧縮できる モードです。一方、
     `Z_FINISH' は圧縮ストリームを閉じ、これ以後のデータの圧縮
     を禁止します。 MODE に `Z_FINISH' を設定して `flush()'
     メソッドを呼び出した後は、`compress()'
     メソッドを再び呼ぶべきではありません。唯一の現実的な操作はこの
     オブジェクトを削除することだけです。

`copy()'
     圧縮オブジェクトのコピーを返します。これを使うと先頭部分が共通している複数のデータを
     効率的に圧縮することができます。 _Added in Python version 2.5_

解凍オブジェクトは以下のメソッドと 2 つの属性をサポートします:

`unused_data'
     圧縮データの末尾までのバイト列が入った文字列です。
     すなわち、この値は圧縮データの入っているバイト列の最後の文字
     までが読み出せるかぎり `""' となります。入力文字列全てが圧縮
     データを含んでいた場合、この属性は `""' 、すなわち空文字列に
     なります。

     圧縮データ文字列がどこで終了しているかを決定する唯一の
     方法は、実際にそれを解凍することです。つまり、大きなファイル
     の一部分に圧縮データが含まれているときに、その末端を調べるために
     は、データをファイルから読み出し、空でない文字列を後ろに続けて、
     `unused_data' が空文字列でなくなるまで、解凍オブジェクトの
     `decompress' メソッドに入力しつづけるしかありません。

`unconsumed_tail'
     解凍されたデータを収めるバッファの長さ制限を超えたために、最も最近の
     `decompress' 呼び出しで処理しきれなかったデータを含む文字列です。
     このデータはまだ zlib
     側からは見えていないので、正しい解凍出力を得るには 以降の
     `decompress' メソッド呼び出しに (場合によっては後続の
     データが追加された) データを差し戻さなければなりません。


`decompress(string[, max_length])'
     STRING を解凍し、少なくとも STRING の一部分に対応する
     解凍されたデータを含む文字列を返します。このデータは以前に
     `decompress()' メソッドを呼んだ時に返された出力と結合する
     ことができます。入力データの一部分が以後の処理のために内部バッファに
     保存されることもあります。

     オプションパラメタ MAX_LENGTH が与えられると、返される解凍データ
     の長さが MAX_LENGTH 以下に制限されます。このことは入力した圧縮
     データの全てが処理されるとは限らないことを意味し、処理されなかった
     データは `unconsumed_tail' 属性に保存されます。
     解凍処理を継続したいならば、この保存されたデータを以降の
     `decompress()' 呼び出しに渡さなくてはなりません。 MAX_LENGTH
     が与えられなかった場合、全ての入力が解凍され、 `unconsumed_tail'
     属性は空文字列になります。

`flush([length])'
     未処理の入力データを全て処理し、最終的に圧縮されなかった残りの
     出力文字列を返します。 `flush()' を呼んだ後、 `decompress()'
     を再度呼ぶべきではありません。このときできる唯一現実的な操作は
     オブジェクトの削除だけです。

     オプション引数 LENGTH は出力バッファの初期サイズを決めます。

`copy()'
     解凍オブジェクトのコピーを返します。これを使うとデータストリームの途中にある
     解凍オブジェクトの状態を保存でき、未来のある時点で行なわれるストリームの
     ランダムなシークをスピードアップするのに利用できます。 _Added in
     Python version 2.5_

See also:
     *Note gzip:: Reading and writing `gzip'-format files.

    `http://www.zlib.net'
          zlib ライブラリホームページ

    `http://www.zlib.net/manual.html'
          zlib ライブラリの 多くの関数の意味と使い方を解説したマニュアル



File: python-lib-jp.info,  Node: gzip,  Next: bz2,  Prev: zlib,  Up: データ圧縮とアーカイブ

12.2 `gzip' ファイルのサポート
==============================

ファイルオブジェクトを用いた `gzip'
圧縮および解凍のためのインタフェース `zlib'
モジュールで提供されているデータ圧縮は、GNU の 圧縮プログラム `gzip'
のものと互換性があります。 そこで、`gzip' モジュールでは、`gzip' 形式の
ファイルを読み書きするための `GzipFile' クラスを提供します。
このクラスのオブジェクトは自動的にデータを圧縮または解凍するので、
通常のファイルオブジェクトのように見えます。 `gzip' や `gunzip'
プログラムで解凍できる、 `compress' や `pack'
による他の形式の圧縮ファイルは
このモジュールではサポートされていないので注意してください。

このモジュールでは以下の項目を定義しています:

`GzipFile([filename[, mode[, compresslevel[, fileobj]]]])'
     `GzipFile' クラスのコンストラクタです。`GzipFile' オブジェクト は
     `readinto()' と `truncate()' メソッドを除くほとんどの
     ファイルオブジェクトのメソッドをシミュレートします。 少なくとも
     FILEOBJ および FILENAME は有効な値でなければ なりません。

     クラスの新しいインスタンスは、FILEOBJ に基づいて作成
     されます。FILEOBJ は通常のファイル、`StringIO'
     オブジェクト、そしてその他ファイルをシミュレートできる
     オブジェクトでかまいません。値はデフォルトでは None で、
     ファイルオブジェクトを生成するために FILENAME を開きます。

     `gzip' ファイルヘッダ中には、ファイルが解凍されたときの元の
     ファイル名を収めることができますが、FILEOBJ が `None'
     でない場合、引数 FILENAME がファイル名として認識できる文字列
     であれば、FILENAME はファイルヘッダに収めるためだけに使われ
     ます。そうでない場合（この値はデフォルトでは空文字列です）、
     元のファイル名はヘッダに収められません。

     MODE 引数は、ファイルを読み出すのか、書き込むのかによって、 `'r'',
     `'rb'', `'a'', `'ab'', `'w'', そして `'wb'',
     のいずれかになります。FILEOBJ の
     ファイルモードが認識可能な場合、MODE はデフォルトで FILEOBJ
     のモードと同じになります。そうでない場合、 デフォルトのモードは
     `'rb'' です。'b' フラグがついて
     いなくても、ファイルがバイナリモードで開かれることを保証するために
     'b' フラグが追加されます。これはプラットフォーム間での移植性の
     ためです。

     COMPRESSLEVEL 引数は `1' から `9' までの整数で、
     圧縮のレベルを制御します。`1' は最も高速で最小限の圧縮しか
     行いません。`9' は最も低速ですが、最大限の圧縮を行います。
     デフォルトの値は `9' です。

     圧縮したデータの後ろにさらに何か追記したい場合もあるので、
     `GzipFile' オブジェクトの `close()' メソッド呼び出し は FILEOBJ
     をクローズしません。この機能によって、書き
     込みのためにオープンした `StringIO' オブジェクトを FILEOBJ
     として渡し、（`GzipFile' を `close()' した後に） `StringIO'
     オブジェクトの `getvalue()' メソッドを使って
     書き込んだデータの入っているメモリバッファを取得することができます。

`open(filename[, mode[, compresslevel]])'
     `GzipFile(FILENAME,' `MODE,' `COMPRESSLEVEL)' の短縮形です。 引数
     FILENAME は必須です。デフォルトで MODE は`'rb'' に、 COMPRESSLEVEL
     は `9' に設定されています。

See also:
     *Note zlib:: `gzip' ファイル形式のサポートを行うために必要な
     基本ライブラリモジュール。


File: python-lib-jp.info,  Node: bz2,  Next: zipfile,  Prev: gzip,  Up: データ圧縮とアーカイブ

12.3 `bzip2' 互換の圧縮ライブラリ
=================================

`bzip2' 互換の圧縮／解凍ルーチンへのインタフェース

_Added in Python version 2.3_

このモジュールでは bz2
圧縮ライブラリのためのわかりやすいインタフェースを
提供します。モジュールでは完全なファイルインタフェース、データを一括
して圧縮（解凍）する関数、データを逐次的に圧縮（解凍）するためのクラス
型を実装しています。

bz2 モジュールで提供されている機能を以下にまとめます:

   * `BZ2File' クラスは、`readline()', `readlines()', `writelines()',
     `seek()' 等を含む、完全な ファイルインタフェースを実装します。

   * `BZ2File' クラスは `seek()' をエミュレーションで サポートします。

   * `BZ2File' クラスは広範囲の改行文字バリエーションを サポートします。

   * `BZ2File' クラスはファイルオブジェクトで言うところの先読み
     アルゴリズムを用いた行単位のイテレーション機能を提供します。

   * `BZ2Compressor' および`BZ2Decompressor' クラスでは
     逐次的圧縮（解凍）をサポートしています。

   * `compress()' および`decompress()' では
     一括圧縮（解凍）を関数サポートしています。

   * 個別のロックメカニズムによってスレッド安全性を持っています。

   * 埋め込みドキュメントが完備しています。

* Menu:

* ファイルの圧縮（解凍）::
* 逐次的な圧縮（解凍）::
* 一括圧縮（解凍）::


File: python-lib-jp.info,  Node: ファイルの圧縮（解凍）,  Next: 逐次的な圧縮（解凍）,  Prev: bz2,  Up: bz2

12.3.1 ファイルの圧縮（解凍）
-----------------------------

`BZ2File' クラスは圧縮ファイルの操作機能を提供しています。

`BZ2File(filename[, mode[, buffering[, compresslevel]]])'
     bz2 ファイルを開きます。ファイルのモードは `'r'' または `'w''
     で、それぞれ読み出しと書き込みに対応します。
     書き出し用に開いた場合、ファイルが存在しないなら新しく作成し、
     そうでない場合ファイルを切り詰ます。 BUFFERING
     パラメタを与えた場合、`0' はバッファリング
     なしを表し、それよりも大きい値はバッファサイズになります。
     デフォルトでは `0' です。圧縮レベルCOMPRESSLEVEL
     を与える場合、値は `1' から `9' までの整数値でなければ
     なりません。デフォルトの値は `9' です。
     ファイルへの入力に広範囲の改行文字バリエーションをサポートさせたい
     場合は `U' をファイルモードに追加します。
     入力ファイルの行末はどれも、Pythonからは `\n' として見えます。
     また、また、開かれているファイルオブジェクトは `newlines' 属性
     を持ち、`None' (まだ改行文字を読み込んでいない時), `'\r'', `'\n'',
     `'\r\n'' または全ての改行文字バリエーション
     を含むタプルになります。広範囲の改行文字サポートが利用できるのは
     読み込みだけです。`BZ2File' が生成するインスタンスは通常の
     ファイルインスタンスと同様のイテレーション操作をサポートしています。

`close()'
     ファイルを閉じます。オブジェクトのデータ属性 `closed' を真に
     します。閉じたファイルはそれ以後入出力操作の対象にできません。
     `close()' 自体の呼び出しはエラーを引き起こすことなく何度も
     実行できます。

`read([size])'
     最大で SIZE バイトの解凍されたデータを読み出し、文字列として
     返します。SIZE 引数を負の値にした場合や省略した場合、EOF に
     たどり着くまで読み出します。

`readline([size])'
     ファイルから次の 1 行を読み出し、改行文字も含めて文字列を返します。
     負でない SIZE 値は、返される文字列の最大バイト長を制限します
     (その場合不完全な行を返すこともあります)。 EOF の時には空文字列
     を返します。

`readlines([size])'
     ファイルから読み取った各行の文字列からなるリストを返します。
     オプション引数 SIZE を与えた場合、文字列リストの
     合計バイト長の大まかな上限の指定になります。

`xreadlines()'
     前のバージョンとの互換性のために用意されています。 `BZ2File'
     オブジェクトはかつて `xreadlines' モジュールで提供されて
     いたパフォーマンス最適化を含んでいます。 _This is deprecated in
     Python 2.3.  このメソッドは `file' オブジェクトの同名の
     メソッドとの互換性のために用意されていますが、現在は推奨されない
     メソッドです。代りに `for line in file' を使ってください。_


`seek(offset[, whence])'
     ファイルの読み書き位置を移動します。 引数 OFFSET はバイト数で
     指定したオフセット値です。 オプション引数 WHENCE はデフォルトで
     `0' (ファイルの 先頭からのオフセットで、offset `>= 0' になるはず)
     です。 他にとり得る値は `1'
     (現在のファイル位置からの相対位置で、正負
     どちらの値もとり得る)、および `2'
     (ファイルの終末端からの相対位置で、
     通常は負の値になるが、多くのプラットフォームではファイルの終末端を
     越えて seek できる) です。

     bz2 ファイルの seek
     はエミュレーションであり、パラメタの設定によっては
     処理が非常に低速になるかもしれないので注意してください。

`tell()'
     現在のファイル位置を整数（long
     整数になるかもしれません）で返します。

`write(data)'
     ファイルに文字列 DATA を書き込みます。バッファリングのため、
     ディスク上のファイルに書き込まれたデータを反映させるには `close()'
     が必要になるかもしれないので注意してください。

`writelines(sequence_of_strings)'
     複数の文字列からなるシーケンスをファイルに書き込みます。それぞれの
     文字列を書き込む際に改行文字を追加することはありません。
     シーケンスはイテレーション処理で文字列を取り出せる任意のオブジェクトに
     できます。この操作はそれぞれの文字列を write() を呼んで
     書き込むのと同じ操作です。


File: python-lib-jp.info,  Node: 逐次的な圧縮（解凍）,  Next: 一括圧縮（解凍）,  Prev: ファイルの圧縮（解凍）,  Up: bz2

12.3.2 逐次的な圧縮（解凍）
---------------------------

逐次的な圧縮および解凍は `BZ2Compressor' および `BZ2Decompressor'
クラスを用いて行います。

`BZ2Compressor([compresslevel])'
     新しい圧縮オブジェクトを作成します。このオブジェクトはデータを逐次的に
     圧縮できます。一括してデータを圧縮したいのなら、`compress()'
     関数を代りに使ってください。COMPRESSLEVEL パラメタを与える場合、
     この値は `1' and `9' の間の整数でなければなりません。
     デフォルトの値は `9' です。

`compress(data)'
     圧縮オブジェクトに追加のデータを入力します。圧縮データの
     チャンクを生成できた場合にはチャンクを返します。圧縮データの入力を
     終えた後は圧縮処理を終えるために `flush()' を呼んでください。
     内部バッファに残っている未処理のデータを返します。

`flush()'
     圧縮処理を終え、内部バッファに残されているデータを返します。
     このメソッドの呼び出し以降は同じ圧縮オブジェクトを使ってはなりません。

`BZ2Decompressor()'
     新しい解凍オブジェクトを生成します。このオブジェクトは逐次的にデータ
     を解凍できます。一括してデータを解凍したいのなら、 `decompress()'
     関数を代りに使ってください。

`decompress(data)'
     解凍オブジェクトに追加のデータを入力します。可能な限り、解凍データの
     チャンクを生成できた場合にはチャンクを返します。ストリームの末端に到達
     した後に解凍処理を行おうとした場合には、例外 `EOFError' を
     送出します。ストリームの終末端の後ろに何らかのデータがあった場合、
     解凍処理はこのデータを無視し、オブジェクトの `unused_data'
     属性に収めます。


File: python-lib-jp.info,  Node: 一括圧縮（解凍）,  Prev: 逐次的な圧縮（解凍）,  Up: bz2

12.3.3 一括圧縮（解凍）
-----------------------

一括での圧縮および解凍を行うための関数、`compress()' および
`decompress()' が提供されています。

`compress(data[, compresslevel])'
     DATA を一括して圧縮します。データを逐次的に圧縮したいなら、
     `BZ2Compressor' を代りに使ってください。もし COMPRESSLEVEL
     パラメタを与えるなら、この値は `1' から `9' をとらなくては
     なりません。デフォルトの値は `9' です。

`decompress(data)'
     DATA を一括して解凍します。データを逐次的に解凍したいなら、
     `BZ2Decompressor' を代りに使ってください。


File: python-lib-jp.info,  Node: zipfile,  Next: tarfile,  Prev: bz2,  Up: データ圧縮とアーカイブ

12.4 ZIP アーカイブの処理
=========================

ZIP-フォーマットのアーカイブファイルを読み書きする

_Added in Python version 1.6_

ZIP は一般によく知られているアーカイブ
（書庫化）および圧縮の標準ファイルフォーマットです。 このモジュールでは
ZIP 形式のファイルの作成、読み書き、追記、
書庫内のファイル一覧の作成を行うためのツールを提供します。
より高度な使い方でこのモジュールを利用したいなら、 .  に定義されている
ZIP ファイルフォーマットを理解することが必要に なるでしょう。

このモジュールは現在のところ、コメントを追記した ZIP ファイルや
マルチディスク ZIP ファイルを扱うことはできません。 ZIP64
拡張を利用する ZIP ファイル(サイズが 4GB を超えるような ZIP ファイル)
は扱えます。

このモジュールで利用できる属性を以下に示します:

`error'
     不備のある ZIP ファイル操作の際に送出されるエラー

`LargeZipFile'
     ZIP ファイルが ZIP64 の機能を必要とするとき、
     その機能が有効にされていないと送出されるエラー

`ZipFile'
     ZIP ファイルの読み書きのためのクラスです。
     コンストラクタの詳細については、 "" (*Note ZipFile オブジェクト::
     節) を参照してください。

`PyZipFile'
     Python ライブラリを含む ZIP アーカイブを生成するためのクラスです。

`ZipInfo([filename[, date_time]])'
     アーカイブ中のメンバに関する情報を提供するために用いられるクラスです。
     このクラスのインスタンスは `ZipFile' オブジェクトの `getinfo()'
     および `infolist()' メソッドによって返され ます。`zipfile'
     モジュールを利用するほとんどのユーザはこの
     オブジェクトを自ら生成する必要はなく、モジュールが生成して返す
     オブジェクトを利用するだけでしょう。 FILENAME
     はアーカイブメンバの完全な名前で、 DATE_TIME は
     ファイルの最終更新時刻を記述する、 6 つの
     フィールドからなるタプルでなくてはなりません。各フィールドについては
     *Note tarfile::, "ZipInfo オブジェクト" 節を参照してください。

`is_zipfile(filename)'
     FILENAME が正しいマジックナンバをもつ ZIP ファイルのときに `True'
     を返し、そうでない場合 `False' を返します。この
     モジュールは現在のところ、コメントを追記した ZIP ファイルを扱うこと
     ができません。

`ZIP_STORED'
     アーカイブメンバが圧縮されていないことを表す数値定数です。

`ZIP_DEFLATED'
     通常の ZIP 圧縮手法を表す数値定数。ZIP 圧縮は zlib モジュールを必要
     とします。現在のところ他の圧縮手法はサポートされていません。

See also:
     `PKZIP Application Note'{ZIP
     ファイル形式およびアルゴリズムを作成した  Phil Katz
     によるドキュメント。}

     `Info-ZIP Home Page'{Info-ZIP プロジェクトによる ZIP
     アーカイブプログラム及びプログラム開発ライブラリに関する情報。}

* Menu:

* ZipFile オブジェクト::
* PyZipFile オブジェクト::
* ZipInfo オブジェクト::


File: python-lib-jp.info,  Node: ZipFile オブジェクト,  Next: PyZipFile オブジェクト,  Prev: zipfile,  Up: zipfile

12.4.1 ZipFile オブジェクト
---------------------------

`ZipFile(file[, mode[, compression[, allowZip64]]])'
     ZIP ファイルを開きます。FILE はファイルへのパス名 (文字列)
     またはファイルのように振舞うオブジェクトのどちらでもかまいません。
     MODE パラメタは、既存のファイルを読むためには	`'r''、
     既存のファイルを切り詰めたり新しいファイルに書き込むためには
     `'w''、 追記を行うためには `'a'' でなくてはなりません。 MODE が
     `'a'' で FILE が既存の ZIP ファイルを
     参照している場合、追加するファイルは既存のファイル中の ZIP
     アーカイブ に追加されます。FILE が ZIP
     を参照していない場合、新しい ZIP
     アーカイブが生成され、既存のファイルの末尾に追加されます。このことは、
     ある ZIP ファイルを他のファイル、例えば	`python.exe' に

          cat myzip.zip >> python.exe

     として追加することができ、少なくとも `WinZip' がこのような
     ファイルを読めることを意味します。 COMPRESSION
     はアーカイブを書き出すときの ZIP 圧縮法で、 `ZIP_STORED' または
     `ZIP_DEFLATED' でなくては なりません。不正な値を指定すると
     `RuntimeError' が送出 されます。また、`ZIP_DEFLATED'
     定数が指定されているのに `zlib' を利用することができない場合、
     `RuntimeError' が送出されます。デフォルト値は `ZIP_STORED' です。
     ALLOWZIP64 が `True' ならば 2GB より大きな ZIP ファイルの作成時に
     ZIP64 拡張を使用します。これが `False' ならば、`zipfile'
     モジュールは ZIP64 拡張が必要になる場面で例外を送出します。 ZIP64
     拡張はデフォルトでは無効にされていますが、これは UNIX の `zip'
     　および `unzip' (InfoZIP ユーティリティ)
     コマンドがこの拡張をサポートしていないからです。

`close()'
     アーカイブファイルを閉じます。`close()' は
     プログラムを終了する前に必ず呼び出さなければなりません。
     さもないとアーカイブ上の重要なレコードが書き込まれません。

`getinfo(name)'
     アーカイブメンバ NAME に関する情報を持つ `ZipInfo'
     オブジェクトを返します。

`infolist()'
     アーカイブに含まれる各メンバの `ZipInfo' オブジェクトからなる
     リストを返します。既存のアーカイブファイルを開いている場合、
     リストの順番は実際の ZIP ファイル中のメンバの順番と同じになります。

`namelist()'
     アーカイブメンバの名前のリストを返します。

`printdir()'
     アーカイブの目次を `sys.stdout' に出力します。

`read(name)'
     アーカイブ中のファイルの内容をバイト列にして返します。アーカイブは
     読み込みまたは追記モードで開かれていなくてはなりません。

`testzip()'
     アーカイブ中の全てのファイルを読み、CRC
     チェックサムとヘッダが正常か調べます。
     最初に見つかった不正なファイルの名前を返します。
     不正なファイルがなければ `None' を返します。

`write(filename[, arcname[, compress_type]])'
     FILENAME に指定したファイル名を持つファイルを、アーカイブ名を
     ARCNAME (デフォルトでは FILENAME と同じですが
     ドライブレターと先頭にあるパスセパレータは取り除かれます)
     にしてアーカイブに収録します。 COMPRESS_TYPE
     を指定した場合、コンストラクタを使って新たなアーカイブエントリ
     を生成した際に使ったCOMPRESSION
     パラメタを上書きします。アーカイブのモードは `'w'' または `'a''
     でなくてはなりません。

     _Note:_ ZIP
     ファイル中のファイル名に関する公式なエンコーディング方式はありません。
     もしユニコードのファイル名が付けられているならば、それを `write()'
     に渡す前に望ましいエンコーディングでバイト列に変換しておいてください。
     WinZip は全てのファイル名を DOS Latin としても知られる CP437
     で解釈します。

     _Note:_
     アーカイブ名はアーカイブルートに対する相対的なものでなければなりません。
     言い換えると、アーカイブ名はパスセパレータで始まってはいけません。

`writestr(zinfo_or_arcname, bytes)'
     文字列 BYTESをアーカイブに書き込みます。ZINFO_OR_ARCNAME
     はアーカイブ中で指定するファイル名か、または`ZipInfo' インスタンス
     を指定します。ZINFO_OR_ARCNAMEに`ZipInfo' インスタンスを指定
     する場合、ZINFOインスタンスには少なくともファイル名、日付および時刻
     を指定しなければなりません。ファイル名を指定した場合、日付と時刻には現在の
     日付と時間が設定されます。アーカイブはモード `'w'' または `'a''
     で開かれていなければなりません。

以下のデータ属性も利用することができます。

`debug'
     使用するデバッグ出力レベル。この属性は `0'
     (デフォルト、何も出力しない) から `3' (最も多くデバッグ情報を
     出力する) までの値に設定することができます。デバッグ情報は
     `sys.stdout' に出力されます。


File: python-lib-jp.info,  Node: PyZipFile オブジェクト,  Next: ZipInfo オブジェクト,  Prev: ZipFile オブジェクト,  Up: zipfile

12.4.2 PyZipFile オブジェクト
-----------------------------

`PyZipFile' コンストラクタは `ZipFile' コンストラクタ
と同じパラメタを必要とします。インスタンスは `ZipFile' の
メソッドの他に、追加のメソッドを一つ持ちます。

`writepy(pathname[, basename])'
     `*.py' ファイルを探し、`*.py' ファイルに対応するファイルを
     アーカイブに追加します。 対応するファイルとは、もしあれば `*.pyo'
     であり、そうでなければ `*.pyc' で、必要に応じて `*.py'
     からコンパイルします。 もし pathname がファイルなら、ファイル名は
     `.py' で終わっていな ければなりません。また、(`*.py' に対応する
     `*.py[co]') ファイルはアーカイブのトップレベルに (パス情報なしで)
     追加されます。 もし pathname
     がディレクトリで、ディレクトリがパッケージディレクトリ
     でないなら、全ての `*.py[co]' ファイルはトップレベルに追加され
     ます。もしディレクトリがパッケージディレクトリなら、全ての
     `*.py[co]' ファイルはパッケージ名の名前をもつファイルパスの
     下に追加されます。サブディレクトリがパッケージディレクトリなら、
     それらは再帰的に追加されます BASENAME はクラス内部での呼び出し
     に使用するためのものです。

     `writepy()' メソッドは以下のようなファイル名を持ったアーカイブ
     を生成します。

              string.pyc                    # トップレベル名
              test/__init__.pyc             # パッケージディレクトリ
              test/testall.pyc              # test.testall モジュール
              test/bogus/__init__.pyc       # サブパッケージディレクトリ
              test/bogus/myfile.pyc         # test.bogus.myfile サブモジュール



File: python-lib-jp.info,  Node: ZipInfo オブジェクト,  Prev: PyZipFile オブジェクト,  Up: zipfile

12.4.3 ZipInfo オブジェクト
---------------------------

`ZipFile' オブジェクトの `getinfo()' および `infolist()' メソッドは
`ZipInfo' クラスのインスタンス
を返します。それぞれのインスタンスオブジェクトは ZIP アーカイブの
一個のメンバについての情報を保持しています。

インスタンスは以下の属性を持ちます:

`filename'
     アーカイブ中のファイルの名前。

`date_time'
     アーカイブメンバの最終更新日時。この属性は6つの値からなるタプルです。:

     Index                              Value
     ------                             -----
     0                                  西暦年
     1                                  月 (1 から始まる)
     2                                  日 (1 から始まる)
     3                                  時 (0 から始まる)
     4                                  分 (0 から始まる)
     5                                  秒 (0 から始まる)


`compress_type'
     アーカイブメンバの圧縮形式。

`comment'
     各アーカイブメンバに対するコメント。

`extra'
     拡張フィールドデータ。
     この文字列データに含まれているデータの内部構成については、

     でコメントされています。

`create_system'
     ZIP アーカイブを作成したシステムを記述する文字列。

`create_version'
     このアーカイブを作成した PKZIP のバージョン。

`extract_version'
     このアーカイブを展開する際に必要な PKZIP のバージョン。

`reserved'
     予約領域。ゼロでなくてはなりません。

`flag_bits'
     ZIP フラグビット列。

`volume'
     ファイルヘッダのボリュームナンバ。

`internal_attr'
     内部属性。

`external_attr'
     外部ファイル属性。

`header_offset'
     　ファイルヘッダへのバイト数で表したオフセット。

`CRC'
     圧縮前のファイルの CRC-32 チェックサム。

`compress_size'
     圧縮後のデータのサイズ。

`file_size'
     圧縮前のファイルのサイズ。


File: python-lib-jp.info,  Node: tarfile,  Prev: zipfile,  Up: データ圧縮とアーカイブ

12.5 tar アーカイブファイルを読み書きする
=========================================

tar-形式のアーカイブファイルを読み書きします。 _Added in Python version
2.3_

`tarfile' モジュールは、tar
アーカイブを読んで作成することができるようにします。
いくつかの事実と外観：

   * `gzip' と `bzip2' で圧縮されたアーカイブを読み書きします。

   * POSIX 1003.1-1990 準拠あるいは GNU tar
     互換のアーカイブを作成します。

   * GNU tar 拡張機能 _長い名前_、 _longlink_ および _sparse_
     を読みます。

   * GNU tar 拡張機能を使って、無制限長さのパス名を保存します。

   *
     ディレクトリ、普通のファイル、ハードリンク、シンボリックリンク、fifo、
     キャラクタデバイスおよびブロックデバイスを処理します。また、タイムスタンプ、
     アクセス許可およびオーナーのようなファイル情報の取得および保存が可能です。

   * テープデバイスを取り扱うことができます。

`open([name[, mode [, fileobj[, bufsize]]]])'
     パス名 NAMEに `TarFile' オブジェクトを返します。 `TarFile'
     オブジェクトに関する詳細な情報については、  (セクション *Note
     TarFile オブジェクト::)を見て下さい。

     MODE は `'filemode[:compression]'' の形式をとる文字列で
     なければなりません．デフォルトの値は `'r'' です．以下に
     MODEのとりうる組み合わせ全てを示します．

     mode                               動作
     ------                             -----
     'r' または 'r:*'                   透過な圧縮つきで読み込むためにオープンします(推奨)。
     'r:'                               圧縮なしで排他的に読み込むためにオープンします。
     'r:gz'                             gzip
                                        圧縮で読み込むためにオープンします。
     'r:bz2'                            bzip2
                                        圧縮で読み込むためにオープンします。
     'a' または 'a:'                    圧縮なしで追加するためにオープンします。
     'w' または 'w:'                    非圧縮で書き込むためにオープンします。
     'w:gz'                             gzip
                                        圧縮で書き込むためにオープンします。
     'w:bz2'                            bzip2
                                        圧縮で書き込むためにオープンします。

     `'a:gz'' あるいは `'a:bz2''は可能ではないことに注意して下さい。
     もし MODEが、ある(圧縮した)ファイルを読み込み用にオープンするのに、
     適していないなら、`ReadError'が発生します。これを防ぐには MODE
     `'r'' を使って下さい。もし圧縮メソッドが サポートされていなければ、
     `CompressionError' が発生します。

     もし FILEOBJが指定されていれば、それは NAMEでオープンされた
     ファイルオブジェクトの代替として使うことができます。

     特別な目的のために、MODEの2番目の形式: `'ファイルモード|[圧縮]''
     があります。この形式を使うと，
     `open'が返すのはデータをブロックからなるストリームとして扱う
     `TarFile' オブジェクトになります．この場合，ファイルに対して
     ランダムな seek を行えなくなります．FILEOBJ を指定する場合，
     `read()'および`write()' メソッドを持つ任意のオブジェクトに
     できます． BUFSIZE にはブロックサイズを指定します．デフォルトは
     `20 * 512' バイトです。`sys.stdin' ，ソケットファイル
     オブジェクト，テーブデバイスと組み合わせる場合にはこの形式を
     使ってください．ただし，このような`TarFile' オブジェクトには
     ランダムアクセスを行えないという制限があります．  (セクション
     *Note 何を pickle 化したり unpickle
     化できるのか?::)を参照してください。 現在可能なモードは：

     モード                             動作
     ------                             -----
     'r|*'                              tar ブロックの _ストリーム_
                                        を透過な読み込みにオープンします。
     'r|'                               非圧縮 tar ブロックの
                                        _ストリーム_
                                        を読み込みにオープンします。
     'r|gz'                             gzip 圧縮
                                        _ストリーム_を読み込みにオープンします。
     'r|bz2'                            bzip2 圧縮 _ストリーム_
                                        を読み込みにオープンします。
     'w|'                               非圧縮
                                        _ストリーム_を書き込みにオープンします。
     'w|gz'                             gzip 圧縮 _ストリーム_
                                        を書き込みにオープンします。
     'w|bz2'                            bzip2 圧縮
                                        _ストリーム_を書き込みにオープンします。


`TarFile'
     tar
     アーカイブを読んだり、書いたりするためのクラスです。このクラスを
     直接使わず，代わりに `open()' を使ってください． `TarFile'
     オブジェクト (*Note TarFile オブジェクト:: 節) を参照
     してください．

`is_tarfile(name)'
     もし NAMEが tar アーカイブファイルであり，`tarfile'
     モジュールで読み出せる場合に`True'を返します．

`TarFileCompat(filename[, mode[, compression]])'
     `zipfile'-風なインターフェースを持つ tar アーカイブへの
     制限されたアクセスのためのクラスです。詳細は
     `zipfile'のドキュメントを参照してください． COMPRESSION
     は、以下の定数のどれかでなければなりません：

    `TAR_PLAIN'
          非圧縮 tar アーカイブのための定数。

    `TAR_GZIPPED'
          `gzip'圧縮 tar アーカイブのための定数。


`TarError'
     すべての `tarfile' 例外のための基本クラスです。

`ReadError'
     tar アーカイブがオープンされた時、`tarfile' モジュールで操作
     できないか、あるいは何か無効であるとき発生します。

`CompressionError'
     圧縮方法がサポートされていないか、あるいはデータを正しくデコードできない
     時に発生します。

`StreamError'
     ストリーム風の `TarFile' オブジェクトで典型的な制限の
     ために発生します。

`ExtractError'
     `extract()'を使った時、もし`TarFile.errorlevel'` == 2' の
     _フェータルでない_ エラーに対してだけ発生します。

See also:
     *Note zipfile:: `zipfile' 標準モジュールのドキュメント。

     `GNU tar マニュアル, 基本 Tar 形式'{GNU tar 拡張機能を含む、 tar
     アーカイブファイルのためのドキュメント。}

* Menu:

* TarFile オブジェクト::
* TarInfo オブジェクト::
* 例 6::


File: python-lib-jp.info,  Node: TarFile オブジェクト,  Next: TarInfo オブジェクト,  Prev: tarfile,  Up: tarfile

12.5.1 TarFile オブジェクト
---------------------------

`TarFile' オブジェクトは、tar
アーカイブへのインターフェースを提供します。 tar
アーカイブは一連のブロックです。アーカイブメンバー(保存されたファイル)は、
ヘッダーブロックとそれに続くデータブロックから構成されています。ある
tar アーカイブに
ファイルを何回も保存することができます。各アーカイブメンバーは、
`TarInfo' オブジェクトによって表わされます、詳細については  (セクション
*Note TarInfo オブジェクト::)を見て下さい。

`TarFile([name [, mode[, fileobj]]])'
     _(非圧縮の)_ tar アーカイブ NAMEをオープンします。 MODE
     は、既存のアーカイブから読み込むには `'r'' 、
     既存のファイルにデータを追加するには
     `'a''、あるいは既存のファイルを
     上書きして新しいファイルを作成するには `'w'' のどれかです。MODE
     のデフォールトは `'r''です。

     もし
     FILEOBJが与えられていれば、それを使ってデータを読み書きします。
     もしそれが決定できれば、MODEは FILEOBJ のモードで上書きされます。.
     _Notice:_ FILEOBJ
     は、`TarFile'をクローズする時は、クローズされません。


`open(...)'
     代替コンストラクタです。モジュールレベルでの `open()' 関数は、
     実際はこのクラスメソッドへのショートカットです。詳細については
     セクション  を見て下さい。

`getmember(name)'
     メンバー NAME に対する `TarInfo' オブジェクトを返します。 もし
     NAMEがアーカイブに見つからなければ、`KeyError'が発生します。
     _Notice:_
     もしメンバーがアーカイブに1つ以上あれば、その最後に出現する
     ものが、最新のバージョンであるとみなされます。


`getmembers()'
     `TarInfo'
     オブジェクトのリストとしてアーカイブのメンバーを返します。
     このリストはアーカイブ内のメンバーと同じ順番です。

`getnames()'
     メンバーをその名前のリストとして返します。これは
     `getmembers()'で返されるリストと同じ順番です。

`list(verbose=True)'
     コンテンツの表を `sys.stdout' に印刷します。もし VERBOSE が
     `False' であれば、メンバー名のみ印刷します。もしそれが `True'
     であれば、`"ls -l"' に似た出力を生成します．

`next()'
     `TarFile'が読み込み用にオープンされている時、
     アーカイブの次のメンバーを
     `TarInfo'オブジェクトとして返します。もしそれ以上利用可能なものがなければ、
     `None' を返します。

`extractall([path[, members]])'
     全てのメンバーをアーカイブから現在の作業ディレクトリーまたは PATH
     に 抽出します。オプションの MEMBERS が与えられるときには、
     `getmembers()' で返されるリストの一部でなければなりません。
     所有者、変更時刻、許可のようなディレクトリー情報は全てのメンバーが抽出された後に
     セットされます。これは二つの問題を回避するためです。一つはディレクトリー
     の変更時刻はその中にファイルが作成されるたびにリセットされるということ。
     もう一つは、ディレクトリーに書き込み許可がなければその中のファイル抽出は
     失敗してしまうということです。 _Added in Python version 2.5_

`extract(member[, path])'
     メンバーをアーカイブから現在の作業ディレクトリに、そのフル名を使って、
     抽出します。そのファイル情報はできるだけ正確に 抽出されます。
     MEMBERは、ファイル名でも`TarInfo' オブジェクトでも構いません。
     PATHを使って、異なるディレクトリを指定することができます。
     _Notice:_ `extract()' メソッドでは tar アーカイブにランダムアクセス
     することが許されるので、これを使う場合には使用者自身が気をつけな
     ければならない問題があります。上の `extractall()' の説明を
     参照してください。


`extractfile(member)'
     アーカイブからメンバーをオブジェクトとして抽出します。
     MEMBERは、ファイル名あるいは `TarInfo' オブジェクトです。 もし
     MEMBERが普通のファイルであれば、ファイル風のオブジェクトを返します。
     もし
     MEMBERがリンクであれば、ファイル風のオブジェクトをリンクのターゲットから
     構成します。 もし MEMBERが上のどれでもなければ、`None'
     が返されます。 _Notice:_
     ファイル風のオブジェクトは読み出し専用で以下のメソッドを提供します：
     `read()', `readline()', `readlines()', `seek()', `tell()'.


`add(name[, arcname[, recursive]])'
     ファイル NAMEをアーカイブに追加します。NAME
     は、任意のファイルタイプ
     (ディレクトリ、fifo、シンボリックリンク等)です。 もしARCNAME
     が与えられていれば、それはアーカイブ内のファイルの代替名を
     指定します。デフォールトではディレクトリは再帰的に追加されます。
     これは、RECURSIVE を `False' に設定することで
     避けることができます。デフォルトは `True' です．

`addfile(tarinfo[, fileobj])'
     `TarInfo'オブジェクトTARINFOをアーカイブに追加します。 もし
     FILEOBJ が与えられていれば、`TARINFO.size' バイトがそれから読まれ、
     アーカイブに追加されます。`gettarinfo()'を使って `TarInfo'
     オブジェクトを作成することができます。 _Notice:_ Windows
     プラットフォームでは、FILEOBJは、ファイルサイズに関する問題を避けるために、
     常に、モード `'rb'' でオープンされるべきです。


`gettarinfo([name[, arcname [, fileobj]]])'
     `TarInfo'オブジェクトをファイル NAME あるいは
     (そのファイル記述子に `os.fstat()'を使って)
     ファイルオブジェクトFILEOBJの どちらか用に作成します。
     `TarInfo'の属性のいくつかは、
     `addfile()'を使って追加する前に修正することができます。
     ARCNAMEがもし与えられていれば、アーカイブ内のファイルの
     代替名を指定します。

`close()'
     `TarFile'をクローズします。書き出しモードでは、完了ゼロブロックが
     2つ、アーカイブに追加されます。

`posix'
     この値が真なら、POSIX 1003.1-1990 準拠のアーカイブを作成します。GNU
     拡張機能はは POSIX 標準の一部ではないため使いません． POSIX
     準拠のアーカイブでは，ファイル名の長さは最大 256 ，
     リンク名の最大長は100文字に制限されており，ファイルの最大長は 8
     ギガバイト以下です．ファイルがこれらの制限を超えた場合，
     `ValueError'を送出します． この値が偽の場合，GNU tar
     互換のアーカイブを作成します． POSIX
     仕様には準拠しませんが，上記の制約を受けずにファイルを
     保存できます． _Changed in Python version 2.4_

`dereference'
     この値が偽の場合，シンボリックリンクとハードリンクをアーカイブに
     追加します。真の場合，ターゲットファイルの内容をアーカイブに追加します。
     この値はリンクをサポートしないシステムには影響しません。

`ignore_zeros'
     この値が偽の場合，空のブロックをアーカイブの終わりとして処理します。
     真の場合，空(で無効な)ブロックを飛ばして、できるだけ多くのメンバを
     取得しようとします。これはアーカイブを連結している場合やアーカイブが
     損傷している場合に役に立ちます。

`debug=0'
     `0'(デバッグメッセージなし、デフォルト)から `3'(すべてのデバッグ
     メッセージあり)までの値に設定します．メッセージは `sys.stderr'
     に出力されます．

`errorlevel=0'
     この値が`0' (デフォルトの値です) の場合， `extract()'
     実行時の全てのエラーを無視します．ただし，
     デバッグが有効になっている場合には，デバッグ出力にエラーメッセージ
     として出力します． 値を`1' にした場合，すべての_致命的な_
     エラーに対して `OSError'または`IOError' 例外を送出します． 値を`2'
     にした場合、_致命的でない_エラーもまた，全て `TarError'
     例外として送出します．


File: python-lib-jp.info,  Node: TarInfo オブジェクト,  Next: 例 6,  Prev: TarFile オブジェクト,  Up: tarfile

12.5.2 TarInfo オブジェクト
---------------------------

`TarInfo' オブジェクトは `TarFile'
の一つのメンバーを表します。ファイルに
必要な(ファイルタイプ、ファイルサイズ、時刻、許可、所有者等のような)すべての属性を保存する他に、
そのタイプを決定するのに役に立ついくつかのメソッドを提供します。
これにはファイルのデータそのものは含まれま_せん_。

`TarInfo'オブジェクトは `TarFile'のメソッド `getmember()'、
`getmembers()' および `gettarinfo()'によって返されます。

`TarInfo([name])'
     `TarInfo' オブジェクトを作成します。

`frombuf()'
     `TarInfo' オブジェクトを文字列バッファから作成して返します。

`tobuf([posix])'
     `TarInfo' オブジェクトから文字列バッファを作成します。 POSIX
     引数については `TarFile' の `posix' 属性の
     項を参照してください。この引数はデフォルトでは `False' です。

     _Added in Python version 2.5_

`TarInfo'オブジェクトには以下の public なデータ属性があります：

`name'
     アーカイブメンバーの名前。

`size'
     バイト単位でのサイズ。

`mtime'
     最終更新時刻。

`mode'
     許可ビット。

`type'
     ファイルタイプです． TYPE は普通、以下の定数: `REGTYPE',
     `AREGTYPE', `LNKTYPE', `SYMTYPE', `DIRTYPE', `FIFOTYPE',
     `CONTTYPE', `CHRTYPE', `BLKTYPE', `GNUTYPE_SPARSE' のいずれかです．
     `TarInfo' オブジェクトのタイプをもっと便利に決定するには、 下記の
     `is_*()' メソッドを使って下さい。

`linkname'
     ターゲットファイル名の名前で、これは タイプ`LNKTYPE' と `SYMTYPE'
     の`TarInfo'オブジェクトにだけ存在します。

`uid'
     ファイルメンバを保存した元のユーザのユーザ ID です．

`gid'
     ファイルメンバを保存した元のユーザのグループ ID です．

`uname'
     ファイルメンバを保存した元のユーザのユーザ名です．

`gname'
     ファイルメンバを保存した元のユーザのグループ名です．

`TarInfo'オブジェクトは便利な照会用のメソッドもいくつか提供しています:

`isfile()'
     `Tarinfo' オブジェクトが普通のファイルの場合に、 `True'
     を返します。

`isreg()'
     `isfile()'と同じです。

`isdir()'
     ディレクトリの場合に`True'を返します。

`issym()'
     シンボリックリンクの場合に`True'を返します。

`islnk()'
     ハードリンクの場合に`True'を返します。

`ischr()'
     キャラクタデバイスの場合に`True'を返します。

`isblk()'
     ブロックデバイスの場合に`True'を返します。

`isfifo()'
     FIFO の場合に`True'を返します。

`isdev()'
     キャラクタデバイス、ブロックデバイスあるいは FIFOの
     いずれかの場合に `True'を返します。


File: python-lib-jp.info,  Node: 例 6,  Prev: TarInfo オブジェクト,  Up: tarfile

12.5.3 例
---------

tar アーカイブから現在のディレクトリーに全て抽出する方法：
     import tarfile
     tar = tarfile.open("sample.tar.gz")
     tar.extractall()
     tar.close()

非圧縮 tar アーカイブをファイル名のリストから作成する方法：
     import tarfile
     tar = tarfile.open("sample.tar", "w")
     for name in ["foo", "bar", "quux"]:
         tar.add(name)
     tar.close()

gzip 圧縮 tar アーカイブを作成してメンバー情報のいくつかを表示する方法：
     import tarfile
     tar = tarfile.open("sample.tar.gz", "r:gz")
     for tarinfo in tar:
         print tarinfo.name, " は 大きさが ", tarinfo.size, "バイトで ",
         if tarinfo.isreg():
             print "普通のファイルです。"
         elif tarinfo.isdir():
             print "ディレクトリです。"
         else:
             print "ファイル・ディレクトリ以外のものです。"
     tar.close()

見せかけの情報を持つ tar アーカイブを作成する方法：
     import tarfile
     tar = tarfile.open("sample.tar.gz", "w:gz")
     for name in namelist:
         tarinfo = tar.gettarinfo(name, "fakeproj-1.0/" + name)
         tarinfo.uid = 123
         tarinfo.gid = 456
         tarinfo.uname = "johndoe"
         tarinfo.gname = "fake"
         tar.addfile(tarinfo, file(name))
     tar.close()

非圧縮 tar ストリームを`sys.stdin'から抽出する _唯一の_方法：
     import sys
     import tarfile
     tar = tarfile.open(mode="r|", fileobj=sys.stdin)
     for tarinfo in tar:
         tar.extract(tarinfo)
     tar.close()


File: python-lib-jp.info,  Node: データの永続化,  Next: 汎用オペレーティングシステムサービス,  Prev: データ圧縮とアーカイブ,  Up: Top

13 データの永続化
*****************

この章で解説されるモジュール群は Python データをディスクに永続的な形式
で保存します。 モジュール `pickle' と モジュール `marshal' は 多くの
Python データ型をバイト列に変換し、バイト列から再生成します。 様々な
DBM関連モジュールはハッシュを基にした、文字列から他の文字列へのマッ
プを保存するファイルフォーマット群をサポートします。 モジュール `bsddb'
はディスクベースの文字列から文字列へのマッピ ングを、ハッシュ、B-Tree,
レコードを基にしたフォーマットで提供します。

この章で説明されるモジュールは:

* Menu:

* pickle::
* cPickle::
* copy_reg::
* shelve::
* marshal::
* anydbm::
* whichdb::
* dbm::
* gdbm::
* dbhash::
* bsddb::
* dumbdbm::
* sqlite3::


File: python-lib-jp.info,  Node: pickle,  Next: cPickle,  Prev: データの永続化,  Up: データの永続化

13.1 Python オブジェクトの整列化
================================

Python オブジェクトからバイトストリームへの変換、およびその逆。

`pickle' モジュールでは、Python オブジェクトデータ構造を 直列化
(serialize) したり非直列化 (de-serialize) するための
基礎的ですが強力なアルゴリズムを実装しています。 "Pickle 化 (Pickling)"
は Python のオブジェクト階層をバイト
ストリームに変換する過程を指します。"非 Pickle 化 (unpickling)"
はその逆の操作で、バイトストリームをオブジェクト階層に戻すように
変換します。Pickle 化 (及び非 Pickle 化) は、別名 "直列化
(serialization)" や "整列化 (marshalling)" (1) 、"平坦化 (flattening)"
として知られていますが、 ここでは混乱を避けるため、用語として "Pickle
化" および "非 Pickle 化" を使います。

このドキュメントでは `pickle' モジュールおよび `cPickle'
モジュールの両方について記述します。

* Menu:

* 他の Python モジュールとの関係::
* データストリームの形式::
* 使用法::
* 何を pickle 化したり unpickle 化できるのか?::
* pickle 化プロトコル::
* Unpickler をサブクラス化する::
* 例 7::

---------- Footnotes ----------

(1) `marshal' モジュールと間違えないように注意 してください


File: python-lib-jp.info,  Node: 他の Python モジュールとの関係,  Next: データストリームの形式,  Prev: pickle,  Up: pickle

13.1.1 他の Python モジュールとの関係
-------------------------------------

`pickle' モジュールには `cPickle' と呼ばれる
最適化のなされた親類モジュールがあります。名前が示すように、 `cPickle'
は C で書かれており、このため `pickle' より 1000
倍くらいまで高速になる可能性があります。しかしながら `cPickle' では
`Pickler()' および `Unpickler()'
クラスのサブクラス化をサポートしていません。 これは `cPickle'
では、これらは関数であってクラスでは
ないからです。ほとんどのアプリケーションではこの機能は
不要であり、`cPickle' の持つ高いパフォーマンスの
恩恵を受けることができます。その他の点では、二つのモジュールに
おけるインタフェースはほとんど同じです; このマニュアルでは
共通のインタフェースを記述しており、必要に応じてモジュール間
の相違について指摘します。以下の議論では、`pickle' と `cPickle'
の総称として "pickle" という用語を使う ことにします。

これら二つのモジュールが生成するデータストリームは相互交換
できることが保証されています。

Python には `marshal' と呼ばれるより原始的な直列化モジュール
がありますが、一般的に Python オブジェクトを直列化する方法としては
`pickle' を選ぶべきです。`marshal' は基本的に `.pyc'
ファイルをサポートするために存在しています。

`pickle' モジュールはいくつかの点で `marshal' と明確に異なります:

   * `pickle' モジュールでは、同じオブジェクトが再度直列化
     されることのないよう、すでに直列化されたオブジェクトについて追跡
     情報を保持します。`marshal' はこれを行いません。

     この機能は再帰的オブジェクトと共有オブジェクトの両方に重要な
     関わりをもっています。再帰的オブジェクトとは自分自身に対する
     参照を持っているオブジェクトです。再帰的オブジェクトは marshal
     で扱うことができず、実際、再帰的オブジェクトを marshal 化しようと
     すると Python インタプリタをクラッシュさせてしまいます。
     共有オブジェクトは、直列化しようとするオブジェクト階層の異なる
     複数の場所で同じオブジェクトに対する参照が存在する場合に生じます。
     共有オブジェクトを共有のままにしておくことは、変更可能なオブジェクト
     の場合には非常に重要です。

   * `marshal' はユーザ定義クラスやそのインスタンスを
     直列化するために使うことができません。`pickle' は
     クラスインスタンスを透過的に保存したり復元したりすることができますが、
     クラス定義をインポートすることが可能で、かつオブジェクトが保存
     された際と同じモジュールで定義されていなければなりません。

   * `marshal' の直列化フォーマットは Python の異なる
     バージョンで可搬性があることを保証していません。`marshal'
     の本来の仕事は `.pyc' ファイルのサポートなので、Python
     を実装する人々には、必要に応じて直列化フォーマットを以前の
     バージョンと互換性のないものに変更する権限が残されています。
     `pickle' 直列化フォーマットには、全ての Python リリース
     間で以前のバージョンとの互換性が保証されています。


_Notice:_ [警告] `pickle' モジュールは誤りを含む、あるいは悪意を持って
構築されたデータに対して安全にはされていません。信用できない、
あるいは認証されていないデータ源から受信したデータを逆 pickle 化
しないでください。

直列化は永続化 (persisitence) よりも原始的な概念です; `pickle'
はファイルオブジェクトを読み書きしますが、永続化
されたオブジェクトの名前付け問題や、(より複雑な) オブジェクトに
対する競合アクセスの問題を扱いません。`pickle' モジュール
は複雑なオブジェクトをバイトストリームに変換することができ、
バイトストリームを変換前と同じ内部構造をオブジェクトに変換する
ことができます。このバイトストリームの最も明白な用途は
ファイルへの書き込みですが、その他にもネットワークを介して送信
したり、データベースに記録したりすることができます。 モジュール
`shelve' はオブジェクトを DBM 形式の データベースファイル上で pickle
化したり unpickle 化したりする
ための単純なインタフェースを提供しています。


File: python-lib-jp.info,  Node: データストリームの形式,  Next: 使用法,  Prev: 他の Python モジュールとの関係,  Up: pickle

13.1.2 データストリームの形式
-----------------------------

`pickle' が使うデータ形式は Python 特有です。そうする ことで、XDR  のような
外部の標準が持つ制限 (例えば XDR ではポインタの共有を表現できません)
を課せられることがないという利点があります; しかしこれは Python
で書かれていないプログラムが pickle 化された Python オブジェクトを
再構築できない可能性があることを意味します。

標準では、`pickle' データ形式では印字可能な ASCII 表現を
使います。これはバイナリ表現よりも少しかさばるデータになります。
印字可能な ASCII の利用 (とその他の `pickle' 表現形式が 持つ特徴)
の大きな利点は、デバッグやリカバリを目的とした場合に、 pickle
化されたファイルを標準的なテキストエディタで読めるという ことです。

現在、pickle化に使われるプロトコルは、以下の 3 種類です。

   * バージョン 0 のプロトコルは、最初の ASCII
     プロトコルで、以前のバージョンのPython と後方互換です。

   * バージョン 1
     のプロトコルは、古いバイナリ形式で、以前のバージョンの Python
     と後方互換です。

   * バージョン 2 のプロトコルは、Python 2.3
     で導入されました。新しいスタイルのクラスを、より効率よく piclke
     化します。


詳細は PEP 307 を参照してください。

PROTOCOL を指定しない場合、プロトコル 0 が使われます。PROTOCOL に負値か
`HIGHEST_PROTOCOL'
を指定すると、有効なプロトコルの内、もっとも高いバージョンのものが使われます。

_Changed in Python version 2.3_

PROTOCOL version >= 1 を指定することで、少しだけ効率の高いバイナリ
形式を選ぶことができます。


File: python-lib-jp.info,  Node: 使用法,  Next: 何を pickle 化したり unpickle 化できるのか?,  Prev: データストリームの形式,  Up: pickle

13.1.3 使用法
-------------

オブジェクト階層を直列化するには、まず pickler を生成し、続いてpickler
の `dump()' メソッドを呼び出します。データストリームから非直列化
するには、まず unpickler を生成し、続いて unpicklerの `load()' メ
ソッドを呼び出します。`pickle' モジュールでは以下の定数を提供して
います:

`HIGHEST_PROTOCOL'
     有効なプロトコルのうち、最も大きいバージョン。この値は、PROTOCOL
     として渡せます。 _Added in Python version 2.3_

_Note:_ protocols >= 1 で作られた pickle
ファイルは、常にバイナリモードで オープンするようにしてください。古い
ASCII ベースの pickle プロトコル 0 では、
矛盾しない限りにおいてテキストモードとバイナリモードのいずれも利用することができます。
プロトコル 0 で書かれたバイナリの pickle
ファイルは、行ターミネータとして単独の改行(LF)を含んでいて、
ですのでこの形式をサポートしない、 Notepad
や他のエディタで見たときに「おかしく」見えるかもしれません。

この pickle 化の手続きを便利にするために、`pickle' モジュールでは
以下の関数を提供しています:

`dump(obj, file[, protocol])'
     すでに開かれているファイルオブジェクト FILE に、OBJ を pickle
     化したものを表現する文字列を書き込みます。 `Pickler(FILE,
     PROTOCOL).dump(OBJ)' と同じです。

     PROTOCOL を指定しない場合、プロトコル 0 が使われます。 PROTOCOL
     に負値か `HIGHEST_PROTOCOL' を指定すると、
     有効なプロトコルの内、もっとも高いバージョンのものが使われます。

     _Changed in Python version 2.3_

     FILE は、単一の文字列引数を受理する `write()' メソッド
     を持たなければなりません。従って、 FILE としては、書き込みのために
     開かれたファイルオブジェクト、 `StringIO' オブジェクト、
     その他前述のインタフェースに適合する他のカスタムオブジェクトをとることが
     できます。

`load(file)'
     すでに開かれているファイルオブジェクト FILE から文字列を読み出し、
     読み出された文字列を pickle 化されたデータ列として解釈して、もとの
     オブジェクト階層を再構築して返します。`Unpickler(FILE).load()'
     と同じです。

     FILE は、整数引数をとる `read()' メソッドと、引数の必要 ない
     `readline()' メソッドを持たなければなりません。
     これらのメソッドは両方とも文字列を返さなければなりません。
     従って、 FILE としては、読み出しのために
     開かれたファイルオブジェクト、 `StringIO' オブジェクト、
     その他前述のインタフェースに適合する他のカスタムオブジェクトをとることが
     できます。

     この関数はデータ列の書き込まれているモードがバイナリかそうでないかを
     自動的に判断します。

`dumps(obj[, protocol])'
     OBJ の pickle 化された表現を、ファイルに書き込む代わりに
     文字列で返します。

     PROTOCOL を指定しない場合、プロトコル 0 が使われます。 PROTOCOL
     に負値か `HIGHEST_PROTOCOL' を指定すると、
     有効なプロトコルの内、もっとも高いバージョンのものが使われます。

     _Changed in Python version 2.3_


`loads(string)'
     pickle 化されたオブジェクト階層を文字列から読み出します。
     文字列中で pickle 化されたオブジェクト表現よりも後に続く文字列
     は無視されます。

`pickle' モジュールでは、以下の 3 つの例外も定義しています:

`PickleError'
     下で定義されている他の例外で共通の基底クラスです。`Exception'
     を継承しています。

`PicklingError'
     この例外は unpickle 不可能なオブジェクトが `dump()' メソッドに
     渡された場合に送出されます。

`UnpicklingError'
     この例外は、オブジェクトを unpickle 化する際に問題が発生した場合に
     送出されます。 unpickle 化中には `AttributeError'、 `EOFError'、
     `ImportError'、および `IndexError' といった他の例外
     (これだけとは限りません) も発生する可能性があるので
     注意してください。

`pickle' モジュールでは、2 つの呼び出し可能オブジェクト (1)
として、`Pickler' および `Unpickler' を提供しています:

`Pickler(file[, protocol])'
     pickle 化されたオブジェクトのデータ列を書き込むためのファイル類似の
     オブジェクトを引数にとります。

     PROTOCOL を指定しない場合、プロトコル 0 が使われます。PROTOCOL
     に負値か `HIGHEST_PROTOCOL'
     を指定すると、有効なプロトコルの内、もっとも高いバージョンのものが使われます。

     _Changed in Python version 2.3_

     FILE は単一の文字列引数を受理する `write()' メソッドを
     持たなければなりません。従って、 FILE としては、書き込みのために
     開かれたファイルオブジェクト、 `StringIO' オブジェクト、
     その他前述のインタフェースに適合する他のカスタムオブジェクトをとることが
     できます。

`Pickler' オブジェクトでは、一つ (または二つ) の public なメソッド
を定義しています:

`dump(obj)'
     コンストラクタで与えられた、すでに開かれているファイルオブジェクトに
     OBJ の pickle 化された表現を書き込みます。コンストラクタに渡された
     PROTOCOL 引数の値に応じて、バイナリおよびASCII 形式が使われます。

`clear_memo()'
     picller の "メモ" を消去します。メモとは、共有オブジェクトまたは
     再帰的なオブジェクトが値ではなく参照で記憶されるようにするために、
     pickler がこれまでどのオブジェクトに遭遇してきたかを記憶するデータ
     構造です。このメソッドは pickler を再利用する際に便利です。

     _Notice:_ Python 2.3 以前では、`clear_memo()' は `cPickle'
     で生成された pickler でのみ利用可能でした。`pickle' モジュール
     では、pickler は `memo' と呼ばれる Python 辞書型のインスタンス
     変数を持ちます。従って、`pickler' モジュールにおける pickler
     のメモを消去は、以下のようにしてできます:

          mypickler.memo.clear()

     以前のバージョンの Python
     での動作をサポートする必要のないコードでは、 単に `clear_memo()'
     を使ってください。


同じ `Pickler' のインスタンスに対し、 `dump()' メソッドを
複数回呼び出すことは可能です。この呼び出しは、対応する `Unpickler'
インスタンスで同じ回数だけ `load()' を呼び出す操作に対応します。
同じオブジェクトが `dump()' を複数回呼び出して pickle 化された
場合、`load()' は全て同じオブジェクトに対して参照を行います (2)。 。

`Unpickler' オブジェクトは以下のように定義されています:

`Unpickler(file)'
     pickle データ列を読み出すためのファイル類似のオブジェクトを引数に
     取ります。このクラスはデータ列がバイナリモードかどうかを自動的に
     判別します。従って、`Pickler' のファクトリメソッドのような
     フラグを必要としません。

     FILE は、整数引数を取る `read()' メソッド、および引数を 持たない
     `readline()' メソッドの、 2 つのメソッドを持ちます。
     両方のメソッドとも文字列を返します。従って、 FILE としては、
     読み出しのために開かれたファイルオブジェクト、 `StringIO'
     オブジェクト、その他前述のインタフェースに適合する他のカスタム
     オブジェクトをとることができます。

`Unpickler' オブジェクトは 1 つ (または 2 つ) の public な
メソッドを持っています:

`load()'
     コンストラクタで渡されたファイルオブジェクトからオブジェクトの
     pickle 化表現
     を読み出し、中に収められている再構築されたオブジェクト階層を返します。

`noload()'
     `load()' に似ていますが、実際には何もオブジェクトを生成
     しないという点が違います。この関数は第一に pickle
     化データ列中で参照されている、"永続化 id" と呼ばれている
     値を検索する上で便利です。 詳細は以下の ~*Note pickle
     化プロトコル:: を参照してください。

     *注意:* `noload()' メソッドは現在 `cPickle' モジュールで生成された
     `Unpickler' オブジェクトのみで 利用可能です。`pickle' モジュールの
     `Unpickler' には、 `noload()' メソッドがありません。

---------- Footnotes ----------

(1)  `pickle'では、これらの呼び出し可能オブジェクトはクラスであり、
サブクラス化してその動作をカスタマイズすることができます。しかし、
`cPickle' モジュールでは、これらの呼び出し可能オブジェクト
はファクトリ関数であり、サブクラス化することができません。
サブクラスを作成する共通の理由の一つは、どのオブジェクトを実際に
unpickle するかを制御することです。詳細については  ~*Note Unpickler
をサブクラス化する:: を参照してください。

(2)  _警告_: これは、複数のオブジェクトを pickle
化する際に、オブジェクト
やそれらの一部に対する変更を妨げないようにするための仕様です。
あるオブジェクトに変更を加えて、その後同じ `Pickler' を使って 再度
pickle 化しようとしても、そのオブジェクトは pickle 化しなおされ ません
-- そのオブジェクトに対する参照が pickle 化され、`Unpickler'
は変更された値ではなく、元の値を返します。これには 2 つの問題点 : (1)
変更の検出、そして (2) 最小限の変更を整列化すること、があります。
ガーベジコレクションもまた問題になります。


File: python-lib-jp.info,  Node: 何を pickle 化したり unpickle 化できるのか?,  Next: pickle 化プロトコル,  Prev: 使用法,  Up: pickle

13.1.4 何を pickle 化したり unpickle 化できるのか?
--------------------------------------------------

以下の型は pickle 化できます:

   * `None'、 `True'、および `False'

   * 整数、長整数、浮動小数点数、複素数

   * 通常文字列および Unicode 文字列

   * pickle 化可能なオブジェクトからなるタプル、リスト、集合および辞書

   * モジュールのトップレベルで定義されている関数

   * モジュールのトップレベルで定義されている組込み関数

   * モジュールのトップレベルで定義されているクラス

   * `__dict__' または `__setstate__()' を pickle 化
     できる上記クラスのインスタンス (詳細は ~*Note pickle
     化プロトコル:: 節を 参照してください)


pickle 化できないオブジェクトを pickle 化しようとすると、
`PicklingError' 例外が送出されます; この例外が起きた
場合、背後のファイルには未知の長さのバイト列が書き込まれて しまいます。
極端に再帰的なデータ構造を pickle 化しようとした場合には
再帰の深さ制限を越えてしまうかもしれず、この場合には `RuntimeError' が
送出されます。この制限は、`sys.setrecursionlimit()' で
慎重に上げていくことは可能です。

(組み込みおよびユーザ定義の) 関数は、値ではなく "完全記述された"
参照名として pickle 化されるので注意してください。これは、
関数の定義されているモジュールの名前と一緒と併せ、関数名 だけが pickle
化されることを意味します。 関数のコードや関数の属性は何も pickle
化されません。 従って、定義しているモジュールは unpickle 化環境で
import 可能で
なければならず、そのモジュールには指定されたオブジェクトが含まれて
いなければなりません。そうでない場合、例外が送出されます (1) 。

クラスも同様に名前参照で pickle 化されるので、unpickle 化環境には
同じ制限が課せられます。クラス中のコードやデータは何も pickle 化
されないので、以下の例ではクラス属性 `attr' が unpickle 化環境
で復元されないことに注意してください:

     class Foo:
         attr = 'a class attr'

     picklestring = pickle.dumps(Foo)

pickle 化可能な関数やクラスがモジュールのトップレベルで定義されて
いなければならないのはこれらの制限のためです。

同様に、クラスのインスタンスが pickle 化された際、そのクラスの
コードおよびデータはオブジェクトと一緒に pickle 化されることは
ありません。インスタンスのデータのみが pickle 化されます。
この仕様は、クラス内のバグを修正したりメソッドを追加した後でも、
そのクラスの以前のバージョンで作られたオブジェクトを読み出せるように
意図的に行われています。あるクラスの多くのバージョンで使われる
ような長命なオブジェクトを作ろうと計画しているなら、 そのクラスの
`__setstate__()' メソッドによって適切な変換が
行われるようにオブジェクトのバージョン番号を入れておくとよいかも
しれません。

---------- Footnotes ----------

(1) 送出される例外は `ImportError' や `AttributeError'
になるはずですが、他の例外も 起こりえます


File: python-lib-jp.info,  Node: pickle 化プロトコル,  Next: Unpickler をサブクラス化する,  Prev: 何を pickle 化したり unpickle 化できるのか?,  Up: pickle

13.1.5 pickle 化プロトコル
--------------------------

この節では pickler/unpickler と直列化対象のオブジェクトとの間の
インタフェースを定義する "pickle 化プロトコル" について記述します。
このプロトコルは自分のオブジェクトがどのように直列化されたり非直列化
されたりするかを定義し、カスタマイズし、制御するための標準的な方法を
提供します。この節での記述は、unpickle 化環境を不信な pickle 化データ
に対して安全にするために使う特殊なカスタマイズ化についてはカバー
していません; 詳細は ~*Note Unpickler をサブクラス化する::
を参照してください。

* Menu:

* 通常のクラスインスタンスの pickle 化および unpickle 化::
* 拡張型の pickle 化および unpickle 化::
* 外部オブジェクトの pickle 化および unpickle 化::


File: python-lib-jp.info,  Node: 通常のクラスインスタンスの pickle 化および unpickle 化,  Next: 拡張型の pickle 化および unpickle 化,  Prev: pickle 化プロトコル,  Up: pickle 化プロトコル

13.1.5.1 通常のクラスインスタンスの pickle 化および unpickle 化
...............................................................

pickle 化されたクラスインスタンスが unpickle 化されたとき、
`__init__()' メソッドは通常呼び出され_ません_ 。 unpickle 化の際に
`__init__()' が呼び出される方が望ましい場合、
旧スタイルクラスではメソッド `__getinitargs__()' を定義することが
できます。このメソッドはクラスコンストラクタ (例えば `__init__()')
に渡されるべき _タプルを_ 返さなければなりません。 `__getinitargs__()'
メソッドは pickle 時に呼び出されます;
この関数が返すタプルはインスタンスの pickle 化データに組み込まれます。 

新スタイルクラスでは、プロトコル 2 で呼び出される `__getnewargs__()'
を定義する事ができます。インスタンス生成時に内
部的な不変条件が成立する必要があったり、（タプルや文字列のように）型の
`__new__()'メソッドに指定する引数によってメモリの割り当てを変更す
る必要がある場合には`__getnewargs__()'を定義してください。新スタ
イルクラス`C'のインスタンスは、次のように生成されます。

     obj = C.__new__(C, *ARGS)

ここでARGSは元のオブジェクトの`__getnewargs__()'メソッドを
呼び出した時の戻り値となります。`__getnewargs__()'を定義していな
い場合、ARGSは空のタプルとなります。

クラスは、インスタンスの pickle 化方法にさらに影響を与えることが
できます; クラスが `__getstate__()' メソッドを定義している
場合、このメソッドが呼び出され、返された状態値はインスタンスの内容
として、インスタンスの辞書の代わりに pickle 化されます。
`__getstate__()' メソッドが定義されていない場合、 インスタンスの
`__dict__' の内容が pickle 化されます。

unpickle 化では、クラスが `__setstate__()' も定義していた
場合、unpickle 化された状態値とともに呼び出されます
(1)。`__setstate__()' メソッドが定義 されていない場合、pickle
化された状態は辞書型でなければならず、
その要素は新たなインスタンスの辞書に代入されます。クラスが
`__getstate__()' と `__setstate__()' の両方を定義して
いる場合、状態値オブジェクトは辞書である必要はなく、これらのメソッド
は期待通りの動作を行います。 (2)

_Notice:_ [warning] 新しいスタイルのクラスにおいて `__getstate__()'
が負値を返す場合、`__setstate__()' メソッドは呼ばれません。

---------- Footnotes ----------

(1) これらのメソッドはクラスインスタンスのコピーを
実装する際にもｔ用いられます

(2) このプロトコルはまた、 `copy'
で定義されている浅いコピーや深いコピー操作でも用いら れます。


File: python-lib-jp.info,  Node: 拡張型の pickle 化および unpickle 化,  Next: 外部オブジェクトの pickle 化および unpickle 化,  Prev: 通常のクラスインスタンスの pickle 化および unpickle 化,  Up: pickle 化プロトコル

13.1.5.2 拡張型の pickle 化および unpickle 化
.............................................

`Pickler' が全く未知の型の -- 拡張型のような -- オブジェクトに
遭遇した場合、pickle 化方法のヒントとして 2 個所を探します。 第一は
`__reduce__()' メソッドを実装しているかどうかです。
もし実装されていれば、pickle 化時に `__reduce__()' メソッド
が引数なしで呼び出されます。メソッドはこの呼び出しに対して
文字列またはタプルのどちらかを返さねばなりません。

文字列を返す場合、その文字列は通常通りに pickle 化されるグローバル変数
の名前を指しています。`__reduce__' の返す文字列は、
モジュールにからみてオブジェクトのローカルな名前でなければなりません;
pickle モジュールはモジュールの名前空間を検索して、オブジェクトの
属するモジュールを決定します。

タプルを返す場合、タプルの要素数は 2 から 5 でなければなりません。
オプションの要素は省略したり `None' を指定したりできます。
各要素の意味づけは以下の通りです:

   * 呼び出し可能なオブジェクトで、unpickle 化環境において、クラスか、
     "安全なコンストラクタ (safe constructor)" (下を参照してください)
     として登録 されているか、属性 `__safe_for_unpickling__'
     を持ち値が真に
     設定されているような呼び出し可能なオブジェクトでなければなりません。
     そうでない場合、 unpickle 化環境で `UnpicklingError' が
     送出されます。通常通り、呼び出しオブジェクト自体はその名前が
     pickle 化されます。

   * オブジェクトの初期バージョンを生成するために呼び出される
     呼び出し可能オブジェクトです。この呼び出し可能オブジェクトへの引数
     はタプルの次の要素で与えられます。それ以降の要素では pickle
     化されたデータを完全に再構築するために使われる付加的な状態情報
     が与えられます。

     逆 pickle 化の環境下では、このオブジェクトはクラスか、
     "安全なコンストラクタ (safe constructor, 下記参照)" として登録
     されていたり属性`__safe_for_unpickling__' の値が真であるような
     呼び出し可能オブジェクトでなければなりません。 そうでない場合、逆
     pickle 化を行う環境で`UnpicklingError' が送出されます。通常通り、
     callable は名前だけで pickle 化されるので 注意してください。

   * 呼び出し可能なオブジェクトのための引数からなるタプル _Changed in
     Python version 2.5_

   * オプションとして、オブジェクトの状態。 *Note 外部オブジェクトの
     pickle 化および unpickle 化::
     節で記述されているようにして、オブジェクトの `__setstate__()'
     メソッドに渡されます。オブジェクトが `__setstate__()'
     メソッドを持たない場合、上記のように、
     この値は辞書でなくてはならず、オブジェクトの `__dict__'
     に追加されます。

   * オプションとして、リスト中の連続する要素を返すイテレータ
     (シーケンスではありません)。このリストの要素は pickle 化され、
     `obj.append(ITEM)' または `obj.extend(LIST_OF_ITEMS)'
     のいずれかを使って追加されます。主にリストのサブクラスで用いられて
     いますが、他のクラスでも、適切なシグネチャの `append()' や
     `extend()' を備えている限り利用できます。 (`append()' と`extend()'
     のいずれを使うかは、 どのバージョンの pickle
     プロトコルを使っているか、そして追加する
     要素の数で決まります。従って両方のメソッドをサポートしていなければ
     なりません。)

   *   * オプションとして、辞書中の連続する要素を返すイテレータ
     (シーケンスではありません)。このリストの要素は `(KEY, VALUE)'
     という形式でなければなりません。要素は pickle 化され、 `obj[KEY] =
     VALUE' を使ってオブジェクトに格納
     されます。主に辞書のサブクラスで用いられていますが、他のクラスでも、
     `__setitem__' を備えている限り利用できます。


_This is deprecated in Python 2.3.  引数のタプルを使ってください。_

`__reduce__' を実装する場合、プロトコルのバージョンを
知っておくと便利なことがあります。これは `__reduce__' の
代わりに`__reduce_ex__' を使って実現できます。 `__reduce_ex__'
が定義されている場合、 `__reduce__' よりも優先して呼び出されます
(以前のバージョンとの互換性のために `__reduce__'
を残しておいてもかまいません)。 `__reduce_ex__'
はプロトコルのバージョンを表す 整数の引数を一つ伴って呼び出されます。

`object' クラスでは `__reduce__' と `__reduce_ex__'
の両方を定義しています。とはいえ、 サブクラスで `__reduce__'
をオーバライドしており、 `__reduce_ex__'
をオーバライドしていない場合には、 `__reduce_ex__'
の実装がそれを検出して `__reduce__' を呼び出すようになっています。

pickle 化するオブジェクト上で `__reduce__()' メソッドを実装
する代わりに、`copy_reg' モジュールを使って
呼び出し可能オブジェクトを登録する方法もあります。このモジュール
はプログラムに "縮小化関数 (reduction function)" と
ユーザ定義型のためのコンストラクタを登録する方法を提供します。
縮小化関数は、単一の引数として pickle 化するオブジェクトをとる
ことを除き、上で述べた `__reduce__()' メソッドと同じ意味
とインタフェースを持ちます。

登録されたコンストラクタは上で述べたような unpickle 化については
"安全なコンストラクタ" であると考えられます。


File: python-lib-jp.info,  Node: 外部オブジェクトの pickle 化および unpickle 化,  Prev: 拡張型の pickle 化および unpickle 化,  Up: pickle 化プロトコル

13.1.5.3 外部オブジェクトの pickle 化および unpickle 化
.......................................................

オブジェクトの永続化を便利にするために、`pickle' は pickle
化されたデータ列上にないオブジェクトに対して参照を
行うという概念をサポートしています。これらのオブジェクトは "永続化 id
(persistent id)" で参照されており、この id は 単に印字可能な ASCII
文字からなる任意の文字列です。 これらの名前の解決方法は `pickle'
モジュールでは定義されて いません; オブジェクトはこの名前解決を pickler
および unpickler 上のユーザ定義関数にゆだねます (1) 。

外部永続化 id の解決を定義するには、pickler オブジェクトの
`persistent_id' 属性と、 unpickler オブジェクトの `persistent_load'
属性を設定する必要があります。

外部永続化 id を持つオブジェクトを pickle 化するには、pickler は自作の
`persistent_id()' メソッドを
持たなければなりません。このメソッドは一つの引数をとり、 `None'
とオブジェクトの永続化 id のうちどちらかを
返さなければなりません。`None' が返された場合、 pickler
は単にオブジェクトを通常のように pickle 化するだけ です。永続化 id
文字列が返された場合、 piclkler はその 文字列に対して、、unpickler
がこの文字列を永続化 id として 認識できるように、マーカと共に pickle
化します。

外部オブジェクトを unpickle 化するには、unpickler は自作の
`persistent_load()' 関数を持たなければなりません。 この関数は永続化 id
文字列を引数にとり、参照されているオブジェクト を返します。

_多分_ より理解できるようになるようなちょっとした 例を以下に示します:

     import pickle
     from cStringIO import StringIO

     src = StringIO()
     p = pickle.Pickler(src)

     def persistent_id(obj):
         if hasattr(obj, 'x'):
             return 'the value %d' % obj.x
         else:
             return None

     p.persistent_id = persistent_id

     class Integer:
         def __init__(self, x):
             self.x = x
         def __str__(self):
             return 'My name is integer %d' % self.x

     i = Integer(7)
     print i
     p.dump(i)

     datastream = src.getvalue()
     print repr(datastream)
     dst = StringIO(datastream)

     up = pickle.Unpickler(dst)

     class FancyInteger(Integer):
         def __str__(self):
             return 'I am the integer %d' % self.x

     def persistent_load(persid):
         if persid.startswith('the value '):
             value = int(persid.split()[2])
             return FancyInteger(value)
         else:
             raise pickle.UnpicklingError, 'Invalid persistent id'

     up.persistent_load = persistent_load

     j = up.load()
     print j

`cPickle' モジュール内では、 unpickler の `persistent_load' 属性は
Python リスト型として設定することができます。この場合、 unpickler
が永続化 id に遭遇しても、永続化 id 文字列は単にリストに
追加されるだけです。この仕様は、pickle データ中の全てのオブジェクトを
実際にインスタンス化しなくても、 pickle データ列中でオブジェクトに対する
参照を "嗅ぎ回る" ことができるようにするために存在しています (2)。
リストに `persistent_load' を設定するやり方は、 よく Unpickler クラスの
`noload()' メソッドと共に使われます。

---------- Footnotes ----------

(1)  ユーザ定義関数に関連付けを行うための実際のメカニズムは、 `pickle'
および `cPickle' では少し異なります。 `pickle'
のユーザは、サブクラス化を行い、 `persistend_id()' および
`persistent_load()'
メソッドを上書きすることで同じ効果を得ることができます

(2) Guide と Jim が居間に座り込んでピクルス (pickles) を
嗅いでいる光景を想像してください。


File: python-lib-jp.info,  Node: Unpickler をサブクラス化する,  Next: 例 7,  Prev: pickle 化プロトコル,  Up: pickle

13.1.6 Unpickler をサブクラス化する
-----------------------------------

デフォルトでは、逆 pickle 化は pickle 化されたデータ中に見つかった
クラスを import することになります。自前の unpickler をカスタマイズ
することで、何が unpickle 化されて、どのメソッドが呼び出されるか
を厳密に制御することはできます。しかし不運なことに、厳密に
なにを行うべきかは`pickle' と `cPickle' のどちらを使うかで異なります
(1)。

`pickle' モジュールでは、`Unpickler' からサブクラスを
導出し、`load_global()' メソッドを上書きする必要があります。
`load_global()' は pickle データ列から最初の 2 行を読まなければ
ならず、ここで最初の行はそのクラスを含むモジュールの名前、2 行目は
そのインスタンスのクラス名になるはずです。
次にこのメソッドは、例えばモジュールをインポートして属性を掘り起こす
などしてクラスを探し、発見されたものを unpickler のスタックに置きます。
その後、このクラスは空のクラスの `__class__' 属性に代入する
方法で、クラスの `__init__()' を使わずにインスタンスを魔法のように
生成します。 あなたの作業は (もしその作業を受け入れるなら)、unpickler
のスタックの 上に push された `load_global()' を、unpickle
しても安全だと
考えられる何らかのクラスの既知の安全なバージョンにすることです。
あるいは全てのインスタンスに対して unpickling を許可したくないなら
エラーを送出してください。このからくりがハックのように
思えるなら、あなたは間違っていません。このからくりを動かすには、
ソースコードを参照してください。

`cPickle' では事情は多少すっきりしていますが、十分という
わけではありません。何を unpickle 化するかを制御するには、 unpickler の
`find_global' 属性を関数か `None' に 設定します。属性が `None'
の場合、インスタンスを unpickle しようとする試みは全て
`UnpicklingError' を送出します。
属性が関数の場合、この関数はモジュール名またはクラス名を
受理し、対応するクラスオブジェクトを返さなくてはなりません。
このクラスが行わなくてはならないのは、クラスの探索、必要な import
のやり直しです。そしてそのクラスのインスタンスが unpickle
化されるのを防ぐためにエラーを送出することもできます。

以上の話から言えることは、アプリケーションが unpickle 化する
文字列の発信元については非常に高い注意をはらわなくてはならないと
いうことです。

---------- Footnotes ----------

(1)  注意してください: ここで記述されている機構は内部の属性とメソッドを
使っており、これらはPython の将来のバージョンで変更される対象に
なっています。われわれは将来、この挙動を制御するための、 `pickle'
および `cPickle' の両方で動作する、
共通のインタフェースを提供するつもりです。


File: python-lib-jp.info,  Node: 例 7,  Prev: Unpickler をサブクラス化する,  Up: pickle

13.1.7 例
---------

いちばん単純には、`dump()' と `load()' を
使用してください。自己参照リストが正しく pickle 化およびリストアされる
ことに注目してください。

     import pickle

     data1 = {'a': [1, 2.0, 3, 4+6j],
              'b': ('string', u'Unicode string'),
              'c': None}

     selfref_list = [1, 2, 3]
     selfref_list.append(selfref_list)

     output = open('data.pkl', 'wb')

     # Pickle dictionary using protocol 0.
     pickle.dump(data1, output)

     # Pickle the list using the highest protocol available.
     pickle.dump(selfref_list, output, -1)

     output.close()

以下の例は pickle 化された結果のデータを読み込みます。 pickle
を含むデータを読み込む場合、ファイルはバイナリモードで
オープンしなければいけません。これは ASCII 形式とバイナリ形式の
どちらが使われているかは分からないからです。

     import pprint, pickle

     pkl_file = open('data.pkl', 'rb')

     data1 = pickle.load(pkl_file)
     pprint.pprint(data1)

     data2 = pickle.load(pkl_file)
     pprint.pprint(data2)

     pkl_file.close()

より大きな例で、クラスを pickle 化する挙動を変更するやり方を示します。
`TextReader' クラスはテキストファイルを開き、 `readline()'
メソッドが呼ばれるたびに行番号と行の内容を 返します。`TextReader'
インスタンスが pickle 化された場合、 ファイルオブジェクト _以外の_
全ての属性が保存されます。 インスタンスが unpickle
化された際、ファイルは再度開かれ、
以前のファイル位置から読み出しを再開します。上記の動作を
実装するために、`__setstat__()' および `__getstate__()'
メソッドが使われています。

     class TextReader:
         """Print and number lines in a text file."""
         def __init__(self, file):
             self.file = file
             self.fh = open(file)
             self.lineno = 0

         def readline(self):
             self.lineno = self.lineno + 1
             line = self.fh.readline()
             if not line:
                 return None
             if line.endswith("\n"):
                 line = line[:-1]
             return "%d: %s" % (self.lineno, line)

         def __getstate__(self):
             odict = self.__dict__.copy() # copy the dict since we change it
             del odict['fh']              # remove filehandle entry
             return odict

         def __setstate__(self,dict):
             fh = open(dict['file'])      # reopen file
             count = dict['lineno']       # read from file...
             while count:                 # until line count is restored
                 fh.readline()
                 count = count - 1
             self.__dict__.update(dict)   # update attributes
             self.fh = fh                 # save the file object

使用例は以下のようになるでしょう:

     >>> import TextReader
     >>> obj = TextReader.TextReader("TextReader.py")
     >>> obj.readline()
     '1: #!/usr/local/bin/python'
     >>> # (more invocations of obj.readline() here)
     ... obj.readline()
     '7: class TextReader:'
     >>> import pickle
     >>> pickle.dump(obj,open('save.p','w'))

`pickle' が Python プロセス間でうまく働くことを見たい
なら、先に進む前に他の Python セッションを開始してください。
以下の振る舞いは同じプロセスでも新たなプロセスでも起こります。

     >>> import pickle
     >>> reader = pickle.load(open('save.p'))
     >>> reader.readline()
     '8:     "Print and number lines in a text file."'

See also:
     *Note copy_reg:: 拡張型を登録するための Pickle
     インタフェース構成機構。

     *Note shelve:: オブジェクトのインデクス付きデータベース; `pickle'
     を使います。

     *Note copy:: オブジェクトの浅いコピーおよび深いコピー。

     *Note marshal:: 高いパフォーマンスを持つ組み込み型整列化機構。


File: python-lib-jp.info,  Node: cPickle,  Next: copy_reg,  Prev: pickle,  Up: データの永続化

13.2 より高速な `pickle'
========================

`pickle' の高速バージョンですが、サブクラスはできません。

`cPickle' モジュールは Python オブジェクトの直列化および
非直列化をサポートし、`pickle' 

モジュールとほとんど同じインタフェースと機能を提供します。
いくつか相違点がありますが、最も重要な違いはパフォーマンスと
サブクラス化が可能かどうかです。

第一に、`cPickle' は C で実装されているため、`pickle' よりも最大で 1000
倍高速です。第二に、`cPickle' モジュール
内では、呼び出し可能オブジェクト `Pickler()' および `Unpickler()'
は関数で、クラスではありません。 つまり、pickle 化や unpickle
化を行うカスタムのサブクラスを 導出することができないということです。
多くのアプリケーションではこの機能は不要なので、`cPickle'
モジュールによる大きなパフォーマンス向上の恩恵を受けられるはず
です。`pickle' と `cPickle' で作られた pickle
データ列は同じなので、既存の pickle データに対して `pickle' と
`cPickle' を互換に使用することができます (1)。

`cPickle' と `pickle' の API 間には他にも些細な相違が
ありますが、ほとんどのアプリケーションで互換性があります。
より詳細なドキュメンテーションは `pickle' のドキュメント
にあり、そこでドキュメント化されている相違点について挙げています。

---------- Footnotes ----------

(1) pickle データ形式は実際には小規模なスタック指向のプログラム
言語であり、またあるオブジェクトをエンコードする際に多少の自由度が
あるため、二つのモジュールが同じ入力オブジェクトに対して異なる
データ列を生成することもあります。しかし、常に互いに他のデータ列
を読み出せることが保証されています。


File: python-lib-jp.info,  Node: copy_reg,  Next: shelve,  Prev: cPickle,  Up: データの永続化

13.3 `pickle'サポート関数を登録する
===================================

`pickle'サポート関数を登録する。

`copy_reg'モジュールは`pickle' と`cPickle' モジュールに対するサポートを提供します。その上、`copy' モジュールは将来これをつかう可能性が高いです。クラスでないオブジェクトコンストラクタについての設定情報を提供します。このようなコンストラクタはファクトリ関数か、またはクラスインスタンスでしょう。

`constructor(object)'
     OBJECTを有効なコンストラクタであると宣言します。OBJECTが呼び出し可能でなければ(そして、それゆえコンストラクタとして有効でないならば)、`TypeError'を発生します。

`pickle(type, function[, constructor])'
     FUNCTIONが型TYPEのオブジェクトに対する"リダクション"関数として使うことを宣言します。TYPEは"標準的な"クラスオブジェクトであってはいけません。(標準的なクラスは異なった扱われ方をします。詳細は、`pickle'モジュールのドキュメンテーションを参照してください。)
     FUNCTIONは文字列または二ないし三つの要素を含むタプルです。

     オプションのCONSTRUCTORパラメータが与えられた場合は、ピクルス化時にFUNCTIONが返した引数のタプルとともによびだされたときにオブジェクトを再構築するために使われ得る呼び出し可能オブジェクトです。OBJECTがクラスであるか、またはCONSTRUCTORが呼び出し可能でない場合に、`TypeError'を発生します。

     FUNCTIONとCONSTRUCTORの求められるインターフェイスについての詳細は、`pickle'モジュールを参照してください。


File: python-lib-jp.info,  Node: shelve,  Next: marshal,  Prev: copy_reg,  Up: データの永続化

13.4 Python オブジェクトの永続化
================================

Python オブジェクトの永続化。

"シェルフ (shelf, 棚)" は辞書に似た永続性を持つオブジェクトです。 "dbm"
データベースとの違いは、シェルフの値 (キーではありません！)
は実質上どんな Python オブジェクトにも -- `pickle' モジュール
が扱えるなら何でも -- できるということです。これにはほとんどの
クラスインスタンス、再帰的なデータ型、沢山の共有されたサブオブジェクト
を含むオブジェクトが含まれます。キーは通常の文字列です。 

`open(filename[,flag='c'[,protocol=`None'[,writeback=`False']]])'
     永続的な辞書を開きます。指定された FILENAME は、根底にある
     データベースの基本ファイル名となります。副作用として、FILENAME
     には拡張子がつけられる場合があり、ひとつ以上のファイルが生成される
     可能性もあります。デフォルトでは、根底にあるデータベースファイルは
     読み書き可能なように開かれます。オプションの {}FLAG パラメタ は
     `anydbm.open' における FLAG パラメタと同様に 解釈されます。

     デフォルトでは、値を整列化する際にはバージョン 0 の pickle 化が
     用いられます。pickle 化プロトコルのバージョンは PROTOCOL
     パラメタで指定することができます。_Changed in Python version 2.3_

     デフォルトでは、永続的な辞書の可変エントリに対する変更をおこなっても、
     自動的にファイルには書き戻されません。オプションの WRITEBACK
     パラメタが {}TRUE に設定されていれば、アクセスされたすべての
     エントリはメモリ上にキャッシュされ、ファイルを閉じる際に書き戻されます;
     この機能は永続的な辞書上の可変の要素に対する変更を容易にしますが、
     多数のエントリがアクセスされた場合、膨大な量のメモリがキャッシュの
     ために消費され、アクセスされた全てのエントリを書き戻す
     (アクセスされた
     エントリが可変であるか、あるいは実際に変更されたかを決定する方法は
     存在しないのです)
     ために、ファイルを閉じる操作を非常に低速にしてしまいます。

shelve
オブジェクトは辞書がサポートする全てのメソッドをサポートしています。
これにより、辞書ベースのスクリプトから永続的な記憶媒体を必要とする
スクリプトに容易に移行できるようになります。

もう一つ追加でサポートされるメソッドがあります。

`sync()'
     シェルフが WRITEBACK を TRUE にセットして開かれている場合に、
     キャッシュ中の全てのエントリを書き戻します。また容易にできるならば、
     キャッシュを空にしてディスク上の永続的な辞書を同期します。このメソッドは
     シェルフを `close()' によって閉じるとき自動的に呼び出されます。

* Menu:

* 制限事項::
* 使用例 6::


File: python-lib-jp.info,  Node: 制限事項,  Next: 使用例 6,  Prev: shelve,  Up: shelve

13.4.1 制限事項
---------------

   * どのデータベースパッケージが使われるか (例えば `dbm'、
     `gdbm'、`bsddb') は、どのインタフェースが
     利用可能かに依存します。従って、データベースを `dbm'
     を使って直接開く方法は安全ではありません。データベースはまた、
     `dbm' が使われた場合 (不幸なことに) その制約に縛られます --
     これはデータベースに 記録されたオブジェクト (の pickle
     化された表現) はかなり小さく
     なければならず、キー衝突が生じた場合に、稀にデータベースを更新
     することができなくなるということを意味します。 

   * 実装に依存して、永続化した辞書を閉じるときには、変更がディスクに
     書き込まれるかもしれないし、必ずしも書き込まれないかもしれません。
     `Shelf' クラスの `__del__' メソッドは `close'
     メソッドを呼び出すので、プログラマは通常この作業を明示的に行う必要は
     ありません。

   * `shelve' モジュールは、シェルフに置かれたオブジェクトの _並列した_
     読み出し/書き込みアクセスをサポートしません
     (複数の同時読み出しアクセスは安全です)。あるプログラムが書き込み
     ために開かれたシェルフを持っているとき、他のプログラムは
     そのシェルフを読み書きのために開いてはいけません。この問題を
     解決するために UNIX のファイルロック機構を使うことができますが、
     この機構は UNIX のバージョン間で異なり、使われている
     データベースの実装について知識が必要となります。

`Shelf(dict[, protocol=None[, writeback=False]])'
     `UserDict.DictMixin' のサブクラスで、pickle 化された値を DICT
     オブジェクトに保存します。

     デフォルトでは、値を整列化する際にはバージョン 0 の pickle 化が
     用いられます。pickle 化プロトコルのバージョンは PROTOCOL
     パラメタで指定することができます。pickle 化プロトコルについては
     `pickle' のドキュメントを参照してください。 _Changed in Python
     version 2.3_

     WRITEBACK パラメタが {}TRUE
     に設定されていれば、アクセスされたすべての
     エントリはメモリ上にキャッシュされ、ファイルを閉じる際に書き戻されます;
     この機能により、可変のエントリに対して自然な操作が可能になりますが、
     さらに多くのメモリを消費し、辞書をファイルと同期して閉じる際に長い時間が
     かかるようになります。

`BsdDbShelf(dict[, protocol=None[, writeback=False]])'
     `Shelf' のサブクラスで、`first'、`next'、 `previous'、 `last'
     および `set_location' メソッドを公開しています。これらのメソッドは
     `bsddb' モジュールでは
     利用可能ですが、他のデータベースモジュールでは利用できません。
     コンストラクタに渡された DICT オブジェクトは上記のメソッドを
     サポートしていなくてはなりません。通常は、`bsddb.hashopen'、
     `bsddb.btopen' または `bsddb.rnopen' のいずれか
     を呼び出して得られるオブジェクトが条件を満たしています。オプションの
     PROTOCOL、および WRITEBACK パラメタは `Shelf'
     クラスにおけるパラメタと同様に解釈されます。


`DbfilenameShelf(filename[, flag='c'[, protocol=None[, writeback=False]]])'
     `Shelf' のサブクラスで、辞書様オブジェクトの代わりに FILENAME
     を受理します。根底にあるファイルは {}`anydbm.open'
     を使って開かれます。デフォルトでは、
     ファイルは読み書き可能な状態で開かれます。オプションの FLAG
     パラメタは `open' 関数におけるパラメタと同様に解釈されます。
     オプションの PROTOCOL、および WRITEBACK パラメタは `Shelf'
     クラスにおけるパラメタと同様に解釈されます。



File: python-lib-jp.info,  Node: 使用例 6,  Prev: 制限事項,  Up: shelve

13.4.2 使用例
-------------

インタフェースは以下のコードに集約されています (`key' は文字列で、
`data' は任意のオブジェクトです):

     import shelve

     d = shelve.open(filename) # open -- file may get suffix added by low-level
                               # library

     d[key] = data   # store data at key (overwrites old data if
                     # using an existing key)
     data = d[key]   # retrieve a COPY of data at key (raise KeyError if no
                     # such key)
     del d[key]      # delete data stored at key (raises KeyError
                     # if no such key)
     flag = d.has_key(key)   # true if the key exists
     klist = d.keys() # a list of all existing keys (slow!)

     # as d was opened WITHOUT writeback=True, beware:
     d['xx'] = range(4)  # this works as expected, but...
     d['xx'].append(5)   # *this doesn't!* -- d['xx'] is STILL range(4)!!!

     # having opened d without writeback=True, you need to code carefully:
     temp = d['xx']      # extracts the copy
     temp.append(5)      # mutates the copy
     d['xx'] = temp      # stores the copy right back, to persist it

     # or, d=shelve.open(filename,writeback=True) would let you just code
     # d['xx'].append(5) and have it work as expected, BUT it would also
     # consume more memory and make the d.close() operation slower.

     d.close()       # close it

See also:
     *Note anydbm:: `dbm'
     スタイルのデータベースに対する汎用インタフェース。 *Note bsddb::
     BSD `db' データベースインタフェース。 *Note dbhash:: `bsddb'
     をラップする薄いレイヤで、他のデータベースモジュールのように関数
     `open' を提供しています。 *Note dbm:: 標準の UNIX
     データベースインタフェース。 *Note dumbdbm:: `dbm'
     インタフェースの移植性のある実装。 *Note gdbm:: `dbm'
     インタフェースに基づいた GNU データベースインタフェース。 *Note
     pickle:: `shelve' によって使われるオブジェクト整列化機構。 *Note
     cPickle:: `pickle' の高速版。


File: python-lib-jp.info,  Node: marshal,  Next: anydbm,  Prev: shelve,  Up: データの永続化

13.5 内部使用向けの Python オブジェクト整列化
=============================================

Python オブジェクトをバイト列に変換したり、その逆を
(異なる拘束条件下で) 行います。

このモジュールには Python 値をバイナリ形式で読み書きできるような関数
が含まれています。このバイナリ形式は Python 特有のものですが、
マシンアーキテクチャ非依存のものです (つまり、Python の値を PC 上で
ファイルに書き込み、Sun に転送し、そこで読み戻すことができます)。
バイナリ形式の詳細がドキュメントされていないのは故意によるもの です;
この形式は (稀にしかないことですが) Python のバージョン間で
変更される可能性があるからです。(1)

このモジュールは汎用の "永続化 (persistence)" モジュールでは
ありません。汎用的な永続化や、RPC 呼び出しを通じたPython オブジェクト
の転送については、モジュール `pickle' および `shelve'
を参照してください。`marshal' モジュールは主に、 "擬似コンパイルされた
(pseudo-compiled)" コードの `.pyc' ファイル
への読み書きをサポートするために存在します。従って、 Python のメンテナ
は、必要が生じれば marshal 形式を後方互換性のないものに変更する権利を
有しています。Python オブジェクトを直列化および非直列化したい場合には、
`pickle' モジュールを使ってください。

_Notice:_ [warning]
`marshal'モジュールは、誤ったデータや悪意を持って作成されたデータ
に対する安全性を考慮していません。信頼できない、もしくは認証されていない
出所からのデータを非直列化してはなりません。

全ての Python オブジェクト型がサポートされているわけではありません;
一般的には、どの起動中の Python 上に存在するかに依存しないオブジェクト
だけがこのモジュールで読み書きできます。以下の型:
`None'、整数、長整数、浮動小数点数、文字列、Unicode オブジェクト、
タプル、リスト、辞書、タプルとして解釈されるコードオブジェクト、
がサポートされています。リストと辞書は含まれている要素もサポート
されている型であるもののみサポートされています; 再帰的なリストおよび
辞書は書き込んではなりません (無限ループを引き起こしてしまいます)。

*補足説明:* C 言語の `long int' が (DEC Alpha のように) 32
ビットよりも長いビット長を持つ場合、32 ビットよりも長い Python
整数を作成することが可能です。そのような整数が整列化された後、 C 言語の
`long int' のビット長が 32 ビットしかないマシン上で
読み戻された場合、通常整数の代わりにPython 長整数が返されます。
型は異なりますが、数値は同じです。(この動作は Python 2.2 で新たに
追加されたものです。それ以前のバージョンでは、値のうち最小桁から 32
ビット以外の情報は失われ、警告メッセージが出力されます。)

文字列を操作する関数と同様に、ファイルの読み書きを行う関数が
提供されています。

このモジュールでは以下の関数を定義しています:

`dump(value, file[, version])'
     開かれたファイルに値を書き込みます。値はサポートされている型で
     なくてはなりません。ファイルは `sys.stdout' か、 `open()' や
     `posix.popen()' が返すようなファイル
     オブジェクトでなくてはなりません。またファイルはバイナリモード
     (`'wb'' または `'w+b'') で開かれていなければ なりません。

     値 (または値のオブジェクトに含まれるオブジェクト) がサポートされて
     いない型の場合、`ValueError' 例外が送出されます --
     が、同時にごみのデータがファイルに書き込まれます。このオブジェクトは
     `load()' で適切に読み出されることはないはずです。

     _Added in Python version 2.4_

`load(file)'
     開かれたファイルから値を一つ読んで返します。有効な値が読み出せなかった
     場合、`EOFError'、`ValueError'、または `TypeError'
     を送出します。ファイルはバイナリモード (`'rb'' または `'r+b'')
     で開かれたファイルオブジェクトでなければ なりません.
     _サポートされない型を含むオブジェクトが `dump()' で
     整列化されている場合、`load()' は整列化不能な値を `None'
     で置き換えます。_

`dumps(value[, version])'
     `dump(VALUE, FILE)' でファイルに書き込まれるような
     文字列を返します。値はサポートされている型でなければなりません。値が
     サポートされていない型 (またはサポートされていない型のオブジェクト
     を含むような) オブジェクトの場合、`ValueError' 例外が
     送出されます。

     _Added in Python version 2.4_

`loads(string)'
     データ文字列を値に変換します。有効な値が見つからなかった場合、
     `EOFError'、 `ValueError'、または `TypeError' が送出されます。
     文字列中の他の文字は無視されます。

これに加えて、以下の定数が定義されています:

`version'
     モジュールが利用するバージョンを表します。バージョン0 は歴史的
     なフォーマットです。バージョン1(Python 2.4で追加されました)は
     文字列の再利用をします。バージョン 2 (Python 2.5で追加されました)は
     浮動小数点数にバイナリフォーマットを使用します。
     現在のバージョンは2です。 _Added in Python version 2.4_

---------- Footnotes ----------

(1)  このモジュールの名前は (特に) Modula-3 の設計者の間で使われて
いた用語の一つに由来しています。彼らはデータを自己充足的な形式
で輸送する操作に "整列化 (marshalling)" という用語を使いました。
厳密に言えば、"整列させる (to marshal)" とは、あるデータを (例えば RPC
バッファのように) 内部表現形式から外部表現形式に変換する
ことを意味し、"非整列化 (unmarshalling)" とはその逆を意味します。


File: python-lib-jp.info,  Node: anydbm,  Next: whichdb,  Prev: marshal,  Up: データの永続化

13.6 DBM 形式のデータベースへの汎用アクセスインタフェース
=========================================================

DBM 形式のデータベースモジュールに対する汎用インタフェース。

`anydbm' は種々の DBM データベース -- (`bsddb'  を使う) `dbhash'  、
`gdbm' 、および `dbm' -- への汎用インタフェースです。
これらのモジュールがどれもインストールされていない場合、 `dumbdbm'  モジュールの
低速で単純な DBM 実装が使われます。

`open(filename[, flag[, mode]])'
     データベースファイル FILENAME を開き、対応するオブジェクトを
     返します。

     データベースファイルがすでに存在する場合、`whichdb' モジュール
     を使ってファイルタイプが判定され、適切なモジュールが使われます;
     既存のデータベースファイルが存在しなかった場合、上に挙げたモジュール中で
     最初にインポートすることができたものが使われます。

     オプションの FLAG は 既存のデータベースを読み込み専用で開く `'r''、
     既存のデータベースを読み書き用に開く `'w''、
     既存のデータベースが存在しない場合には新たに作成する `'c''、および
     常に新たにデータベースを作成する `'n'' をとることができます。
     この引数が指定されない場合、標準の値は `'r'' になります。

     オプションの MODE
     引数は、新たにデータベースを作成しなければならない 場合に使われる
     UNIX のファイルモードです。標準の値は 8 進数の `0666' です
     (この値は現在有効な umask で修飾されます)。

`error'
     サポートされているモジュールのどれかによって送出されうる例外が
     収められるタプルで、先頭の要素は `anydbm.error' になって います --
     `anydbm.error' が送出された場合、後者が使われます。

`open()' によって返されたオブジェクトは辞書とほとんど同じ
同じ機能をサポートします; キーとそれに対応付けられた値を
記憶し、引き出し、削除することができ、`has_key()' および `keys()'
メソッドを使うことができます。キーおよび値は 常に文字列です。

以下の例ではホスト名と対応するタイトルがいくつか登録し、データベースの
内容を表示します:

     import anydbm

     # データベースを開く、必要なら作成する
     db = anydbm.open('cache', 'c')

     # いくつかの値を設定する
     db['www.python.org'] = 'Python Website'
     db['www.cnn.com'] = 'Cable News Network'

     # 内容についてループ。
     # .keys(), .values() のような他の辞書メソッドもつかえます。
     for k, v in db.iteritems():
         print k, '\t', v

     # 文字列でないキーまたは値は例外を
     # おこします（ほとんどのばあい TypeErrorです)。
     db['www.yahoo.com'] = 4

     # 終了したらcloseします。
     db.close()

See also:
     *Note dbhash:: BSD `db' データベースインタフェース。 *Note dbm::
     標準の UNIX データベースインタフェース。 *Note dumbdbm:: `dbm'
     インタフェースの移植性のある実装。 *Note gdbm:: `dbm'
     インタフェースに基づいた GNU データベースインタフェース。 *Note
     shelve:: Python `dbm' インタフェース上に構築された
     汎用オブジェクト永続化機構。 *Note whichdb::
     既存のデータベースがどの形式のデータベースか判定する
     ユーティリティモジュール。


File: python-lib-jp.info,  Node: whichdb,  Next: dbm,  Prev: anydbm,  Up: データの永続化

13.7 どのDBMモジュールがデータベースを作ったかを推測する
========================================================

どのDBM形式のモジュールが与えられたデータベースを作ったかを推測する

このモジュールに含まれる唯一の関数はあることを推測します。つまり、与えられたファイルを開くためには、利用可能なデータベースモジュール（`dbm'、`gdbm'、`dbhash'）のどれを用いるべきかということです。

`whichdb(filename)'
     ファイルが読めないか存在しないために開くことが出来ない場合は`None'、ファイルの形式を推測できない場合は空の文字列(`''')、推測できる場合は必要なモジュール名（`'dbm''、`'gdbm''など）を含む文字列を返します。


File: python-lib-jp.info,  Node: dbm,  Next: gdbm,  Prev: whichdb,  Up: データの永続化

13.8 UNIX dbmのシンプルなインタフェース
=======================================

ndbmを基にした基本的なデータベースインタフェースです。

dbmモジュールはUNIX(`n')`dbm'インタフェースの
ライブラリを提供します。dbmオブジェクトは、キーと値が必ず文字列である以外は
辞書オブジェクトのようなふるまいをします。
print文などでdbmインスタンスを出力してもキーと値は出力されません。
また、`items()'と`values()'メソッドはサポートされません。

このモジュールは、BSD DB、GNU GDBM互換インタフェースを持った
クラシックなndbmインタフェースを使うことができます。
UNIX上のビルド時に`configure'スクリプトで適切なヘッダファイルが
割り当られます。

以下はこのモジュールの定義:

`error'
     I/Oエラーのようなdbm特有のエラーが起ったときに上げられる値です。
     また、正しくないキーが与えられた場合に通常のマッピングエラーのような
     `KeyError'が上げられます。

`library'
     `ndbm'が使用している実装ライブラリ名です。

`open(filename[, flag[, mode]])'
     dbmデータベースを開いてdbmオブジェクトを返します。
     引数FILENAMEはデータベースのファイル名を指定します。
     (拡張子`.dir'や`.pag'は付けません。 また、BSD
     DBは拡張子`.db'がついたファイルが一つ作成されます。)

     オプション引数FLAGは次のような値を指定します:

     Value                              Meaning
     ------                             -----
     'r'                                存在するデータベースを読取り専用で開きます。(デフォルト)
     'w'                                存在するデータベースを読み書き可能な状態で開きます。
     'c'                                データベースを読み書き可能な状態で開きます。
                                        また、データベースが存在しない場合は新たに作成します。
     'n'                                Always create a new, empty
                                        database, open for reading and
                                        writing
     'n'                                常に空のデータベースが作成され、読み書き可能な状態で開きます。

     オプション引数MODEはデータベース作成時に使用される
     UNIXのファイルモードを指定します。デフォルトでは8進数の`0666'です

See also:
     *Note anydbm:: `dbm'スタイルの一般的なインタフェース *Note gdbm::
     GNU GDBMライブラリの類似したインタフェース *Note whichdb::
     存在しているデータベースの形式を決めるための
     ユーティリティモジュール


File: python-lib-jp.info,  Node: gdbm,  Next: dbhash,  Prev: dbm,  Up: データの永続化

13.9 GNU による dbm の再実装
============================

GNU による dbm の再実装。

このモジュールは `dbm'  モジュールに よく似ていますが、`gdbm'
を使っていくつかの追加機能を提供しています。 `gdbm' と `dbm'
では生成されるファイル形式に互換性がないので 注意してください。

`gdbm' モジュールでは GNU DBM ライブラリへのインタフェースを
提供します。`gdbm' オブジェクトはキーと値が常に文字列である
ことを除き、マップ型 (辞書型) と同じように動作します。 `gdbm'
オブジェクトに対して `print' を適用しても
キーや値を印字することはなく、`items()' 及び `values()'
メソッドはサポートされていません。

このモジュールでは以下の定数および関数を定義しています:

`error'
     I/O エラーのような `gdbm' 特有のエラーで送出されます。
     誤ったキーの指定のように、一般的なマップ型のエラーに対しては
     `KeyError' が送出されます。

`open(filename, [flag, [mode]])'
     `gdbm' データベースを開いて `gdbm' オブジェクトを返します。
     FILENAME 引数はデータベースファイルの名前です。

     オプションの FLAG としては、 `'r''
     (既存のデータベースを読み込み専用で開く -- 標準の値です)、 `'w''
     (既存のデータベースを読み書き用に開く)、 `'c''
     (既存のデータベースが存在しない場合には新たに作成する)、または
     `'n'' (常に新たにデータベースを作成する)、をとることができます。

     データベースをどのように開くかを制御するために、フラグに以下の文字を
     追加することができます:

        * `'f'' --
          データベースを高速モードで開きます。このモードではデータベースへの書き込みはファイルシステムと同期されません。

        * `'s'' --
          同期モードで開きます。データベースへの変更はファイルに即座いに書き込まれます。

        * `'u'' -- データベースをロックしません。

     全てのバージョンの `gdbm' で全てのフラグが有効とは限りません。
     モジュール定数 `open_flags' はサポートされているフラグ文字
     からなる文字列です。無効なフラグが指定された場合、例外 `error'
     が送出されます。

     オプションの MODE
     引数は、新たにデータベースを作成しなければならない 場合に使われる
     UNIX のファイルモードです。標準の値は 8 進数の `0666' です。

辞書型形式のメソッドに加えて、`gdbm' オブジェクトには以下のメソッド
があります:

`firstkey()'
     このメソッドと `next()' メソッドを使って、データベースの全ての
     キーにわたってループ処理を行うことができます。探索は `gdbm' の
     内部ハッシュ値の順番に行われ、キーの値に順に並んでいるとは限りません。
     このメソッドは最初のキーを返します。

`nextkey(key)'
     データベースの順方向探索において、KEY よりも後に来るキーを
     返します。以下のコードはデータベース `db' に
     ついて、キー全てを含むリストをメモリ上に生成することなく
     全てのキーを出力します:

          k = db.firstkey()
          while k != None:
              print k
              k = db.nextkey(k)


`reorganize()'
     大量の削除を実行した後、`gdbm' ファイルの占めるスペースを
     削減したい場合、このルーチンはデータベースを再組織化します。
     この再組織化を使う以外に `gdbm' はデータベースファイルの
     大きさを短くすることはありません; そうでない場合、削除された
     部分のファイルスペースは保持され、新たな (キー、値の) ペアが追加
     される際に再利用されます。

`sync()'
     データベースが高速モードで開かれていた場合、このメソッドは
     ディスクにまだ書き込まれていないデータを全て書き込ませます。

See also:
     *Note anydbm:: `dbm' 形式のデータベースへの汎用インタフェース。
     *Note whichdb::
     既存のデータベースがどの形式のデータベースか判定する
     ユーティリティモジュール。


File: python-lib-jp.info,  Node: dbhash,  Next: bsddb,  Prev: gdbm,  Up: データの永続化

13.10 BSD データベースライブラリへの DBM 形式のインタフェース
=============================================================

BSD データベースライブラリへの DBM 形式のインタフェース。

`dbhash' モジュールでは BSD `db' ライブラリを使って
データベースを開くための関数を提供します。このモジュールは、 DBM 形式
のデータベースへのアクセスを提供する他の Python データベースモジュールの
インタフェースをそのまま反映しています。 `dbhash' を使うには `bsddb' モジュールが必要です。

このモジュールでは一つの例外と一つの関数を提供しています:

`error'
     `KeyError' 以外のデータベースのエラーで送出されます。
     `bsddb.error' と同じ意味です。

`open(path[, flag[, mode]])'
     データベース `db' を開き、データベースオブジェクトを返します。
     引数 PATH はデータベースファイルの名前です。

     引数 FLAG は `'r'' (標準の値)、 `'w''、`'c''
     (データベースが存在しない場合には作成する)、あるいは `'n''
     (常に新たな空のデータベースを作成する) をとることができます。 BSD
     `db' ライブラリがファイルロックをサポートするような
     プラットフォームでは、ロックを使うよう示すために `l'
     を追加することができます。

     オプションの MODE 引数は、新たにデータベースを作成しなければ
     ならないときにデータベースファイルに設定すべき UNIX ファイル権限
     ビットを表すために使われます; この値はプロセスの現在の umask 値で
     マスクされます。

See also:
     *Note anydbm:: `dbm' 形式のデータベースへの汎用インタフェース。
     *Note bsddb:: BSD `db' ライブラリへの低レベルインタフェース。
     *Note whichdb::
     既存のデータベースがどの形式のデータベースか判定する
     ユーティリティモジュール。

* Menu:

* データベースオブジェクト::


File: python-lib-jp.info,  Node: データベースオブジェクト,  Prev: dbhash,  Up: dbhash

13.10.1 データベースオブジェクト
--------------------------------

`open()' によって返されるデータベースオブジェクトは、 全ての DBM
形式データベースやマップ型オブジェクトで共通のメソッドを
提供します。それら標準のメソッドに加え、dbhash では以下のメソッドが
利用可能です。

`first()'
     このメソッドと `next()' メソッドを使って、データベースの全ての
     キー/値のペアにわたってループ処理を行えます。探索はデータベースの
     内部ハッシュ値の順番に行われ、キーの値に順に並んでいるとは限りません。
     このメソッドは最初のキーを返します。

`last()'
     データベース探索における最後のキー/値を返します。逆順探索を開始する
     際に使うことができます; `previous()' を参照してください。

`next()'
     データベースの順方向探索において、次のよりも後に来るキー/値のペアを
     返します。以下のコードはデータベース `db' に
     ついて、キー全てを含むリストをメモリ上に生成することなく
     全てのキーを出力します。

          print db.first()
          for i in xrange(1, len(db)):
              print db.next()


`previous()'
     データベースの逆方向探索において、手前に来るキー/値のペアを
     返します。`last()' と併せて、逆方向の探索に用いられます。

`sync()'
     このメソッドはディスクにまだ書き込まれていないデータを全て書き込ませます。


File: python-lib-jp.info,  Node: bsddb,  Next: dumbdbm,  Prev: dbhash,  Up: データの永続化

13.11 Berkeley DB ライブラリへのインタフェース
==============================================

Berkeley DB ライブラリへのインタフェース

`bsddb' モジュールは Berkeley DB ライブラリへのインタフェース
を提供します。ユーザは適当な `open' 呼び出しを使うことで、
ハッシュ、B-Tree、 またはレコードに基づくデータベースファイルを生成
することができます。bsddb オブジェクトは辞書と大体同じように振る舞い
ます。しかし、キー及び値は文字列でなければならないので、
他のオブジェクトをキーとして使ったり、他の種のオブジェクトを記録
したい場合、それらのデータを何らかの方法で直列化しなければなりません。
これには通常 `marshal.dumps()' や `pickle.dumps()' が使われます。

`bsddb' モジュールは、バージョン 3.3 から 4.4 までの間の Berkeley DB
ライブラリを必要とします。

See also:
    `http://pybsddb.sourceforge.net/'
          Berkeley DBインターフェース `bsddb.db'
          のドキュメントがあります。新しいインターフェースは、Berkeley
          DB
          3と4でSleepycatが提供しているオブジェクト指向インターフェースとほぼ
          同じインターフェースとなっています。

    `http://www.sleepycat.com/'
          Sleepycat Software は、 Berkeley
          DBライブラリを開発しています。


より新しい DB である DBEnv や DBSequence
オブジェクトのインターフェースも `bsddb.db'
モジュールで使用できます。これは、上の URL で説明されている Sleepycat
Berkeley DB C API によりマッチしています。`bsddb.db' API
が提供する追加機能には、チューニングやトランザクション、
ログ出力、マルチプロセス環境でのデータベースへの同時アクセスなどがあります。

以下では、従来のbsddbモジュールと互換性のある、古いインターフェースを解
説しています。Python 2.5
以降、このインターフェースはマルチスレッドに対応しています。
マルチスレッドを使用する場合は `bsddb.db' API を推奨します。
こちらのほうがスレッドをよりうまく制御できるからです。

`bsddb' モジュールでは、適切な形式の Berkeley DB ファイルに
アクセスするオブジェクトを生成する以下の関数を定義しています。
各関数の最初の二つの引数は同じです。可搬性のために、ほとんどの
インスタンスでは最初の二つの引数だけが使われているはずです。

`hashopen(filename[, flag[, mode[, bsize[, ffactor[, nelem[, cachesize[, hash[, lorder]]]]]]]])'
     FILENAME と名づけられたハッシュ形式のファイルを開きます。 FILENAME
     に `None' を指定することで、ディスクに保存する
     つもりがないファイルを生成することもできます。 オプションの FLAG
     には、ファイルを開くためのモードを指定します。 このモードは `r'
     (読み出し専用), `w' (読み書き可能)、 `c' (読み書き可能 -
     必要ならファイルを生成 … これがデフォルトです) または `n'
     (読み書き可能 - ファイル長を 0 に切り詰め)、にすることが
     できます。他の引数はほとんど使われることはなく、下位レベルの
     `dbopen()' 関数に渡されるだけです。他の引数の使い方
     およびその解釈については Berkeley DB のドキュメントを読んで下さい。

`btopen(filename[, flag[, mode[, btflags[, cachesize[, maxkeypage[, minkeypage[, pgsize[, lorder]]]]]]]])'
     FILENAME と名づけられた B-Tree 形式のファイルを開きます。 FILENAME
     に `None' を指定することで、ディスクに保存する
     つもりがないファイルを生成することもできます。 オプションの FLAG
     には、ファイルを開くためのモードを指定します。 このモードは `r'
     (読み出し専用)、 `w' (読み書き可能)、 `c' (読み書き可能 -
     必要ならファイルを生成 … これがデフォルトです)、または `n'
     (読み書き可能 - ファイル長を 0 に切り詰め)、にすることが
     できます。他の引数はほとんど使われることはなく、下位レベルの
     `dbopen()' 関数に渡されるだけです。他の引数の使い方
     およびその解釈については Berkeley DB のドキュメントを読んで下さい。

`rnopen(filename[, flag[, mode[, rnflags[, cachesize[, pgsize[, lorder[, reclen[, bval[, bfname]]]]]]]]])'
     FILENAME と名づけられた DB レコード形式のファイルを開きます、
     FILENAME に `None' を指定することで、ディスクに保存する
     つもりがないファイルを生成することもできます、 オプションの FLAG
     には、ファイルを開くためのモードを指定します、 このモードは `r'
     (読み出し専用), `w' (読み書き可能)、 `c' (読み書き可能 -
     必要ならファイルを生成 … これがデフォルトです)、または `n'
     (読み書き可能 - ファイル長を 0 に切り詰め)、にすることが
     できます。他の引数はほとんど使われることはなく、下位レベルの
     `dbopen()' 関数に渡されるだけです、他の引数の使い方
     およびその解釈については Berkeley DB のドキュメントを読んで下さい。

_Notice:_ 2.3以降の UNIX
版Pythonには、`bsddb185'モジュールが存在する場合があ
ります。このモジュールは古いBerkeley DB 1.85データベースライブラリを持つ
システムをサポートするため_だけ_に存在しています。新規に開発する
コードでは、`bsddb185'を直接使用しないで下さい。

See also:
     *Note dbhash:: `bsddb' への DBM 形式のインタフェース

* Menu:

* ハッシュ、BTree、およびレコードオブジェクト::


File: python-lib-jp.info,  Node: ハッシュ、BTree、およびレコードオブジェクト,  Prev: bsddb,  Up: bsddb

13.11.1 ハッシュ、BTree、およびレコードオブジェクト
---------------------------------------------------

インスタンス化したハッシュ、B-Tree, およびレコードオブジェクトは
辞書型と同じメソッドをサポートするようになります。加えて、以下に
列挙したメソッドもサポートします。 _Changed in Python version 2.3.1_

`close()'
     データベースの背後にあるファイルを閉じます。オブジェクトはアクセスできなく
     なります。これらのオブジェクトには `oepn' メソッドがないため、
     再度ファイルを開くためには、新たな `bsddb' モジュールを開く
     関数を呼び出さなくてはなりません。

`keys()'
     DB ファイルに収められているキーからなるリストを返します。リスト内の
     キーの順番は決まっておらず、あてにはなりません。特に、異なるファイル
     形式の DB 間では返されるリストの順番が異なります。

`has_key(key)'
     引数 KEY が DB ファイルにキーとして含まれている場合 `1'
     を返します。

`set_location(key)'
     カーソルを KEY で示される要素に移動し、キー及び値からなる
     タプルを返します。(`bopen' を使って開かれる) B-Tree
     データベースでは、KEY が実際にはデータベース内に存在しなかった
     場合、カーソルは並び順が KEY の次に来るような要素を指し、
     その場所のキー及び値が返されます。
     他のデータベースでは、データベース中に KEY が見つからなかった 場合
     `KeyError' が送出されます。

`first()'
     カーソルを DB ファイルの最初の要素に設定し、その要素を返します。
     B-Tree
     データベースの場合を除き、ファイル中のキーの順番は決まっていません。
     データベースが空の場合、このメソッドは `bsddb.error'
     を発生させます。

`next()'
     カーソルを DB ファイルの次の要素に設定し、その要素を返します。
     B-Tree データベースの場合を除き、ファイル中のキーの順番は決まって
     いません。

`previous()'
     カーソルを DB ファイルの直前の要素に設定し、その要素を返します。
     B-Tree データベースの場合を除き、ファイル中のキーの順番は決まって
     いません。 (`hashopen()' で開かれるような)  ハッシュ表データベース
     ではサポートされていません。

`last()'
     カーソルを DB ファイルの最後の要素に設定し、その要素を返します。
     ファイル中のキーの順番は決まっていません。 (`hashopen()'
     で開かれるような)  ハッシュ表データベース
     ではサポートされていません。
     データベースが空の場合、このメソッドは `bsddb.error'
     を発生させます。

`sync()'
     ディスク上のファイルをデータベースに同期させます。

以下はプログラム例です:

     >>> import bsddb
     >>> db = bsddb.btopen('/tmp/spam.db', 'c')
     >>> for i in range(10): db['%d'%i] = '%d'% (i*i)
     ...
     >>> db['3']
     '9'
     >>> db.keys()
     ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
     >>> db.first()
     ('0', '0')
     >>> db.next()
     ('1', '1')
     >>> db.last()
     ('9', '81')
     >>> db.set_location('2')
     ('2', '4')
     >>> db.previous()
     ('1', '1')
     >>> for k, v in db.iteritems():
     ...     print k, v
     0 0
     1 1
     2 4
     3 9
     4 16
     5 25
     6 36
     7 49
     8 64
     9 81
     >>> '8' in db
     True
     >>> db.sync()
     0


File: python-lib-jp.info,  Node: dumbdbm,  Next: sqlite3,  Prev: bsddb,  Up: データの永続化

13.12 可搬性のある DBM 実装
===========================

単純な DBM インタフェースに対する可搬性のある実装。

_Notice:_ `dumbdbm' モジュールは、 `anydbm' が安定なモジュールを
他に見つけることができなかった際の最後の手段とされています。 `dumbdbm'
モジュールは速度を重視して書かれているわけではなく、
他のデータベースモジュールのように重い使い方をするためのものでは
ありません。

`dumbdbm' モジュールは永続性辞書に類似したインタフェースを 提供し、全て
Python で書かれています。 `gdbm' や `bsddb' といったモジュールと異なり、
外部ライブラリは必要ありません。他の永続性マップ型のように、
キーおよび値は常に文字列でなければなりません。

このモジュールでは以下の内容を定義してします:

`error'
     I/O エラーのような dumbdbm 特有のエラーの際に送出されます。
     不正なキーを指定したときのような、一般的な対応付けエラーの際には
     `KeyError' が送出されます。

`open(filename[, flag[, mode]])'
     dumbdbm データベースを開き、 dubmdbm オブジェクトを返します。
     FILENAME 引数はデータベースファイル名の雛型 (特定の拡張子を
     もたないもの) です。dumbdbm データベースが生成される際、 `.dat'
     および `.dir' の拡張子を持ったファイルが生成されます。

     オプションの FLAG 引数は現状では無視されます; データベースは
     常に更新のために開かれ、存在しない場合には新たに作成されます。

     オプションの MODE 引数は UNIX におけるファイルのモードで、
     データベースを作成する際に使われます。デフォルトでは 8 進コード の
     `0666' になっています (umask によって修正を受けます)。 _Changed in
     Python version 2.2_

See also:
     *Note anydbm:: `dbm' 形式のデータベースに対する汎用インタフェース。
     *Note dbm:: DBM/NDBM ライブラリに対する同様のインタフェース。
     *Note gdbm:: GNU GDBM ライブラリに対する同様のインタフェース。
     *Note shelve:: 非文字列データを記録する永続化モジュール。 *Note
     whichdb::
     既存のデータベースの形式を判定するために使われるユーティリティモジュール。

* Menu:

* Dumbdbm オブジェクト::


File: python-lib-jp.info,  Node: Dumbdbm オブジェクト,  Prev: dumbdbm,  Up: dumbdbm

13.12.1 Dumbdbm オブジェクト
----------------------------

`UserDict.DictMixin' クラスで提供されているメソッドに加え、 `dumbdbm'
オブジェクトでは以下のメソッドを提供しています。

`sync()'
     ディスク上の辞書とデータファイルを同期します。このメソッドは
     `Shelve' オブジェクトの `sync' メソッドから 呼び出されます。


File: python-lib-jp.info,  Node: sqlite3,  Prev: dumbdbm,  Up: データの永続化

13.13 SQLite データベースに対する DB-API 2.0 インタフェース
===========================================================

A DB-API 2.0 implementation using SQLite 3.x.

_Added in Python version 2.5_

SQLite は、別にサーバプロセスは必要とせずデータベースのアクセスに SQL
問い合わせ言語の非標準的な一種を使える軽量なディスク上のデータベースを
提供する C ライブラリです。ある種のアプリケーションは内部データ保存 に
SQLite を使えます。また、SQLite を使ってアプリケーションのプロトタイ
プを作りその後そのコードを PostgreSQL や Oracle のような大規模データベー
スに移植するということも可能です。

pysqlite は Gerhard H"aring によって書かれ、PEP 249 に記述され た
DB-API 2.0 仕様に準拠したSQL インタフェースを提供するものです。

このモジュールを使うには、最初にデータベースを表す `Connection'
オブジェクトを作ります。ここではデータはファイル `/tmp/example' に
格納されているものとします。

     conn = sqlite3.connect('/tmp/example')

特別な名前である `:memory:' を使うと RAM 上にデータベースを作るこ
ともできます。

`Connection' があれば、 `Cursor' オブジェクトを作りそ の `execute()'
メソッドを呼んで SQL コマンドを実行することができ ます。

     c = conn.cursor()

     # Create table
     c.execute('''create table stocks
     (date text, trans text, symbol text,
      qty real, price real)''')

     # Insert a row of data
     c.execute("""insert into stocks
               values ('2006-01-05','BUY','RHAT',100,35.14)""")

たいてい、SQL 操作は Python 変数の値を使う必要があります。この時、クエ
リーを Python の文字列操作を使って構築することは、安全とは言えないので、
すべきではありません。そのようなことをするとプログラムが SQL インジェク
ション攻撃に対し脆弱になりかねません。

代わりに、DB-API のパラメータ割り当てを使います。`?' を変数の値を
使いたいところに埋めておきます。その上で、値のタプルをカーソル の
`execute()' メソッドの第2引数として引き渡します。(他のデータ
ベースモジュールでは変数の場所を示すのに`%s' や `:1' などの
異なった表記を用いることがあります。) 例を示します。

     # Never do this -- insecure!
     symbol = 'IBM'
     c.execute("... where symbol = '%s'" % symbol)

     # Do this instead
     t = (symbol,)
     c.execute('select * from stocks where symbol=?', t)

     # Larger example
     for t in (('2006-03-28', 'BUY', 'IBM', 1000, 45.00),
               ('2006-04-05', 'BUY', 'MSOFT', 1000, 72.00),
               ('2006-04-06', 'SELL', 'IBM', 500, 53.00),
              ):
         c.execute('insert into stocks values (?,?,?,?,?)', t)

SELECT 文を実行した後データを取得する方法は3つありどれを使っても構いま
せん。一つはカーソルをイテレータとして扱う、一つはカーソル の
`fetchone()' メソッドを呼んで一致した内の一行を取得する、もう 一つは
`fetchall()' メソッドを呼んで一致した全ての行のリストとし
て受け取る、という3つです。

以下の例ではイテレータの形を使います。

     >>> c = conn.cursor()
     >>> c.execute('select * from stocks order by price')
     >>> for row in c:
     ...    print row
     ...
     (u'2006-01-05', u'BUY', u'RHAT', 100, 35.140000000000001)
     (u'2006-03-28', u'BUY', u'IBM', 1000, 45.0)
     (u'2006-04-06', u'SELL', u'IBM', 500, 53.0)
     (u'2006-04-05', u'BUY', u'MSOFT', 1000, 72.0)
     >>>

See also:
    `http://www.pysqlite.org'
          pysqlite のウェブページ

    `http://www.sqlite.org'
          SQLite のウェブページ。 ここの文書ではサポートされる SQL
          方言の文法と使えるデータ型を説明しています

    *PEP249 Database API Specification 2.0*
          Marc-Andr'e Lemburg により書かれた PEP

    `http://www.python.jp/doc/contrib/peps/pep-0249.txt'
          訳注: PEP 249 の日本語訳があります


* Menu:

* モジュールの関数と定数::
* Connection オブジェクト::
* カーソルオブジェクト::
* SQLite と Python の型::
* トランザクション制御::
* pysqlite の効率的な使い方::


File: python-lib-jp.info,  Node: モジュールの関数と定数,  Next: Connection オブジェクト,  Prev: sqlite3,  Up: sqlite3

13.13.1 モジュールの関数と定数
------------------------------

`PARSE_DECLTYPES'
     この定数は `connect' 関数の DETECT_TYPES パラメータと
     して使われます。

     この定数を設定すると `sqlite3' モジュールは戻り値のカラムの宣言
     された型を読み取るようになります。意味を持つのは宣言の最初の単語です。
     すなわち、"integer primary key" においては "integer"
     が読み取られます。
     そしてそのコラムに対して、変換関数の辞書を探してその型に対して登録され
     た関数を使うようにします。変換関数の名前は大文字と小文字を区別します!

`PARSE_COLNAMES'
     この定数は `connect' 関数の DETECT_TYPES パラメータと
     して使われます。

     この定数を設定すると SQLite
     のインタフェースは戻り値のそれぞれのカラムの名前を
     読み取るようになります。文字列の中の [mytype]
     といった形の部分を探し、'mytype'
     がそのカラムの名前であると判断します。そして 'mytype'
     のエントリを変換関数辞書
     の中から見つけ、見つかった変換関数を値を返す際に用います。
     `cursor.description'
     で見つかるカラム名はその最初の単語だけです。すなわち、 もし `'as
     "x [datetime]"'' のようなものを SQL の中で使っていたとすると、
     読み取るのはカラム名の中の最初の空白までの全てですので、カラム名として使われるのは
     単純に "x" ということになります。

`connect(database[, timeout, isolation_level, detect_types, factory])'
     ファイル DATABASE の SQLite データベースへの接続を開きます。
     `":memory:"' という名前を使うことでディスクの代わりに RAM 上
     のデータベースへの接続を開くこともできます。

     データベースが複数の接続からアクセスされている状況で、その内の一つがデー
     タベースに変更を加えたとき、SQLite
     データベースはそのトランザクションが
     コミットされるまでロックされます。TIMEOUT パラメータで、例外を送
     出するまで接続がロックが解除されるのをどれだけ待つかを決めます。デフォ
     ルトは 5.0 (5秒) です。

     ISOLATION_LEVEL パラメータについて は、*Note Connection
     オブジェクト::節の `Connection' オブ ジェクトの `isolation_level'
     プロパティの説明を参照してくださ い。

     SQLite がネイティブにサポートするのは TEXT, INTEGER, FLOAT, BLOB
     およ び NULL
     型だけです。もし他の型を使いたければ、その型のためのサポートを
     自分で追加しなければなりません。DETECT_TYPES パラメータを、モジュー
     ルレベルの `register_converter' 関数で登録した自作の *変換関数*
     と一緒に使えば、簡単にできます。

     パラメータ DETECT_TYPES のデフォルトは 0
     (つまりオフ、型検知無し)です。
     型検知を有効にするためには、`PARSE_DECLTYPES' と `PARSE_COLNAMES'
     の適当な組み合わせをこのパラメータにセットします。

     デフォルトでは、 `sqlite3' モジュールは connect の呼び出しの際に
     モジュールの `Connection' クラスを使います。しか し、`Connection'
     クラスを継承したクラスを FACTORY パラメー タに渡して `connect'
     にそのクラスを使わせることもできます。詳 しくはこのマニュアルの
     *Note デフォルトの適合関数と変換関数::節を参考にしてください。

     `sqlite3' モジュールは SQL 解析のオーバーヘッドを避けるために内
     部で文キャッシュを使っています。接続に対してキャッシュされる文の数を自
     分で指定したいならば、CACHED_STATEMENTS パラメータに設定してくだ
     さい。現在の実装ではデフォルトでキャッシュされる SQL 文の数を 100
     にし ています。

`register_converter(typename, callable)'
     データベースから得られるバイト列を希望する Python
     の型に変換する呼び 出し可能オブジェクト (callable)
     を登録します。その呼び出し可能オブジェ クトは型が TYPENAME
     である全てのデータベース上の値に対して呼び
     出されます。型検知がどのように働くかについては `connect' 関 数の
     DETECT_TYPES パラメータの説明も参照してください。注意が必 要なのは
     TYPENAME はクエリの中の型名と大文字小文字も一致しなけ
     ればならないということです。

`register_adapter(type, callable)'
     自分が使いたい Python の型 TYPE を SQLite がサポートしている型
     に変換する呼び出し可能オブジェクト (callable)
     を登録します。その呼び 出し可能オブジェクト CALLABLE
     はただ一つの引数に Python の値を 受け取り、int, long, float,
     (UTF-8 でエンコードされた) str, unicode または buffer
     のいずれかの型の値を返さなければなりません

`complete_statement(sql)'
     もし文字列 SQL がセミコロンで終端された一つ以上の完全な SQL 文
     であれば `True' を返します。判定は SQL 文として文法的に正し
     いかではなく、閉じられていない文字列リテラルが無いことおよびセミコロン
     で終端されていることだけで行なわれます。

     この関数は以下の例にあるような SQLite
     のシェルを作る際に使われます。

     `sqlite3/complete_statement.py'

`enable_callback_tracebacks(flag)'
     デフォルトでは、ユーザ定義の関数、集計関数、変換関数、認可コールバック
     などはトレースバックを出力しません。デバッグの際にはこの関数を
     FLAG に `True' を指定して呼び出します。そうした後は
     先に述べたような関数のトレースバックが `sys.stderr' に出力されま
     す。元に戻すには `False' を使います。


File: python-lib-jp.info,  Node: Connection オブジェクト,  Next: カーソルオブジェクト,  Prev: モジュールの関数と定数,  Up: sqlite3

13.13.2 Connection オブジェクト
-------------------------------

`Connection' のインスタンスには以下の属性とメソッドがあります:

`isolation_level'
     現在の分離レベルを取得または設定します。None
     で自動コミットモードまたは "DEFERRED", "IMMEDIATE", "EXLUSIVE"
     のどれかです。より詳しい説明は *Note
     位置ではなく名前でカラムにアクセスする::節「トランザクション制御」を
     参照してください。

`cursor([cursorClass])'
     cursor メソッドはオプション引数 CURSORCLASS を受け付けます。
     これを指定するならば、指定されたクラスは `sqlite3.Cursor' を
     継承したカーソルクラスでなければなりません。

`execute(sql, [parameters])'
     このメソッドは非標準のショートカットで、cursor
     メソッドを呼び出して中間的な
     カーソルオブジェクトを作り、そのカーソルの `execute'
     メソッドを与えられた パラメータと共に呼び出します。

`executemany(sql, [parameters])'
     このメソッドは非標準のショートカットで、cursor
     メソッドを呼び出して中間的な
     カーソルオブジェクトを作り、そのカーソルの `executemany'
     メソッドを与えられた パラメータと共に呼び出します。

`executescript(sql_script)'
     このメソッドは非標準のショートカットで、cursor
     メソッドを呼び出して中間的な
     カーソルオブジェクトを作り、そのカーソルの `executescript'
     メソッドを与えられた パラメータと共に呼び出します。

`create_function(name, num_params, func)'
     後から SQL 文中で NAME
     という名前の関数として使えるユーザ定義関数を作成します。
     NUM_PARAMS は関数が受け付ける引数の数、 FUNC は SQL
     関数として使われる Python の呼び出し可能オブジェクトです。

     関数は SQLite
     でサポートされている任意の型を返すことができます。具体的には
     unicode, str, int, long, float, buffer および None です。

     例:

     `sqlite3/md5func.py'

`create_aggregate(name, num_params, aggregate_class)'
     ユーザ定義の集計関数を作成します。

     集計クラスには パラメータ NUM_PARAMS　で指定される個数の引数を取る
     `step' メソッドおよび最終的な集計結果を返す `finalize' メソッドを
     実装しなければなりません。

     `finalize' メソッドは SQLite
     でサポートされている任意の型を返すことができます。 具体的には
     unicode, str, int, long, float, buffer および None です。

     例:

     `sqlite3/mysumaggr.py'

`create_collation(name, callable)'
     NAME と CALLABLE で指定される照合順序を作成します。呼び出
     し可能オブジェクトには二つの文字列が渡されます。一つめのものが二つめ
     のものより低く順序付けられるならば -1 を返し、等しければ 0
     を返し、一 つめのものが二つめのものより高く順序付けられるならば 1
     を返すようにし なければなりません。この関数はソート(SQL での ORDER
     BY)をコントロール するもので、比較を行なうことは他の SQL
     操作には影響を与えないことに注 意しましょう。

     また、呼び出し可能オブジェクトに渡される引数は Python
     のバイト文字列 として渡されますが、それは通常 UTF-8
     で符号化されたものになります。

     以下の例は「間違った方法で」ソートする自作の照合順序です:

     `sqlite3/collation_reverse.py'

     照合順序を取り除くには `create_collation' を callable とし て None
     を渡して呼び出します:

              con.create_collation("reverse", None)


`interrupt()'
     このメソッドを別スレッドから呼び出して接続上で現在実行中であろうクエリを中断させられます。
     クエリが中断されると呼び出し元は例外を受け取ります。

`set_authorizer(authorizer_callback)'
     このルーチンはコールバックを登録します。コールバックはデータベースの
     テーブルのカラムにアクセスしようとするたびに呼び出されます。コールバッ
     クはアクセスが許可されるならば `SQLITE_OK' を、SQL 文全体が
     エラーとともに中断されるべきならば `SQLITE_DENY' を、カラム が
     NULL 値として扱われるべきなら `SQLITE_IGNORE' を返さなけ
     ればなりません。これらの定数は `sqlite3' モジュールに用意され
     ています。

     コールバックの第一引数はどの種類の操作が許可されるかを決めます。第二第
     三引数には第一引数に依存して本当に使われる引数か `None' かが渡
     されます。第四引数はもし適用されるならばデータベースの名前("main",
     "temp",
     etc.)です。第五引数はアクセスを試みる要因となった最も内側のトリ
     ガまたはビューの名前、またはアクセスの試みが入力された SQL
     コードに直接 起因するものならば `None' です。

     第一引数に与えることができる値や、その第一引数によって決まる第二第三引
     数の意味については、SQLite
     の文書を参考にしてください。必要な定数は全 て `sqlite3'
     モジュールに用意されています。

`row_factory'
     この属性を、カーソルとタプルの形での元の行のデータを受け取り最終的な
     行を表すオブジェクトを返す呼び出し可能オブジェクトに、変更することが
     できます。これによって、より進んだ結果の返し方を実装することができま
     す。例えば、カラムの名前で各データにアクセスできるようなオブジェクト
     を返したりできます。

     例:

     `sqlite3/row_factory.py'

     タプルを返すのでは物足りず、名前に基づいたカラムへのアクセスが行ない
     たい場合は、高度に最適化された `sqlite3.Row' 型を `row_factory'
     にセットすることを考えてはいかがでしょうか。 `Row'
     クラスでは添字でも大文字小文字を無視した名前でもカラムに
     アクセスでき、しかもほとんどメモリーを浪費しません。
     おそらく、辞書を使うような独自実装のアプローチよりも、もしか
     すると db の行に基づいた解法よりも良いものかもしれません。

`text_factory'
     この属性を使って TEXT
     データ型をどのオブジェクトで返すかを制御できます。
     デフォルトではこの属性は `unicode' に設定されており、 `sqlite3'
     モジュールは TEXT を Unicode オブジェクトで返します。
     もしバイト列で返したいならば、`str' に設定してください。

     効率の問題を考えて、非ASCIIデータに限って Unicode
     オブジェクトを返し、
     その他の場合にはバイト列を返す方法もあります。これを有効にしたければ、
     この属性を `sqlite3.OptimizedUnicode' に設定してください。

     バイト列を受け取って望みの型のオブジェクトを返すような呼び出し可能オブジェクトを
     何でも設定して構いません。

     以下の説明用のコード例を参照してください:

     `sqlite3/text_factory.py'

`total_changes'
     データベース接続が開始されて以来の行の変更・挿入・削除がなされた行の総数を返します。


File: python-lib-jp.info,  Node: カーソルオブジェクト,  Next: SQLite と Python の型,  Prev: Connection オブジェクト,  Up: sqlite3

13.13.3 カーソルオブジェクト
----------------------------

`Cursor' のインスタンスはには以下の属性とメソッドがあります:

`execute(sql, [parameters])'
     SQL 文を実行します。SQL 文はパラメータ化できます(すなわち SQL
     リテラル の代わりの場所確保文字 (placeholder) を入れておけます)。
     `sqlite3' モジュールは2種類の場所確保記法をサポートします。
     一つは疑問符(qmark スタイル)、もう一つは名前(named スタイル)です。

     まず最初の例は qmark スタイルのパラメータを使った書き方を示します:

     `sqlite3/execute_1.py'

     次の例は named スタイルの使い方です:

     `sqlite3/execute_2.py'

     `execute()' は一つの SQL 文しか実行しません。二つ以上の文を実行
     しようとすると、Warning を発生させます。複数の SQL
     文を一つの呼び出し で実行したい場合は `executescript()'
     を使ってください。

`executemany(sql, seq_of_parameters)'
     SQL 文 SQL を SEQ_OF_PARAMETERS の全てのパラメータシーケン
     スまたはマッピングに対して実行します。`sqlite3'
     モジュールでは、シーケンスの代わりにパラメータの組を
     作り出すイテレータ使うことが許されています。

     `sqlite3/executemany_1.py'

     もう少し短いジェネレータを使った例です:

     `sqlite3/executemany_2.py'

`executescript(sql_script)'
     これは非標準の便宜メソッドで、一度に複数の SQL
     文を実行することができ ます。メソッドは最初に COMMIT
     文を発行し、次いで引数として渡された SQL スクリプトを実行します。

     SQL_SCRIPT はバイト文字列または Unicode 文字列です。

     例:

     `sqlite3/executescript.py'

`rowcount'
     一応 `sqlite3' モジュールの `Cursor' クラスはこの属性を実
     装していますが、データベースエンジン自身の「影響を受けた行」/「選択さ
     れた行」の決定方法は少し風変わりです。

     `SELECT' 文では、全ての行を取得し終えるまで全部で何行になったか決
     められないので `rowcount' はいつでも None です。

     `DELETE' 文では、条件を付けずに `DELETE FROM table' とすると
     SQLite は `rowcount' を 0 と報告します。

     `executemany' では、変更数が `rowcount' に合計されます。

     Python DB API 仕様で求められているように、`rowcount' 属性は
     「現在のカーソルがまだ executeXXX() を実行していない場合や、
     データベースインタフェースから最後に行った操作の結果行数を
     決定できない場合には、この属性は -1 となります」。

