これは python-lib-jp.info、python-lib-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-lib-jp.info,  Node: 電子メールメッセージの表現,  Next: 電子メールメッセージを解析パースする,  Prev: email,  Up: email

7.1.1 電子メールメッセージの表現
--------------------------------

電子メールのメッセージを表現する基底クラス

`Message' クラスは、 `email' パッケージの中心となるクラスです。 これは
`email' オブジェクトモデルの基底クラスになっています。 `Message'
はヘッダフィールドを検索したりメッセージ本体にアクセスするための
核となる機能を提供します。

概念的には、(`email.message'モジュールからインポートされる) `Message'
オブジェクトには _ヘッダ_ と _ペイロード_ が
格納されています。ヘッダは、RFC 2822 形式のフィールド名およびフィールド値が
コロンで区切られたものです。コロンはフィールド名またはフィールド値の
どちらにも含まれません。

ヘッダは大文字小文字を区別した形式で保存されますが、ヘッダ名が一致するかどうかの検査は
大文字小文字を区別せずにおこなうことができます。_Unix-From_ ヘッダまたは
`From_'
ヘッダとして知られるエンベロープヘッダがひとつ存在することもあります。
ペイロードは、単純なメッセージオブジェクトの場合は単なる文字列ですが、
MIME コンテナ文書 (`multipart/*' または `message/rfc822' など) の場合は
`Message' オブジェクトの リストになっています。

`Message' オブジェクトは、メッセージヘッダにアクセスするための マップ
(辞書) 形式のインタフェイスと、ヘッダおよびペイロードの両方に
アクセスするための明示的なインタフェイスを提供します。
これにはメッセージオブジェクトツリーからフラットなテキスト文書を
生成したり、一般的に使われるヘッダのパラメータにアクセスしたり、また
オブジェクトツリーを再帰的にたどったりするための便利なメソッドを含みます。

`Message' クラスのメソッドは以下のとおりです:

`Message()'
     コンストラクタは引数をとりません。

`as_string([unixfrom])'
     メッセージ全体をフラットな文字列として返します。 オプション
     UNIXFROM が `True' の場合、返される文字列には
     エンベロープヘッダも含まれます。UNIXFROM のデフォルトは `False'
     です。

     このメソッドは手軽に利用する事ができますが、必ずしも期待通りにメッセージを
     フォーマットするとは限りません。たとえば、これはデフォルトでは
     `From ' で 始まる行を変更してしまいます。以下の例のように
     `Generator' のインスタンスを生成して `flatten()'
     メソッドを直接呼び出せば より柔軟な処理を行う事ができます。

          from cStringIO import StringIO
          from email.generator import Generator
          fp = StringIO()
          g = Generator(fp, mangle_from_=False, maxheaderlen=60)
          g.flatten(msg)
          text = fp.getvalue()


`__str__()'
     `as_string(unixfrom=True)' と同じです。

`is_multipart()'
     メッセージのペイロードが子 `Message' オブジェクトからなる
     リストであれば `True' を返し、そうでなければ `False' を返します。
     `is_multipart()' が False を返した場合は、ペイロードは
     文字列オブジェクトである必要があります。

`set_unixfrom(unixfrom)'
     メッセージのエンベロープヘッダを UNIXFROM
     に設定します。これは文字列である必要があります。

`get_unixfrom()'
     メッセージのエンベロープヘッダを返します。
     エンベロープヘッダが設定されていない場合は None が返されます。

`attach(payload)'
     与えられた PAYLOAD を現在のペイロードに追加します。
     この時点でのペイロードは `None' か、あるいは `Message'
     オブジェクトの
     リストである必要があります。このメソッドの実行後、ペイロードは必ず
     `Message' オブジェクトのリストになります。ペイロードに
     スカラーオブジェクト (文字列など) を格納したい場合は、かわりに
     `set_payload()' を使ってください。

`get_payload([i[, decode]])'
     現在のペイロードへの参照を返します。これは `is_multipart()' が
     `True' の場合 `Message'
     オブジェクトのリストになり、`is_multipart()' が `False'
     の場合は文字列になります。ペイロードがリストの場合、
     リストを変更することはそのメッセージのペイロードを変更することになります。

     オプション引数の I がある場合、 `is_multipart()' が `True' ならば
     `get_payload()' は ペイロード中で 0 から数えて I
     番目の要素を返します。I が 0
     より小さい場合、あるいはペイロードの個数以上の場合は `IndexError'
     が発生します。ペイロードが文字列 (つまり `is_multipart()' が
     `False') にもかかわらず I が与えられたときは `TypeError'
     が発生します。

     オプションの DECODE はそのペイロードが `Content-Transfer-Encoding'
     ヘッダに従って デコードされるべきかどうかを指示するフラグです。
     この値が `True' でメッセージが multipart ではない場合、
     ペイロードはこのヘッダの値が `quoted-printable' または `base64'
     のときにかぎりデコードされます。これ以外のエンコーディングが
     使われている場合、`Content-Transfer-Encoding' ヘッダが
     ない場合、あるいは曖昧なbase64データが含まれる場合は、ペイロードはそのまま
     (デコードされずに) 返されます。 もしメッセージが multipart で
     DECODE フラグが `True' の場合は `None' が返されます。DECODE
     のデフォルト値は `False' です。

`set_payload(payload[, charset])'
     メッセージ全体のオブジェクトのペイロードを PAYLOAD に設定します。
     ペイロードの形式をととのえるのは呼び出し側の責任です。
     オプションの CHARSET
     はメッセージのデフォルト文字セットを設定します。 詳しくは
     `set_charset()' を参照してください。

     _Changed in Python version 2.2.2_

`set_charset(charset)'
     ペイロードの文字セットを CHARSET に変更します。 ここには
     `Charset'インスタンス (`email.charset' 参照)、
     文字セット名をあらわす文字列、あるいは `None'
     のいずれかが指定できます。 文字列を指定した場合、これは `Charset'
     インスタンスに変換されます。 CHARSET が `None' の場合、`charset'
     パラメータは `Content-Type' ヘッダから除去されます。
     これ以外のものを文字セットとして指定した場合、 `TypeError'
     が発生します。

     ここでいうメッセージとは、CHARSET.INPUT_CHARSET でエンコードされた
     `text/*' 形式のものを仮定しています。これは、もし必要とあらば
     プレーンテキスト形式を変換するさいに CHARSET.OUTPUT_CHARSET の
     エンコードに変換されます。MIME ヘッダ (`MIME-Version',
     `Content-Type', `Content-Transfer-Encoding')
     は必要に応じて追加されます。

     _Added in Python version 2.2.2_

`get_charset()'
     そのメッセージ中のペイロードの `Charset' インスタンスを 返します。
     _Added in Python version 2.2.2_

以下のメソッドは、メッセージの RFC 2822 ヘッダにアクセスするための
マップ (辞書) 形式のインタフェイスを実装したものです。
これらのメソッドと、通常のマップ (辞書)
型はまったく同じ意味をもつわけでは
ないことに注意してください。たとえば辞書型では、同じキーが複数あることは
許されていませんが、ここでは同じメッセージヘッダが複数ある場合があります。
また、辞書型では `keys()' で返されるキーの順序は保証されていませんが、
`Message' オブジェクト内のヘッダはつねに元のメッセージ中に
現れた順序、あるいはそのあとに追加された順序で返されます。削除され、その後
ふたたび追加されたヘッダはリストの一番最後に現れます。

こういった意味のちがいは意図的なもので、最大の利便性をもつようにつくられています。

注意: どんな場合も、メッセージ中のエンベロープヘッダは
このマップ形式のインタフェイスには含まれません。

`__len__()'
     複製されたものもふくめてヘッダ数の合計を返します。

`__contains__(name)'
     メッセージオブジェクトが NAME という名前のフィールドを持っていれば
     true を返します。
     この検査では名前の大文字小文字は区別されません。NAME
     は最後にコロンをふくんでいてはいけません。
     このメソッドは以下のように `in' 演算子で使われます:

          if 'message-id' in myMessage:
              print 'Message-ID:', myMessage['message-id']


`__getitem__(name)'
     指定された名前のヘッダフィールドの値を返します。 NAME
     は最後にコロンをふくんでいてはいけません。 そのヘッダがない場合は
     `None' が返され、`KeyError' 例外は発生しません。

     注意: 指定された名前のフィールドがメッセージのヘッダに
     2回以上現れている場合、
     どちらの値が返されるかは未定義です。ヘッダに存在するフィールドの値をすべて
     取り出したい場合は `get_all()' メソッドを使ってください。

`__setitem__(name, val)'
     メッセージヘッダに NAME という名前の VAL という値をもつ
     フィールドをあらたに追加します。このフィールドは現在メッセージに
     存在するフィールドのいちばん後に追加されます。

     注意: このメソッドでは、すでに同一の名前で存在するフィールドは
     上書き_されません_。もしメッセージが名前 NAME をもつ
     フィールドをひとつしか持たないようにしたければ、最初にそれを除去してください。
     たとえば:

          del msg['subject']
          msg['subject'] = 'PythonPythonPython!'


`__delitem__(name)'
     メッセージのヘッダから、 NAME という名前をもつ
     フィールドをすべて除去します。たとえこの名前をもつヘッダが
     存在していなくても例外は発生しません。

`has_key(name)'
     メッセージが NAME という名前をもつ
     ヘッダフィールドを持っていれば真を、そうでなければ偽を返します。

`keys()'
     メッセージ中にあるすべてのヘッダのフィールド名のリストを返します。

`values()'
     メッセージ中にあるすべてのフィールドの値のリストを返します。

`items()'
     メッセージ中にあるすべてのヘッダのフィールド名とその値を
     2-タプルのリストとして返します。

`get(name[, failobj])'
     指定された名前をもつフィールドの値を返します。
     これは指定された名前がないときにオプション引数の FAILOBJ
     (デフォルトでは `None') を返すことをのぞけば、`__getitem__()'
     と同じです。

役に立つメソッドをいくつか紹介します:

`get_all(name[, failobj])'
     NAME の名前をもつフィールドのすべての値からなるリストを返します。
     該当する名前のヘッダがメッセージ中に含まれていない場合は FAILOBJ
     (デフォルトでは `None') が返されます。

`add_header(_name, _value, **_params)'
     拡張ヘッダ設定。このメソッドは `__setitem__()' と似ていますが、
     追加のヘッダ・パラメータをキーワード引数で指定できるところが違っています。
     _NAME に追加するヘッダフィールドを、_VALUE にそのヘッダの
     _最初の_値を渡します。

     キーワード引数辞書 _PARAMS の各項目ごとに、
     そのキーがパラメータ名として扱われ、キー名にふくまれる
     アンダースコアはハイフンに置換されます (なぜならハイフンは 通常の
     Python 識別子としては使えないからです)。ふつう、 パラメータの値が
     `None' 以外のときは、`key="value"' の
     形で追加されます。パラメータの値が `None'
     のときはキーのみが追加されます。

     例を示しましょう:

          msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')

     こうするとヘッダには以下のように追加されます。

          Content-Disposition: attachment; filename="bud.gif"


`replace_header(_name, _value)'
     ヘッダの置換。_NAME
     と一致するヘッダで最初に見つかったものを置き換えます。
     このときヘッダの順序とフィールド名の大文字小文字は保存されます。
     一致するヘッダがない場合、 `KeyError' が発生します。

     _Added in Python version 2.2.2_

`get_content_type()'
     そのメッセージの content-type を返します。
     返された文字列は強制的に小文字で `maintype/subtype'
     の形式に変換されます。 メッセージ中に `Content-Type'
     ヘッダがない場合、デフォルトの content-type は
     `get_default_type()' が返す値によって与えられます。 RFC 2045 によればメッセージはつねにデフォルトの
     content-type を もっているので、`get_content_type()'
     はつねになんらかの値を返すはずです。

     RFC 2045 はメッセージのデフォルト content-type を、 それが
     `multipart/digest' コンテナに現れているとき以外は `text/plain'
     に規定しています。あるメッセージが `multipart/digest'
     コンテナ中にある場合、その content-type は `message/rfc822'
     になります。 もし `Content-Type' ヘッダが適切でない content-type
     書式だった場合、 RFC 2045 はそれのデフォルトを `text/plain'
     として扱うよう 定めています。

     _Added in Python version 2.2.2_

`get_content_maintype()'
     そのメッセージの主 content-type を返します。 これは
     `get_content_type()' によって 返される文字列の `maintype'
     部分です。

     _Added in Python version 2.2.2_

`get_content_subtype()'
     そのメッセージの副 content-type (sub content-type、subtype)
     を返します。 これは `get_content_type()' によって 返される文字列の
     `subtype' 部分です。

     _Added in Python version 2.2.2_

`get_default_type()'
     デフォルトの content-type を返します。
     ほどんどのメッセージではデフォルトの content-type は `text/plain'
     ですが、メッセージが `multipart/digest' コンテナに
     含まれているときだけ例外的に `message/rfc822' になります。

     _Added in Python version 2.2.2_

`set_default_type(ctype)'
     デフォルトの content-type を設定します。 CTYPE は `text/plain'
     あるいは `message/rfc822'
     である必要がありますが、強制ではありません。 デフォルトの
     content-type はヘッダの `Content-Type' には 格納されません。

     _Added in Python version 2.2.2_

`get_params([failobj[, header[, unquote]]])'
     メッセージの `Content-Type' パラメータをリストとして返します。
     返されるリストは キー/値の組からなる
     2要素タプルが連なったものであり、 これらは `='
     記号で分離されています。`=' の左側は
     キーになり、右側は値になります。パラメータ中に `=' がなかった場合、
     値の部分は空文字列になり、そうでなければその値は `get_param()' で
     説明されている形式になります。また、オプション引数 UNQUOTE が
     `True' (デフォルト) である場合、この値は unquote されます。

     オプション引数 FAILOBJ は、`Content-Type' ヘッダが
     存在しなかった場合に返すオブジェクトです。オプション引数 HEADER
     には `Content-Type' のかわりに検索すべきヘッダを指定します。

     _Changed in Python version 2.2.2_

`get_param(param[, failobj[, header[, unquote]]])'
     メッセージの `Content-Type' ヘッダ中のパラメータ PARAM を
     文字列として返します。そのメッセージ中に `Content-Type' ヘッダが
     存在しなかった場合、 FAILOBJ  (デフォルトは `None') が返されます。

     オプション引数 HEADER が与えられた場合、 `Content-Type'
     のかわりにそのヘッダが使用されます。

     パラメータのキー比較は常に大文字小文字を区別しません。
     返り値は文字列か 3 要素のタプルで、タプルになるのはパラメータが
     RFC 2231 

     エンコードされている場合です。3 要素タプルの場合、各要素の値は
     `(CHARSET, LANGUAGE, VALUE)' の形式になっています。 `CHARSET' と
     `LAGUAGE' は `None' になることがあり、その場合 `VALUE' は
     `us-ascii' 文字セットでエンコードされているとみなさねば
     ならないので注意してください。普段は `LANGUAGE' を無視できます。

     この関数を使うアプリケーションが、パラメータが RFC 2231 形式で
     エンコードされているかどうかを気にしないのであれば、`email.Utils.collapse_rfc2231_value()'
     に `get_param()'
     の返り値を渡して呼び出すことで、このパラメータをひとつにまとめることができます。
     この値がタプルならばこの関数は適切にデコードされた Unicode
     文字列を返し、 そうでない場合は unquote
     された元の文字列を返します。たとえば:

          rawparam = msg.get_param('foo')
          param = email.Utils.collapse_rfc2231_value(rawparam)

     いずれの場合もパラメータの値は (文字列であれ 3要素タプルの `VALUE'
     項目であれ) つねに unquote されます。 ただし、UNQUOTE が `False'
     に指定されている場合は unquote されません。

     _Changed in Python version 2.2.2_

`set_param(param, value[, header[, requote[, charset[, language]]]])'
     `Content-Type' ヘッダ中のパラメータを設定します。
     指定されたパラメータがヘッダ中にすでに存在する場合、その値は VALUE
     に置き換えられます。`Content-Type' ヘッダがまだ
     このメッセージ中に存在していない場合、RFC 2045 にしたがいこの値には
     `text/plain' が設定され、新しいパラメータ値が末尾に追加されます。

     オプション引数 HEADER が与えられた場合、 `Content-Type'
     のかわりにそのヘッダが使用されます。 オプション引数 UNQUOTE が
     `False' でない限り、 この値は unquote されます (デフォルトは
     `True')。

     オプション引数 CHARSET が与えられると、 そのパラメータは RFC 2231 に従ってエンコードされます。
     オプション引数 LANGUAGE は RFC 2231 の言語を指定しますが、
     デフォルトではこれは空文字列となります。 CHARSET と LANGUAGE
     はどちらも文字列である必要があります。

     _Added in Python version 2.2.2_

`del_param(param[, header[, requote]])'
     指定されたパラメータを `Content-Type' ヘッダ中から完全に
     とりのぞきます。ヘッダはそのパラメータと値がない状態に書き換えられます。
     REQUOTE が `False' でない限り (デフォルトでは `True' です)、
     すべての値は必要に応じて quote されます。オプション変数 HEADER
     が与えられた場合、 `Content-Type'
     のかわりにそのヘッダが使用されます。

     _Added in Python version 2.2.2_

`set_type(type[, header][, requote])'
     `Content-Type' ヘッダの maintype と subtype を設定します。 TYPE は
     `maintype/subtype' という形の文字列でなければなりません。
     それ以外の場合は `ValueError' が発生します。

     このメソッドは `Content-Type' ヘッダを置き換えますが、
     すべてのパラメータはそのままにします。REQUOTE が `False' の場合、
     これはすでに存在するヘッダを quote
     せず放置しますが、そうでない場合は 自動的に quote します
     (デフォルト動作)。

     オプション変数 HEADER が与えられた場合、 `Content-Type'
     のかわりにそのヘッダが使用されます。 `Content-Type'
     ヘッダが設定される場合には、 `MIME-Version'
     ヘッダも同時に付加されます。

     _Added in Python version 2.2.2_

`get_filename([failobj])'
     そのメッセージ中の `Content-Disposition' ヘッダにある、 `filename'
     パラメータの値を返します。目的のヘッダに `filename'
     パラメータがない場合には `name'パラメータを探しま
     す。それも無い場合またはヘッダが無い場合には FAILOBJ が返されます。
     返される文字列はつねに `Utils.unquote()' によって unquote
     されます。


`get_boundary([failobj])'
     そのメッセージ中の `Content-Type' ヘッダにある、 `boundary'
     パラメータの値を返します。目的のヘッダが欠けていたり、 `boundary'
     パラメータがない場合には FAILOBJ が返されます。
     返される文字列はつねに `Utils.unquote()' によって unquote
     されます。

`set_boundary(boundary)'
     メッセージ中の `Content-Type' ヘッダにある、 `boundary'
     パラメータに値を設定します。`set_boundary()' は 必要に応じて
     BOUNDARY を quote します。そのメッセージが `Content-Type'
     ヘッダを含んでいない場合、 `HeaderParseError' が発生します。

     注意: このメソッドを使うのは、古い `Content-Type' ヘッダを
     削除して新しい boundary をもったヘッダを `add_header()' で
     足すのとは少し違います。`set_boundary()' は 一連のヘッダ中での
     `Content-Type' ヘッダの位置を保つからです。 しかし、これは元の
     `Content-Type' ヘッダ中に存在していた 連続する行の順番までは
     _保ちません_。

`get_content_charset([failobj])'
     そのメッセージ中の `Content-Type' ヘッダにある、 `charset'
     パラメータの値を返します。値はすべて小文字に変換されます。
     メッセージ中に `Content-Type' がなかったり、このヘッダ中に
     `boundary' パラメータがない場合には FAILOBJ が返されます。

     注意: これは `get_charset()' メソッドとは異なります。
     こちらのほうは文字列のかわりに、そのメッセージボディのデフォルト
     エンコーディングの `Charset' インスタンスを返します。

     _Added in Python version 2.2.2_

`get_charsets([failobj])'
     メッセージ中に含まれる文字セットの名前をすべてリストにして返します。
     そのメッセージが `multipart' である場合、返されるリストの
     各要素がそれぞれの subpart
     のペイロードに対応します。それ以外の場合、 これは長さ 1
     のリストを返します。

     リスト中の各要素は文字列であり、これは対応する subpart 中の
     それぞれの `Content-Type' ヘッダにある `charset' の値です。
     しかし、その subpart が `Content-Type' をもってないか、 `charset'
     がないか、あるいは MIME maintype が `text' でない
     いずれかの場合には、リストの要素として FAILOBJ が返されます。

`walk()'
     `walk()' メソッドは多目的のジェネレータで、
     これはあるメッセージオブジェクトツリー中のすべての part および
     subpart を
     わたり歩くのに使えます。順序は深さ優先です。おそらく典型的な用法は、
     `walk()' を `for' ループ中でのイテレータとして
     使うことでしょう。ループを一回まわるごとに、次の subpart
     が返されるのです。

     以下の例は、 multipart メッセージのすべての part において、 その
     MIME タイプを表示していくものです。

          >>> for part in msg.walk():
          ...     print part.get_content_type()
          multipart/report
          text/plain
          message/delivery-status
          text/plain
          text/plain
          message/rfc822


_Changed in Python version 2.5_

`Message' オブジェクトはオプションとして 2つのインスタンス属性を
とることができます。これはある MIME メッセージからプレーンテキストを
生成するのに使うことができます。

`preamble'
     MIME ドキュメントの形式では、 ヘッダ直後にくる空行と最初の
     multipart 境界をあらわす文字列のあいだに いくらかのテキスト (訳注:
     preamble, 序文) を埋めこむことを許しています。
     このテキストは標準的な MIME の範疇からはみ出しているので、 MIME
     形式を認識するメールソフトからこれらは通常まったく見えません。
     しかしメッセージのテキストを生で見る場合、あるいはメッセージを
     MIME 対応していないメールソフトで見る場合、このテキストは
     目に見えることになります。

     PREAMBLE 属性は MIME ドキュメントに加える この最初の MIME
     範囲外テキストを含んでいます。 `Parser'
     があるテキストをヘッダ以降に発見したが、 それはまだ最初の MIME
     境界文字列が現れる前だった場合、
     パーザはそのテキストをメッセージの PREAMBLE 属性に格納します。
     `Generator' がある MIME メッセージからプレーンテキスト形式を
     生成するとき、これはそのテキストをヘッダと最初の MIME
     境界の間に挿入します。 詳細は `email.parser' および
     `email.Generator' を 参照してください。

     注意: そのメッセージに preamble がない場合、 PREAMBLE 属性には
     `None' が格納されます。

`epilogue'
     EPILOGUE 属性はメッセージの最後の MIME 境界文字列から
     メッセージ末尾までのテキストを含むもので、それ以外は PREAMBLE
     属性と同じです。

     _Changed in Python version 2.5_

`defects'
     DEFECTS 属性はメッセージを解析する途中で検出されたすべての問題点
     (defect、障害) の
     リストを保持しています。解析中に発見されうる障害についてのより詳細な説明は
     `email.errors' を参照してください。

     _Added in Python version 2.4_


File: python-lib-jp.info,  Node: 電子メールメッセージを解析パースする,  Next: MIME 文書を生成する,  Prev: 電子メールメッセージの表現,  Up: email

7.1.2 電子メールメッセージを解析(パース)する
--------------------------------------------

電子メールメッセージのフラットなテキストを解析し、
メッセージオブジェクト構造体を生成する。

メッセージオブジェクト構造体をつくるには 2つの方法があります。
ひとつはまったくのスクラッチから `Message' を生成して、これを
`attach()' と `set_payload()' 呼び出しを介してつなげていく方法で、
もうひとつは電子メールメッセージのフラットなテキスト表現を 解析
(parse、パーズ) する方法です。

`email' パッケージでは、MIME 文書をふくむ、
ほとんどの電子メールの文書構造に対応できる標準的なパーザ (解析器)
を提供しています。
このパーザに文字列あるいはファイルオブジェクトを渡せば、パーザは
そのオブジェクト構造の基底となる (root の) `Message'
インスタンスを返します。
簡単な非MIMEメッセージであれば、この基底オブジェクトのペイロードは
たんにメッセージのテキストを格納する文字列になるでしょう。MIMEメッセージであれば、
基底オブジェクトはその `is_multipart()' メソッドに対して `True' を
返します。そして、その各 subpart に `get_payload()' メソッドおよび
`walk()' メソッドを介してアクセスすることができます。

実際には 2つのパーザインターフェイスが使用可能です。ひとつは旧式の
`Parser' API であり、もうひとつはインクリメンタルな `FeedParser' API
です。 旧式の `Parser' API
はメッセージ全体のテキストが文字列としてすでに
メモリ上にあるか、それがローカルなファイルシステム上に存在しているときには
問題ありません。`FeedParser'
はメッセージを読み込むときに、そのストリームが
入力待ちのためにブロックされるような場合 (ソケットから email
メッセージを 読み込む時など) に、より有効です。`FeedParser'
はインクリメンタ ルにメッセージを読み込み、解析します。パーザを close
したときには根っ こ (root) のオブジェクトのみが返されます(1)。

このパーザは、ある制限された方法で拡張できます。また、もちろん
自分でご自分のパーザを完全に無から実装することもできます。 `email'
パッケージについているパーザと `Message' クラスの間に
隠された秘密の関係はなにもありませんので、ご自分で実装されたパーザも、
それが必要とするやりかたでメッセージオブジェクトツリーを作成することができます。

* Menu:

* FeedParser API::
* Parser クラス API::
* 追加事項::

---------- Footnotes ----------

(1) Python 2.4 から導入 された email パッケージ バージョン 3.0 では、
旧式の `Parser' は `FeedParser' によって書き直されました。
そのためパーザの意味論と得られる結果は
2つのパーザで同一のものになります。


File: python-lib-jp.info,  Node: FeedParser API,  Next: Parser クラス API,  Prev: 電子メールメッセージを解析パースする,  Up: 電子メールメッセージを解析パースする

7.1.2.1 FeedParser API
......................

_Added in Python version 2.4_

`email.feedparser' モジュールからインポートされる `FeedParser' は email
メッセージをインクリメンタルに解析するのに 向いた API を提供します。
これは email メッセージのテキストを (ソケットなどの)
読み込みがブロックされる
可能性のある情報源から入力するときに必要となります。もちろん
`FeedParser' は 文字列またはファイルにすべて格納されている email
メッセージを解析するのにも
使うことができますが、このような場合には旧式の `Parser' API のほうが
便利かもしれません。これら 2つのパーザ API
の意味論と得られる結果は同一です。

`FeedParser' API は簡単です。まずインスタンスをつくり、それに
テキストを (それ以上テキストが必要なくなるまで) 流しこみます。その後
パーザを close すると根っこ (root)
のメッセージオブジェクトが返されます。
標準に従ったメッセージを解析する場合、`FeedParser' は非常に
正確であり、標準に従っていないメッセージでもちゃんと動きます。
そのさい、これはメッセージがどのように壊れていると認識されたかについての
情報を残します。これはメッセージオブジェクトの DEFECTS 属性に
リストとして現れ、メッセージ中に発見された問題が記録されます。
パーザが検出できる障害 (defect) については `email.errors'
モジュールを参照してください。

以下は `FeedParser' の API です:

`FeedParser([_factory])'
     `FeedParser' インスタンスを作成します。オプション引数 _FACTORY には
     引数なしの callable
     を指定し、これはつねに新しいメッセージオブジェクトの作成が
     必要になったときに呼び出されます。デフォルトでは、これは
     `email.message.Message' クラスになっています。

`feed(data)'
     `FeedParser' にデータを供給します。DATA は 1行または複数行からなる
     文字列を渡します。渡される行は完結していなくてもよく、その場合
     `FeedParser'
     は部分的な行を適切につなぎ合わせます。文字列中の各行は標準的な
     3種類の 行末文字 (復帰 CR、改行 LF、または CR+LF)
     どれかの組み合わせでよく、これらが 混在してもかまいません。

`close()'
     `FeedParser' を close し、それまでに渡されたすべてのデータの
     解析を完了させ根っこ (root) のメッセージオブジェクトを返します。
     `FeedParser' を close したあとにさらにデータを feed した場合の
     挙動は未定義です。


File: python-lib-jp.info,  Node: Parser クラス API,  Next: 追加事項,  Prev: FeedParser API,  Up: 電子メールメッセージを解析パースする

7.1.2.2 Parser クラス API
.........................

`email.parser'モジュールからインポートされる`Parser'クラ
スは、メッセージを表すテキストが文字列またはファイルの形で
完全に使用可能なときメッセージを解析するのに使われる API を提供します。
`email.Parser' モジュールはまた、`HeaderParser' と呼ばれる
2番目のクラスも提供しています。これはメッセージのヘッダのみを処理したい場合に
使うことができ、ずっと高速な処理がおこなえます。なぜならこれはメッセージ本体を
解析しようとはしないからです。かわりに、そのペイロードにはメッセージ本体の
生の文字列が格納されます。`HeaderParser' クラスは `Parser' クラスと同じ
API をもっています。

`Parser([_class])'
     `Parser' クラスのコンストラクタです。 オプション引数 _CLASS
     をとることができます。 これは呼び出し可能なオブジェクト
     (関数やクラス) でなければならず、 メッセージ内コンポーネント
     (sub-message object) が作成されるときは
     常にそのファクトリクラスとして使用されます。 デフォルトではこれは
     `Message' になっています (`email.message'
     参照)。このファクトリクラスは引数なしで呼び出されます。

     オプション引数 STRICT は無視されます。 _This is deprecated in
     Python 2.4.   `Parser' は Python 2.4 で新しく導入された
     `FeedParser' の 後方互換性のための API ラッパで、_すべての_
     解析が事実上 non-strict です。 `Parser' コンストラクタに STRICT
     フラグを渡す必要はありません。_

     _Changed in Python version 2.2.2_ _Changed in Python version 2.4_

それ以外の `Parser' メソッドは以下のとおりです:

`parse(fp[, headersonly])'
     ファイルなどストリーム形式 (1) のオブジェクト FP から
     すべてのデータを読み込み、得られたテキストを解析して基底 (root)
     メッセージ オブジェクト構造を返します。FP
     はストリーム形式のオブジェクトで `readline()' および `read()'
     両方のメソッドを サポートしている必要があります。

     FP に格納されているテキスト文字列は、一連の RFC 2822 形式の
     ヘッダおよびヘッダ継続行 (header continuation lines)
     によって構成されている
     必要があります。オプションとして、最初にエンペローブヘッダが来ることもできます。
     ヘッダ部分はデータの終端か、ひとつの空行によって終了したとみなされます。
     ヘッダ部分に続くデータはメッセージ本体となります (MIME
     エンコードされた subpart を含んでいるかもしれません)。

     オプション引数 HEADERSONLY はヘッダ部分を解析しただけで終了するか
     否かを指定します。デフォルトの値は `False' で、これはそのファイルの
     内容すべてを解析することを意味しています。

     _Changed in Python version 2.2.2_

`parsestr(text[, headersonly])'
     メソッドに似ていますが、ファイルなどのストリーム形式のかわりに
     文字列を引数としてとるところが違います。文字列に対してこのメソッドを
     呼ぶことは、TEXT を `StringIO' インスタンスとして作成して
     `parse()' を適用するのと同じです。

     オプション引数 HEADERSONLY は `parse()' メソッドと同じです。

     _Changed in Python version 2.2.2_

ファイルや文字列からメッセージオブジェクト構造を作成するのは
かなりよくおこなわれる作業なので、便宜上次のような 2つの関数が
提供されています。これらは `email' パッケージのトップレベルの
名前空間で使用できます。

`message_from_string(s[, _class[, strict]])'
     文字列からメッセージオブジェクト構造を作成し返します。 これは
     `Parser().parsestr(s)' とまったく同じです。 オプション引数 _CLASS
     および STRICT は `Parser' クラスの
     コンストラクタと同様に解釈されます。

     _Changed in Python version 2.2.2_

`message_from_file(fp[, _class[, strict]])'
     Open
     されたファイルオブジェクトからメッセージオブジェクト構造を作成し返します。
     これは `Parser().parse(fp)' とまったく同じです。 オプション引数
     _CLASS および STRICT は `Parser' クラスの
     コンストラクタと同様に解釈されます。

     _Changed in Python version 2.2.2_

対話的な Python
プロンプトでこの関数を使用するとすれば、このようになります:

     >>> import email
     >>> msg = email.message_from_string(myString)

---------- Footnotes ----------

(1) file-like object


File: python-lib-jp.info,  Node: 追加事項,  Prev: Parser クラス API,  Up: 電子メールメッセージを解析パースする

7.1.2.3 追加事項
................

以下はテキスト解析の際に適用されるいくつかの規約です:

   * ほとんどの
     非`multipart'形式のメッセージは単一の文字列ペイロードをもつ
     単一のメッセージオブジェクトとして解析されます。このオブジェクトは
     `is_multipart()' に対して `False' を返します。このオブジェクトに
     対する `get_payload()' メソッドは文字列オブジェクトを返します。

   * `multipart'形式のメッセージはすべてメッセージ内 コンポーネント
     (sub-message object) のリストとして解析されます。
     外側のコンテナメッセージオブジェクトは `is_multipart()' に対して
     `True' を返し、このオブジェクトに対する `get_payload()' メソッドは
     `Message' subpart のリストを返します。

   * `message/*' の Content-Type をもつほどんどのメッセージ (例:
     `message/delivery-status' や `message/rfc822' など) も
     コンテナメッセージオブジェクトとして解析されますが、
     ペイロードのリストの長さは 1 になります。このオブジェクトは
     `is_multipart()' メソッドに対して `True' を返し、
     リスト内にあるひとつだけの要素がメッセージ内のコンポーネントオブジェクトになります。

   * いくつかの標準的でないメッセージは、`multipart' の使い方に
     統一がとれていない場合があります。このようなメッセージは
     `Content-Type' ヘッダに `multipart' を指定しているものの、 その
     `is_multipart()' メソッドは `False' を返すことがあります。
     もしこのようなメッセージが `FeedParser' によって解析されると、
     その DEFECTS 属性のリスト中には
     `MultipartInvariantViolationDefect' クラスの
     インスタンスが現れます。詳しい情報については `email.errors' を
     参照してください。


File: python-lib-jp.info,  Node: MIME 文書を生成する,  Next: 電子メールおよび MIME オブジェクトをゼロから作成する,  Prev: 電子メールメッセージを解析パースする,  Up: email

7.1.3 MIME 文書を生成する
-------------------------

メッセージ構造からフラットな電子メールテキストを生成する。

よくある作業のひとつは、メッセージオブジェクト構造から
フラットな電子メールテキストを生成することです。この作業は `smtplib' や
`nntplib' モジュールを使って
メッセージを送信したり、メッセージをコンソールに出力したりするときに
必要になります。あるメッセージオブジェクト構造をとってきて、
そこからフラットなテキスト文書を生成するのは `Generator'
クラスの仕事です。

繰り返しになりますが、`email.parser' モジュールと同じく、
この機能は既存の Generator だけに限られるわけではありません。
これらはご自身でゼロから作りあげることもできます。しかし、
既存のジェネレータはほとんどの電子メールを標準に沿ったやり方で
生成する方法を知っていますし、MIME メッセージも非 MIME メッセージも
扱えます。さらにこれはフラットなテキストから `Parser' クラスを使って
メッセージ構造に変換し、それをまたフラットなテキストに戻しても、
結果が冪等 (1) になるよう設計されています。

`email.generator'モジュールからインポートされる `Generator'
クラスで公開されているメソッドには、以下のようなもの があります:

`Generator(outfp[, mangle_from_[, maxheaderlen]])'
     `Generator' クラスのコンストラクタは OUTFP と呼ばれる
     ストリーム形式 (2) のオブジェクトひとつを 引数にとります。OUTFP は
     `write()' メソッドをサポートし、 Python 拡張 print
     文の出力ファイルとして使えるようになっている必要があります。

     オプション引数 MANGLE_FROM_ はフラグで、`True' のときは
     メッセージ本体に現れる行頭のすべての `From ' という文字列の最初に
     `>' という文字を追加します。これは、このような行が UNIX の mailbox
     形式のエンペローブヘッダ区切り文字列として誤認識されるのを防ぐための、
     移植性ある唯一の方法です (詳しくは WHY THE CONTENT-LENGTH FORMAT
     IS BAD (なぜ Content-Length 形式が有害か)
     を参照してください)。デフォルトでは MANGLE_FROM_ は `True'
     になっていますが、 UNIX の mailbox 形式ファイルに出力しないのならば
     これは `False' に設定してもかまいません。

     オプション引数 MAXHEADERLEN は連続していないヘッダの最大長を
     指定します。ひとつのヘッダ行が MAXHEADERLEN (これは文字数です、
     tab は空白 8文字に展開されます) よりも長い場合、ヘッダは
     `email.header.Header' クラスで定義されているように途中で
     折り返され、間にはセミコロンが挿入されます。
     もしセミコロンが見つからない場合、そのヘッダは放置されます。
     ヘッダの折り返しを禁止するにはこの値にゼロを指定してください。
     デフォルトは 78 文字で、RFC 2822 で推奨されている
     (ですが強制ではありません) 値です。

これ以外のパブリックな `Generator' メソッドは以下のとおりです:

`flatten(msg[, unixfrom])'
     MSG を基点とするメッセージオブジェクト構造体の
     文字表現を出力します。出力先のファイルにはこの `Generator'
     インスタンスが 作成されたときに指定されたものが使われます。各
     subpart は深さ優先順序 (depth-first)
     で出力され、得られるテキストは適切に MIME エンコードされた
     ものになっています。

     オプション引数 UNIXFROM は、基点となるメッセージオブジェクトの
     最初の RFC 2822 ヘッダが現れる前に、エンペローブヘッダ区切り文字列を
     出力することを強制するフラグです。そのメッセージオブジェクトが
     エンペローブヘッダをもたない場合、標準的なエンペローブヘッダが自動的に
     作成されます。デフォルトではこの値は `False' に設定されており、
     エンペローブヘッダ区切り文字列は出力されません。

     注意: 各 subpart に関しては、エンペローブヘッダは出力されません。

     _Added in Python version 2.2.2_

`clone(fp)'
     この `Generator' インスタンスの独立したクローンを生成し返します。
     オプションはすべて同一になっています。

     _Added in Python version 2.2.2_

`write(s)'
     文字列 S を既定のファイルに出力します。 ここでいう出力先は
     `Generator' コンストラクタに 渡した OUTFP
     のことをさします。この関数はただ単に 拡張 print 文で使われる
     `Generator' インスタンスに対して ファイル操作風の API
     を提供するためだけのものです。

ユーザの便宜をはかるため、メソッド `Message.as_string()' と
`str(aMessage)' (つまり `Message.__str__()' のことです) をつかえば
メッセージオブジェクトを特定の書式でフォーマットされた文字列に簡単に変換することができます。
詳細は `email.message' を参照してください。

`email.generator' モジュールはひとつの派生クラスも提供しています。
これは `DecodedGenerator' と呼ばれるもので、`Generator' 基底クラスと
似ていますが、非`text'型の subpart を特定の書式でフォーマットされた
表現形式で置きかえるところが違っています。

`DecodedGenerator(outfp[, mangle_from_[, maxheaderlen[, fmt]]])'
     このクラスは `Generator' から派生したもので、 メッセージの subpart
     をすべて渡り歩きます。subpart の主形式が `text'
     だった場合、これはその subpart のペイロードを
     デコードして出力します。オプション引数 _MANGLE_FROM_ および
     MAXHEADERLEN の意味は基底クラス `Generator' のそれと同じです。

     Subpart の主形式が `text' ではない場合、オプション引数 FMT
     がそのメッセージペイロードのかわりのフォーマット文字列として使われます。
     FMT は `%(keyword)s' のような形式を展開し、
     以下のキーワードを認識します:

        * `type' - 非`text'型 subpart の MIME 形式

        * `maintype' - 非`text'型 subpart の MIME 主形式 (maintype)

        * `subtype' - 非`text'型 subpart の MIME 副形式 (subtype)

        * `filename' - 非`text'型 subpart のファイル名

        * `description' - 非`text'型 subpart につけられた説明文字列

        * `encoding' - 非`text'型 subpart の Content-transfer-encoding


     FMT のデフォルト値は `None' です。
     こうすると以下の形式で出力します:

          [Non-text (%(type)s) part of message omitted, filename %(filename)s]

     _Added in Python version 2.2.2_

_Changed in Python version 2.5_

---------- Footnotes ----------

(1) 訳注: idempotent、その操作を何回くり返しても 1回だけ行ったのと
結果が同じになること。

(2) 訳注: file-like object


File: python-lib-jp.info,  Node: 電子メールおよび MIME オブジェクトをゼロから作成する,  Next: 国際化されたヘッダ,  Prev: MIME 文書を生成する,  Up: email

7.1.4 電子メールおよび MIME オブジェクトをゼロから作成する
----------------------------------------------------------

ふつう、メッセージオブジェクト構造はファイルまたは何がしかの
テキストをパーザに通すことで得られます。パーザは与えられた
テキストを解析し、基底となる root のメッセージオブジェクトを返します。
しかし、完全なメッセージオブジェクト構造を何もないところから作成することも
また可能です。個別の `Message' を手で作成することさえできます。
実際には、すでに存在するメッセージオブジェクト構造をとってきて、
そこに新たな `Message' オブジェクトを追加したり、あるものを
別のところへ移動させたりできます。これは MIME メッセージを
切ったりおろしたりするために非常に便利なインターフェイスを提供します。

新しいメッセージオブジェクト構造は `Message' インスタンスを
作成することにより作れます。ここに添付ファイルやその他適切なものを
すべて手で加えてやればよいのです。MIME メッセージの場合、 `email'
パッケージはこれらを簡単におこなえるようにするために
いくつかの便利なサブクラスを提供しています。

以下がそのサブクラスです:

`MIMEBase(_maintype, _subtype, **_params)'
     Module: `email.mime.base'

     これはすべての MIME 用サブクラスの基底となるクラスです。 とくに
     `MIMEBase' のインスタンスを直接作成することは (可能ではありますが)
     ふつうはしないでしょう。`MIMEBase' は 単により特化された MIME
     用サブクラスのための便宜的な基底クラスとして提供されています。

     _MAINTYPE は `Content-Type' の主形式 (maintype) であり (`text' や
     `image' など)、_SUBTYPE は `Content-Type' の副形式 (subtype) です
     (`plain' や `gif' など)。 _PARAMS
     は各パラメータのキーと値を格納した辞書であり、 これは直接
     `Message.add_header()' に渡されます。

     `MIMEBase' クラスはつねに (_MAINTYPE、 _SUBTYPE、 および _PARAMS
     にもとづいた) `Content-Type' ヘッダと、 `MIME-Version' ヘッダ
     (必ず `1.0' に設定される) を追加します。

`MIMENonMultipart()'
     Module: `email.mime.nonmultipart'

     `MIMEBase' のサブクラスで、これは `multipart' 形式でない MIME
     メッセージのための中間的な基底クラスです。このクラスのおもな目的は、
     通常 `multipart' 形式のメッセージに対してのみ意味をなす `attach()'
     メソッドの使用をふせぐことです。もし `attach()' メソッドが
     呼ばれた場合、これは `MultipartConversionError' 例外を発生します。

     _Added in Python version 2.2.2_

`MIMEMultipart([subtype[, boundary[, _subparts[, _params]]]])'
     Module: `email.mime.multipart'

     `MIMEBase' のサブクラスで、これは `multipart' 形式の MIME
     メッセージのための中間的な基底クラスです。オプション引数 _SUBTYPE
     は デフォルトでは `mixed' になっていますが、そのメッセージの副形式
     (subtype) を
     指定するのに使うことができます。メッセージオブジェクトには
     `multipart/'_SUBTYPE という値をもつ `Content-Type' ヘッダとともに、
     `MIME-Version' ヘッダが追加されるでしょう。

     オプション引数 BOUNDARY は multipart の境界文字列です。 これが
     `None' の場合 (デフォルト)、境界は必要に応じて計算されます。

     _SUBPARTS はそのペイロードの subpart
     の初期値からなるシーケンスです。
     このシーケンスはリストに変換できるようになっている必要があります。
     新しい subpart はつねに `Message.attach()' メソッドを使って
     そのメッセージに追加できるようになっています。

     `Content-Type' ヘッダに対する追加のパラメータは キーワード引数
     _PARAMS を介して取得あるいは設定されます。
     これはキーワード辞書になっています。

     _Added in Python version 2.2.2_

`MIMEApplication(_data[, _subtype[, _encoder[, **_params]]])'
     Module: `email.mime.application'

     `MIMENonMultipart'のサブクラスである `MIMEApplication' ク ラスは
     MIME メッセージオブジェクトのメジャータイプ `application'
     を表します。_DATAは生のバイト列が入った文 字列です。オプション引数
     _SUBTYPEは MIMEのサブタイプを設定します。 サブタイプのデフォルトは
     `octet-stream' です。

     オプション引数の_ENCODERは呼び出し可能なオブジェクト(関数など)で、
     データの転送に使う実際のエンコード処理を行います。
     この呼び出し可能なオブジェクトは引数を1つ取り、それは
     `MIMEApplication'のインスタンスです。
     ペイロードをエンコードされた形式に変更するために`get_payload()'
     と`set_payload()'を使い、
     必要に応じて`Content-Transfer-Encoding'やその他のヘッダをメッ
     セージオブジェクトに追加するべきです。デフォルトのエンコードはbase64で
     す。組み込みのエンコーダの一覧は `email.encoders' モジュール
     を見てください。

     _PARAMS は 基底クラスのコンストラクタにそのまま渡されます。 _Added
     in Python version 2.5_

`MIMEAudio(_audiodata[, _subtype[, _encoder[, **_params]]])'
     Module: `email.mime.audio'

     `MIMEAudio' クラスは `MIMENonMultipart' のサブクラスで、 主形式
     (maintype) が `audio' の MIME
     オブジェクトを作成するのに使われます。 _AUDIODATA
     は実際の音声データを格納した文字列です。 もしこのデータが標準の
     Python モジュール `sndhdr' によって
     認識できるものであれば、`Content-Type' ヘッダの 副形式 (subtype)
     は自動的に決定されます。 そうでない場合はその画像の形式 (subtype)
     を _SUBTYPE で
     明示的に指定する必要があります。副形式が自動的に決定できず、
     _SUBTYPE の指定もない場合は、`TypeError' が発生します。

     オプション引数 _ENCODER は呼び出し可能なオブジェクト (関数など)
     で、 トランスポートのさいに画像の実際のエンコードをおこないます。
     このオブジェクトは `MIMEAudio'
     インスタンスの引数をひとつだけ取ることができます。
     この関数は、与えられたペイロードをエンコードされた形式に変換するのに
     `get_payload()' および `set_payload()' を使う必要があります。
     また、これは必要に応じて `Content-Transfer-Encoding' あるいは
     そのメッセージに適した何らかのヘッダを追加する必要があります。
     デフォルトのエンコーディングは base64
     です。組み込みのエンコーダの詳細については `email.encoders'
     を参照してください。

     _PARAMS は `MIMEBase' コンストラクタに直接渡されます。

`MIMEImage(_imagedata[, _subtype[, _encoder[, **_params]]])'
     Module: `email.mime.image'

     `MIMEImage' クラスは `MIMENonMultipart' のサブクラスで、 主形式
     (maintype) が `image' の MIME
     オブジェクトを作成するのに使われます。 _IMAGEDATA
     は実際の画像データを格納した文字列です。 もしこのデータが標準の
     Python モジュール `imghdr' によって
     認識できるものであれば、`Content-Type' ヘッダの 副形式 (subtype)
     は自動的に決定されます。 そうでない場合はその画像の形式 (subtype)
     を _SUBTYPE で
     明示的に指定する必要があります。副形式が自動的に決定できず、
     _SUBTYPE の指定もない場合は、`TypeError' が発生します。

     オプション引数 _ENCODER は呼び出し可能なオブジェクト (関数など)
     で、 トランスポートのさいに画像の実際のエンコードをおこないます。
     このオブジェクトは `MIMEImage'
     インスタンスの引数をひとつだけ取ることができます。
     この関数は、与えられたペイロードをエンコードされた形式に変換するのに
     `get_payload()' および `set_payload()' を使う必要があります。
     また、これは必要に応じて `Content-Transfer-Encoding' あるいは
     そのメッセージに適した何らかのヘッダを追加する必要があります。
     デフォルトのエンコーディングは base64
     です。組み込みのエンコーダの詳細については `email.encoders'
     を参照してください。

     _PARAMS は `MIMEBase' コンストラクタに直接渡されます。

`MIMEMessage(_msg[, _subtype])'
     Module: `email.mime.message'

     `MIMEMessage' クラスは `MIMENonMultipart' のサブクラスで、 主形式
     (maintype) が `message' の MIME
     オブジェクトを作成するのに使われます。ペイロードとして使われるメッセージは
     _MSG になります。これは `Message' クラス (あるいはそのサブクラス)
     の インスタンスでなければいけません。そうでない場合、この関数は
     `TypeError' を発生します。

     オプション引数 _SUBTYPE はそのメッセージの副形式 (subtype)
     を設定します。 デフォルトではこれは `rfc822' になっています。

`MIMEText(_text[, _subtype[, _charset]])'
     Module: `email.mime.text'

     `MIMEText' クラスは `MIMENonMultipart' のサブクラスで、 主形式
     (maintype) が `text' の MIME
     オブジェクトを作成するのに使われます。ペイロードの文字列は _TEXT
     になります。_SUBTYPE には副形式 (subtype) を指定し、 デフォルトは
     `plain' です。_CHARSET はテキストの
     文字セットで、`MIMENonMultipart'
     コンストラクタに引数として渡されます。 デフォルトではこの値は
     `us-ascii' になっています。
     テキストデータに対しては文字コードの推定やエンコードはまったく行われません。

     _Changed in Python version 2.4_


File: python-lib-jp.info,  Node: 国際化されたヘッダ,  Next: 文字セットの表現,  Prev: 電子メールおよび MIME オブジェクトをゼロから作成する,  Up: email

7.1.5 国際化されたヘッダ
------------------------

非ASCII形式のヘッダを表現する

RFC 2822 は電子メールメッセージの形式を規定する基本規格です。
これはほとんどの電子メールが ASCII 文字のみで構成されていたころ普及した
RFC 822 標準から発展したものです。RFC 2822 は電子メールが すべて 7-bit
ASCII 文字のみから構成されていると仮定して作られた仕様です。

もちろん、電子メールが世界的に普及するにつれ、この仕様は国際化されてきました。
今では電子メールに言語依存の文字セットを使うことができます。
基本規格では、まだ電子メールメッセージを 7-bit ASCII 文字のみを
使って転送するよう要求していますので、多くの RFC でどうやって 非ASCII
の電子メールを RFC 2822 準拠な形式にエンコードするかが
記述されています。これらの RFC は以下のものを含みます: RFC 2045 、 RFC
2046 、 RFC 2047 、 および RFC 2231 。 `email' パッケージは、
`email.header' および `email.charset' モジュールでこれらの規格を
サポートしています。

ご自分の電子メールヘッダ、たとえば `Subject' や `To'
などのフィールドに非ASCII文字を入れたい場合、 `Header'
クラスを使う必要があります。`Message' オブジェクトの
該当フィールドに文字列ではなく、`Header' インスタンスを 使うのです。
`Header'クラスは`email.header'モジュールから インポートしてください。
たとえば:

     >>> from email.message import Message
     >>> from email.header import Header
     >>> msg = Message()
     >>> h = Header('p\xf6stal', 'iso-8859-1')
     >>> msg['Subject'] = h
     >>> print msg.as_string()
     Subject: =?iso-8859-1?q?p=F6stal?=

`Subject' フィールドに非ASCII文字をふくめていることに
注目してください。ここでは、含めたいバイト列がエンコードされている
文字セットを指定して `Header' インスタンスを作成することによって
実現しています。のちにこの `Message' インスタンスから
フラットなテキストを生成するさいに、この `Subject' フィールドは RFC 2047 準拠の適切な形式にエンコードされます。MIME
機能のついている メーラなら、このヘッダに埋めこまれた ISO-8859-1
文字をただしく表示するでしょう。

_Added in Python version 2.2.2_

以下は `Header' クラスの説明です:

`Header([s[, charset[, maxlinelen[, header_name[, continuation_ws[, errors]]]]]])'
     別の文字セットの文字列をふくむ MIME準拠なヘッダを作成します。

     オプション引数 S はヘッダの値の初期値です。 これが `None' の場合
     (デフォルト)、ヘッダの初期値は設定されません。 この値はあとから
     `append()' メソッドを呼びだすことによって
     追加することができます。S はバイト文字列か、あるいは Unicode
     文字列でもかまいません。 この意味については `append()'
     の項を参照してください。

     オプション引数 CHARSET には 2つの目的があります。 ひとつは
     `append()' メソッドにおける CHARSET 引数と
     同じものです。もうひとつの目的は、これ以降 CHARSET 引数を 省略した
     `append()' メソッド呼び出しすべてにおける、
     デフォルト文字セットを決定するものです。コンストラクタに CHARSET
     が与えられない場合 (デフォルト)、初期値の S および 以後の
     `append()' 呼び出しにおける文字セットとして `us-ascii'
     が使われます。

     行の最大長は MAXLINELEN によって明示的に指定できます。 最初の行を
     (`Subject' などの S に含まれない フィールドヘッダの責任をとるため)
     短く切りとる場合、 HEADER_NAME
     にそのフィールド名を指定してください。 MAXLINELEN のデフォルト値は
     76 であり、HEADER_NAME の デフォルト値は `None'
     です。これはその最初の行を
     長い、切りとられたヘッダとして扱わないことを意味します。

     オプション引数 CONTINUATION_WS は RFC 2822 準拠の
     折り返し用余白文字で、ふつうこれは空白か、ハードウェアタブ文字
     (hard tab) である
     必要があります。ここで指定された文字は複数にわたる行の行頭に挿入されます。

     オプション引数 ERRORS は、`append()' メソッドにそのまま渡されます。

`append(s[, charset[, errors]])'
     この MIME ヘッダに文字列 S を追加します。

     オプション引数 CHARSET がもし与えられた場合、これは `Charset'
     インスタンス (`email.charset' を参照) か、
     あるいは文字セットの名前でなければなりません。この場合は `Charset'
     インスタンスに変換されます。この値が `None' の場合 (デフォルト)、
     コンストラクタで与えられた CHARSET が使われます。

     S はバイト文字列か、Unicode 文字列です。 こればバイト文字列
     (`isinstance(s, str)' が真) の場合、 CHARSET
     はその文字列のエンコーディングであり、
     これが与えられた文字セットでうまくデコードできないときは
     `UnicodeError' が発生します。

     いっぽう S が Unicode 文字列の場合、CHARSET は
     その文字列の文字セットを決定するためのヒントとして使われます。
     この場合、RFC 2822 準拠のヘッダは RFC 2047 の規則をもちいて作成され、
     Unicode 文字列は以下の文字セットを (この優先順位で)
     適用してエンコードされます: `us-ascii'、 CHARSET
     で与えられたヒント、それもなければ `utf-8'。 最初の文字セットは
     `UnicodeError' をなるべくふせぐために使われます。

     オプション引数 ERRORS は `unicode()' 又は `ustr.encode()'
     の呼び出し時に使用し、デフォルト値は "strict"です。

`encode([splitchars])'
     メッセージヘッダを RFC に沿ったやり方でエンコードします。
     おそらく長い行は折り返され、非ASCII部分は base64 または
     quoted-printable エンコーディングで包含されるでしょう。
     オプション引数 SPLITCHARS には長いASCII行を分割する
     文字の文字列を指定し、 RFC 2822 の_highest level syntactic
     breaks_の 大まかなサポートの為に使用します。この引数は RFC 2047 でエンコード
     された行には影響しません。

`Header' クラスは、標準の演算子や組み込み関数を
サポートするためのメソッドもいくつか提供しています。

`__str__()'
     `Header.encode()' と同じです。 `str(aHeader)'
     などとすると有用でしょう。

`__unicode__()'
     組み込みの `unicode()' 関数の補助です。 ヘッダを Unicode
     文字列として返します。

`__eq__(other)'
     このメソッドは、ふたつの `Header'
     インスタンスどうしが等しいかどうか 判定するのに使えます。

`__ne__(other)'
     このメソッドは、ふたつの `Header'
     インスタンスどうしが異なっているかどうかを 判定するのに使えます。

さらに、`email.header' モジュールは以下のような
便宜的な関数も提供しています。

`decode_header(header)'
     文字セットを変換することなしに、メッセージのヘッダをデコードします。
     ヘッダの値は HEADER に渡します。

     この関数はヘッダのそれぞれのデコードされた部分ごとに、
     `(decoded_string, charset)' という形式の 2要素タプルからなる
     リストを返します。CHARSET はヘッダのエンコードされていない部分に
     対しては `None' を、それ以外の場合はエンコードされた文字列が
     指定している文字セットの名前を小文字からなる文字列で返します。

     以下はこの使用例です:

          >>> from email.header import decode_header
          >>> decode_header('=?iso-8859-1?q?p=F6stal?=')
          [('p\xf6stal', 'iso-8859-1')]


`make_header(decoded_seq[, maxlinelen[, header_name[, continuation_ws]]])'
     `decode_header()' によって返される 2要素タプルのリストから
     `Header' インスタンスを作成します。

     `decode_header()' はヘッダの値をとってきて、 `(decoded_string,
     charset)' という形式の 2要素タプルからなる
     リストを返します。ここで DECODED_STRING はデコードされた文字列、
     CHARSET はその文字セットです。

     この関数はこれらのリストの項目から、`Header'
     インスタンスを返します。 オプション引数 MAXLINELEN、HEADER_NAME
     および CONTINUATION_WS は `Header'
     コンストラクタに与えるものと同じです。


File: python-lib-jp.info,  Node: 文字セットの表現,  Next: エンコーダ,  Prev: 国際化されたヘッダ,  Up: email

7.1.6 文字セットの表現
----------------------

文字セット

このモジュールは文字セットを表現する `Charset' クラスと
電子メールメッセージにふくまれる文字セット間の変換、および
文字セットのレジストリとこのレジストリを操作するための
いくつかの便宜的なメソッドを提供します。`Charset' インスタンスは
`email' パッケージ中にあるほかのいくつかのモジュールで使用されます。

このクラスは `email.charset' モジュールからimportしてください。

_Added in Python version 2.2.2_

`Charset([input_charset])'
     文字セットを email のプロパティに写像する。 Map character sets to
     their email properties.

     このクラスはある特定の文字セットに対し、電子メールに課される制約の情報を提供します。
     また、与えられた適用可能な codec
     をつかって、文字セット間の変換をおこなう
     便宜的なルーチンも提供します。またこれは、ある文字セットが与えられたときに、
     その文字セットを電子メールメッセージのなかで どうやって RFC
     に準拠したやり方で使用するかに関する、
     できうるかぎりの情報も提供します。

     文字セットによっては、それらの文字を電子メールのヘッダあるいはメッセージ本体で使う場合は
     quoted-printable 形式あるいは
     base64形式でエンコードする必要があります。
     またある文字セットはむきだしのまま変換する必要があり、電子メールの中では
     使用できません。

     以下ではオプション引数 INPUT_CHARSET について説明します。
     この値はつねに小文字に強制的に変換されます。
     そして文字セットの別名が正規化されたあと、この値は文字セットの
     レジストリ内を検索し、ヘッダのエンコーディングと
     メッセージ本体のエンコーディング、および出力時の変換に使われる
     codec をみつけるのに使われます。 たとえば INPUT_CHARSET が
     `iso-8859-1' の場合、ヘッダおよびメッセージ本体は quoted-printable
     でエンコードされ、出力時の変換用 codec は必要ありません。 もし
     INPUT_CHARSET が `euc-jp' ならば、ヘッダは base64
     でエンコードされ、
     メッセージ本体はエンコードされませんが、出力されるテキストは
     `euc-jp' 文字セットから `iso-2022-jp' 文字セットに変換されます。

`Charset' インスタンスは以下のようなデータ属性をもっています:

`input_charset'
     最初に指定される文字セットです。
     一般に通用している別名は、_正式な_ 電子メール用の名前に変換されます
     (たとえば、`latin_1' は `iso-8859-1' に変換されます)。
     デフォルトは 7-bit の `us-ascii' です。

`header_encoding'
     この文字セットが電子メールヘッダに使われる前にエンコードされる必要がある場合、
     この属性は `Charset.QP' (quoted-printable エンコーディング)、
     `Charset.BASE64' (base64 エンコーディング)、あるいは 最短の QP
     または BASE64 エンコーディングである `Charset.SHORTEST' に
     設定されます。そうでない場合、この値は `None' になります。

`body_encoding'
     HEADER_ENCODING と同じですが、この値はメッセージ本体のための
     エンコーディングを記述します。これはヘッダ用のエンコーディングとは
     違うかもしれません。BODY_ENCODING では、`Charset.SHORTEST' を
     使うことはできません。

`output_charset'
     文字セットによっては、電子メールのヘッダあるいはメッセージ本体に
     使う前にそれを変換する必要があります。もし INPUT_CHARSET が
     それらの文字セットのどれかをさしていたら、この OUTPUT_CHARSET
     属性は それが出力時に変換される文字セットの名前をあらわしています。
     それ以外の場合、この値は `None' になります。

`input_codec'
     INPUT_CHARSET を Unicode に変換するための Python 用 codec 名です。
     変換用の codec が必要ないときは、この値は `None' になります。

`output_codec'
     Unicode を OUTPUT_CHARSET に変換するための Python 用 codec 名です。
     変換用の codec が必要ないときは、この値は `None' になります。
     この属性は INPUT_CODEC と同じ値をもつことになるでしょう。

`Charset' インスタンスは、以下のメソッドも持っています:

`get_body_encoding()'
     メッセージ本体のエンコードに使われる content-transfer-encoding
     の値を返します。

     この値は使用しているエンコーディングの文字列 `quoted-printable'
     または `base64' か、
     あるいは関数のどちらかです。後者の場合、これはエンコードされる
     Message オブジェクトを
     単一の引数として取るような関数である必要があります。この関数は変換後
     `Content-Transfer-Encoding'
     ヘッダ自体を、なんであれ適切な値に設定する必要があります。

     このメソッドは BODY_ENCODING が `QP' の場合 `quoted-printable'
     を返し、BODY_ENCODING が `BASE64' の場合 `base64'
     を返します。それ以外の場合は文字列 `7bit' を返します。

`convert(s)'
     文字列 S を INPUT_CODEC から OUTPUT_CODEC に変換します。

`to_splittable(s)'
     おそらくマルチバイトの文字列を、安全に split
     できる形式に変換します。 S には split する文字列を渡します。

     これは INPUT_CODEC を使って文字列を Unicode にすることで、
     文字と文字の境界で (たとえそれがマルチバイト文字であっても) 安全に
     split できるようにします。

     INPUT_CHARSET の文字列 S をどうやって Unicode に変換すればいいかが
     不明な場合、このメソッドは与えられた文字列そのものを返します。

     Unicode に変換できなかった文字は、Unicode 置換文字 (Unicode
     replacement character) `U+FFFD' に置換されます。

`from_splittable(ustr[, to_output])'
     split できる文字列をエンコードされた文字列に変換しなおします。
     USTR は "逆split" するための Unicode 文字列です。

     このメソッドでは、文字列を Unicode
     からべつのエンコード形式に変換するために 適切な codec
     を使用します。与えられた文字列が Unicode ではなかった場合、
     あるいはそれをどうやって Unicode から変換するか不明だった場合は、
     与えられた文字列そのものが返されます。

     Unicode から正しく変換できなかった文字については、 適当な文字
     (通常は `?') に置き換えられます。

     TO_OUTPUT が `True' の場合 (デフォルト)、 このメソッドは
     OUTPUT_CODEC をエンコードの形式として 使用します。TO_OUTPUT が
     `False' の場合、これは INPUT_CODEC を使用します。

`get_output_charset()'
     出力用の文字セットを返します。

     これは OUTPUT_CHARSET 属性が `None' でなければその値になります。
     それ以外の場合、この値は INPUT_CHARSET と同じです。

`encoded_header_len()'
     エンコードされたヘッダ文字列の長さを返します。 これは
     quoted-printable エンコーディングあるいは base64
     エンコーディングに対しても 正しく計算されます。

`header_encode(s[, convert])'
     文字列 S をヘッダ用にエンコードします。

     CONVERT が `True' の場合、
     文字列は入力用文字セットから出力用文字セットに自動的に変換されます。
     これは行の長さ問題のあるマルチバイトの文字セットに対しては役に立ちません
     (マルチバイト文字はバイト境界ではなく、文字ごとの境界で split
     する必要があります)。 これらの問題を扱うには、高水準のクラスである
     `Header' クラスを 使ってください (`email.header' を参照)。 CONVERT
     の値はデフォルトでは `False' です。

     エンコーディングの形式 (base64 または quoted-printable) は、
     HEADER_ENCODING 属性に基づきます。

`body_encode(s[, convert])'
     文字列 S をメッセージ本体用にエンコードします。

     CONVERT が `True' の場合 (デフォルト)、
     文字列は入力用文字セットから出力用文字セットに自動的に変換されます。
     `header_encode()' とは異なり、メッセージ本体にはふつう
     バイト境界の問題やマルチバイト文字セットの問題がないので、
     これはきわめて安全におこなえます。

     エンコーディングの形式 (base64 または quoted-printable) は、
     BODY_ENCODING 属性に基づきます。

`Charset' クラスには、 標準的な演算と組み込み関数をサポートする
いくつかのメソッドがあります。

`__str__()'
     INPUT_CHARSET を小文字に変換された文字列型として返します。
     `__repr__()' は、`__str__()' の別名となっています。

`__eq__(other)'
     このメソッドは、2つの `Charset'
     インスタンスが同じかどうかをチェックするのに使います。

`__ne__(other)'
     このメソッドは、2つの `Charset'
     インスタンスが異なるかどうかをチェックするのに使います。

また、`email.charset' モジュールには、
グローバルな文字セット、文字セットの別名(エイリアス) および codec
用のレジストリに 新しいエントリを追加する以下の関数もふくまれています:

`add_charset(charset[, header_enc[, body_enc[, output_charset]]])'
     文字の属性をグローバルなレジストリに追加します。

     CHARSET
     は入力用の文字セットで、その文字セットの正式名称を指定する必要があります。

     オプション引数 HEADER_ENC および BODY_ENC は quoted-printable
     エンコーディングをあらわす `Charset.QP' か、 base64
     エンコーディングをあらわす `Charset.BASE64'、 最短の
     quoted-printable または base64 エンコーディングをあらわす
     `Charset.SHORTEST'、あるいはエンコーディングなしの `None' の
     どれかになります。`SHORTEST' が使えるのは HEADER_ENC だけです。
     デフォルトの値はエンコーディングなしの `None' になっています。

     オプション引数 OUTPUT_CHARSET には出力用の文字セットが入ります。
     `Charset.convert()' が呼ばれたときの変換は
     まず入力用の文字セットを Unicode
     に変換し、それから出力用の文字セットに
     変換されます。デフォルトでは、出力は入力と同じ文字セットになっています。

     INPUT_CHARSET および OUTPUT_CHARSET は
     このモジュール中の文字セット-codec 対応表にある Unicode codec
     エントリである 必要があります。モジュールがまだ対応していない
     codec を追加するには、 `add_codec()'
     を使ってください。より詳しい情報については `codecs'
     モジュールの文書を参照してください。

     グローバルな文字セット用のレジストリは、モジュールの global 辞書
     `CHARSETS' 内に保持されています。

`add_alias(alias, canonical)'
     文字セットの別名 (エイリアス) を追加します。 ALIAS
     はその別名で、たとえば `latin-1' のように指定します。 CANONICAL
     はその文字セットの正式名称で、たとえば `iso-8859-1'
     のように指定します。

     文字セットのグローバルな別名用レジストリは、モジュールの global
     辞書 `ALIASES' 内に保持されています。

`add_codec(charset, codecname)'
     与えられた文字セットの文字と Unicode との変換をおこなう codec
     を追加します。

     CHARSET はある文字セットの正式名称で、 CODECNAME は Python 用
     codec の名前です。 これは組み込み関数 `unicode()' の第2引数か、
     あるいは Unicode 文字列型の `encode()' メソッドに
     適した形式になっていなければなりません。


File: python-lib-jp.info,  Node: エンコーダ,  Next: 例外および障害クラス,  Prev: 文字セットの表現,  Up: email

7.1.7 エンコーダ
----------------

電子メールメッセージのペイロードのためのエンコーダ。

何もないところから `Message' を作成するときしばしば必要になるのが、
ペイロードをメールサーバに通すためにエンコードすることです。
これはとくにバイナリデータを含んだ `image/*' や `text/*'
タイプのメッセージで必要です。

`email' パッケージでは、`encoders' モジュールにおいて
いくかの便宜的なエンコーディングをサポートしています。実際にはこれらの
エンコーダは `MIMEAudio' および `MIMEImage' クラスの
コンストラクタでデフォルトエンコーダとして使われています。
すべてのエンコーディング関数は、エンコードするメッセージオブジェクト
ひとつだけを引数にとります。これらはふつうペイロードを取りだし、
それをエンコードして、ペイロードをエンコードされたものにセットしなおします。
これらはまた `Content-Transfer-Encoding' ヘッダを適切な値に 設定します。

提供されているエンコーディング関数は以下のとおりです:

`encode_quopri(msg)'
     ペイロードを quoted-printable 形式にエンコードし、
     `Content-Transfer-Encoding' ヘッダを `quoted-printable'(1)
     に設定します。
     これはそのペイロードのほとんどが通常の印刷可能な文字からなっているが、
     印刷不可能な文字がすこしだけあるときのエンコード方法として適しています。

`encode_base64(msg)'
     ペイロードを base64 形式でエンコードし、
     `Content-Transfer-Encoding' ヘッダを `base64'
     に変更します。これはペイロード中の
     データのほとんどが印刷不可能な文字である場合に適しています。
     quoted-printable
     形式よりも結果としてはコンパクトなサイズになるからです。 base64
     形式の欠点は、これが人間にはまったく読めないテキストに
     なってしまうことです。

`encode_7or8bit(msg)'
     これは実際にはペイロードを変更はしませんが、ペイロードの形式に応じて
     `Content-Transfer-Encoding' ヘッダを `7bit' あるいは `8bit'
     に適した形に設定します。

`encode_noop(msg)'
     これは何もしないエンコーダです。 `Content-Transfer-Encoding'
     ヘッダを設定さえしません。

---------- Footnotes ----------

(1) 注意: `encode_quopri()' を
使ってエンコードすると、データ中のタブ文字や空白文字も
エンコードされます。


File: python-lib-jp.info,  Node: 例外および障害クラス,  Next: 雑用ユーティリティ,  Prev: エンコーダ,  Up: email

7.1.8 例外および障害クラス
--------------------------

email パッケージで使われる例外クラス

`email.errors' モジュールでは、 以下の例外クラスが定義されています:

`MessageError()'
     これは `email' パッケージが発生しうるすべての例外の基底クラスです。
     これは標準の `Exception' クラスから派生しており、
     追加のメソッドはまったく定義されていません。

`MessageParseError()'
     これは `Parser' クラスが発生しうる例外の基底クラスです。
     `MessageError' から派生しています。

`HeaderParseError()'
     メッセージの RFC 2822 ヘッダを解析している途中にある条件でエラーがおこると発生します。
     これは `MessageParseError' から派生しています。
     この例外が起こる可能性があるのは `Parser.parse()' メソッドと
     `Parser.parsestr()' メソッドです。

     この例外が発生するのはメッセージ中で最初の RFC 2822 ヘッダが現れたあとに
     エンベロープヘッダが見つかったとか、最初の RFC 2822 ヘッダが現れる前に
     前のヘッダからの継続行が見つかったとかいう状況を含みます。
     あるいはヘッダでも継続行でもない行がヘッダ中に見つかった場合でも
     この例外が発生します。

`BoundaryError()'
     メッセージの RFC 2822 ヘッダを解析している途中にある条件でエラーがおこると発生します。
     これは `MessageParseError' から派生しています。
     この例外が起こる可能性があるのは `Parser.parse()' メソッドと
     `Parser.parsestr()' メソッドです。

     この例外が発生するのは、厳格なパーズ方式が用いられているときに、
     `multipart/*'
     形式の開始あるいは終了の文字列が見つからなかった場合などです。

`MultipartConversionError()'
     この例外は、 `Message' オブジェクトに `add_payload()'
     メソッドを使って
     ペイロードを追加するとき、そのペイロードがすでに単一の値である
     (訳注: リストでない) にもかかわらず、そのメッセージの
     `Content-Type' ヘッダのメインタイプがすでに設定されていて、それが
     `multipart' 以外になって しまっている場合にこの例外が発生します。
     `MultipartConversionError' は `MessageError' と 組み込みの
     `TypeError' を両方継承しています。

     `Message.add_payload()' はもはや推奨されないメソッドのため、
     この例外はふつうめったに発生しません。しかしこの例外は `attach()'
     メソッドが `MIMENonMultipart' から 派生したクラスのインスタンス
     (例: `MIMEImage' など) に対して
     呼ばれたときにも発生することがあります。

以下は `FeedParser' がメッセージの解析中に検出する障害 (defect)
の一覧です。 注意:
これらの障害は、問題が見つかったメッセージに追加されるため、たとえば
`multipart/alternative' 内にあるネストしたメッセージが
異常なヘッダをもっていた場合には、そのネストしたメッセージが障害を
持っているが、その親メッセージには障害はないとみなされます。

すべての障害クラスは `email.errors.MessageDefect' のサブクラスですが、
これは例外とは_違います_ので注意してください。

_Added in Python version 2.4_

   * `NoBoundaryInMultipartDefect' - メッセージが multipart
     だと宣言されているのに、 `boundary' パラメータがない。

   * `StartBoundaryNotFoundDefect' - `Content-Type' ヘッダで宣言された
     開始境界がない。

   * `FirstHeaderLineIsContinuationDefect' - メッセージの最初のヘッダが
     継続行から始まっている。

   * `MisplacedEnvelopeHeaderDefect' - ヘッダブロックの途中に "Unix
     From" ヘッダがある。

   * `MalformedHeaderDefect' -
     コロンのないヘッダがある、あるいはそれ以外の異常なヘッダである。

   * `MultipartInvariantViolationDefect' - メッセージが `multipart' だと
     宣言されているのに、サブパートが存在しない。注意:
     メッセージがこの障害を持っているとき、 `is_multipart()' メソッドは
     たとえその content-type が `multipart' であっても false
     を返すことがあります。


File: python-lib-jp.info,  Node: 雑用ユーティリティ,  Next: イテレータ,  Prev: 例外および障害クラス,  Up: email

7.1.9 雑用ユーティリティ
------------------------

電子メールパッケージの雑多なユーティリティ。

`email.utils'
モジュールではいくつかの便利なユーティリティを提供しています。

`quote(str)'
     文字列 STR 内のバックスラッシュを バックスラッシュ2つ に置換した
     新しい文字列を返します。また、ダブルクォートは バックスラッシュ +
     ダブルクォートに置換されます。

`unquote(str)'
     文字列 STR を _逆クォート_した新しい文字列を返します。 もし STR
     の先頭あるいは末尾がダブルクォートだった場合、
     これらは単に切りおとされます。同様にもし STR の先頭あるいは末尾が
     角ブラケット (<、>) だった場合も切りおとされます。

`parseaddr(address)'
     アドレスをパーズします。`To' や `Cc' のような
     アドレスをふくんだフィールドの値を与えると、構成部分の _実名_ と
     _電子メールアドレス_ を取り出します。
     パーズに成功した場合、これらの情報をタプル `(realname,
     email_address)' にして返します。 失敗した場合は 2要素のタプル
     `('', '')' を返します。

`formataddr(pair)'
     `parseaddr()' の逆で、実名と電子メールアドレスからなる
     2要素のタプル `(realname, email_address)' を引数にとり、 `To'
     あるいは `Cc' ヘッダに適した形式の文字列を 返します。タプル PAIR
     の第1要素が偽である場合、第2要素の値を そのまま返します。

`getaddresses(fieldvalues)'
     このメソッドは 2要素タプルのリストを `parseaddr()'
     と同じ形式で返します。 FIELDVALUES はたとえば `Message.get_all()'
     が返すような、
     ヘッダのフィールド値からなるシーケンスです。以下はある電子メールメッセージから
     すべての受け取り人を得る一例です:

          from email.utils import getaddresses

          tos = msg.get_all('to', [])
          ccs = msg.get_all('cc', [])
          resent_tos = msg.get_all('resent-to', [])
          resent_ccs = msg.get_all('resent-cc', [])
          all_recipients = getaddresses(tos + ccs + resent_tos + resent_ccs)


`parsedate(date)'
     RFC 2822 に記された規則にもとづいて日付を解析します。
     しかし、メイラーによってはここで指定された規則に従っていないものがあり、
     そのような場合 `parsedate()'
     はなるべく正しい日付を推測しようとします。 DATE は RFC 2822 形式の日付を保持している文字列で、
     `"Mon, 20 Nov 1995 19:12:08 -0500"' のような形をしています。
     日付の解析に成功した場合、`parsedate()' は 関数 `time.mktime()'
     に直接渡せる形式の 9要素からなるタプルを返し、失敗した場合は
     `None' を返します。 返されるタプルの
     6、7、8番目のフィールドは有効ではないので注意してください。

`parsedate_tz(date)'
     `parsedate()' と同様の機能を提供しますが、 `None' または
     10要素のタプルを返すところが違います。 最初の 9つの要素は
     `time.mktime()' に直接渡せる形式のものであり、 最後の
     10番目の要素は、その日付の時間帯の UTC
     (グリニッジ標準時の公式な呼び名です) に対するオフセットです (1)。
     入力された文字列に時間帯が指定されていなかった場合、10番目の要素には
     `None' が入ります。 タプルの
     6、7、8番目のフィールドは有効ではないので注意してください。

`mktime_tz(tuple)'
     `parsedate_tz()' が返す 10要素のタプルを UTC の
     タイムスタンプに変換します。与えられた時間帯が `None' である場合、
     時間帯として現地時間 (localtime) が仮定されます。 マイナーな欠点:
     `mktime_tz()' はまず TUPLE の最初の 8要素を localtime
     として変換し、つぎに時間帯の差を加味しています。
     夏時間を使っている場合には、これは通常の使用にはさしつかえないものの、
     わずかな誤差を生じるかもしれません。

`formatdate([timeval[, localtime][, usegmt]])'
     日付を RFC 2822 形式の文字列で返します。例:

          Fri, 09 Nov 2001 01:08:47 -0000

     オプションとして float 型の値をもつ引数 TIMEVAL が与えられた場合、
     これは `time.gmtime()' および `time.localtime()' に
     渡されます。それ以外の場合、現在の時刻が使われます。

     オプション引数 LOCALTIME はフラグです。 これが `True'
     の場合、この関数は TIMEVAL を解析したあと UTC のかわりに現地時間
     (localtime) の時間帯をつかって変換します。
     おそらく夏時間も考慮に入れられるでしょう。 デフォルトではこの値は
     `False' で、UTC が使われます。

     オプション引数 USEGMT が `True' のときは、タイムゾーンを表すのに
     数値の `-0000' ではなく ascii文字列である `GMT' が使われます。
     これは (HTTP などの) いくつかのプロトコルで必要です。 この機能は
     LOCALTIME が `False' のときのみ適用されます。 _Added in Python
     version 2.4_

`make_msgid([idstring])'
     RFC 2822 準拠形式の `Message-ID' ヘッダに適した
     文字列を返します。オプション引数 IDSTRING が文字列として
     与えられた場合、これはメッセージ ID
     の一意性を高めるのに利用されます。

`decode_rfc2231(s)'
     RFC 2231 に従って文字列 S をデコードします。

`encode_rfc2231(s[, charset[, language]])'
     RFC 2231 に従って S をエンコードします。 オプション引数 CHARSET
     および LANGUAGE が与えられた場合、
     これらは文字セット名と言語名として使われます。
     もしこれらのどちらも与えられていない場合、S はそのまま返されます。
     CHARSET は与えられているが LANGUAGE が与えられていない場合、
     文字列 S は LANGUAGE の空文字列を使ってエンコードされます。

`collapse_rfc2231_value(value[, errors[, fallback_charset]])'
     ヘッダのパラメータが RFC 2231 形式でエンコードされている場合、
     `Message.get_param()' は 3要素からなるタプルを返すことがあります。
     ここには、そのパラメータの文字セット、言語、および値の順に格納されています。
     `collapse_rfc2231_value()' はこのパラメータをひとつの Unicode
     文字列に まとめます。オプション引数 ERRORS は built-in である
     `unicode()' 関数の 引数 ERRORS に渡されます。このデフォルト値は
     `replace' となっています。 オプション引数 FALLBACK_CHARSET
     は、もし RFC 2231 ヘッダの使用している 文字セットが Python
     の知っているものではなかった場合の非常用文字セットとして
     使われます。デフォルトでは、この値は `us-ascii' です。

     便宜上、`collapse_rfc2231_value()' に渡された引数 VALUE が
     タプルでない場合には、これは文字列である必要があります。その場合には
     unquote された文字列が返されます。

`decode_params(params)'
     RFC 2231 に従ってパラメータのリストをデコードします。 PARAMS は
     `(content-type, string-value)' のような形式の
     2要素からなるタプルです。

_Changed in Python version 2.4_

_Changed in Python version 2.4_

_Changed in Python version 2.4_

---------- Footnotes ----------

(1) 注意: この時間帯のオフセット値は `time.timezone' の値と
符合が逆です。これは `time.timezone' が POSIX
標準に準拠しているのに対して、 こちらは RFC 2822 に準拠しているからです。


File: python-lib-jp.info,  Node: イテレータ,  Next: パッケージの履歴,  Prev: 雑用ユーティリティ,  Up: email

7.1.10 イテレータ
-----------------

メッセージオブジェクトツリーをたどる。

`Message.walk()' メソッドを使うと、簡単に
メッセージオブジェクトツリー内を次から次へとたどる (iteration)
ことができます。 `email.iterators'
モジュールはこのための高水準イテレータを いくつか提供します。

`body_line_iterator(msg[, decode])'
     このイテレータは MSG 中のすべてのサブパートに含まれる
     ペイロードをすべて順にたどっていき、ペイロード内の文字列を
     1行ずつ返します。 サブパートのヘッダはすべて無視され、Python
     文字列でないペイロードからなる サブパートも無視されます。これは
     `readline()' を使って、 ファイルからメッセージを
     (ヘッダだけとばして) フラットなテキストとして
     読むのにいくぶん似ているかもしれません。

     オプション引数 DECODE
     は、`Message.get_payload()'にそのまま渡されます。

`typed_subpart_iterator(msg[, maintype[, subtype]])'
     このイテレータは MSG 中のすべてのサブパートをたどり、
     それらの中で指定された MIME 形式 MAINTYPE と SUBTYPE
     をもつようなパートのみを返します。

     SUBTYPE は省略可能であることに注意してください。
     これが省略された場合、サブパートの MIME 形式は maintype のみが
     チェックされます。じつは MAINTYPE も省略可能で、
     その場合にはデフォルトは `text' です。

     つまり、デフォルトでは `typed_subpart_iterator()' は MIME 形式
     `text/*' をもつサブパートを順に返していくというわけです。

以下の関数は役に立つデバッグ用ツールとして追加されたもので、
パッケージとして公式なサポートのあるインターフェイスでは_ありません_。

`_structure(msg[, fp[, level]])'
     そのメッセージオブジェクト構造の content-type をインデントつきで
     表示します。たとえば:

          >>> msg = email.message_from_file(somefile)
          >>> _structure(msg)
          multipart/mixed
              text/plain
              text/plain
              multipart/digest
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
                  message/rfc822
                      text/plain
              text/plain

     オプション引数 FP は出力を渡すためのストリーム
     (1)オブジェクトです。 これは Python の拡張 print
     文が対応できるようになっている必要があります。 LEVEL
     は内部的に使用されます。

---------- Footnotes ----------

(1) 訳注: 原文では file-like。


File: python-lib-jp.info,  Node: パッケージの履歴,  Next: mimelib との違い,  Prev: イテレータ,  Up: email

7.1.11 パッケージの履歴
-----------------------

このテーブルはemailパッケージのリリース履歴を表しています。
それぞれのバージョンと、それが同梱されたPythonのバージョンとの関連が示
されています。
このドキュメントでの、追加/変更されたバージョンの表記はemail パッケー
ジのバージョン_ではなく_、Pythonのバージョンです。
このテーブルはPythonの各バージョン間のemailパッケージの互換性も示して
います。

email バージョン         配布                     互換
------                   -----                    -----
1.x                      Python 2.2.0 to Python   _もうサポートされません_
                         2.2.1                    
2.5                      Python 2.2.2+ and        Python 2.1 から 2.5
                         Python 2.3               
3.0                      Python 2.4               Python 2.3 から 2.5
4.0                      Python 2.5               Python 2.3 から 2.5

以下は `email' バージョン4と3の間のおもな差分です。

   * 全モジュールが PEP 8 標準にあわせてリネームされました。
     たとえば、version 3 でのモジュール `email.Message' は version 4
     では `email.message' になりました。

   * 新しいサブパッケージ　`email.mime' が追加され、 version 3 の　
     `email.MIME*' は、`email.mime' のサブパッケージにまと
     められました。 たとえば、version 3 での `email.MIMEText' は、
     　`email.mime.text' になりました。

     _Python 2.6までは version 3 の名前も有効です。_

   * `email.mime.application' モジュールが追加されました。これ
     は`MIMEApplication'クラスを含んでいます。

   * version 3 で推奨されないとされた機能は削除されました。これらは
     `Generator.__call__()'、 `Message.get_type()'、
     `Message.get_main_type()'、 `Message.get_subtype()'を含 みます。

   * RFC 2331 サポートの修正が追加されました。これは
     `Message.get_param()'などの関数の返り値を変更します。
     いくつかの環境では、3つ組のタプルで返されていた値が1つの文字列で返さ
     れます(とくに、全ての拡張パラメータセグメントがエンコードされていな
     かった場合、予測されていたlanguage
     やcharsetの指定がないと、返り値は
     単純な文字列になります)。過去の版では % デコードが
     エンコードされている
     セグメントおよびエンコードされていないセグメントに対して行われました
     が、エンコードされたセグメントのみで行われるようになりました。

`email' バージョン 3 と バージョン 2 との違いは以下のようなものです:

   * `FeedParser' クラスが新しく導入され、`Parser' クラスは
     `FeedParser' を使って実装されるようになりました。このパーザは
     non-strict なものであり、解析はベストエフォート方式でおこなわれ
     解析中に例外を発生させることはありません。解析中に発見された問題は
     そのメッセージの DEFECT (障害) 属性に保存されます。

   * バージョン 2 で `DeprecationWarning' を発生していた API は
     すべて撤去されました。以下のものが含まれています: `MIMEText'
     コンストラクタに渡す引数 _ENCODER、`Message.add_payload()'
     メソッド、 `Utils.dump_address_pair()' 関数、そして
     `Utils.decode()' と `Utils.encode()' です。

   * 新しく以下の関数が `DeprecationWarning' を発生するようになりました:
     `Generator.__call__()', `Message.get_type()',
     `Message.get_main_type()', `Message.get_subtype()', そして
     `Parser' クラスに対する STRICT 引数です。これらは email
     の将来のバージョンで 撤去される予定です。

   * Python 2.3 以前はサポートされなくなりました。

`email' バージョン 2 と バージョン 1 との違いは以下のようなものです:

   * `email.Header' モジュールおよび `email.Charset' モジュールが
     追加されています。

   * `Message' インスタンスの Pickle 形式が変わりました。
     が、これは正式に定義されたことは一度もないので (そしてこれからも)、
     この変更は互換性の欠如とはみなされていません。ですがもし
     お使いのアプリケーションが `Message' インスタンスを pickle
     あるいは unpickle しているなら、現在 `email' バージョン 2 では
     プライベート変数 _CHARSET および _DEFAULT_TYPE を
     含むようになったということに注意してください。

   * `Message' クラス中のいくつかのメソッドは推奨されなくなったか、
     あるいは呼び出し形式が変更になっています。また、多くの新しいメソッドが
     追加されています。詳しくは `Message'
     クラスの文書を参照してください。
     これらの変更は完全に下位互換になっているはずです。

   * `message/rfc822' 形式のコンテナは、
     見た目上のオブジェクト構造が変わりました。`email' バージョン 1 では
     この content type
     はスカラー形式のペイロードとして表現されていました。
     つまり、コンテナメッセージの `is_multipart()' は false
     を返し、`get_payload()' はリストオブジェクトではなく 単一の
     `Message' インスタンスを直接返すようになっていたのです。

     この構造はパッケージ中のほかの部分と整合がとれていなかったため、
     `message/rfc822' 形式のオブジェクト表現形式が
     変更されました。`email' バージョン 2 では、コンテナは
     `is_multipart()' に _`True' を返し_ます。 また `get_payload()'
     はひとつの `Message' インスタンスを
     要素とするリストを返すようになりました。

     注意:
     ここは下位互換が完全には成りたたなくなっている部分のひとつです。
     けれどもあらかじめ `get_payload()' が返すタイプをチェックするように
     なっていれば問題にはなりません。ただ `message/rfc822' 形式の
     コンテナを `Message' インスタンスにじかに `set_payload()'
     しないようにさえすればよいのです。

   * `Parser' コンストラクタに STRICT 引数が 追加され、`parse()' および
     `parsestr()' メソッドには HEADERSONLY 引数がつきました。STRICT
     フラグは また `email.message_from_file()' と
     `email.message_from_string()' にも追加されています。

   * `Generator.__call__()' はもはや推奨されなくなりました。 かわりに
     `Generator.flatten()' を使ってください。また、 `Generator'
     クラスには `clone()' メソッドが追加されています。

   * `email.generator' モジュールに `DecodedGenerator' クラスが
     加わりました。

   * 中間的な基底クラスである `MIMENonMultipart' および `MIMEMultipart'
     がクラス階層の中に追加され、 ほとんどの MIME
     関係の派生クラスがこれを介するようになっています。

   * `MIMEText' コンストラクタの _ENCODER 引数は
     推奨されなくなりました。いまやエンコーダは _CHARSET 引数に
     もとづいて暗黙のうちに決定されます。

   * `email.utils' モジュールにおける以下の関数は
     推奨されなくなりました: `dump_address_pairs()'、 `decode()'、
     および `encode()'。
     また、このモジュールには以下の関数が追加されています:
     `make_msgid()'、 `decode_rfc2231()'、 `encode_rfc2231()' そして
     `decode_params()'。

   * Public ではない関数 `email.iterators._structure()' が
     追加されました。


File: python-lib-jp.info,  Node: mimelib との違い,  Next: 使用例 3,  Prev: パッケージの履歴,  Up: email

7.1.12 `mimelib' との違い
-------------------------

`email' パッケージはもともと `mimelib' と
呼ばれる個別のライブラリからつくられたものです。その後変更が加えられ、
メソッド名がより一貫したものになり、いくつかのメソッドやモジュールが
加えられたりはずされたりしました。いくつかのメソッドでは、
その意味も変更されています。しかしほとんどの部分において、 `mimelib'
パッケージで使うことのできた機能は、ときどきその方法が変わってはいるものの
`email' パッケージでも使用可能です。 `mimelib' パッケージと `email'
パッケージの間の 下位互換性はあまり優先はされませんでした。

以下では `mimelib' パッケージと `email' パッケージにおける
違いを簡単に説明し、それに沿ってアプリケーションを移植するさいの
指針を述べています。

おそらく 2つのパッケージのもっとも明らかな違いは、 パッケージ名が
`email' に変更されたことでしょう。
さらにトップレベルのパッケージが以下のように変更されました:

   * `messageFromString()' は `message_from_string()'
     に名前が変更されました。

   * `messageFromFile()' は `message_from_file()'
     に名前が変更されました。


`Message' クラスでは、以下のような違いがあります:

   * `asString()' メソッドは `as_string()' に名前が変更されました。

   * `ismultipart()' メソッドは `is_multipart()'
     に名前が変更されました。

   * `get_payload()' メソッドはオプション引数として DECODE
     をとるようになりました。

   * `getall()' メソッドは `get_all()' に名前が変更されました。

   * `addheader()' メソッドは `add_header()' に名前が変更されました。

   * `gettype()' メソッドは `get_type()' に名前が変更されました。

   * `getmaintype()' メソッドは `get_main_type()'
     に名前が変更されました。

   * `getsubtype()' メソッドは `get_subtype()' に名前が変更されました。

   * `getparams()' メソッドは `get_params()' に名前が変更されました。
     また、従来の `getparams()' は文字列のリストを返していましたが、
     `get_params()' は 2-タプルのリストを返すようになっています。
     これはそのパラメータのキーと値の組が、`='
     記号によって分離されたものです。

   * `getparam()' メソッドは `get_param()'.

   * `getcharsets()' メソッドは `get_charsets()'
     に名前が変更されました。

   * `getfilename()' メソッドは `get_filename()'
     に名前が変更されました。

   * `getboundary()' メソッドは `get_boundary()'
     に名前が変更されました。

   * `setboundary()' メソッドは `set_boundary()'
     に名前が変更されました。

   * `getdecodedpayload()' メソッドは廃止されました。
     これと同様の機能は `get_payload()' メソッドの DECODE フラグに 1
     を渡すことで実現できます。

   * `getpayloadastext()' メソッドは廃止されました。 これと同様の機能は
     `email.Generator' モジュールの `DecodedGenerator'
     クラスによって提供されます。

   * `getbodyastext()' メソッドは廃止されました。 これと同様の機能は
     `email.iterators' モジュールにある `typed_subpart_iterator()'
     を使ってイテレータを作ることにより 実現できます。

`Parser' クラスは、その public なインターフェイスは変わっていませんが、
これはより一層かしこくなって `message/delivery-status'
形式のメッセージを 認識するようになりました。これは配送状態通知 (1)
において、各ヘッダブロックを表す独立した `Message' パートを含む
ひとつの `Message' インスタンスとして表現されます。

`Generator' クラスは、その public
なインターフェイスは変わっていませんが、 `email.generator'
モジュールに新しいクラスが加わりました。 `DecodedGenerator'
と呼ばれるこのクラスは 以前 `Message.getpayloadastext()'
メソッドで使われていた 機能のほとんどを提供します。

また、以下のモジュールおよびクラスが変更されています:

   * `MIMEBase' クラスのコンストラクタ引数 _MAJOR と _MINOR
     は、それぞれ _MAINTYPE と _SUBTYPE に変更されています。

   * `Image' クラスおよびモジュールは `MIMEImage' に
     名前が変更されました。_MINOR 引数も _SUBTYPE に
     名前が変更されています。

   * `Text' クラスおよびモジュールは `MIMEText' に
     名前が変更されました。_MINOR 引数も _SUBTYPE に
     名前が変更されています。

   * `MessageRFC822' クラスおよびモジュールは `MIMEMessage' に
     名前が変更されました。注意: 従来バージョンの `mimelib' では、
     このクラスおよびモジュールは `RFC822' という名前でしたが、
     これは大文字小文字を区別しないファイルシステムでは Python
     の標準ライブラリモジュール `rfc822' と
     名前がかち合ってしまっていました。

     また、`MIMEMessage' クラスはいまや `message' main type
     をもつあらゆる種類の MIME メッセージを
     表現できるようになりました。これはオプション引数として、 MIME
     subtype を指定する _SUBTYPE 引数をとることができる
     ようになっています。デフォルトでは、_SUBTYPE は `rfc822' に
     なります。

`mimelib' では、`address' および `date' モジュールで
いくつかのユーティリティ関数が提供されていました。 これらの関数はすべて
`email.utils' モジュールの中に 移されています。

`MsgReader' クラスおよびモジュールは廃止されました。
これにもっとも近い機能は `email.iterators' モジュール中の
`body_line_iterator()' 関数によって提供されています。

---------- Footnotes ----------

(1) 配送状態通知 (Delivery Status Notifications, DSN) は RFC 1894 によって定義されています。


File: python-lib-jp.info,  Node: 使用例 3,  Prev: mimelib との違い,  Up: email

7.1.13 使用例
-------------

ここでは `email' パッケージを使って電子メールメッセージを
読む・書く・送信するいくつかの例を紹介します。より複雑な MIME
メッセージについても扱います。

最初に、テキスト形式の単純なメッセージを作成・送信する方法です:

`email-simple.py'

つぎに、あるディレクトリ内にある何枚かの家族写真をひとつの MIME
メッセージに 収めて送信する例です:

`email-mime.py'

つぎはあるディレクトリに含まれている内容全体を
ひとつの電子メールメッセージとして送信するやり方です (1):

`email-dir.py'

そして最後に、上のような MIME メッセージをどうやって
展開してひとつのディレクトリ上の複数ファイルにするかを示します:

`email-unpack.py'

---------- Footnotes ----------

(1) 最初の思いつきと用例は Matthew Dixon Cowles のおかげです。


File: python-lib-jp.info,  Node: mailcap,  Next: mailbox,  Prev: email,  Up: インターネット上のデータの操作

7.2 mailcap ファイルの操作
==========================

mailcap ファイルの操作。

mailcap ファイルは、メイルリーダや Web ブラウザのような MIME 対応の
アプリケーションが、異なる MIME タイプのファイルにどのように反応
するかを設定するために使われます ("mailcap" の名前は "mail capability"
から取られました)。 例えば、ある mailcap ファイルに `video/mpeg; xmpeg
%s' のような 行が入っていたとします。ユーザが email メッセージや Web
ドキュメント 上でその MIME タイプ `video/mpeg' に遭遇すると、 `%s'
はファイル名 (通常テンポラリファイルに属するものになります)
に置き換えられ、ファイルを閲覧するために `xmpeg' プログラムが
自動的に起動されます。

mailcap の形式は RFC 1524 , "A User Agent Configuration Mechanism For
Multimedia Mail Format Information"
で文書化されていますが、この文書はインターネット標準ではありません。
しかしながら、 mailcap ファイルはほとんどの UNIX システムで
サポートされています。

`findmatch(caps, MIMEtype                            [, key[, filename[, plist]]])'
     2 要素のタプルを返します; 最初の要素は文字列で、実行すべき
     コマンド (`os.system()' に渡されます) が入っています。
     二つめの要素は与えられた MIME タイプに対する mailcap エントリです。
     一致する MIME タイプが見つからなかった場合、`(None, None)' が
     返されます。

     KEY は desired フィールドの値で、
     実行すべき動作のタイプを表現します; ほとんどの場合、単に MIME
     形式のデータ本体を見たいと思うので、標準の値は 'view'
     になっています。与えられた MIME 型をもつ新たなデータ本体を作成した
     場合や、既存のデータ本体を置き換えたい場合には、'view' の他に
     'compose' および 'edit' を取ることもできます。

     これらフィールドの完全なリストについては RFC 1524 を参照してください。

     FILENAME はコマンドライン中で `%s' に代入されるファイル名 です;
     標準の値は `'/dev/null'' で、たいていこの値を使いたい
     わけではないはずです。従って、ファイル名を指定してこのフィールドを
     上書きする必要があるでしょう。

     PLIST は名前付けされたパラメタのリストです; 標準の値は単なる
     空のリストです。リスト中の各エントリはパラメタ名を含む文字列、
     等号 (`=')、およびパラメタの値でなければなりません。 mailcap
     エントリには `%{foo}' といったような名前つき
     のパラメタを含めることができ、'foo' と名づけられたパラメタの値に
     置き換えられます。例えば、コマンドライン `showpartial %{id}
     %{number} %{total}' が mailcap ファイルにあり、PLIST が `['id=1',
     'number=2', 'total=3']' に設定されていれば、コマンドラインは
     `'showpartial 1 2 3'' になります。

     mailcap ファイル中では、 オプションの "test" フィールドを
     使って、(計算機アーキテクチャや、利用しているウィンドウシステムといった)
     何らかの外部条件をテストするよう指定することができます。
     `findmatch()' はこれらの条件を自動的にチェックし、
     チェックが失敗したエントリを読み飛ばします。

`getcaps()'
     MIME タイプを mailcap
     ファイルのエントリに対応付ける辞書を返します。 この辞書は
     `findmatch()' 関数に渡されるべきものです。
     エントリは辞書のリストとして記憶されますが、この表現形式の
     詳細について知っておく必要はないでしょう。

     mailcap 情報はシステム上で見つかった全ての mailcap ファイルから
     導出されます。ユーザ設定の mailcap ファイル `$HOME/.mailcap'
     はシステムの mailcap ファイル `/etc/mailcap'、
     `/usr/etc/mailcap'、および `/usr/local/etc/mailcap'
     の内容を上書きします。

以下に使用例を示します:
     >>> import mailcap
     >>> d=mailcap.getcaps()
     >>> mailcap.findmatch(d, 'video/mpeg', filename='/tmp/tmp1223')
     ('xmpeg /tmp/tmp1223', {'view': 'xmpeg %s'})


File: python-lib-jp.info,  Node: mailbox,  Next: mhlib,  Prev: mailcap,  Up: インターネット上のデータの操作

7.3 様々な形式のメールボックス操作
==================================

様々な形式のメールボックス操作

このモジュールでは二つのクラス `Mailbox' および `Message' を
ディスク上のメールボックスとそこに収められたメッセージへのアクセスと操作のために
定義しています。`Mailbox' は辞書のようなキーからメッセージへの対応付けを
提供しています。`Message' は `email.Message' モジュールの `Message'
を拡張して形式ごとの状態と振る舞いを追加しています。
サポートされるメールボックスの形式は Maildir, mbox, MH, Babyl, MMDF
です。

See also:
     *Note email:: メッセージの表現と操作

* Menu:

* Mailbox オブジェクト::
* Message objects::
* 例外::
* 撤廃されたクラスとメソッド::
* 例 4::


File: python-lib-jp.info,  Node: Mailbox オブジェクト,  Next: Message objects,  Prev: mailbox,  Up: mailbox

7.3.1 `Mailbox' オブジェクト
----------------------------

`Mailbox'
     メールボックス。中を見られたり変更されたりします。

`Mailbox'
のインタフェースは辞書風で、小さなキーがメッセージに対応します。
キーは対象となる `Mailbox'
インスタンスが発行するもので、そのインスタンスに対して
のみ意味を持ちます。一つのキーは一つのメッセージにひも付けられ、その対応はメッセージが
他のメッセージで置き換えられるような更新をされたあとも続きます。メッセージを
`Mailbox' インスタンスに追加するには集合風のメソッド `add()'
を使います。 また削除は `del' 文または集合風の `remove()' や `discard()'
を使って行ないます。

`Mailbox' インタフェースのセマンティクスと辞書のそれとは注意すべき違いが
あります。メッセージは、要求されるたびに新しい表現(典型的には `Message'
インスタンス)が現在のメールボックスの状態に基づいて生成されます。同様に、メッセージが
`Mailbox' インスタンスに追加される時も、渡されたメッセージ表現の内容が
コピーされます。どちらの場合も `Makebox' インスタンスにメッセージ表現
への参照は保たれません。

デフォルトの `Mailbox' イテレータはメッセージ表現ごとに繰り返すもので、
辞書のイテレータのようにキーごとの繰り返しではありません。さらに、繰り返し中の
メールボックスを変更することは安全であり整合的に定義されています。イテレータが
作られた後にメールボックスに追加されたメッセージはそのイテレータからは見えません。
そのイテレータが yield
するまえにメールボックスから削除されたメッセージは
黙ってスキップされますが、イテレータからのキーを使ったときにはそのキーに対応する
メッセージが削除されているならば `KeyError' を受け取ることに なります。

`Mailbox' 自体はインタフェースを定義し形式ごとのサブクラスに継承される
ように意図されたもので、インスタンス化されることは想定されていません。インスタンス化
したいならばサブクラスを代わりに使うべきです。

`Mailbox' インスタンスには次のメソッドがあります。

`add(message)'
     メールボックスに MESSAGE
     を追加し、それに割り当てられたキーを返します。

     引数 MESSAGE は `Message' インスタンス、 `email.Message.Message'
     インスタンス、文字列、ファイル風オブジェクト
     (テキストモードで開かれていなければなりませんが)を使えます。
     MESSAGE が適切な形式に特化した `Message' サブクラスのインスタンス
     (例えばメールボックスが `mbox' インスタンスのときの `mboxMessage'
     インスタンス)であれば、形式ごとの情報が利用されます。そうでなければ、形式ごとに
     必要な情報は適当なデフォルトが使われます。

`remove(key)'

`__delitem__(key)'

`discard(key)'
     メールボックスから KEY に対応するメッセージを削除します。

     対応するメッセージが無い場合、メソッドが `remove()' または
     `__delitem__()' として呼び出されている時は `KeyError' 例外が
     送出されます。しかし、`discard()'
     として呼び出されている場合は例外は発生
     しません。基づいているメールボックス形式が別のプロセスからの平行した変更をサポート
     しているならば、この `discard()'
     の振る舞いの方が好まれるかもしれません。

`__setitem__(key, message)'
     KEY に対応するメッセージを MESSAGE で置き換えます。 KEY
     に対応しているメッセージが既に無くなっている場合 `KeyError' 例外
     が送出されます。

     `add()' と同様に、引数の MESSAGE には `Message' イン
     スタンス、`email.Message.Message' インスタンス、文字列、ファイル
     風オブジェクト(テキストモードで開かれていなければなりませんが)を使えま
     す。MESSAGE が適切な形式に特化した `Message' サブクラスのイ
     ンスタンス(例えばメールボックスが `mbox' インスタンスのとき の
     `mboxMessage' インスタンス)であれば、形式ごとの情報が利用され
     ます。そうでなければ、現在 KEY
     に対応するメッセージの形式ごとの情報が 変更されずに残ります。

`iterkeys()'

`keys()'
     `iterkeys()'
     として呼び出されると全てのキーについてのイテレータを返しますが、
     `keys()' として呼び出されるとキーのリストを返します。

`itervalues()'

`__iter__()'

`values()'
     `itervalues()' または `__iter__()' として呼び出されると
     全てのメッセージの表現についてのイテレータを返しますが、
     `values()' として呼び出されるとその表現のリストを返します。
     メッセージは適切な形式ごとの `Message'
     サブクラスのインスタンスとして表現される のが普通ですが、`Mailbox'
     インスタンスが初期化されるときに指定すればお好みの
     メッセージファクトリを使うこともできます。_Note:_ `__iter__()' は
     辞書のそれのようにキーについてのイテレータではありません。

`iteritems()'

`items()'
     (KEY, MESSAGE) ペア、ただし KEY はキーで MESSAGE は
     メッセージ表現、のイテレータ(`iteritems()'
     として呼び出された場合)、または リスト(`items()'
     として呼び出された場合)を返します。メッセージは適切な 形式ごとの
     `Message' サブクラスのインスタンスとして表現される
     のが普通ですが、`Mailbox'
     インスタンスが初期化されるときに指定すればお好みの
     メッセージファクトリを使うこともできます。

`get(key[, default=None])'

`__getitem__(key)'
     KEY に対応するメッセージの表現を返します。
     対応するメッセージが存在しない場合、`get()' として呼び出されたなら
     DEFAULT を返しますが、`__getitem__()' として呼び出されたなら
     `KeyError' 例外 が送出されます。メッセージは適切な 形式ごとの
     `Message' サブクラスのインスタンスとして表現される
     のが普通ですが、`Mailbox'
     インスタンスが初期化されるときに指定すればお好みの
     メッセージファクトリを使うこともできます。

`get_message(key)'
     KEY に対応するメッセージの表現を形式ごとの `Message' サブクラスの
     インスタンスとして返します。もし対応するメッセージが存在しなければ
     `KeyError' 例外が送出されます。

`get_string(key)'
     KEY
     に対応するメッセージの表現を文字列として返します。もし対応するメッセージが
     存在しなければ`KeyError' 例外が送出されます。

`get_file(key)'
     KEY に対応するメッセージの表現をファイル風表現として返します。
     もし対応するメッセージが存在しなければ`KeyError' 例外が送出
     されます。ファイル風オブジェクトはバイナリモードで開かれているように
     振る舞います。このファイルは必要がなくなったら閉じなければなりません。

     _Note:_
     他の表現方法とは違い、ファイル風オブジェクトはそれを作り出した
     `Mailbox'
     インスタンスやそれが基づいているメールボックスと独立である必要がありません。
     より詳細な説明は各サブクラスごとにあります。

`has_key(key)'

`__contains__(key)'
     KEY がメッセージに対応していれば `True' を、そうでなければ `False'
     を返します。

`__len__()'
     メールボックス中のメッセージ数を返します。

`clear()'
     メールボックスから全てのメッセージを削除します。

`pop(key[, default])'
     KEY
     に対応するメッセージの表現を返します。もし対応するメッセージが存在しなければ
     DEFAULT が供給されていればその値を返し、そうでなければ `KeyError'
     例外を送出します。メッセージは適切な 形式ごとの `Message'
     サブクラスのインスタンスとして表現される のが普通ですが、`Mailbox'
     インスタンスが初期化されるときに指定すればお好みの
     メッセージファクトリを使うこともできます。

`popitem()'
     任意に選んだ (KEY, MESSAGE) ペアを返します。 ただしここで KEY
     はキーで MESSAGE はメッセージ表現です。
     もしメールボックスが空ならば、`KeyError'
     例外を送出します。メッセージは適切な 形式ごとの `Message'
     サブクラスのインスタンスとして表現される のが普通ですが、`Mailbox'
     インスタンスが初期化されるときに指定すればお好みの
     メッセージファクトリを使うこともできます。

`update(arg)'
     引数 ARG は KEY から MESSAGE へのマッピングまたは (KEY, MESSAGE)
     ペアのイテレート可能オブジェクトでなければなりません。
     メールボックスは、各 KEY と MESSAGE のペアについて `__setitem__()'
     を使ったかのように KEY に対応するメッセージが MESSAGE
     になるように更新されます。 `__setitem__()' と同様に、KEY
     は既存のメールボックス中のメッセージ
     に対応しているものでなければならず、そうでなければ `KeyError'
     が送出されます。 ですから、一般的には ARG に `Mailbox'
     インスタンスを渡すのは間違いです。 _Note:_
     辞書と違い、キーワオード引数はサポートされていません。

`flush()'
     保留されている変更をファイルシステムに書き込みます。`Mailbox'
     のサブクラス
     によっては変更はいつも直ちにファイルに書き込まれこのメソッドは何もしないという
     こともあります。

`lock()'
     メールボックスの排他的アドバイザリロックを取得し、他のプロセスが変更しないようにします。
     ロックが取得できない場合 `ExternalClashError' が送出されます。
     ロック機構はメールボックス形式によって変わります。

`unlock()'
     メールボックスのロックを、もしあれば、解放します。

`close()'
     +Flush the mailbox, unlock it if necessary, and close any open
     files. For some +`Mailbox' subclasses, this method does nothing.
     メールボックスをフラッシュし、必要ならばアンロックし、開いているファイルを閉じます。
     `Mailbox' サブクラスによっては何もしないこともあります。

* Menu:

* Maildir::
* mbox::
* MH::
* Babyl::
* MMDF::


File: python-lib-jp.info,  Node: Maildir,  Next: mbox,  Prev: Mailbox オブジェクト,  Up: Mailbox オブジェクト

7.3.1.1 `Maildir'
.................

`Maildir(dirname[, factory=rfc822.Message[, create=True]])'
     Maildir 形式のメールボックスのための `Mailbox' のサブクラス。
     パラメータ FACTORY は呼び出し可能オブジェクトで
     (バイナリモードで開かれているかのように振る舞う)ファイル風メッセージ表現を
     受け付けて好みの表現を返すものです。FACTORY が `None'ならば、
     `MaildirMessage' がデフォルトのメッセージ表現として使われます。
     CREATE が `True' ならばメールボックスが存在しないときには
     作成します。

     FACTORY のデフォルトが `rfc822.Message' であったり、 PATH ではなく
     DIRNAME という名前であったりというのは
     歴史的理由によるものです。`Maildir' インスタンスが他の `Mailbox'
     サブクラスと同じように振る舞わせるためには、FACTORY に `None' を
     セットしてください。

Maildir はディレクトリ型のメールボックス形式でメール転送エージェント
qmail 用に
発明され、現在では多くの他のプログラムでもサポートされているものです。Maildir
メールボックス中のメッセージは共通のディレクトリ構造の下で個別のファイルに保存されます。
このデザインにより、Maildir メールボックスは複数の無関係の
プログラムからデータを失うことなくアクセスしたり変更したりできます。
そのためロックは不要です。

Maildir メールボックスには三つのサブディレクトリ `tmp', `new', `cur'
があります。メッセージはまず `tmp' サブディレクトリに瞬間的に
作られた後、`new'
サブディレクトリに移動されて配送を完了します。メールユーザ
エージェントが引き続いて `cur' サブディレクトリにメッセージを移動し
メッセージの状態についての情報をファイル名に追加される特別な"info"セクションに
保存することができます。

Courier
メール転送エージェントによって導入されたスタイルのフォルダもサポートされます。
主たるメールボックスのサブディレクトリは `.' がファイル名の先頭であれば
フォルダと見なされます。フォルダ名は `Maildir' によって先頭の `.'
を除いて表現されます。各フォルダはまた Maildir
メールボックスですがさらにフォルダを
含むことはできません。その代わり、論理的包含関係は例えば
"Archived.2005.07" のような `.' を使ったレベル分けで表わされます。

_Notice:_ 本来の Maildir
仕様ではある種のメッセージのファイル名にコロン(`:')を
使う必要があります。しかしながら、オペレーティングシステムによってはこの文字を
ファイル名に含めることができないことがあります。そういった環境で
Maildir のような
形式を使いたい場合、代わりに使われる文字を指定する必要があります。感嘆符(`!')
を使うのが一般的な選択です。以下の例を見てください。
     import mailbox
     mailbox.Maildir.colon = '!'

`colon' 属性はインスタンスごとにセットしても構いません。

`Maildir' インスタンスには `Mailbox' の全てのメソッドに加え以下の
メソッドもあります。

`list_folders()'
     全てのフォルダ名のリストを返します。

`get_folder(folder)'
     名前が FOLDER であるフォルダを表わす `Maildir'
     インスタンスを返します。 そのようなフォルダが存在しなければ
     `NoSuchMailboxError' 例外が送出されます。

`add_folder(folder)'
     名前が FOLDER であるフォルダを作り、それを表わす `Maildir'
     インスタンスを返します。

`remove_folder(folder)'
     名前が FOLDER
     であるフォルダを削除します。もしフォルダに一つでもメッセージが
     含まれていれば `NotEmptyError'
     例外が送出されフォルダは削除されません。

`clean()'
     過去36時間以内にアクセスされなかったメールボックス内の一時ファイルを削除します。
     Maildir
     仕様はメールを読むプログラムはときどきこの作業をすべきだとしています。

`Maildir' で実装された `Mailbox' のいくつかのメソッドには特別な注意が
必要です。

`add(message)'

`__setitem__(key, message)'

`update(arg)'
     _これらのメソッドは一意的なファイル名をプロセスIDに基づいて生成します。
     複数のスレッドを使う場合は、同じメールボックスを同時に操作しないようにスレッド間で
     調整しておかないと検知されない名前の衝突が起こりメールボックスを壊すかもしれません。_

`flush()'
     Maildir
     メールボックスへの変更は即時に適用されるので、このメソッドは何もしません。

`lock()'

`unlock()'
     Maildir メールボックスはロックをサポート(または要求)しないので、
     このメソッドは何もしません。

`close()'
     `Maildir'
     インスタンスは開いたファイルを保持しませんしメールボックスは
     ロックをサポートしませんので、このメソッドは何もしません。

`get_file(key)'
     ホストのプラットフォームによっては、返されたファイルが開いている間元になったメッセージを
     変更したり削除したりできない場合があります。

See also:
    `*http://www.qmail.org/man/man5/maildir.html*'
          (qmail の maildir man  ページ) Maildir 形式のオリジナルの仕様

    `*http://cr.yp.to/proto/maildir.html*'
          (Using maildir format) Maildir
          形式の発明者による注意書き。更新された名前生成規則と "info"
          の解釈 についても含まれます。

    `*http://www.courier-mta.org/?maildir.html*'
          (Courier の maildir man ページ) Maildir
          形式のもう一つの仕様。フォルダをサポートする一般的な拡張について
          記述されています。



File: python-lib-jp.info,  Node: mbox,  Next: MH,  Prev: Maildir,  Up: Mailbox オブジェクト

7.3.1.2 `mbox'
..............

`mbox(path[, factory=None[, create=True]])'
     mbox 形式のメールボックスのための `Mailbox' のサブクラス。
     パラメータ FACTORY は呼び出し可能オブジェクトで
     (バイナリモードで開かれているかのように振る舞う)ファイル風メッセージ表現を
     受け付けて好みの表現を返すものです。FACTORY が `None'ならば、
     `mboxMessage' がデフォルトのメッセージ表現として使われます。
     CREATE が `True' ならばメールボックスが存在しないときには
     作成します。

mbox 形式は UNIXシステム上でメールを保存する古くからある形式です。 mbox
メールボックスでは全てのメッセージが一つのファイルに保存されており
それぞれのメッセージは "From~"
という5文字で始まる行を先頭に付けられています。

mbox
形式には幾つかのバリエーションがあり、それぞれオリジナルの形式にあった欠点を克服すると
主張しています。互換性のために、`mbox' はオリジナルの(時に "mboxo"
と呼ばれる) 形式を実装しています。すなわち、`Content-Length'
ヘッダはもしあっても 無視され、メッセージのボディにある行頭の "From~"
はメッセージを保存する際に ">From~" に変換されますが、この ">From~"
は読み出し時にも "From~" に変換されません。

`mbox' で実装された `Mailbox' のいくつかのメソッドには特別な注意が
必要です。

`get_file(key)'
     `mbox' インスタンスに対し `flush()' や `close()' を呼び出した
     後でファイルを使用すると予期しない結果を引き起こしたり例外が送出されたりすることがあります。

`lock()'

`unlock()'
     3種類のロック機構が使われます --
     ドットロッキングと、もし使用可能ならば `flock()' と `lockf()'
     システムコールです。

See also:
    `*http://www.qmail.org/man/man5/mbox.html*'
          (qmail の mbox man ページ) mbox
          形式の仕様および種々のバリエーション

    `*http://www.tin.org/bin/man.cgi?section=5&topic=mbox*'
          (tin の mbox man ページ) もう一つの mbox
          形式の仕様でロックについての詳細を含む

    `*http://home.netscape.com/eng/mozilla/2.0/relnotes/demo/content-length.html*'
          (Configuring Netscape Mail on UNIX: Why The Content-Length
          Format is Bad) バリエーションの一つではなくオリジナルの mbox
          を使う理由

    `*http://homepages.tesco.net./~J.deBoynePollard/FGA/mail-mbox-formats.html*'
          ("mbox" is a family of several mutually incompatible mailbox
          formats) mbox バリエーションの歴史



File: python-lib-jp.info,  Node: MH,  Next: Babyl,  Prev: mbox,  Up: Mailbox オブジェクト

7.3.1.3 `MH'
............

`MH(path[, factory=None[, create=True]])'
     MH 形式のメールボックスのための `Mailbox' のサブクラス。
     パラメータ FACTORY は呼び出し可能オブジェクトで
     (バイナリモードで開かれているかのように振る舞う)ファイル風メッセージ表現を
     受け付けて好みの表現を返すものです。FACTORY が `None'ならば、
     `MHMessage' がデフォルトのメッセージ表現として使われます。 CREATE
     が `True' ならばメールボックスが存在しないときには 作成します。

MH はディレクトリに基づいたメールボックス形式で MH Message Handling
System というメールユーザエージェントのために発明されました。MH
メールボックス中の
それぞれのメッセージは一つのファイルとして収められています。MH
メールボックスには メッセージの他に別の MH メールボックス("フォルダ"
と呼ばれます)を含んでも
かまいません。フォルダは無限にネストできます。MH
メールボックスにはもう一つ "シーケンス"
という名前付きのリストでメッセージをサブフォルダに移動することなく
論理的に分類するものがサポートされています。シーケンスは各フォルダの
`.mh_sequences' というファイルで定義されます。

`MH' クラスは MH メールボックスを操作しますが、`mh' の動作の全てを
模倣しようとはしていません。特に、`mh' が状態と設定を保存する `context'
や `.mh_profile' といったファイルは書き換えませんし 影響も受けません。

`MH' インスタンスには `Mailbox' の全てのメソッドの他に次のメソッドが
あります。

`list_folders()'
     全てのフォルダの名前のリストを返します。

`get_folder(folder)'
     FOLDER という名前のフォルダを表わす `MH' インスタンスを返します。
     もしフォルダが存在しなければ `NoSuchMailboxError'
     例外が送出されます。

`add_folder(folder)'
     FOLDER という名前のフォルダを作成し、それを表わす `MH'
     インスタンスを 返します。

`remove_folder(folder)'
     FOLDER
     という名前のフォルダを削除します。フォルダにメッセージが一つでも残っていれば、
     `NotEmptyError' 例外が送出されフォルダは削除されません。

`get_sequences()'
     シーケンス名をキーのリストに対応付ける辞書を返します。シーケンスが一つもなければ
     空の辞書を返します。

`set_sequences(sequences)'
     メールボックス中のシーケンスを `get_sequences()'
     で返されるような名前と キーのリストを対応付ける辞書 SEQUENCES
     に基づいて再定義します。

`pack()'
     番号付けの間隔を詰める必要に応じてメールボックス中のメッセージの名前を付け替えます。
     シーケンスのリストのエントリもそれに応じて更新されます。_Note:_
     既に発行された
     キーはこの操作によって無効になるのでそれ以降使ってはなりません。

`MH' で実装された `Mailbox' のいくつかのメソッドには特別な注意が
必要です。

`remove(key)'

`__delitem__(key)'

`discard(key)'
     これらのメソッドはメッセージを直ちに削除します。名前の前にコンマを付加して
     メッセージに削除の印を付けるという MH の規約は使いません。

`lock()'

`unlock()'
     3種類のロック機構が使われます --
     ドットロッキングと、もし使用可能ならば `flock()' と `lockf()'
     システムコールです。 MH メールボックスに対するロックとは
     `.mh_sequences' のロックと、
     それが影響を与える操作中だけの個々のメッセージファイルに対するロックを意味します。

`get_file(key)'
     ホストのプラットフォームによっては、返されたファイルが開いている間元になったメッセージを
     変更したり削除したりできない場合があります。

`flush()'
     MH
     メールボックスへの変更は即時に適用されますのでこのメソッドは何もしません。

`close()'
     `MH' インスタンスは開いたファイルを保持しませんのでこのメソッドは
     `unlock' と同じです。

See also:
    `*http://www.nongnu.org/nmh/*'
          (nmh - Message Handling System) `mh' の改良版である `nmh'
          のホームページ

    `*http://www.ics.uci.edu/~mh/book/*'
          (MH & nmh:  Email for Users & Programmers) GPLライセンスの
          `mh' および `nmh'
          の本で、このメールボックス形式についての情報があります



File: python-lib-jp.info,  Node: Babyl,  Next: MMDF,  Prev: MH,  Up: Mailbox オブジェクト

7.3.1.4 `Babyl'
...............

`Babyl(path[, factory=None[, create=True]])'
     Babyl 形式のメールボックスのための `Mailbox' のサブクラス。
     パラメータ FACTORY は呼び出し可能オブジェクトで
     (バイナリモードで開かれているかのように振る舞う)ファイル風メッセージ表現を
     受け付けて好みの表現を返すものです。FACTORY が `None'ならば、
     `BabylMessage' がデフォルトのメッセージ表現として使われます。
     CREATE が `True' ならばメールボックスが存在しないときには
     作成します。

Babyl は単一ファイルのメールボックス形式で Emacs に付属している Rmail
メールユーザエージェントで使われているものです。メッセージの開始は
Control-Underscore (`\037') および Control-L (`\014')
の二文字を含む行で示されます。
メッセージの終了は次のメッセージの開始または最後のメッセージの場合には
Control-Underscore を含む行で示されます。

Babyl メールボックス中のメッセージには二つのヘッダのセット、オリジナル
ヘッダといわゆる可視ヘッダ、があります。可視ヘッダは典型的にはオリジナ
ルヘッダの一部を分り易いように再整形したり短くしたりしたもので
す。Babyl メールボックス中のそれぞれのメッセージには "ラベル" とい
うそのメッセージについての追加情報を記録する短い文字列のリストを伴い、
メールボックス中に見出されるユーザが定義した全てのラベルのリスト は
Babyl オプションセクションに保持されます。

`Babyl' インスタンスには `Mailbox' の全てのメソッドの他に次のメソッドが
あります。

`get_labels()'
     メールボックスで使われているユーザが定義した全てのラベルのリストを返します。
     _Note:_ メールボックスにどのようなラベルが存在するかを決めるのに、
     Babyl オプションセクション のリストを参考にせず、
     実際のメッセージを捜索しますが、 Babyl
     セクションもメールボックスが変更されたときにはいつでも更新されます。

`Babyl' で実装された `Mailbox' のいくつかのメソッドには特別な注意が
必要です。

`get_file(key)'
     Babyl
     メールボックスにおいて、メッセージのヘッダはボディと繋がって格納されていません。
     ファイル風の表現を生成するために、ヘッダとボディが (`StringIO'
     モジュールの) ファイルと同じ API を持つ `StringIO'
     インスタンスに一緒にコピーされます。
     その結果、ファイル風オブジェクトは本当に元にしているメールボックスとは独立していますが、
     文字列表現と比べてメモリーを節約することにもなりません。

`lock()'

`unlock()'
     3種類のロック機構が使われます --
     ドットロッキングと、もし使用可能ならば `flock()' と `lockf()'
     システムコールです。

See also:
    `*http://quimby.gnus.org/notes/BABYL*'
          (Format of Version 5 Babyl Files) Babyl 形式の仕様

    `*http://www.gnu.org/software/emacs/manual/html_node/Rmail.html*'
          (Reading Mail with Rmail) Rmail のマニュアルで Babyl
          のセマンティクスについての情報も少しある



File: python-lib-jp.info,  Node: MMDF,  Prev: Babyl,  Up: Mailbox オブジェクト

7.3.1.5 `MMDF'
..............

`MMDF(path[, factory=None[, create=True]])'
     MMDF 形式のメールボックスのための `Mailbox' のサブクラス。
     パラメータ FACTORY は呼び出し可能オブジェクトで
     (バイナリモードで開かれているかのように振る舞う)ファイル風メッセージ表現を
     受け付けて好みの表現を返すものです。FACTORY が `None'ならば、
     `BabylMessage' がデフォルトのメッセージ表現として使われます。
     CREATE が `True' ならばメールボックスが存在しないときには
     作成します。

MMDF は単一ファイルのメールボックス形式で Multichannel Memorandum
Distribution Facility
というメール転送エージェント用に発明されたものです。 各メッセージは
mbox と同様の形式で収められますが、前後を4つの Control-A (`\001')
を含む行で挟んであります。 mbox
形式と同じようにそれぞれのメッセージの開始は "From~" の5文字を含む行で
示されますが、それ以外の場所での "From~" は格納の際 ">From~"
には変えられません。
それは追加されたメッセージ区切りによって新たなメッセージの開始と見間違うことが
避けられるからです。

`MMDF' で実装された `Mailbox' のいくつかのメソッドには特別な注意が
必要です。

`get_file(key)'
     `MMDF' インスタンスに対し `flush()' や `close()' を呼び出した
     後でファイルを使用すると予期しない結果を引き起こしたり例外が送出されたりすることがあります。

`lock()'

`unlock()'
     3種類のロック機構が使われます --
     ドットロッキングと、もし使用可能ならば `flock()' と `lockf()'
     システムコールです。

See also:
    `*http://www.tin.org/bin/man.cgi?section=5&topic=mmdf*'
          (tin の  mmdf man page) ニュースリーダ tin のドキュメント中の
          MMDF 形式仕様

    `*http://en.wikipedia.org/wiki/MMDF*'
          (MMDF) Multichannel Memorandum Distribution Facility
          についてのウィキペディアの記事



File: python-lib-jp.info,  Node: Message objects,  Next: 例外,  Prev: Mailbox オブジェクト,  Up: mailbox

7.3.2 `Message' objects
-----------------------

`Message([message])'
     `email.Message' モジュールの `Message' のサブクラス。
     `mailbox.Message'
     のサブクラスはメールボックス形式ごとの状態と動作を 追加します。

     MESSAGE
     が省略された場合、新しいインスタンスはデフォルトの空の状態で生成されます。
     MESSAGE が `email.Message.Message' インスタンスならば
     その内容がコピーされます。さらに、MESSAGE が `Message' インスタンス
     ならば、形式固有の情報も可能な限り変換されます。MESSAGE
     が文字列または ファイルならば、読まれ解析されるべき RFC 2822 準拠のメッセージを
     含んでいなければなりません

サブクラスにより提供される形式ごとの状態と動作は様々ですが、一般に或るメールボックス
に固有のものでないプロパティだけがサポートされます(おそらくプロパティのセットは
メールボックス形式ごとに固有でしょうが)。例えば、単一ファイルメールボックス形式
におけるファイルオフセットやディレクトリ式メールボックス形式におけるファイル名は
保持されません、というのもそれらは元々のメールボックスにしか適用できないからです。
しかし、メッセージがユーザに読まれたかどうかあるいは重要だとマークされたかどうか
という状態は保持されます、というのはそれらはメッセージ自体に適用されるからです。

`Mailbox' インスタンスを使って取得したメッセージを表現するのに
`Message' インスタンスが使われなければいけないとは要求していません。
ある種の状況では `Message'
による表現を生成するのに必要な時間やメモリーが
受け入れられないこともあります。そういった状況では `Mailbox'
インスタンス
は文字列やファイル風オブジェクトの表現も提供できますし、`Mailbox'
インスタンス
を初期化する際にメッセージファクトリーを指定することもできます。

* Menu:

* MaildirMessage::
* mboxMessage::
* MHMessage::
* BabylMessage::
* MMDFMessage::


File: python-lib-jp.info,  Node: MaildirMessage,  Next: mboxMessage,  Prev: Message objects,  Up: Message objects

7.3.2.1 `MaildirMessage'
........................

`MaildirMessage([message])'
     Maildir 固有の動作をするメッセージ。引数 MESSAGE は `Message'
     のコンストラクタと同じ意味を持ちます。

通常、メールユーザエージェントは `new' サブディレクトリにある全ての
メッセージをユーザが最初にメールボックスを開くか閉じるかした後で `cur'
サブディレクトリに移動し、メッセージが実際に読まれたかどうかを記録します。
`cur' にある各メッセージには状態情報を保存するファイル名に付け加えられた
"info" セクションがあります。(メールリーダの中には "info" セクションを
`new' にあるメッセージに付けることもあります。) "info"
セクションには二つの形式があります。 一つは "2,"
の後に標準化されたフラグのリストを付けたもの (たとえば "2,FR")、
もう一つは "1," の後にいわゆる実験的情報を付け加えるものです。 Maildir
の標準的なフラグは以下の通りです:

フラグ                   意味                     説明
------                   -----                    -----
D                        ドラフト(Draft)          作成中
F                        フラグ付き(Flagged)      重要とされたもの
P                        通過(Passed)             転送、再送またはバウンス
R                        返答済み(Replied)        返答されたもの
S                        既読(Seen)               読んだもの
T                        ごみ(Trashed)            削除予定とされたもの

`MaildirMessage' インスタンスは以下のメソッドを提供します。

`get_subdir()'
     "new" (メッセージが `new'
     サブディレクトリに保存されるべき場合)または "cur" (メッセージが
     `cur' サブディレクトリに保存されるべき場合)のどちらかを
     返します。_Note:_
     メッセージは通常メールボックスがアクセスされた後、
     メッセージが読まれたかどうかに関わらず `new' から `cur'
     に移動されます。 メッセージ `msg' は `"S" not in msg.get_flags()'
     が `True' ならば読まれています。

`set_subdir(subdir)'
     メッセージが保存されるべきサブディレクトリをセットします。パラメータ
     SUBDIR は "new" または "cur" のいずれかでなければなりません。

`get_flags()'
     現在セットされているフラグを特定する文字列を返します。メッセージが標準
     Maildir 形式に
     準拠しているならば、結果はアルファベット順に並べられたゼロまたは1回の
     `D'、 `F'、`P'、`R'、`S'、`T'
     をつなげたものです。空文字列が返されるのはフラグが一つもない場合、または
     "info" が実験的セマンティクスを使っている場合です。

`set_flags(flags)'
     FLAGS で指定されたフラグをセットし、他のフラグは下ろします。

`add_flag(flag)'
     FLAGS で指定されたフラグをセットしますが他のフラグは変えません。
     一度に二つ以上のフラグをセットすることは、FLAG
     に2文字以上の文字列を 指定すればできます。現在の "info"
     はフラグの代わりに実験的情報を使っていても 上書きされます。

`remove_flag(flag)'
     FLAGS で指定されたフラグを下ろしますが他のフラグは変えません。
     一度に二つ以上のフラグを取り除くことは、FLAG に2文字以上の文字列を
     指定すればできます。"info"
     がフラグの代わりに実験的情報を使っている場合は 現在の "info"
     は書き換えられません。

`get_date()'
     メッセージの配送日時をエポックからの秒数を表わす浮動小数点数で返します。

`set_date(date)'
     メッセージの配送日時を DATE にセットします。DATE は
     エポックからの秒数を表わす浮動小数点数です。

`get_info()'
     メッセージの "info" を含む文字列を返します。このメソッドは実験的
     (即ちフラグの リストでない) "info"
     にアクセスし、また変更するのに役立ちます。

`set_info(info)'
     "info" に文字列 INFO をセットします。

`MaildirMessage' インスタンスが `mboxMessage' や `MMDFMessage'
のインスタンスに基づいて生成されるとき、`Status' および `X-Status'
ヘッダは省かれ以下の変換が行われます:

結果の状態                           `mboxMessage' または `MMDFMessage'
                                     の状態
------                               -----
"cur" サブディレクトリ               O フラグ
F フラグ                             F フラグ
R フラグ                             A フラグ
S フラグ                             R フラグ
T フラグ                             D フラグ

`MaildirMessage' インスタンスが `MHMessage' インスタンスに
基づいて生成されるとき、以下の変換が行われます:

結果の状態                           `MHMessage' の状態
------                               -----
"cur" サブディレクトリ               "unseen" シーケンス
"cur" サブディレクトリおよび S       "unseen" シーケンス無し
フラグ                               
F フラグ                             "flagged" シーケンス
R フラグ                             "replied" シーケンス

`MaildirMessage' インスタンスが `BabylMessage' インスタンスに
基づいて生成されるとき、以下の変換が行われます:

結果の状態                           `BabylMessage' の状態
------                               -----
"cur" サブディレクトリ               "unseen" ラベル
"cur" サブディレクトリおよび S       "unseen" ラベル無し
フラグ                               
P フラグ                             "forwarded" または "resent" ラベル
R フラグ                             "answered" ラベル
T フラグ                             "deleted" ラベル


File: python-lib-jp.info,  Node: mboxMessage,  Next: MHMessage,  Prev: MaildirMessage,  Up: Message objects

7.3.2.2 `mboxMessage'
.....................

`mboxMessage([message])'
     mbox 固有の動作をするメッセージ。引数 MESSAGE は `Message'
     のコンストラクタと同じ意味を持ちます。

mbox
メールボックス中のメッセージは単一ファイルにまとめて格納されています。
送り主のエンベロープアドレスおよび配送日時は通常メッセージの開始を示す
"From~" から 始まる行に記録されますが、正確なフォーマットに関しては
mbox の実装ごとに
大きな違いがあります。メッセージの状態を示すフラグ、たとえば読んだかどうかあるいは
重要だとマークを付けられているかどうかといったようなもの、は典型的には
`Status' および `X-Status' に収められます。

規定されている mbox メッセージのフラグは以下の通りです:

フラグ                   意味                     説明
------                   -----                    -----
R                        既読(Read)               読んだ
O                        古い(Old)                以前に MUA に発見された
D                        削除(Deleted)            削除予定
F                        フラグ付き(Flagged)      重要だとマークされた
A                        返答済み(Answered)       返答した

"R" および "O" フラグは `Status' ヘッダに記録され、 "D"、"F"、"A"
フラグは `X-Status' ヘッダに記録されます。
フラグとヘッダは通常記述された順番に出現します。

`mboxMessage' インスタンスは以下のメソッドを提供します:

`get_from()'
     mbox メールボックスのメッセージの開始を示す "From~"
     行を表わす文字列を返します。 先頭の "From~"
     および末尾の改行は含まれません。

`set_from(from_[, time_=None])'
     "From~" 行を FROM_ にセットします。FROM_ は先頭の "From~" や
     末尾の改行を含まない形で指定しなければなりません。利便性のために、TIME_
     を指定して適切に整形して FROM_ に追加させることができます。TIME_
     を指定する場合、それは `struct_time'
     インスタンス、`time.strftime()' に渡すのに適したタプル、または
     `True' (この場合 `time.gmtime()'
     を使います)のいずれかでなければなりません。

`get_flags()'
     現在セットされているフラグを特定する文字列を返します。メッセージが規定された形式に
     準拠しているならば、結果は次の順に並べられたゼロまたは1回の `R'、
     `O'、`D'、`F'、`A' です。

`set_flags(flags)'
     FLAGS で指定されたフラグをセットして、他のフラグは下ろします。
     FLAGS は並べられたゼロまたは1回の `R'、 `O'、`D'、`F'、`A' です。

`add_flag(flag)'
     FLAGS で指定されたフラグをセットしますが他のフラグは変えません。
     一度に二つ以上のフラグをセットすることは、FLAG
     に2文字以上の文字列を 指定すればできます。

`remove_flag(flag)'
     FLAGS で指定されたフラグを下ろしますが他のフラグは変えません。
     一度に二つ以上のフラグを取り除くことは、FLAG に2文字以上の文字列を
     指定すればできます。

`mboxMessage' インスタンスが `MaildirMessage' インスタンスに
基づいて生成されるとき、`MaildirMessage'
インスタンスの配送日時に基づいて "From~"
行が作り出され、次の変換が行われます:

結果の状態                           `MaildirMessage' の状態
------                               -----
R フラグ                             S フラグ
O フラグ                             "cur" サブディレクトリ
D フラグ                             T フラグ
F フラグ                             F フラグ
A フラグ                             R フラグ

`mboxMessage' インスタンスが `MHMessage' インスタンスに
基づいて生成されるとき、以下の変換が行われます。

結果の状態                           `MHMessage' 状態
------                               -----
R フラグ および O フラグ             "unseen" シーケンス無し
O フラグ                             "unseen" シーケンス
F フラグ                             "flagged" シーケンス
A フラグ                             "replied" シーケンス

`mboxMessage' インスタンスが `BabylMessage' インスタンスに
基づいて生成されるとき、以下の変換が行われます:

結果の状態                           `BabylMessage' の状態
------                               -----
R フラグ および O フラグ             "unseen" ラベル無し
O フラグ                             "unseen" ラベル
D フラグ                             "deleted" ラベル
A フラグ                             "answered" ラベル

`mboxMessage' インスタンスが `MMDFMessage' インスタンスに
基づいて生成されるとき、"From~"
行はコピーされ全てのフラグは直接対応します:

結果の状態                           `MMDFMessage' の状態
------                               -----
R フラグ                             R フラグ
O フラグ                             O フラグ
D フラグ                             D フラグ
F フラグ                             F フラグ
A フラグ                             A フラグ


File: python-lib-jp.info,  Node: MHMessage,  Next: BabylMessage,  Prev: mboxMessage,  Up: Message objects

7.3.2.3 `MHMessage'
...................

`MHMessage([message])'
     MH 固有の動作をするメッセージ。引数 MESSAGE は `Message'
     のコンストラクタと同じ意味を持ちます。

MH
メッセージは伝統的な意味あいにおいてマークやフラグをサポートしません。
しかし、MH
メッセージにはシーケンスがあり任意のメッセージを論理的にグループ分けできます。
いくつかのメールソフト(標準の `mh' や `nmh' はそうではありませんが)
は他の形式におけるフラグとほぼ同じようにシーケンスを使います。

シーケンス                           説明
------                               -----
unseen                               読んではいないが既にMUAに見つけられている
replied                              返答した
flagged                              重要だとマークされた

`MHMessage' インスタンスは以下のメソッドを提供します:

`get_sequences()'
     このメッセージを含むシーケンスの名前のリストを返す。

`set_sequences(sequences)'
     このメッセージを含むシーケンスのリストをセットする。

`add_sequence(sequence)'
     SEQUENCE をこのメッセージを含むシーケンスのリストに追加する。

`remove_sequence(sequence)'
     SEQUENCE をこのメッセージを含むシーケンスのリストから除く。

`MHMessage' インスタンスが `MaildirMessage' インスタンスに
基づいて生成されるとき、以下の変換が行われます:

結果の状態                           `MaildirMessage' の状態
------                               -----
"unseen" シーケンス                  S フラグ無し
"replied" シーケンス                 R フラグ
"flagged" シーケンス                 F フラグ

`MHMessage' インスタンスが `mboxMessage' や `MMDFMessage'
のインスタンスに基づいて生成されるとき、`Status' および `X-Status'
ヘッダは省かれ以下の変換が行われます:

結果の状態                           `mboxMessage' または `MMDFMessage'
                                     の状態
------                               -----
"unseen" シーケンス                  R フラグ無し
"replied" シーケンス                 A フラグ
"flagged" シーケンス                 F フラグ

`MHMessage' インスタンスが `BabylMessage' インスタンスに
基づいて生成されるとき、以下の変換が行われます:

結果の状態                           `BabylMessage' の状態
------                               -----
"unseen" シーケンス                  "unseen" ラベル
"replied" シーケンス                 "answered" ラベル


File: python-lib-jp.info,  Node: BabylMessage,  Next: MMDFMessage,  Prev: MHMessage,  Up: Message objects

7.3.2.4 `BabylMessage'
......................

`BabylMessage([message])'
     Babyl 固有の動作をするメッセージ。引数 MESSAGE は `Message'
     のコンストラクタと同じ意味を持ちます。

ある種のメッセージラベルは "アトリビュート"
と呼ばれ、規約により特別な意味が
与えられています。アトリビュートは以下の通りです:

ラベル                               説明
------                               -----
unseen                               読んでいないが既に MUA
                                     に見つかっている
deleted                              削除予定
filed                                他のファイルまたはメールボックスにコピーされた
answered                             返答済み
forwarded                            転送された
edited                               ユーザによって変更された
resent                               再送された

デフォルトでは Rmail は可視ヘッダのみ表示する。`BabylMessage'
クラスはしかし、
オリジナルヘッダをより完全だという理由で使います。可視ヘッダは望むならそのように
指示してアクセスすることができます。

`BabylMessage' インスタンスは以下のメソッドを提供します:

`get_labels()'
     メッセージに付いているラベルのリストを返します。

`set_labels(labels)'
     メッセージに付いているラベルのリストを LABELS にセットします。

`add_label(label)'
     メッセージに付いているラベルのリストに LABEL を追加します。

`remove_label(label)'
     メッセージに付いているラベルのリストから LABEL を削除します。

`get_visible()'
     ヘッダがメッセージの可視ヘッダでありボディが空であるような
     `Message' インスタンスを返します。

`set_visible(visible)'
     メッセージの可視ヘッダを VISIBLE のヘッダと同じにセットします。
     引数 VISIBLE は `Message' インスタンスまたは
     `email.Message.Message' インスタンス、
     文字列、ファイル風オブジェクト(テキストモードで開かれてなければなりません)のいずれかです。

`update_visible()'
     `BabylMessage'
     インスタンスのオリジナルヘッダが変更されたとき、可視ヘッダは
     自動的に対応して変更されるわけではありません。このメソッドは可視ヘッダを以下のように
     更新します。
     対応するオリジナルヘッダのある可視ヘッダはオリジナルヘッダの値がセットされます。
     対応するオリジナルヘッダの無い可視ヘッダは除去されます。
     そして、オリジナルヘッダにあって可視ヘッダに無い `Date'、
     `From'、`Reply-To'、`To'、 `CC'、`Subject'
     は可視ヘッダに追加されます。

`BabylMessage' インスタンスが `MaildirMessage' インスタンスに
基づいて生成されるとき、以下の変換が行われます:

結果の状態                           `MaildirMessage' の状態
------                               -----
"unseen" ラベル                      S フラグ無し
"deleted" ラベル                     T フラグ
"answered" ラベル                    R フラグ
"forwarded" ラベル                   P フラグ

`BabylMessage' インスタンスが `mboxMessage' や `MMDFMessage'
のインスタンスに基づいて生成されるとき、`Status' および `X-Status'
ヘッダは省かれ以下の変換が行われます:

結果の状態                           `mboxMessage' または `MMDFMessage'
                                     の状態
------                               -----
"unseen" ラベル                      R フラグ無し
"deleted" ラベル                     D フラグ
"answered" ラベル                    A フラグ

`BabylMessage' インスタンスが `MHMessage' インスタンスに
基づいて生成されるとき、以下の変換が行われます:

結果の状態                           `MHMessage' の状態
------                               -----
"unseen" ラベル                      "unseen" シーケンス
"answered" ラベル                    "replied" シーケンス


File: python-lib-jp.info,  Node: MMDFMessage,  Prev: BabylMessage,  Up: Message objects

7.3.2.5 `MMDFMessage'
.....................

`MMDFMessage([message])'
     MMDF 固有の動作をするメッセージ。引数 MESSAGE は `Message'
     のコンストラクタと同じ意味を持ちます。

mbox メールボックスのメッセージと同様に、MMDF
メッセージは送り主のアドレスと配送日時が 最初の "From~"
で始まる行に記録されています。同様に、メッセージの状態を示すフラグは
通常 `Status' および `X-Status' ヘッダに収められています。

よく使われる MMDF メッセージのフラグは mbox
メッセージのものと同一で以下の通りです:

フラグ                   意味                     説明
------                   -----                    -----
R                        既読(Read)               読んだ
O                        古い(Old)                以前に MUA に発見された
D                        削除(Deleted)            削除予定
F                        フラグ付き(Flagged)      重要だとマークされた
A                        返答済み(Answered)       返答した

"R" および "O" フラグは `Status' ヘッダに記録され、 "D"、"F"、"A"
フラグは `X-Status' ヘッダに記録されます。
フラグとヘッダは通常記述された順番に出現します。

`MMDFMessage' インスタンスは `mboxMessage' インスタンスと同一の
以下のメソッドを提供します:

`get_from()'
     MMDF メールボックスのメッセージの開始を示す "From~"
     行を表わす文字列を返します。 先頭の "From~"
     および末尾の改行は含まれません。

`set_from(from_[, time_=None])'
     "From~" 行を FROM_ にセットします。FROM_ は先頭の "From~" や
     末尾の改行を含まない形で指定しなければなりません。利便性のために、TIME_
     を指定して適切に整形して FROM_ に追加させることができます。TIME_
     を指定する場合、それは `struct_time'
     インスタンス、`time.strftime()' に渡すのに適したタプル、または
     `True' (この場合 `time.gmtime()'
     を使います)のいずれかでなければなりません。

`get_flags()'
     現在セットされているフラグを特定する文字列を返します。メッセージが規定された形式に
     準拠しているならば、結果は次の順に並べられたゼロまたは1回の `R'、
     `O'、`D'、`F'、`A' です。

`set_flags(flags)'
     FLAGS で指定されたフラグをセットして、他のフラグは下ろします。
     FLAGS は並べられたゼロまたは1回の `R'、 `O'、`D'、`F'、`A' です。

`add_flag(flag)'
     FLAGS で指定されたフラグをセットしますが他のフラグは変えません。
     一度に二つ以上のフラグをセットすることは、FLAG
     に2文字以上の文字列を 指定すればできます。

`remove_flag(flag)'
     FLAGS で指定されたフラグを下ろしますが他のフラグは変えません。
     一度に二つ以上のフラグを取り除くことは、FLAG に2文字以上の文字列を
     指定すればできます。

`MMDFMessage' インスタンスが `MaildirMessage' インスタンスに
基づいて生成されるとき、`MaildirMessage'
インスタンスの配送日時に基づいて "From~"
行が作り出され、次の変換が行われます:

結果の状態                           `MaildirMessage' の状態
------                               -----
R フラグ                             S フラグ
O フラグ                             "cur" サブディレクトリ
D フラグ                             T フラグ
F フラグ                             F フラグ
A フラグ                             R フラグ

`MMDFMessage' インスタンスが `MHMessage' インスタンスに
基づいて生成されるとき、以下の変換が行われます。

結果の状態                           `MHMessage' 状態
------                               -----
R フラグ および O フラグ             "unseen" シーケンス無し
O フラグ                             "unseen" シーケンス
F フラグ                             "flagged" シーケンス
A フラグ                             "replied" シーケンス

`MMDFMessage' インスタンスが `BabylMessage' インスタンスに
基づいて生成されるとき、以下の変換が行われます:

結果の状態                           `BabylMessage' の状態
------                               -----
R フラグ および O フラグ             "unseen" ラベル無し
O フラグ                             "unseen" ラベル
D フラグ                             "deleted" ラベル
A フラグ                             "answered" ラベル

`MMDFMessage' インスタンスが `mboxMessage' インスタンスに
基づいて生成されるとき、"From~"
行はコピーされ全てのフラグは直接対応します:

結果の状態                           `mboxMessage' の状態
------                               -----
R フラグ                             R フラグ
O フラグ                             O フラグ
D フラグ                             D フラグ
F フラグ                             F フラグ
A フラグ                             A フラグ


File: python-lib-jp.info,  Node: 例外,  Next: 撤廃されたクラスとメソッド,  Prev: Message objects,  Up: mailbox

7.3.3 例外
----------

`mailbox' モジュールでは以下の例外クラスが定義されています:

`Error()'
     他の全てのモジュール固有の例外の基底クラス。

`NoSuchMailboxError()'
     メールボックスがあると思っていたが見つからなかった場合に送出されます。
     これはたとえば `Mailbox'
     のサブクラスを存在しないパスでインスタンス化しようと したとき(かつ
     CREATE パラメータは `False' であった場合)、
     あるいは存在しないフォルダを開こうとした時などに発生します。

`NotEmptyError()'
     メールボックスが空であることを期待されているときに空でない場合、たとえばメッセージの
     残っているフォルダを削除しようとした時などに送出されます。

`ExternalClashError()'
     メールボックスに関係したある条件がプログラムの制御を外れてそれ以上作業を
     続けられなくなった場合、たとえば他のプログラムが既に保持しているロックを取得しようとして
     失敗したとき、あるいは一意的に生成されたファイル名が既に存在していた場合などに
     送出されます。

`FormatError()'
     ファイル中のデータが解析できない場合、たとえば `MH' インスタンスが
     壊れた `.mh_sequences'
     ファイルを読もうと試みた場合などに送出されます。


File: python-lib-jp.info,  Node: 撤廃されたクラスとメソッド,  Next: 例 4,  Prev: 例外,  Up: mailbox

7.3.4 撤廃されたクラスとメソッド
--------------------------------

古いバージョンの `mailbox' モジュールはメッセージの追加や削除といった
メールボックスの変更をサポートしていませんでした。また形式ごとのメッセージプロパティ
を表現するクラスも提供していませんでした。後方互換性のために、古いメールボックス
クラスもまだ使うことができますが、できるだけ新しいクラスを使うべきです。

古いメールボックスオブジェクトは繰り返しと一つの公開メソッドだけを提供していました:

`next()'
     メールボックスオブジェクトのコンストラクタに渡された、オプションの
     FACTORY 引数を使って、メールボックス中の次のメッセージを
     生成して返します。標準の設定では、FACTORY は `rfc822.Message'
     オブジェクトです (`rfc822' モジュールを参照してください)。
     メールボックスの実装により、このオブジェクトの FP 属性は
     真のファイルオブジェクトかもしれないし、
     複数のメールメッセージが単一のファイルに収められているなどの場合に、
     メッセージ間の境界を注意深く扱うためにファイルオブジェクトをシミュレート
     するクラスのインスタンスであるかもしれません。
     次のメッセージがない場合、このメソッドは `None' を返します。

ほとんどの古いメールボックスクラスは現在のメールボックスクラスと違う名前ですが、
`Maildir' だけは例外です。そのため、新しい方の `Maildir' クラスには
`next()'
メソッドが定義され、コンストラクタも他の新しいメールボックスクラスとは
少し異なります。

古いメールボックスのクラスで名前が新しい対応物と同じでないものは以下の通りです:

`UnixMailbox(fp[, factory])'
     全てのメッセージが単一のファイルに収められ、`From ' (`From_'
     として知られています) 行によって分割されているような、 旧来の
     UNIX形式のメールボックスにアクセスします。 ファイルオブジェクト FP
     はメールボックスファイルを指します。 オプションの FACTORY
     パラメタは新たなメッセージオブジェクト
     を生成するような呼び出し可能オブジェクトです。FACTORY は、
     メールボックスオブジェクトに対して `next()' メソッドを実行
     した際に、単一の引数、FP を伴って呼び出されます。
     この引数の標準の値は `rfc822.Message' クラスです (`rfc822'
     モジュール - および以下 - を参照してください)。

     _Notice:_ このモジュールの実装上の理由により、FP
     オブジェクトはバイナリ
     モードで開くようにしてください。特にWindows上では注意が必要です。

     可搬性を最大限にするために、UNIX形式のメールボックス内にある
     メッセージは、正確に `'From '' (末尾の空白に注意してください)
     で始まる文字列が、直前の正しく二つの改行の後にくるような行で
     分割されます。現実的には広範なバリエーションがあるため、それ以外の
     From_ 行について考慮すべきではないのですが、現在の実装では先頭の
     二つの改行をチェックしていません。これはほとんどのアプリケーションで
     うまく動作します。

     `UnixMailbox' クラスでは、ほぼ正確に From_ デリミタにマッチする
     ような正規表現を用いることで、より厳密に From_ 行のチェックを行う
     バージョンを実装しています。`UnixMailbox' ではデリミタ行が `From
     NAME TIME' の行に分割されるものと考えます。
     可搬性を最大限にするためには、代わりに `PortableUnixMailbox'
     クラスを使ってください。このクラスは `UnixMailbox' と同じですが、
     個々のメッセージは `From ' 行だけで分割されるものとみなします。

     より詳細な情報については、

     を参照してください。

`PortableUnixMailbox(fp[, factory])'
     厳密性の低い `UnixMailbox' のバージョンで、メッセージを分割
     する行は `From ' のみであると見なします。実際に見られるメール
     ボックスのバリエーションに対応するため、 From 行における "NAME
     TIME" 部分は無視されます。メール処理ソフトウェア はメッセージ中の
     `'From '' で始まる行をクオートするため、
     この分割はうまく動作します。

`MmdfMailbox(fp[, factory])'
     全てのメッセージが単一のファイルに収められ、4 つの control-A 文字
     によって分割されているような、MMDF
     形式のメールボックスにアクセスします。 ファイルオブジェクト FP
     はメールボックスファイルをさします。 オプションの FACTORY は
     `UnixMailbox' クラスにおけるのと 同様です。

`MHMailbox(dirname[, factory])'
     数字で名前のつけられた別々のファイルに個々のメッセージを収めた
     ディレクトリである、MH メールボックスにアクセスします。
     メールボックスディレクトリの名前は DIRNAME で渡します。 FACTORY は
     `UnixMailbox' クラスにおけるのと 同様です。

`BabylMailbox(fp[, factory])'
     MMDF メールボックスと似ている、Babyl
     メールボックスにアクセスします。 Babyl
     形式では、各メッセージは二つのヘッダからなるセット、 _original_
     ヘッダおよび _visible_ ヘッダをを持っています。 original ヘッダは
     `'*** EOOH ***'' (End-Of-Original-Headers)
     だけを含む行の前にあり、visible ヘッダは `EOOH' 行の後に
     あります。Babyl 互換のメールリーダは visible ヘッダのみを表示 し、
     `BabylMailbox' オブジェクトは visible ヘッダのみを
     含むようなメッセージを返します。メールメッセージは EOOH
     行で始まり、 `'\037\014'' だけを含む行で終わります。 FACTORY は
     `UnixMailbox' クラスにおけるのと 同様です。

古いメールボックスクラスを撤廃された `rfc822' モジュールではなく、
`email' モジュールと使いたいならば、以下のようにできます:

     import email
     import email.Errors
     import mailbox

     def msgfactory(fp):
         try:
             return email.message_from_file(fp)
         except email.Errors.MessageParseError:
             # Don't return None since that will
             # stop the mailbox iterator
             return ''

     mbox = mailbox.UnixMailbox(fp, msgfactory)

一方、メールボックス内には正しい形式の MIME メッセージしか入っていないと
分かっているのなら、単に以下のようにします:

     import email
     import mailbox

     mbox = mailbox.UnixMailbox(fp, email.message_from_file)


File: python-lib-jp.info,  Node: 例 4,  Prev: 撤廃されたクラスとメソッド,  Up: mailbox

7.3.5 例
--------

メールボックス中の面白そうなメッセージのサブジェクトを全て印字する簡単な例:

     import mailbox
     for message in mailbox.mbox('~/mbox'):
         subject = message['subject']       # Could possibly be None.
         if subject and 'python' in subject.lower():
             print subject

Babyl メールボックスから MH メールボックスへ全てのメールをコピーし、
変換可能な全ての形式固有の情報を変換する:

     import mailbox
     destination = mailbox.MH('~/Mail')
     for message in mailbox.Babyl('~/RMAIL'):
         destination.add(MHMessage(message))

幾つかのメーリングリストのメールをソートする例。
他のプログラムと平行して変更を加えることでメールが破損したり、
プログラムを中断することでメールを失ったり、
はたまた半端なメッセージがメールボックス中にあることで途中で終了してしまう、
といったことを避けるように注意深く扱っている:

     import mailbox
     import email.Errors
     list_names = ('python-list', 'python-dev', 'python-bugs')
     boxes = dict((name, mailbox.mbox('~/email/%s' % name)) for name in list_names)
     inbox = mailbox.Maildir('~/Maildir', None)
     for key in inbox.iterkeys():
         try:
             message = inbox[key]
         except email.Errors.MessageParseError:
             continue                # The message is malformed. Just leave it.
         for name in list_names:
             list_id = message['list-id']
             if list_id and name in list_id:
                 box = boxes[name]
                 box.lock()
                 box.add(message)
                 box.flush()         # Write copy to disk before removing original.
                 box.unlock()
                 inbox.discard(key)
                 break               # Found destination, so stop looking.
     for box in boxes.itervalues():
         box.close()


File: python-lib-jp.info,  Node: mhlib,  Next: mimetools,  Prev: mailbox,  Up: インターネット上のデータの操作

7.4 MH のメイルボックスへのアクセス機構
=======================================

Python から MH のメイルボックスを操作します。

`mhlib' モジュールは MH フォルダおよびその内容に対する Python
インタフェースを提供します。

このモジュールには、あるフォルダの集まりを表現する `MH'、
単一のフォルダを表現する `Folder'、単一のメッセージを表現 する
`Message'、の 3 つのクラスが入っています。

`MH([path[, profile]])'
     `MH' は MH フォルダの集まりを表現します。

`Folder(mh, name)'
     `Folder' クラスは単一のフォルダとフォルダ内のメッセージ群を
     表現します。

`Message(folder, number[, name])'
     `Message' オブジェクトはフォルダ内の個々のメッセージを表現
     します。メッセージクラスは `mimetools.Message' から
     導出されています。

* Menu:

* MH オブジェクト::
* Folder オブジェクト::
* Message オブジェクト::


File: python-lib-jp.info,  Node: MH オブジェクト,  Next: Folder オブジェクト,  Prev: mhlib,  Up: mhlib

7.4.1 MH オブジェクト
---------------------

`MH' インスタンスは以下のメソッドを持っています:

`error(format[, ...])'
     エラーメッセージを出力します - 上書きすることができます。

`getprofile(key)'
     プロファイルエントリ (設定されていなければ `None') を返します。

`getpath()'
     メイルボックスのパス名を返します。

`getcontext()'
     現在のフォルダ名を返します。

`setcontext(name)'
     現在のフォルダ名を設定します。

`listfolders()'
     トップレベルフォルダのリストを返します。

`listallfolders()'
     全てのフォルダを列挙します。

`listsubfolders(name)'
     指定したフォルダの直下にあるサブフォルダのリストを返します。

`listallsubfolders(name)'
     指定したフォルダの下にある全てのサブフォルダのリストを返します。

`makefolder(name)'
     新しいフォルダを生成します。

`deletefolder(name)'
     フォルダを削除します - サブフォルダが入っていてはいけません。

`openfolder(name)'
     新たな開かれたフォルダオブジェクトを返します。


File: python-lib-jp.info,  Node: Folder オブジェクト,  Next: Message オブジェクト,  Prev: MH オブジェクト,  Up: mhlib

7.4.2 Folder オブジェクト
-------------------------

`Folder' インスタンスは開かれたフォルダを表現し、以下のメソッドを
持っています:

`error(format[, ...])'
     エラーメッセージを出力します - 上書きすることができます。

`getfullname()'
     フォルダの完全なパス名を返します。

`getsequencesfilename()'
     フォルダ内のシーケンスファイルの完全なパス名を返します。

`getmessagefilename(n)'
     フォルダ内のメッセージ N の完全なパス名を返します。

`listmessages()'
     フォルダ内のメッセージの (番号の) リストを返します。

`getcurrent()'
     現在のメッセージ番号を返します。

`setcurrent(n)'
     現在のメッセージ番号を N に設定します。

`parsesequence(seq)'
     msgs 文を解釈して、メッセージのリストにします。

`getlast()'
     最新のメッセージを取得します。メッセージがフォルダにない場合には
     `0' を返します。

`setlast(n)'
     最新のメッセージを設定します (内部使用のみ)。

`getsequences()'
     フォルダ内のシーケンスからなる辞書を返します。シーケンス名がキーとして
     使われ、値はシーケンスに含まれるメッセージ番号のリストになります。

`putsequences(dict)'
     フォルダ内のシーケンスからなる辞書 {name: list} を返します。

`removemessages(list)'
     リスト中のメッセージをフォルダから削除します。

`refilemessages(list, tofolder)'
     リスト中のメッセージを他のフォルダに移動します。

`movemessage(n, tofolder, ton)'
     一つのメッセージを他のフォルダの指定先に移動します。

`copymessage(n, tofolder, ton)'
     一つのメッセージを他のフォルダの指定先にコピーします。


File: python-lib-jp.info,  Node: Message オブジェクト,  Prev: Folder オブジェクト,  Up: mhlib

7.4.3 Message オブジェクト
--------------------------

`Message' クラスは `mimetools.Message' の
メソッドに加え、一つメソッドを持っています:

`openmessage(n)'
     新たな開かれたメッセージオブジェクトを返します (ファイル記述子を
     一つ消費します)。


File: python-lib-jp.info,  Node: mimetools,  Next: mimetypes,  Prev: mhlib,  Up: インターネット上のデータの操作

7.5 MIME メッセージを解析するためのツール
=========================================

MIME-スタイルのメッセージ本体を解析するためのツール。 _This is
deprecated in Python 2.3.   `email' パッケージを
`mimetools'モジュールより 優先して使うべきです。この
モジュールは、下位互換性維持のためにのみ 存在しています。_

このモジュールは、 `rfc822'  モジュールの `Message'
クラスのサブクラスと、マルチパートMIME や符合化メッセージの操作に
役に立つ多くのユーティリティ関数を定義しています。

これには以下の項目が定義されています：

`Message(fp[, seekable])'
     `Message' クラスの新しいインスタンスを返します。これは、
     `rfc822.Message' クラスのサブクラスで、いくつかの追加のメソッドが
     あります(以下を参照のこと)。 SEEKABLE 引数は、 `rfc822.Message'の
     ものと同じ意味を持ちます。

`choose_boundary()'
     パートの境界として使うことができる見込みが高いユニークな文字列を返します。
     その文字列は、 `'HOSTIPADDR.UID.PID.TIMESTAMP.RANDOM''
     の形をしています。

`decode(input, output, encoding)'
     オープンしたファイルオブジェクト INPUT から、許される MIME ENCODING
     を使って符号化されたデータを読んで、オープンされたファイルオブジェクト
     OUTPUT に復号化されたデータを書きます。 ENCODING に許される値は、
     `'base64'', `'quoted-printable'', `'uuencode'', `'x-uuencode'',
     `'uue'', `'x-uue'', `'7bit'', および `'8bit''です。`'7bit''
     あるいは `'8bit'' で符号化された
     メッセージを復号化しても何も効果がありません。入力が出力に単純にコピーされるだけです。

`encode(input, output, encoding)'
     オープンしたファイルオブジェクト  INPUT からデータを読んで、
     それを許される MIME ENCODING を使って符号化して、オープンした
     ファイルオブジェクト OUTPUT に書きます。 ENCODING
     に許される値は、[method{decode()}のものと同じです。

`copyliteral(input, output)'
     オープンしたファイル INPUTから行を `EOF' まで読んで、
     それらをオープンしたファイル OUTPUT に書きます。

`copybinary(input, output)'
     オープンしたファイル INPUTからブロックを `EOF' まで読んで、
     それらをオープンしたファイル OUTPUT に書きます。
     ブロックの大きさは現在 8192 に固定されています。

See also:
     *Note email:: 圧縮電子メール操作パッケージ； `mimetools'
     モジュールに委譲。 *Note rfc822::
     `mimetools.Message'のベースクラスを提供する。 *Note multifile::
     MIME データのような、別個のパーツを含む
     ファイルの読み込みをサポート。

    `http://www.cs.uu.nl/wais/html/na-dir/mail/mime-faq/.html'
          MIME でよく訊ねられる質問。MIMEの概要に関しては、 この文書の
          Part 1 の質問 1.1 への答えを見ること。


* Menu:

* Message オブジェクトの追加メソッド::


File: python-lib-jp.info,  Node: Message オブジェクトの追加メソッド,  Prev: mimetools,  Up: mimetools

7.5.1 Message オブジェクトの追加メソッド
----------------------------------------

`Message' クラスは、`rfc822.Message' メソッドに加えて、
以下のメソッドを定義しています：

`getplist()'
     `Content-Type' ヘッダのパラメータリストを返します。
     これは文字列のリストです。 `KEY=VALUE'の形のパラメータに対しては、
     KEY は小文字に変換されますが、 VALUE は変換されません。
     たとえば、もしメッセージに、ヘッダ `Content-type: text/html;
     spam=1; Spam=2; Spam' が含まれていれば、 `getplist()' は、Python
     リスト  `['spam=1', 'spam=2', 'Spam']'を返すでしょう。

`getparam(name)'
     与えられた NAMEの( `NAME=VALUE' の形に対して `getplist()' が返す )
     第1パラメータの VALUE を返します。 もし VALUE が、``<'...`>''
     あるいは ``"'...`"''のように引用符で囲まれていれば、
     これらは除去されます。

`getencoding()'
     `Content-Transfer-Encoding' メッセージヘッダで指定された
     符号化方式を返します。もしそのようなヘッダが存在しなければ、
     `'7bit''を返します。符号化方式文字列は小文字に変換されます。

`gettype()'
     `Content-Type' ヘッダで指定された
     (`TYPE/SUBTYPE'の形での)メッセージ型を返します。
     もしそのようなヘッダが存在しなければ、 `'text/plain''を返します。
     型文字列は小文字に変換されます。

`getmaintype()'
     `Content-Type' ヘッダで指定された主要型を返します。
     もしそのようなヘッダが存在しなければ、 `'text''を返します。
     主要型文字列は小文字に変換されます。

`getsubtype()'
     `Content-Type'ヘッダで指定された下位型を返します。
     もしそのようなヘッダが存在しなければ、 `'plain''を返します。
     下位型文字列は小文字に変換されます。


File: python-lib-jp.info,  Node: mimetypes,  Next: MimeWriter,  Prev: mimetools,  Up: インターネット上のデータの操作

7.6 ファイル名を MIME 型へマップする
====================================

Mapping of filename extensions to MIME types.  ファイル名拡張子の MIME
型へのマッピング。

`mimetypes' モジュールは、ファイル名あるいは URL と、ファイル名拡張子に
関連付けられた MIME 型とを変換します。ファイル名から MIME 型へと、 MIME
型からファイル名拡張子への変換が提供されます；
後者の変換では符号化方式はサポートされていません。

このモジュールは、一つのクラスと多くの便利な関数を提供します。
これらの関数がこのモジュールへの標準のインターフェースですが、
アプリケーションによっては、そのクラスにも関係するかもしれません。

以下で説明されている関数は、このモジュールへの主要なインターフェースを
提供します。たとえモジュールが初期化されていなくても、もしこれらの関数が、
`init()' がセットアップする情報に依存していれば、これらの関数は、
`init()' を呼びます。

`guess_type(filename[, strict])'
     FILENAME で与えられるファイル名あるいは URL に基づいて、
     ファイルの型を推定します。戻り値は、タプル `(TYPE, ENCODING)'
     です、ここで  TYPEは、
     もし型が(拡張子がないあるいは未定義のため)推定できない場合は、
     `None' を、あるいは、 MIME `content-type' ヘッダ に利用できる、`'TYPE/SUBTYPE''の形の文字列です。

     ENCODING は、符合化方式がない場合は `None' を、あるいは、
     符号化に使われるプログラムの名前 (たとえば、`compress' あるいは
     `gzip')です。 符号化方式は  `Content-Encoding'ヘッダとして
     使うのに適しており、 `Content-Transfer-Encoding'
     ヘッダには適して_いません_。
     マッピングはテーブルドリブンです。符号化方式のサフィックスは大/小文字を区別します;
     データ型サフィックスは、最初大/小文字を区別して試し、
     それから大/小文字を区別せずに試します。

     省略可能な STRICTは、既知の MIME 型のリストとして認識されるものが、
     IANAとして登録された
     正式な型のみに限定されるかどうかを指定するフラグです。 STRICT が
     true (デフォール)の時は、IANA 型のみがサポートされます; STRICT が
     false のときは、いくつかの追加の、非標準ではあるが、一般的に
     使用される MIME 型も認識されます。

`guess_all_extensions(type[, strict])'
     TYPE で与えられる MIME 型に基づいてファイルの拡張子を推定します。
     戻り値は、先頭のドット (`.')を含む、可能なファイル拡張子すべてを
     与える文字列のリストです。拡張子と特別なデータストリームとの関連付けは
     保証されませんが、 `guess_type()'によって MIME型 TYPE
     とマップされます。

     省略可能な STRICT は `guess_type()'
     関数のものと同じ意味を持ちます。

`guess_extension(type[, strict])'
     TYPE で与えられる MIME 型に基づいてファイルの拡張子を推定します。
     戻り値は、先頭のドット (`.')を含む、ファイル拡張子を
     与える文字列のリストです。拡張子と特別なデータストリームとの関連付けは
     保証されませんが、 `guess_type()'によって MIME型 TYPE
     とマップされます。 もし TYPEに対して拡張子が推定できない場合は、
     `None'が返されます。

     省略可能な STRICT は `guess_type()'
     関数のものと同じ意味を持ちます。

モジュールの動作を制御するために、いくつかの追加の関数とデータ項目が
利用できます。

`init([files])'
     内部のデータ構造を初期化します。 もし  FILES
     が与えられていれば、これはデフォールトの型のマップを
     増やすために使われる、一連のファイル名でなければなりません。
     もし省略されていれば、使われるファイル名は `knownfiles'から
     取られます。FILE あるいは `knownfiles' 内の各ファイル名は、
     それ以前に現れる名前より優先されます。 繰り返し `init()'
     を呼び出すことは許されています。

`read_mime_types(filename)'
     ファル FILENAME で与えられた型のマップが、もしあればロードします。
     型のマップは、先頭の dot (`.') を含むファイル名拡張子を、
     `'TYPE/SUBTYPE''の形の文字列にマッピングする辞書として返されます。
     もしファイル FILENAME が存在しないか、読み込めなければ、 `None'
     が返されます。

`add_type(type, ext[, strict])'
     mime型 TYPE からのマッピングを拡張子 EXT に追加します。
     拡張子がすでに既知であれば、新しい型が古いものに置き替わります。
     その型がすでに既知であれば、その拡張子が、既知の拡張子のリストに追加されます。

     STRICTがある時は、そのマッピングは正式なMIME型に、
     そうでなければ、非標準のMIME型に追加されます。

`inited'
     グローバルなデータ構造が初期化されているかどうかを示すフラグ。
     これは `init()' により true に設定されます。

`knownfiles'
     共通にインストールされた型マップファイル名のリスト。これらの
     ファイルは、普通 `mime.types'という名前であり、パッケージごとに
     異なる場所にインストールされます。 

`suffix_map'
     サフィックスをサフィックスにマップする辞書。これは、符号化方式と
     型が同一拡張子で示される符号化ファイルが認識できるように
     使用されます。例えば、`.tgz' 拡張子は、符号化と型が別個に
     認識できるように `.tar.gz'にマップされます。

`encodings_map'
     ファイル名拡張子を符号化方式型にマッピングする辞書

`types_map'
     ファイル名拡張子をMIME型にマップする辞書

`common_types'
     ファイル名拡張子を非標準ではあるが、一般に使われているMIME型に
     マップする辞書

`MimeTypes' クラスは、1つ以上のMIME-型 データベースを
必要とするアプリケーションに役に立つでしょう。

`MimeTypes([filenames])'
     このクラスは、MIME-型データベースを表現します。デフォールトでは、
     このモジュールの他のものと同じデータベースへのアクセスを提供します。
     初期データベースは、このモジュールによって提供されるもののコピーで、
     追加の `mime.types'-形式のファイルを、`read()' あるいは `readfp()'
     メソッドを使って、データベースにロードすることで拡張されます。
     マッピング辞書も、もしデフォールトのデータが望むものでなければ、
     追加のデータをロードする前にクリアされます。

     省略可能な FILENAMESパラメータは、追加のファイルを、デフォールト
     データベースの"トップに"ロードさせるのに使うことができます。

     _Added in Python version 2.2_

モジュールの使用例:

     >>> import mimetypes
     >>> mimetypes.init()
     >>> mimetypes.knownfiles
     ['/etc/mime.types', '/etc/httpd/mime.types', ... ]
     >>> mimetypes.suffix_map['.tgz']
     '.tar.gz'
     >>> mimetypes.encodings_map['.gz']
     'gzip'
     >>> mimetypes.types_map['.tgz']
     'application/x-tar-gz'

* Menu:

* Mime型 オブジェクト::


File: python-lib-jp.info,  Node: Mime型 オブジェクト,  Prev: mimetypes,  Up: mimetypes

7.6.1 Mime型 オブジェクト
-------------------------

`MimeTypes' インスタンスは、`mimetypes' モジュールの
それと非常によく似たインターフェースを提供します。

`suffix_map'
     サフィックスをサフィックスにマップする辞書。これは、符号化方式と
     型が同一拡張子で示されるような符号化ファイルが認識できるように
     使用されます。例えば、`.tgz' 拡張子は、符号化方式と型が別個に
     認識できるように `.tar.gz'に対応づけられます。
     これは、最初はモジュールで定義されたグローバルな `suffix_map' の
     コピーです。

`encodings_map'
     ファイル名拡張子を符号化型にマッピングする辞書。
     これは、最初はモジュールで定義されたグローバルな `encodings_map' の
     コピーです。

`types_map'
     ファイル名拡張子をMIME型にマッピングするる辞書。
     これは、最初はモジュールで定義されたグローバルな `types_map' の
     コピーです。

`common_types'
     ファイル名拡張子を非標準ではあるが、一般に使われているMIME型にマップする辞書。
     これは、最初はモジュールで定義されたグローバルな `common_types' の
     コピーです。

`guess_extension(type[, strict])'
     `guess_extension()' 関数と同様に、オブジェクトの
     一部として保存されたテーブルを使用します。

`guess_type(url[, strict])'
     `guess_type()' 関数と同様に、オブジェクトの
     一部として保存されたテーブルを使用します。

`read(path)'
     MIME情報を、PATHという名のファイルからロードします。
     これはファイルを解析するのに `readfp()' を使用します。

`readfp(file)'
     MIME型情報を、オープンしたファイルからロードします。
     ファイルは、標準の `mime.types'
     ファイルの形式でなければなりません。


File: python-lib-jp.info,  Node: MimeWriter,  Next: mimify,  Prev: mimetypes,  Up: インターネット上のデータの操作

7.7 汎用 MIME ファイルライター
==============================

汎用 MIME ファイルライター。

_This is deprecated in Python 2.3.   `email' パッケージを、`MimeWriter'
モジュールよりも優先して使用すべきです。このモジュールは、
下位互換性維持のためだけに存在します。_

このモジュールは、クラス `MimeWriter'を定義します。この `MimeWriter'
クラスは、MIME マルチパートファイルを作成するための
基本的なフォーマッタを実装します。これは出力ファイル内をあちこち移動することも、
大量のバッファスペースを使うこともありません。あなたは、最終のファイルに
現れるであろう順番に、パートを書かなければなりません。 `MimeWriter'
は、あなたが追加するヘッダをバッファして、それらの
順番を並び替えることができるようにします。

`MimeWriter(fp)'
     `MimeWriter' クラスの新しいインスタンスを返します。渡される
     唯一の引数 FP は、書くために使用するファイルオブジェクトです。
     `StringIO' オブジェクトを使うこともできることに注意して下さい。

* Menu:

* MimeWriter オブジェクト::


File: python-lib-jp.info,  Node: MimeWriter オブジェクト,  Prev: MimeWriter,  Up: MimeWriter

7.7.1 MimeWriter オブジェクト
-----------------------------

`MimeWriter' インスタンスには以下のメソッドがあります：

`addheader(key, value[, prefix])'
     MIMEメッセージに新しいヘッダ行を追加します。KEY は、
     そのヘッダの名前であり、そして VALUEで、そのヘッダの値を明示的に
     与えます。省略可能な引数
     PREFIXは、ヘッダが挿入される場所を決定します; `0'
     は最後に追加することを意味し、`1' は先頭への挿入です。
     デフォールトは最後に追加することです。

`flushheaders()'
     今まで集められたヘッダすべてが書かれ(そして忘れられ)るようにします。
     これは、もし全く本体が必要でない場合に役に立ちます。例えば、
     ヘッダのような情報を保管するために(誤って)使用された、 型
     `message/rfc822' のサブパート用。

`startbody(ctype[, plist[, prefix]])'
     メッセージの本体に書くのに使用できるファイルのようなオブジェクトを
     返します。コンテント-型は、与えられた CTYPE に設定され、
     省略可能なパラメータ PLISTは、コンテント-型定義のための
     追加のパラメータを与えます。 PREFIX は、そのデフォールトが
     先頭への挿入以外は `addheader()' でのように働きます。

`startmultipartbody(subtype[, boundary[, plist[, prefix]]])'
     メッセージ本体を書くのに使うことができるファイルのようなオブジェクトを
     返します。更に、このメソッドはマルチパートのコードを初期化します。ここで、
     SUBTYPE が、そのマルチパートのサブタイプを、 BOUNDARY
     がユーザ定義の境界仕様を、そして PLIST
     が、そのサブタイプ用の省略可能なパラメータを定義します。 PREFIX
     は、`startbody()' でのように働きます。サブパートは、
     `nextpart()'を使って作成するべきです。

`nextpart()'
     マルチパートメッセージの個々のパートを表す、 `MimeWriter'の
     新しいインスタンスを返します。これは、そのパートを書くのにも、
     また複雑なマルチパートを再帰的に作成するのにも使うことができます。
     メッセージは、`nextpart()' を使う前に, 最初 `startmultipartbody()'
     で初期化しなければなりません。

`lastpart()'
     これは、マルチパートメッセージの最後のパートを指定するのに使うことが
     でき、マルチパートメッセージを書くときは  _いつでも_使うべきです。


File: python-lib-jp.info,  Node: mimify,  Next: multifile,  Prev: MimeWriter,  Up: インターネット上のデータの操作

7.8 電子メイルメッセージの MIME 処理
====================================

電子メイルメッセージの MIME 化および非 MIME 化。

_This is deprecated in Python 2.3.  `mimify' モジュールを使うよりも
`email' パッケージを使うべきです。このモジュールは
以前のバージョンとの互換性のために保守されているにすぎません。_

`mimify' モジュールでは電子メイルメッセージから MIME へ、 および MIME
から電子メイルメッセージへの変換を行うための二つの関数を
定義しています。電子メイルメッセージは単なるメッセージでも、 MIME
形式でもかまいません。各パートは個別に扱われます。 メッセージ (の一部)
の MIME 化 (mimify) の際、7 ビット ASCII
文字を使って表現できない何らかの文字が含まれていた場合、メッセージの
quoted-printable への符号化が伴います。メッセージが送信される前に
編集しなければならない場合、MIME 化および非 MIME 化は特に便利です。
典型的な使用法は以下のようになります:

     unmimify message
     edit message
     mimify message
     send message

モジュールでは以下のユーザから呼び出し可能な関数と、ユーザが設定可能な
変数を定義しています:

`mimify(infile, outfile)'
     INFILE を OUTFILE にコピーします。その際、パートを
     quoted-printable に変換し、必要なら MIME メイルヘッダを追加します。
     INFILE および OUTFILE はファイルオブジェクト
     (実際には、`readline()' メソッドを持つ (INFILE) か、 `write'
     (OUTFILE) メソッドを持つあらゆるオブジェクト)
     か、ファイル名を指す文字列を指定することができます。 INFILE および
     OUTFILE が両方とも文字列の場合、 同じ値にすることができます。

`unmimify(infile, outfile[, decode_base64])'
     INFILE を OUTFILE にコピーします。その際、全ての quoted-printable
     化されたパートを復号化します。INFILE および OUTFILE
     はファイルオブジェクト (実際には、`readline()' メソッドを持つ
     (INFILE) か、 `write' (OUTFILE) メソッドを持つあらゆるオブジェクト)
     か、ファイル名を指す文字列を指定することができます。 DECODE_BASE64
     引数が与えられており、その値が真である場合、 base64
     符号で符号化されているパートも同様に復号化されます。

`mime_decode_header(line)'
     LINE 内の符号化されたヘッダ行が復号化されたものを 返します。ISO
     8859-1 文字セット (Latin-1) だけをサポートします。

`mime_encode_header(line)'
     LINE 内のヘッダ行が MIME 符号化されたものを返します。

`MAXLEN'
     標準では、非 ASCII 文字 (8 ビット目がセットされている文字) を含む
     か、`MAXLEN' 文字 (標準の値は 200 です) よりも長い 部分は
     quoted-printable 形式で符号化されます。

`CHARSET'
     文字セットがメイルヘッダで指定されていない場合指定しなければ
     なりません。使われている文字セットを表す文字列は `CHARSET'
     に記憶されます。標準の値は ISO-8859-1 (Latin1 (latin-one) としても
     知られています)。

このモジュールはコマンドラインから利用することもできます。
以下のような使用法:
     mimify.py -e [-l length] [infile [outfile]]
     mimify.py -d [-b] [infile [outfile]]

で、それぞれ符号化 (mimify) および復号化 (unmimify) を行います。
標準の設定では INFILE は標準入力で、PUTFILE は標準出力
です。入出力に同じファイルを指定することもできます。

符号化の際に *-l* オプションを与えた場合、LENGTH で
指定した長さより長い行があれば、その長さに含まれる部分が符号化
されます。

復号化の際に *-b* オプションが与えられていれば、base64 パート
も同様に復号化されます。

See also:
     *Note quopri:: MIME quoted-printable 形式ファイルのエンコード
     およびデコード。


File: python-lib-jp.info,  Node: multifile,  Next: rfc822,  Prev: mimify,  Up: インターネット上のデータの操作

7.9 個別の部分を含んだファイル群のサポート
==========================================

MIME データのような、個別の部分を含んだファイル群に対する
読み出しのサポート。

_This is deprecated in Python 2.5.  `multifile'モジュールよりも
`email' パッケージを使うべきです。
このモジュールは後方互換性のためだけに存在しています。_

`MultiFile' オブジェクトはテキストファイルを区分したものを
ファイル類似の入力オブジェクトとして扱えるようにし、指定した区切り文字
(delimiter) パタンに遭遇した際に `''' が返されるようにします。
このクラスの標準設定は MIME マルチパートメッセージを解釈する上で
便利となるように設計されていますが、サブクラス化を行って幾つかの
メソッドを上書きすることで、簡単に汎用目的に対応させることができます。
ます。

`MultiFile(fp[, seekable])'
     マルチファイル (multi-file) を生成します。このクラスは `open()'
     が返すファイルオブジェクトのような、 `MultiFile'
     インスタンスが行データを取得するための
     入力となるオブジェクトを引数としてインスタンス化を
     行わなければなりません。

     `MultiFile' は入力オブジェクトの `readline()' 、 `seek()'、および
     `tell()' メソッドしか参照せず、 後者の二つのメソッドは個々の MIME
     パートにランダムアクセスしたい 場合にのみ必要です。`MultiFile' を
     seek できないストリーム オブジェクトで使うには、オプションの
     SEEKABLE 引数の値を 偽にしてください;
     これにより、入力オブジェクトの `seek()' および `tail()'
     メソッドを使わないようになります。

`MultiFile' の視点から見ると、テキストは三種類の行データ:
データ、セクション分割子、終了マーカ、からなることを知っていると
約に立つでしょう。MultiFile は、多重入れ子構造になっている可能性
のある、それぞれが独自のセクション分割子および終了マーカのパターン
を持つメッセージパートをサポートするように設計されています。

See also:
     *Note email:: 網羅的な電子メイル操作パッケージ;  `multifile'
     モジュールに取って代わります。

* Menu:

* MultiFile オブジェクト::
* MultiFile の例::


File: python-lib-jp.info,  Node: MultiFile オブジェクト,  Next: MultiFile の例,  Prev: multifile,  Up: multifile

7.9.1 MultiFile オブジェクト
----------------------------

`MultiFile' インスタンスには以下のメソッドがあります:

`readline(str)'
     一行データを読みます。その行が
     (セクション分割子や終了マーカや本物の EOF でない)
     データの場合、行データを返します。その行がもっとも最近
     スタックにプッシュされた境界パターンにマッチした場合、`''' を返し、
     マッチした内容が終了マーカかそうでないかによって `self.last' を 1
     か 0
     に設定します。行がその他のスタックされている境界パターンにマッチ
     した場合、エラーが送出されます。背後のストリームオブジェクトにおける
     ファイルの終端に到達した場合、全ての境界がスタックから除去されていない
     限りこのメソッドは `Error' を送出します。

`readlines(str)'
     このパートの残りの全ての行を文字列のリストとして返します。

`read()'
     次のセクションまでの全ての行を読みます。読んだ内容を単一の
     (複数行にわたる) 文字列として返します。このメソッドには size
     引数をとらないので注意してください！

`seek(pos[, whence])'
     ファイルを seek します。seek する際のインデクスは現在のセクションの
     開始位置からの相対位置になります。PIS および WHENCE 引数
     はファイルの seek における引数と同じように解釈されます。

`tell()'
     現在のセクションの先頭に対して相対的なファイル位置を返します。

`next()'
     次のセクションまで行を読み飛ばします (すなわち、セクション分割子
     または終了マーカが消費されるまで行データを読みます)。
     次のセクションがあった場合には真を、終了マーカが発見された場合
     には偽を返します。最も最近スタックにプッシュされた境界パターンを
     最有効化します。

`is_data(str)'
     STR がデータの場合に真を返し、セクション分割子の可能性がある
     場合には偽を返します。このメソッドは行の先頭が (全ての MIME 境界が
     持っている) `'-'`-'' 以外になっているかを調べるように
     実装されていますが、導出クラスで上書きできるように宣言されています。

     このテストは実際の境界テストにおいて高速性を保つために使われて
     いるので注意してください; このテストが常に false を返す場合、
     テストが失敗するのではなく、単に処理が遅くなるだけです。

`push(str)'
     境界文字列をスタックにプッシュします。この境界文字列の修飾された
     バージョンが入力行に見つかった場合、セクション分割子
     または終了マーカであると解釈されます(どちらであるかは修飾に依存します。
     RFC 2045 を参照してください)。それ以降の全てのデータ読み出し
     は、`pop()' を呼んで境界文字列を除去するか、`next()'
     を呼んで境界文字列を再有効化しないかぎり、ファイル終端を示す空文字列を
     返します。

     一つ以上の境界をプッシュすることは可能です。もっとも最近プッシュされた
     境界に遭遇すると EOF が返ります; その他の境界に遭遇するとエラーが
     送出されます。

`pop()'
     セクション境界をポップします。この境界はもはや EOF として解釈
     されません。

`section_divider(str)'
     境界をセクション分割子にします。標準では、このメソッドは (全ての
     MIME 境界が持っている) `'-'`-'' を境界文字列の
     先頭に追加しますが、これは導出クラスで上書きできるように宣言
     されています。末尾の空白は無視されることから考えて、このメソッド
     では LF や CR-LF を追加する必要はありません。

`end_marker(str)'
     境界文字列を終了マーカ行にします。標準では、このメソッドは (MIME
     マルチパートデータのメッセージ終了マーカのように) `'-'`-''
     を境界文字列の先頭に追加し、かつ `'-'`-''
     を境界文字列の末尾に追加しますが、
     これは導出クラスで上書きできるように宣言されています。
     末尾の空白は無視されることから考えて、このメソッド では LF や
     CR-LF を追加する必要はありません。

最後に、`MultiFile' インスタンスは二つの公開されたインスタンス
変数を持っています:

`level'
     現在のパートにおける入れ子の深さです。

`last'
     最後に見つかったファイル終了イベントがメッセージ終了マーカ
     であった場合に真となります。


File: python-lib-jp.info,  Node: MultiFile の例,  Prev: MultiFile オブジェクト,  Up: multifile

7.9.2 `MultiFile' の例
----------------------

     import mimetools
     import multifile
     import StringIO

     def extract_mime_part_matching(stream, mimetype):
         """Return the first element in a multipart MIME message on stream
         matching mimetype."""

         msg = mimetools.Message(stream)
         msgtype = msg.gettype()
         params = msg.getplist()

         data = StringIO.StringIO()
         if msgtype[:10] == "multipart/":

             file = multifile.MultiFile(stream)
             file.push(msg.getparam("boundary"))
             while file.next():
                 submsg = mimetools.Message(file)
                 try:
                     data = StringIO.StringIO()
                     mimetools.decode(file, data, submsg.getencoding())
                 except ValueError:
                     continue
                 if submsg.gettype() == mimetype:
                     break
             file.pop()
         return data.getvalue()


File: python-lib-jp.info,  Node: rfc822,  Next: base64,  Prev: multifile,  Up: インターネット上のデータの操作

7.10 RFC 2822 準拠のメイルヘッダ読み出し
========================================

RFC 2822 形式のメイルメッセージを解釈します。

_This is deprecated in Python 2.3.  `rfc822' モジュールを使うよりも
`email' パッケージを使うべきです。このモジュールは
以前のバージョンとの互換性のために保守されているにすぎません。_

このモジュールでは、インターネット標準 RFC 2822 

(1) で定義されている "電子メイルメッセージ" を表現するクラス、
`Message' を定義しています。
このメッセージはメッセージヘッダ群とメッセージボディの集まり
からなります。このモジュールではまた、ヘルパークラス RFC 2822 アドレス群を解釈するための
`AddressList' クラス を定義しています。RFC 2822 メッセージ固有の構文に関する情報
は RFC を参照してください。

`mailbox'  モジュールでは、
多くのエンドユーザメイルプログラムによって生成されるメイルボックス
を読み出すためのクラスを提供しています。

`Message(file[, seekable])'
     `Message' インスタンスは入力オブジェクトをパラメタに与えて
     インスタンス化します。入力オブジェクトのメソッドのうち、Message が
     依存するのは `readline()' だけです; 通常のファイル
     オブジェクトは適格です。インスタンス化を行うと、入力オブジェクト
     からデリミタ行 (通常は空行 1 行) に到達するまでヘッダを読み出し、
     それらをインスタンス中に保持します。ヘッダの後のメッセージ本体は
     読み出しません。

     このクラスは `readline()' メソッドをサポートする任意の入力
     オブジェクトを扱うことができます。入力オブジェクトが seek および
     tell できる場合、 `rewindbody()' メソッドが動作します。
     また、不正な行データを入力ストリームにプッシュバックできます。
     入力オブジェクトが seek できない一方で、入力行をプッシュバックする
     `unread()' メソッドを持っている場合、`Message'
     は不正な行データにこのプッシュバックを使います。こうして、
     このクラスはバッファされているストリームから来るメッセージを
     解釈するのに使うことができます。

     オプションの SEEKABLE 引数は、`lseek()' システムコール
     が動作しないと分かるまでは `tell()' がバッファされたデータを
     無視するような、ある種の stdio
     ライブラリで回避手段として提供されています。
     可搬性を最大にするために、socket
     オブジェクトによって生成されたファイル のような、seek
     できないオブジェクトを渡す際には、最初に `tell()'
     が呼び出されないようにするために seekable
     引数をゼロに設定すべきです。

     ファイルとして読み出された入力行データは CR-LF と単一の改行 (line
     feed) のどちらで終端されていてもかまいません;
     行データを記憶する前に、終端の CR-LF
     は単一の改行と置き換えられます。

     ヘッダに対するマッチは全て大小文字に依存しません。例えば、
     `M['From']'、 `M['from']'、および `M['FROM']'
     は全て同じ結果になります。

`AddressList(field)'
     RFC 2833 アドレスをカンマで区切ったものとして解釈される
     単一の文字列パラメタを使って、`AddressList' ヘルパークラスを
     インスタンス化することができます。 (パラメタ `None'
     は空のリストを表します。)

`quote(str)'
     STR 中のバックスラッシュが 2 つのバックスラッシュに置き換えられ、
     二重引用符がバックスラッシュ付きの二重引用符に置き換えられた、
     新たな文字列を返します。

`unquote(str)'
     STR の _逆クオートされた_ 新たな文字列を返します。 STR
     が二重引用符で囲われていた場合、二重引用符を剥ぎ取ります。
     同様に、 STR が三角括弧で囲われていた場合にも剥ぎ取ります。

`parseaddr(address)'
     `To' や `Cc' といった、アドレスが入っている フィールドの値 ADDRESS
     を解析し、含まれている "実名 (realname)" 部分および
     "電子メールアドレス" 部分に分けます。それらの情報からなる
     タプルを返します。解析が失敗した場合には 2 要素のタプル `(None,
     None)' を返します。

`dump_address_pair(pair)'
     `parseaddr()' の逆で、`(REALNAME, EMAIL_ADDRESS)' 形式の 2
     要素のタプルをとり、`To' や `Cc' ヘッダに
     適した文字列値を返します。PAIR の最初の要素が真値をとらない
     場合、二つ目の要素をそのまま返します。

`parsedate(date)'
     RFC 2822 の規則に従っている日付を解析しようと試みます。
     しかしながら、メイラによっては RFC 2822 で指定されている
     ような書式に従わないため、そのような場合には `parsedata()'
     は正しい日付を推測しようと試みます。 DATE は `'Mon, 20 Nov 1995
     19:12:08 -0500'' のような RFC 2822 様式の日付を収めた文字列です。日付の解析に成功した場合、
     `parsedate()' は `time.mktime()' にそのまま渡す ことができるような
     9 要素のタプルを返します; そうでない場合には `None'
     を返します。結果のフィールド 6、7、および 8 は
     有用な情報ではありません。

`parsedate_tz(date)'
     `parsedate()' と同じ機能を実現しますが、`None' または 10
     要素のタプルを返します; 最初の 9 要素は `time.mktime()'
     に直接渡すことができるようなタプルで、 10 番目の要素はその日の
     タイムゾーンにおける UTC (グリニッチ標準時の公式名称) からの
     オフセットです。(タイムゾーンオフセットの符号は、
     同じタイムゾーンにおける `time.timezone' 変数の符号と反転
     しています; 後者の変数が POSIX 標準に従っている一方、
     このモジュールは RFC 2822 に従っているからです。) 入力文字列
     がタイムゾーン情報を持たない場合、タプルの最後の要素は `None'
     になります。結果のフィールド 6、7、および 8 は
     有用な情報ではありません。

`mktime_tz(tuple)'
     `parsedata_tz()' が返す 10 要素のタプルを UTC タイムスタンプ
     に変換します。タプル内のタイムゾーン要素が `None' の場合、地域の
     時刻を表しているものと家庭します。些細な欠陥: この関数はまず最初の
     8
     要素を地域における時刻として変換し、次にタイムゾーンの違いに対する
     補償を行います; これにより、夏時間の切り替え日前後でちょっとした
     エラーが生じるかもしれません。通常の利用に関しては心配ありません。

See also:
     *Note email:: 網羅的な電子メイル処理パッケージです; `rfc822'
     モジュールを代替します。 *Note mailbox::
     エンドユーザのメイルプログラムによって生成される、様々な mailbox
     形式を読み出すためのクラス群。 *Note mimetools:: MIME
     エンコードされたメッセージを処理する `rfc822.Message'
     のサブクラス。

* Menu:

* Message オブジェクト 2::
* AddressList オブジェクト::

---------- Footnotes ----------

(1)  このモジュールはもともと RFC 822 に適合していたので、そういう名前に
なっています。その後、RFC 2822 が RFC 822 に対する更新として
リリースされました。このモジュールは RFC 2822 適合であり、特に RFC 822 からの構文や意味付けに対する変更がなされています。


File: python-lib-jp.info,  Node: Message オブジェクト 2,  Next: AddressList オブジェクト,  Prev: rfc822,  Up: rfc822

7.10.1 Message オブジェクト
---------------------------

`Message' インスタンスは以下のメソッドを持っています:

`rewindbody()'
     メッセージ本体の先頭を seek
     します。このメソッドはファイルオブジェクト が seek
     可能である場合にのみ動作します。

`isheader(line)'
     ある行が正しい RFC 2822 ヘッダである場合、その行の正規化された
     フィールド名 (インデクス指定の際に使われる辞書キー) を返します;
     そうでない場合 `None' を返します (解析をここで一度中断し、
     行データを入力ストリームに押し戻すことを意味します)。
     このメソッドをサブクラスで上書きすると便利なことがあります。

`islast(line)'
     与えられた line が Message の区切りとなるデリミタであった場合に真を
     返します。このデリミタ行は消費され、ファイルオブジェクトの読み位置は
     その直後になります。標準ではこのメソッドは単にその行が空行かどうか
     をチェックしますが、サブクラスで上書きすることもできます。

`iscomment(line)'
     与えられた行全体を無視し、単に読み飛ばすときに真を返します。
     標準では、これは控えメソッド (stub) であり、常に `False' を返し
     ますが、サブクラスで上書きすることもできます。

`getallmatchingheaders(name)'
     NAME に一致するヘッダからなる行のリストがあれば、それらを
     全て返します。各物理行は連続した行内容であるか否かに関わらず
     別々のリスト要素になります。NAME に一致するヘッダがない場合、
     空のリストを返します。

`getfirstmatchingheader(name)'
     NAME に一致する最初のヘッダと、その行に連続する (複数)
     行からなる行データのリストを返します。 NAME
     に一致するヘッダがない場合 `None' を返します。

`getrawheader(name)'
     NAME に一致する最初のヘッダにおけるコロン以降のテキストが入った
     単一の文字列を返します。このテキストには、先頭の空白、末尾の改行、
     また後続の行がある場合には途中の改行と空白が含まれます。 NAME
     に一致するヘッダが存在しない場合には `None' を返します。

`getheader(name[, default])'
     `getrawheader(NAME)' に似ていますが、先頭および末尾の
     空白を剥ぎ取ります。途中にある空白は剥ぎ取られません。
     オプションの DEFAULT 引数は、NAME に一致する
     ヘッダが存在しない場合に、別のデフォルト値を返すように指定する
     ために使われます。

`get(name[, default])'
     正規の辞書との互換性をより高めるための `getheader()' の別名
     (alias) です。

`getaddr(name)'
     `getheader(NAME)' が返した文字列を解析して、 `(FULL NAME, EMAIL
     ADDRESS)' からなるペアを返します。 NAME
     に一致するヘッダが無い場合、`(None, None)' が返され ます;
     そうでない場合、FULL NAME および ADDRESS は (空文字列をとりうる)
     文字列になります。

     例: M に最初の `From' ヘッダに文字列 `'jack@cwi.nl (Jack Jansen)''
     が入っている場合、 `m.getaddr('From')' はペア `('Jack Jansen',
     'jack@cwi.nl')' になります。 また、`'Jack Jansen <jack@cwi.nl>''
     であっても、全く同じ結果に なります。

`getaddrlist(name)'
     `getaddr(LIST)' に似ていますが、複数のメイルアドレス
     からなるリストが入ったヘッダ (例えば `To' ヘッダ) を 解析し、
     `(FULL NAME, EMAIL ADDRESS)' のペア からなるリストを
     (たとえヘッダには一つしかアドレスが入っていなかった としても)
     返します。NAME に一致するヘッダが無かった場合、
     空のリストを返します。

     指定された名前に一致する複数のヘッダが存在する場合 (例えば、
     複数の `Cc' ヘッダが存在する場合)、全てのアドレスを
     解析します。指定されたヘッダが連続する行に収められている場合も
     解析されます。

`getdate(name)'
     `getheader()' を使ってヘッダを取得して解析し、 `time.mktime()'
     と互換な 9 要素のタプルにします; フィールド 6、7、および 8
     は有用な値ではないので注意して下さい。 NAME
     に一致するヘッダが存在しなかったり、ヘッダが解析不能
     であった場合、`None' を返します。

     日付の解析は妖術のようなものであり、全てのヘッダが標準に従って
     いるとは限りません。このメソッドは多くの発信源から集められた
     膨大な数の電子メールでテストされており、正しく動作することが
     分かっていますが、間違った結果を出力してしまう可能性はまだ
     あります。

`getdate_tz(name)'
     `getheader()' を使ってヘッダを取得して解析し、10 要素の
     タプルにします; 最初の 9 要素は `time.mktime()' と
     互換性のあるタプルを形成し、10
     番目の要素はその日におけるタイムゾーン の UTC
     からのオフセットを与える数字になります。`getdate()' と同様に、NAME
     に一致するヘッダがなかったり、解析不能であった 場合、`None'
     を返します。

`Message' インスタンスはまた、限定的なマップ型のインタフェースを
持っています。 すなわち: `M[name]' は `M.getheader(name)' に似て
いますが、一致するヘッダがない場合 `KeyError' を送出します; `len(M)'、
`M.get(NAME[, DEFAULT])'、 `M.has_key(NAME)', `M.keys()'、 `M.values()'
`M.items()'、および `M.setdefault(NAME[, DEFAULT])'
は期待通りに動作します。ただし `setdefault()' は標準の設定値
として空文字列をとります。 `Message' インスタンスはまた、
マップ型への書き込みを行えるインタフェース `M[name] = value' および
`del M[name]' をサポートしています。 `Message' オブジェクトでは、
`clear()'、 `copy()'、 `popitem()'、あるいは `update()' といったマップ型
インタフェースのメソッドはサポートしていません。 (`get()' および
`setdefault()' のサポートは Python 2.2 でしか追加されていません。)

最後に、`Message' インスタンスはいくつかの public なインスタンス
変数を持っています:

`headers'
     ヘッダ行のセット全体が、(setitem を呼び出して変更されない限り)
     読み出された順番に入れられたリストです。各行は末尾の改行を
     含んでいます。ヘッダを終端する空行はリストに含まれません。

`fp'
     インスタンス化の際に渡されたファイルまたはファイル類似オブジェクトです。
     この値はメッセージ本体を読み出すために使うことができます。

`unixfrom'
     メッセージに UNIX `From~' 行がある場合はその行、そうでなければ
     空文字列になります。この値は例えば `mbox' 形式のメイルボックス
     ファイルのような、あるコンテキスト中のメッセージを再生成するために
     必要です。


File: python-lib-jp.info,  Node: AddressList オブジェクト,  Prev: Message オブジェクト 2,  Up: rfc822

7.10.2 AddressList オブジェクト
-------------------------------

`AddressList' インスタンスは以下のメソッドを持ちます:

`__len__()'
     アドレスリスト中のアドレスの数を返します。

`__str__()'
     アドレスリストの正規化 (canonicalize) された文字列表現を返します。
     アドレスはカンマで分割された "name" <host@domain> 形式になります。

`__add__(alist)'
     二つの `AddressList' 被演算子中の双方に含まれるアドレスに
     ついて、重複を除いた (集合和の) 全てのアドレスを含む新たな
     `AddressList' インスタンスを返します。

`__iadd__(alist)'
     `__add__()' のインプレース演算版です; `AddressList'
     インスタンスと右側値 ALIST との集合和をとり、その結果を
     インスタンス自体と置き換えます。

`__sub__(alist)'
     左側値の`AddressList' インスタンスのアドレスのうち、
     右側値中に含まれていないもの全てを含む (集合差分の) 新たな
     `AddressList' インスタンスを返します。

`__isub__(alist)'
     `__sub__()' のインプレース演算版で、ALIST にも
     含まれているアドレスを削除します。

最後に、`AddressList' インスタンスは public なインスタンス変数
を一つ持ちます:

`addresslist'
     アドレスあたり一つの文字列ペアで構成されるタプルからなるリストです。
     各メンバ中では、最初の要素は正規化された名前部分で、二つ目は
     実際の配送アドレス (`@' で分割されたユーザ名 と
     ホスト.ドメインからなるペア) です。


File: python-lib-jp.info,  Node: base64,  Next: binhex,  Prev: rfc822,  Up: インターネット上のデータの操作

7.11 RFC 3548: Base16, Base32, Base64 テータの符号化
====================================================

RFC 3548: Base16, Base32, Base64 テータの符号化

このモジュールは任意のバイナリ文字列を(eメールやHTTPのPOSTリクエストの一
部としてで安全に送ることのできるテキスト文字列に変換する)base64形式へエンコー
ドおよびデコードする機能を提供します。 エンコードの概要はRFC 1521 (_MIME(Multipurpose
Internet Mail Extensions)Part One: Mechanisms for Specifying and
Describing the Format of Internet Message Bodies_, section 5.2, "Base64
Content-Transfer-Encoding")で定義されていて、
MIME形式のeメールやインターネットのさまざまな場面で利用されています。
この形式は`uuencode'プログラムによる出力とは違うものです。
たとえば、`'www.python.org''は、
`'d3d3LnB5dGhvbi5vcmc=\n''とエンコードされます。

このモジュールは、 RFC 3548 で定められた仕様による データの符号化
(エンコード、encoding) および復元 (デコード、decoding) を
提供します。この RFC 標準では Base16, Base32 および Base64 が
定義されており、これはバイナリ文字列とテキスト文字列とをエンコードあるいは
デコードするためのアルゴリズムです。変換されたテキスト文字列は email
で確実に 送信したり、URL の一部として使用したり、HTTP POST
リクエストの一部に 含めることができます。これらの符号化アルゴリズムは
`uuencode' で 使われているものとは別物です。

このモジュールでは 2つのインターフェイスが提供されています。
現代的なインターフェイスは、これら 3種類のアルファベット集合を使った
文字列オブジェクトのエンコードおよびデコードをすべてサポートします。
一方、レガシーなインターフェイスは、文字列とともにファイル風のオブジェクトに対する
エンコード / デコードを提供しますが、Base64 標準のアルファベット集合しか
使いません。

現代的なインターフェイスは以下のものを提供します:

`b64encode(s[, altchars])'
     Base64 をつかって、文字列を エンコード (符号化) します。

     S はエンコードする文字列です。オプション引数 ALTCHARS は 最低でも
     2 の長さをもつ文字列で (これ以降の文字は無視されます)、 これは `+'
     と `/' の代わりに使われる代替アルファベットを指定します。
     これにより、アプリケーションはたとえば URL
     やファイルシステムの影響をうけない Base64
     文字列を生成することができます。デフォルトの値は `None' で、
     これは標準の Base64 アルファベット集合が使われることを意味します。

     エンコードされた文字列が返されます。

`b64decode(s[, altchars])'
     Base64 文字列をデコード (復元) します。

     S にはデコードする文字列を渡します。オプション引数の ALTCHARS は
     最低でも 2 の長さをもつ文字列で (これ以降の文字は無視されます)、
     これは `+' と `/'
     の代わりに使われる代替アルファベットを指定します。

     デコードされた文字列が返されます。S
     が正しくパディングされていなかったり、
     規定のアルファベット以外の文字が含まれていた場合には `TypeError'
     が発生します。

`standard_b64encode(s)'
     標準の Base64 アルファベット集合をもちいて文字列 S をエンコード
     (符号化) します。

`standard_b64decode(s)'
     標準の Base64 アルファベット集合をもちいて文字列 S をデコード
     (復元) します。

`urlsafe_b64encode(s)'
     URL 用に安全なアルファベット集合をもちいて文字列 S をエンコード
     (符号化) します。 これは、標準の Base64 アルファベット集合にある
     `+' のかわりに `-' を使い、 `/' のかわりに `_' を使用します。

`urlsafe_b64decode(s)'
     URL 用に安全なアルファベット集合をもちいて文字列 S をデコード
     (復元) します。 これは、標準の Base64 アルファベット集合にある `+'
     のかわりに `-' を使い、 `/' のかわりに `_' を使用します。

`b32encode(s)'
     Base32 をつかって、文字列をエンコード (符号化) します。 S
     にはエンコードする文字列を渡し、エンコードされた文字列が返されます。

`b32decode(s[, casefold[, map01]])'
     Base32 をつかって、文字列をデコード (復元) します。

     S にはエンコードする文字列を渡します。オプション引数 CASEFOLD は
     小文字のアルファベットを受けつけるかどうかを指定します。
     セキュリティ上の理由により、デフォルトではこれは `False'
     になっています。

     RFC 3548 は付加的なマッピングとして、数字の 0 (零) を
     アルファベットの O (オー) に、数字の 1 (壱) をアルファベットの I
     (アイ) または L (エル) に
     対応させることを許しています。オプション引数は MAP01 は、 `None'
     でないときは、数字の 1 をどの文字に対応づけるかを指定します (map01
     が `None' でないとき、数字の 0 はつねにアルファベットの O (オー)
     に対応づけられます)。
     セキュリティ上の理由により、これはデフォルトでは `None'
     になっているため、 0 および 1 は入力として許可されていません。

     デコードされた文字列が返されます。S
     が正しくパディングされていなかったり、
     規定のアルファベット以外の文字が含まれていた場合には `TypeError'
     が発生します。

`b16encode(s)'
     Base16 をつかって、文字列をエンコード (符号化) します。

     S
     にはエンコードする文字列を渡し、エンコードされた文字列が返されます。

`b16decode(s[, casefold])'
     Base16 をつかって、文字列をデコード (復元) します。

     S にはエンコードする文字列を渡します。オプション引数 CASEFOLD は
     小文字のアルファベットを受けつけるかどうかを指定します。
     セキュリティ上の理由により、デフォルトではこれは `False'
     になっています。

     デコードされた文字列が返されます。S
     が正しくパディングされていなかったり、
     規定のアルファベット以外の文字が含まれていた場合には `TypeError'
     が発生します。

レガシーなインターフェイスは以下のものを提供します:

`decode(input, output)'
     INPUTの中身をデコードした結果をOUTPUTに出力します。
     INPUT、OUTPUTともにファイルオブジェクトか、ファイルオブジェ
     クトと同じインターフェースを持ったオブジェクトである必要があります。
     INPUTは`INPUT.read()'が空文字列を返すまで読まれます。

`decodestring(s)'
     文字列Sをデコードして結果のバイナリデータを返します。
     Sには一行以上のbase64形式でエンコードされたデータが含まれている必
     要があります。

`encode(input, output)'
     INPUTの中身をbase64形式でエンコードした結果をOUTPUTに出力します。
     INPUT、OUTPUTともにファイルオブジェクトか、ファイルオブジェ
     クトと同じインターフェースを持ったオブジェクトである必要があります。
     INPUTは`INPUT.read()'が空文字列を返すまで読まれます。
     `encode()'はエンコードされたデータと改行文字(`'\n'')を出 力します。

`encodestring(s)'
     文字列S(任意のバイナリデータを含むことができます)を
     base64形式でエンコードした結果の(1行以上の文字列)データを返します。
     `encodestring()'はエンコードされた一行以上のデータと改行文字
     (`'\n'')を出力します。

モジュールの使用例:

     >>> import base64
     >>> encoded = base64.b64encode('data to be encoded')
     >>> encoded
     'ZGF0YSB0byBiZSBlbmNvZGVk'
     >>> data = base64.b64decode(encoded)
     >>> data
     'data to be encoded'

See also:
     *Note binascii:: ASCII からバイナリへ、バイナリからASCIIへの
     変換をサポートするモジュール。

    *RFC1521 MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies*
          Section 5.2, "Base64 Content-Transfer-Encoding," provides the
          definition of the base64 encoding.



File: python-lib-jp.info,  Node: binhex,  Next: binascii,  Prev: base64,  Up: インターネット上のデータの操作

7.12 binhex4 形式ファイルのエンコードおよびデコード
===================================================

binhex4 形式ファイルのエンコードおよびデコード。

このモジュールは binhex4 形式のファイルに対するエンコードやデコード
を行います。binhex4 は Macintosh のファイルを ASCIIで表現できる
ようにしたものです。Macintosh 上では、ファイルと finder 情報の両方
のフォークがエンコード (またはデコード) されます。他のプラットフォーム
ではデータフォークだけが処理されます。

`binhex' モジュールでは以下の関数を定義しています:

`binhex(input, output)'
     ファイル名 INPUT のバイナリファイルをファイル名 OUTPUT の binhex
     形式ファイルに変換します。OUTPUT パラメタはファイル名 でも
     (`write()' および `close()' メソッドをサポートする
     ような)ファイル様オブジェクトでもかまいません。

`hexbin(input[, output])'
     binhex 形式のファイル INPUT をデコードします。INPUT は
     ファイル名でも、`write()' および `close()' メソッドを
     サポートするようなファイル様オブジェクトでもかまいません。変換結果
     のファイルはファイル名 OUTPUT になります。この引数が省略された
     場合、出力ファイルは binhex ファイルの中から復元されます。

以下の例外も定義されています:

`Error'
     binhex 形式を使ってエンコードできなかった場合 (例えば、ファイル名
     が filename フィールドに収まらないくらい長かった場合など) や、入力
     が正しくエンコードされた binhex 形式のデータでなかった場合に送出
     される例外です。

See also:
     *Note binascii:: ASCIIからバイナリ、およびバイナリからASCII
     への変換をサポートするモジュール。

* Menu:

* 注記::


File: python-lib-jp.info,  Node: 注記,  Prev: binhex,  Up: binhex

7.12.1 注記
-----------

別のより強力なエンコーダおよびデコーダへのインタフェースが存在します。
詳しくはソースを参照してください。

非 Macintosh プラットフォームでテキストファイルをエンコードしたり
デコードしたりする場合でも、Macintosh の改行文字変換 (行末をキヤリッジ
リターンとする) が行われます。

このドキュメントを書いている時点では、`hexbin()' はいつも正しく
動作するわけではないようです。


File: python-lib-jp.info,  Node: binascii,  Next: quopri,  Prev: binhex,  Up: インターネット上のデータの操作

7.13 バイナリデータと ASCIIデータとの間での変換
===============================================

バイナリと各種 ASCIIコード化バイナリ表現との間の 変換を行うツール群。

`binascii' モジュールにはバイナリと ASCIIコード化された
バイナリ表現との間の変換を行うための多数のメソッドが含まれています。
通常、これらの関数を直接使う必要はなく、 `uu' 、 `base64' や `binhex'  といった、ラッパ(wrapper)
モジュールを使うことになるでしょう。
`binascii'モジュールは、高レベルなモジュールで利用される、高速
なCで書かれた低レベル関数を提供しています。

`binascii' モジュールでは以下の関数を定義します:

`a2b_uu(string)'
     uuencode された 1 行のデータ をバイナリに変換し、変換後のバイナリ
     データを返します。最後の行を除いて、通常 1 行には(バイナリデータで)
     45 バイトが含まれます。入力データの先頭には空白文字が連続していても
     かまいません。

`b2a_uu(data)'
     バイナリデータを uuencode して 1 行の ASCII 文字列に変換します。
     戻り値は変換後の 1 行の文字列で、改行を含みます。DATA の長さは 45
     バイト以下でなければなりません。

`a2b_base64(string)'
     base64 でエンコードされたデータのブロックをバイナリに変換し、
     変換後のバイナリデータを返します。一度に 1 行以上のデータを
     与えてもかまいません。

`b2a_base64(data)'
     バイナリデータを base64 でエンコードして 1 行の ASCII 文字列に
     変換します。戻り値は変換後の 1 行の文字列で、改行文字を含みます。
     base64 標準を遵守するためには、DATA の長さは 57 バイト以下で
     なくてはなりません。

`a2b_qp(string[, header])'
     quoted-printable 形式のデータをバイナリに変換し、バイナリデータを
     返します。一度に 1 行以上のデータを渡すことができます。
     オプション引数 HEADER が与えられており、かつその値が真であれば、
     アンダースコアは空白文字にデコードされます。

`b2a_qp(data[, quotetabs, istext, header])'
     バイナリデータを quoted-printable 形式でエンコードして 1
     行から複数行の ASCII 文字列に変換します。変換後の文字列を返します。
     オプション引数 QUPTETABS が存在し、かつその値が真であれば、
     全てのタブおよび空白文字もエンコードされます。オプション引数
     ISTEXT が存在し、かつその値が真であれば、改行はエンコードされま
     せんが、行末の空白文字はエンコードされます。 オプション引数
     HEADERが存在し、かつその値が真である場合、空白文
     字はRFC1522にしたがってアンダースコアにエンコードされます。
     オプション引数
     HEADERが存在し、かつその値が偽である場合、改行文字も同様にエンコードされます。
     そうでない場合、復帰 (linefeed) 文字の変換によってバイナリデータ
     ストリームが破損してしまうかもしれません。

`a2b_hqx(string)'
     binhex4 形式の ASCII 文字列データを RLE 展開を行わないでバイナリに
     変換します。文字列はバイナリのバイトデータを完全に含むような長さか、
     または (binhex4 データの最後の部分の場合)
     余白のビットがゼロになって いなければなりません。

`rledecode_hqx(data)'
     DATA に対し、binhex4 標準に従って RLE 展開を行います。
     このアルゴリズムでは、あるバイトの後ろに `0x90' がきた場合、
     そのバイトの反復を指示しており、さらにその後ろに反復カウントが
     続きます。カウントが `0' の場合 `0x90' 自体を示します。
     このルーチンは入力データの末端における反復指定が不完全でない
     かぎり解凍されたデータを返しますが、不完全な場合、例外
     `Incomplete' が送出されます。

`rlecode_hqx(data)'
     binhex4 方式の RLE 圧縮を DATA に対して行い、その結果を 返します。

`b2a_hqx(data)'
     バイナリを hexbin4 エンコードして ASCII 文字列に変換し、変換後の
     文字列を返します。引数の DATA はすでに RLE エンコードされて
     いなければならず、その長さは (最後のフラグメントを除いて) 3 で
     割り切れなければなりません。

`crc_hqx(data, crc)'
     DATA の binhex4 CRC 値を計算します。初期値は CRC で、計算
     結果を返します。

`crc32(data[, crc])'
     32 ビットチェックサムである CRC-32 を DATA に対して計算します。
     初期値は CRC です。これは ZIP ファイルのチェックサムと同じです。
     このアルゴリズムはチェックサムアルゴリズムとして設計されたもので、
     一般的なハッシュアルゴリズムには向きません。以下のようにして使います:
              print binascii.crc32("hello world")
              # Or, in two pieces:
              crc = binascii.crc32("hello")
              crc = binascii.crc32(" world", crc)
              print crc


`b2a_hex(data)'

`hexlify data'
     バイナリデータ DATA の16進数表現を返します。DATA の各
     バイトは対応する 2 桁の16進数表現に変換されます。従って、変換結果の
     文字列はDATA の 2 倍の長さになります。

`a2b_hex(hexstr)'

`unhexlify hexstr'
     16 進数表記の文字列 HEXSTR の表すバイナリデータを返します。
     この関数は `b2a_hex()' の逆です。HEXSTR は 16進数字
     (大文字でも小文字でもかまいません) を偶数個含んでいなければ
     なりません。そうでないばあい、例外 `TypeError' が送出 されます。

`Error'
     エラーが発生した際に送出される例外です。通常はプログラムのエラーです。

`Incomplete'
     変換するデータが不完全な場合に送出される例外です。通常はプログラムの
     エラーではなく、多少追加読み込みを行って再度変換
     を試みることで対処できます。

See also:
     *Note base64:: MIME 電子メールメッセージで使われる base64
     エンコードのサポート。

     *Note binhex:: Macintosh で使われる binhex フォーマットのサポート。

     *Note uu:: UNIXで使われる UU エンコードのサポート。

     *Note quopri:: MIME 電子メールメッセージで使われる
     quoted-printable エンコードのサポート。


File: python-lib-jp.info,  Node: quopri,  Next: uu,  Prev: binascii,  Up: インターネット上のデータの操作

7.14 MIME quoted-printable 形式データのエンコードおよびデコード
===============================================================

MIME quoted-printable 形式ファイルのエンコードおよびデコード。

このモジュールは RFC 1521 : "MIME (Multipurpose Internet Mail
Extensions) Part One: Mechanisms for Specifying and Describing the
Format of Internet Message Bodies" で定義されている quoted-printable
による伝送のエンコードおよびデコードを行います。 quoted-printable
円コーディングは比較的印字不可能な文字の少ないデータのために設計
されています;
画像ファイルを送るときのように印字不可能な文字がたくさんある
場合には、`base64' モジュールで利用できる base64
エンコーディングのほうがよりコンパクトになります。 

`decode(input, output[,header])'
     ファイル INPUT の内容をデコードして、デコードされたバイナリ
     データを ファイル OUTPUT に書き出します。 INPUT および OUTPUT
     はファイルか、ファイルオブジェクトの
     インタフェースを真似たオブジェクトでなければなりません。 INPUT は
     `INPUT.readline()' が空文字列を返すまで
     読みつづけられます。オプション引数 HEADER が存在し、かつその
     値が真である場合、アンダースコアは空白文字にデコードされます。
     これは RFC 1522 : "MIME (Multipurpose Internet Mail Extensions)
     Part Two: Message Header Extensions for Non-ASCII Text"
     で記述されているところの "Q"-エンコードされたヘッダをデコードするの
     に使われます。

`encode(input, output, quotetabs)'
     ファイル INPUT の内容をエンコードして、quoted-printable 形式に
     エンコードされたデータをファイル OUTPUT に書き出します。 INPUT
     および OUTPUT はファイルか、ファイルオブジェクトの
     インタフェースを真似たオブジェクトでなければなりません。 INPUT は
     `INPUT.readline()' が空文字列を返すまで 読みつづけられます。
     QUOTETABS はデータ中に埋め込まれた空白文字やタブを変換するか
     どうか制御するフラグです; この値が真なら、それらの空白をエンコード
     します。偽ならエンコードせずそのままにしておきます。行末のスペースや
     タブは RFC 1521 に従って常に変換されるので注意してください。

`decodestring(s[,header])'
     `decode()' に似ていますが、文字列を入力として受け取り、
     デコードされた文字列を返します。

`encodestring(s[, quotetabs])'
     `encode()' に似ていますが、文字列を入力として受け取り、
     エンコードされた文字列を返します。QUOTETABS はオプション
     (デフォルトは 0 です) で、この値はそのまま`encode()' に
     渡されます。

See also:
     *Note mimify:: MIME メッセージを処理するための汎用ユーティリティ。
     *Note base64:: MIME base64 形式データのエンコードおよびデコード


File: python-lib-jp.info,  Node: uu,  Prev: quopri,  Up: インターネット上のデータの操作

7.15 uuencode形式のエンコードとデコード
=======================================

uuencode形式のエンコードとデコードを行う。

このモジュールではファイルをuuencode形式(任意のバイナリデータをASCII文字列
に変換したもの)にエンコード、デコードする機能を提供します。
引数としてファイルが仮定されている所では、ファイルのようなオブジェクトが
利用できます。後方互換性のために、パス名を含む文字列も利用できるようにし
ていて、対応するファイルを開いて読み書きします。しかし、このインターフェー
スは利用しないでください。呼び出し側でファイルを開いて(Windowsでは
`'rb''か`'wb''のモードで)利用する方法が推奨されます。

このコードはLance Ellinghouseによって提供され、Jack Jansenによって更新さ
れました。 

`uu'モジュールでは以下の関数を定義しています。

`encode(in_file, out_file[, name[, mode]])'
     IN_FILEをOUT_FILEにエンコードします。
     エンコードされたファイルには、デフォルトでデコード時に利用される
     NAMEとMODEを含んだヘッダがつきます。省略された場合には、
     IN_FILEから取得された名前か`'-'' という文字と、`0666'
     がそれぞれデフォルト値として与えられます。

`decode(in_file[, out_file[, mode]])'
     uuencode形式でエンコードされたIN_FILEをデコードして
     var{out_file}に書き出します。もしOUT_FILEがパス名でかつファイルを
     作る必要があるときには、 MODEがパーミッションの設定に使われます。
     OUT_FILEとMODEのデフォルト値はIN_FILEのヘッダから取得
     されます。しかし、ヘッダで指定されたファイルが既に存在していた場合は、
     `uu.Error'が起きます。

     誤った実装のuuencoderによる入力で、エラーから復旧できた場合、
     `decode()'は標準エラー出力に警告を表示するかもしれません。
     QUIETを真にすることでこの警告を抑制することができます。

`Error()'
     `Exception'のサブクラスで、`uu.decode()'によって、さ
     まざまな状況で起きる可能性があります。上で紹介された場合以外にも、ヘッダ
     のフォーマットが間違っている場合や、入力ファイルが途中で区切れた場合に
     も起きます。

See also:
     *Note binascii:: ASCII からバイナリへ、バイナリからASCIIへの
     変換をサポートするモジュール。


File: python-lib-jp.info,  Node: 構造化マークアップツール,  Next: File Formats,  Prev: インターネット上のデータの操作,  Up: Top

8 構造化マークアップツール
**************************

Python は様々な構造化データマークアップ形式を扱うための、様々な
モジュールをサポートしています。これらは 標準化一般マークアップ言語
(SGML) およびハイパーテキストマークアップ 言語
(HTML)、そして可拡張性マークアップ言語 (XML) を扱うための
いくつかのインタフェースからなります。

注意すべき重要な点として、`xml' パッケージは少なくとも一つの SAX
に対応した XML パーザが利用可能でなければなりません。 Python 2.3 からは
Expat パーザが Python に取り込まれているので、 `xml.parsers.expat'
モジュールは常に利用できます。 また、PyXML 追加パッケージ
についても知りたいと思うかもしれません; このパッケージは Python
用の拡張された XML ライブラリセットを提供します。

`xml.dom' および `xml.sax' パッケージのドキュメントは Python による DOM
および SAX インタフェースへのバインディングに 関する定義です。

See also:
     `Python/XML ライブラリ' {Python にバンドルされてくる `xml'
     パッケージへの 拡張である PyXML パッケージのホームページです。}

* Menu:

* HTMLParser::
* sgmllib::
* htmllib::
* htmlentitydefs::
* xmlparsersexpat::
* xmldom::
* xmldomminidom::
* xmldompulldom::
* xmlsax::
* xmlsaxhandler::
* xmlsaxsaxutils::
* xmlsaxxmlreader::
* xmletreeElementTree::


File: python-lib-jp.info,  Node: HTMLParser,  Next: sgmllib,  Prev: 構造化マークアップツール,  Up: 構造化マークアップツール

8.1 HTML および XHTML のシンプルなパーザ
========================================

HTML と XHTML を扱えるシンプルなパーザ。

_Added in Python version 2.2_

このモジュールでは `HTMLParser' クラスを定義します。 このクラスは HTML  (ハイパーテキスト記述言語、
HyperText Mark-up Language) および XHTML で書式化されているテキストファイルを解釈するための基礎と
なります。`htmllib' にあるパーザと違って、このパーザ は `sgmllib' の
SGML パーザに基づいてはいません。

`HTMLParser()'
     `HTMLParser' クラスは引数なしでインスタンス化します。

     HTMLParser インスタンスに HTML データが入力されると、
     タグが開始したとき、及び終了したときに関数を呼び出します。
     `HTMLParser' クラスは、ユーザが行いたい動作を提供する
     ために上書きできるようになっています。

     `htmllib' のパーザと違い、このパーザは終了タグが開始タグと
     一致しているか調べたり、外側のタグ要素が閉じるときに内側で明示的
     に閉じられていないタグ要素のタグ終了ハンドラを呼び出したりはしません。

例外も定義されています:

`HTMLParseError'
     パーズ中にエラーに遭遇した場合に`HTMLParser'
     クラスが送出する例外です。 この例外は三つの属性を提供しています:
     `msg' はエラーの内容を 説明する簡単なメッセージ、`lineno'
     は壊れたマークアップ構造 を検出した場所の行番号、`offset'
     は問題のマークアップ構造の 行内での開始位置を示す文字数です。

`HTMLParser' インスタンスは以下のメソッドを提供します:

`reset()'
     インスタンスをリセットします。未処理のデータは全て失われます。
     インスタンス化の際に非明示的に呼び出されます。

`feed(data)'
     パーザにテキストを入力します。入力が完全なタグ要素で構成されている
     場合に限り処理が行われます; 不完全なデータであった場合、新たに
     データが入力されるか、`close()' が呼び出されるまでバッファ
     されます。

`close()'
     全てのバッファされているデータについて、その後にファイル終了マーク
     が続いているとみなして強制的に処理を行います。このメソッドは
     入力データの終端で行うべき追加処理を定義するために導出クラスで
     上書きすることができますが、再定義を行ったクラスでは常に、
     `HTMLParser' 基底クラスのメソッド `close()' を
     呼び出さなくてはなりません。

`getpos()'
     現在の行番号およびオフセット値を返します。

`get_starttag_text()'
     最も最近開かれた開始タグのテキスト部分を返します。このテキストは
     必ずしも元データを構造化する上で必須ではありませんが、
     "広く知られている (as deployed)" HTML を扱ったり、入力を
     最小限の変更で再生成 (属性間の空白をそのままにする、など) したり
     する場合に便利なことがあります。

`handle_starttag(tag, attrs)'
     このメソッドはタグの開始部分を処理するために呼び出されます。
     導出クラスで上書きするためのメソッドです; 基底クラスの実装では
     何も行いません。

     TAG 引数はタグの名前で、小文字に変換されています。 ATTRS 引数は
     `(NAME, VALUE)' のペアからなる リストで、タグの `<>'
     括弧内にある属性が収められています。 NAME
     は小文字に変換され、VALUE 内のエンティティ参照
     は変換されます。二重引用符やバックスラッシュは変換しません。例えば、
     タグ `<A HREF="http://www.cwi.nl/">' を処理する場合、このメソッドは
     `handle_starttag('a', [('href', 'http://www.cwi.nl/')])'
     として呼び出されます。

`handle_startendtag(tag, attrs)'
     `handle_starttag()' と似ていますが、パーザが XHTML 形式の 空タグ
     (`<a .../>') に遭遇した場合に呼び出されます。 この特定の語彙情報
     (lexical information) が必要な場合、
     このメソッドをサブクラスで上書きすることができます; 標準の実装
     では、単に `handle_starttag()' および `handle_endtag()'
     を呼ぶだけです。

`handle_endtag(tag)'
     このメソッドはあるタグ要素の終了タグを処理するために呼び出されます。
     導出クラスで上書きするためのメソッドです; 基底クラスの実装では
     何も行いません。TAG 引数はタグの名前で、小文字に変換されています。

`handle_data(data)'
     このメソッドは、他のメソッドに当てはまらない任意のデータを処理するために
     呼び出されます。 導出クラスで上書きするためのメソッドです;
     基底クラスの実装では 何も行いません。

`handle_charref(ref)'
     このメソッドはタグ外の `&#REF;' 形式の文字参照 (character
     reference) を処理するために呼び出されます。 REF には、先頭の`&#'
     および末尾の`;' は 含まれません。
     導出クラスで上書きするためのメソッドです; 基底クラスの実装では
     何も行いません。

`handle_entityref(name)'
     このメソッドはタグ外の `&NAME;' 形式の一般のエンティティ参照
     (entity reference) NAME を処理するために呼び出されます。 NAME
     には、先頭の`&' および末尾の`;' は 含まれません。
     導出クラスで上書きするためのメソッドです; 基底クラスの実装では
     何も行いません。

`handle_comment(data)'
     このメソッドはコメントに遭遇した場合に呼び出されます。COMMENT
     引数は文字列で、`--' および `--' デリミタ間の、
     デリミタ自体を除いたテキストが収められています。例えば、コメント
     `<!--text-->' があると、このメソッドは引数`'text'' で
     呼び出されます。導出クラスで上書きするためのメソッドです;
     基底クラスの実装では何も行いません。

`handle_decl(decl)'
     パーザが SGML 宣言を読み出した際に呼び出されるメソッドです。 DECL
     パラメタは `<!'...`>' 記述内の宣言内容 全体になります。
     導出クラスで上書きするためのメソッドです; 基底クラスの実装では
     何も行いません。

`handle_pi(data)'
     処理指令に遭遇した場合に呼び出されます。DATAには、処理指令
     全体が含まれ、例えば`<?proc color='red'>'という処理指令の場合、
     `handle_pi("proc color='red'")'のように呼び出されます。
     このメソッドは導出クラスで上書きするためのメソッドです;
     基底クラスの 実装では何も行いません。

     _Note:_ The
     `HTMLParser'クラスでは、処理指令にSGMLの構文を使用します。
     末尾に`?'がXHTMLの処理指令では、`?'がDATAに 含まれます。

`HTMLParseError'
     HTML の構文に沿わないパターンを発見したときに送出される例外です。
     HTML
     構文法上の全てのエラーを発見できるわけではないので注意してください。

* Menu:

* HTML パーザアプリケーションの例::


File: python-lib-jp.info,  Node: HTML パーザアプリケーションの例,  Prev: HTMLParser,  Up: HTMLParser

8.1.1 HTML パーザアプリケーションの例
-------------------------------------

基礎的な例として、`HTMLParser' クラスを使い、発見したタグを出力
する、非常に基礎的な HTML パーザを以下に示します。

     from HTMLParser import HTMLParser

     class MyHTMLParser(HTMLParser):

         def handle_starttag(self, tag, attrs):
             print "Encountered the beginning of a %s tag" % tag

         def handle_endtag(self, tag):
             print "Encountered the end of a %s tag" % tag


File: python-lib-jp.info,  Node: sgmllib,  Next: htmllib,  Prev: HTMLParser,  Up: 構造化マークアップツール

8.2 単純な SGML パーザ
======================

HTML を解析するのに必要な機能だけを備えた SGML パーザ。

このモジュールでは SGML (Standard Generalized Mark-up Language:
汎用マークアップ言語標準) で書式化されたテキストファイルを解析
するための基礎として働く `SGMLParser' クラスを定義しています。
実際には、このクラスは完全な SGML パーザを提供しているわけではありません
-- このクラスは HTML で用いられているような SGML だけを解析し、
モジュール自体も `htmllib' モジュールの基礎にするため
だけに存在しています。XHTML をサポートし、少し異なったインタフェースを
提供しているもう一つの HTML パーザは、`HTMLParser'
モジュールで使うことができます。

`SGMLParser()'
     `SGMLParser' クラスは引数無しでインスタンス化されます。
     このパーザは以下の構成を認識するようにハードコードされています:

        * `<TAG ATTR="VALUE" ...>' と `</TAG>'
          で表されるタグの開始部と終了部。

        * `&#NAME;' 形式をとる文字の数値参照。

        * `&NAME;' 形式をとるエンティティ参照。

        * `<!--TEXT-->' 形式をとる SGML コメント。 末尾の `>'
          とその直前にある `--' の間には
          スペース、タブ、改行を入れることができます。


例外が以下のように定義されます:

`SGMLParseError'
     `SGMLParser'クラスで構文解析中にエラーに出逢うとこの例外が発生します。
     _Added in Python version 2.1_

`SGMLParser' インスタンスは以下のメソッドを持っています:

`reset()'
     インスタンスをリセットします。未処理のデータは全て失われます。
     このメソッドはインスタンス生成時に非明示的に呼び出されます。

`setnomoretags()'
     タグの処理を停止します。以降の入力をリテラル入力 (CDATA)
     として扱います。(この機能は HTML タグ `<PAINTEXT>' を実装
     できるようにするためだけに提供されています)

`setliteral()'
     リテラルモード (CDATA モード) に移行します。

`feed(data)'
     テキストをパーザに入力します。入力は完全なエレメントから成り立つ
     場合に限り処理されます;
     不完全なデータは追加のデータが入力されるか、 `close()'
     が呼び出されるまでバッファに蓄積されます。

`close()'
     バッファに蓄積されている全てのデータについて、直後にファイル終了記号
     が来た時のようにして強制的に処理します。このメソッドは導出クラスで
     再定義して、入力の終了時に追加の処理行うよう定義することができますが、
     このメソッドの再定義されたバージョンでは常に `close()'
     を呼び出さなければなりません。

`get_starttag_text()'
     もっとも最近開かれた開始タグのテキストを返します。通常、構造化された
     データの処理をする上でこのメソッドは必要ありませんが、
     "広く知られている (as deployed)" HTML を扱ったり、入力を
     最小限の変更で再生成 (属性間の空白をそのままにする、など) したり
     する場合に便利なことがあります。

`handle_starttag(tag, method, attributes)'
     このメソッドは `start_TAG()' か `do_TAG()'
     のどちらかのメソッドが定義されている開始タグを処理するために呼び出され
     ます。TAG 引数はタグの名前で、小文字に変換されています。 METHOD
     引数は開始タグの意味解釈をサポートするために用いられる
     バインドされたメソッドです。 ATTRIBUTES 引数は `(NAME, VALUE)'
     のペアからなる リストで、タグの `<>'
     括弧内にある属性が収められています。

     NAME は小文字に変換されます。 VALUE
     内の二重引用符とバックスラッシュも変換され、
     と同時に知られている文字参照および知られているエンティティ参照で
     セミコロンで終端されているものも変換されます(通常、エンティティ参照は任意の非英数文字
     で終端されてよいのですが、これを許すと非常に一般的な `<A
     HREF="url?spam=1&eggs=2">'　において `eggs' が
     正当なエンティティ参照であるようなケースを破綻させます)。

     例えば、タグ `<A HREF="http://www.cwi.nl/">'
     を処理する場合、このメソッドは `unknown_starttag('a', [('href',
     'http://www.cwi.nl/')])'
     として呼び出されます。基底クラスの実装では、単に METHOD
     を単一の引数 ATTRIBUTES と共に呼び出します。 _Added in Python
     version 2.5_

`handle_endtag(tag, method)'
     このメソッドは `end_TAG()' メソッドの定義されている
     終了タグを処理するために呼び出されます。 TAG
     引数はタグの名前で、小文字に変換されており、 METHOD
     引数は終了タグの意味解釈をサポートするために使われる
     バインドされたメソッドです。`end_TAG()' メソッドが
     終了エレメントとして定義されていない場合、ハンドラは一切呼び出され
     ません。基底クラスの実装では単に METHOD を呼び出します。

`handle_data(data)'
     このメソッドは何らかのデータを処理するために呼び出されます。
     導出クラスで上書きするためのメソッドです; 基底クラスの実装では
     何も行いません。

`handle_charref(ref)'
     このメソッドは `&#REF;' 形式の文字参照 (character reference)
     を処理するために呼び出されます。
     基底クラスの実装は、`convert_charref()' を使って
     参照を文字列に変換します。 もしそのメソッドが文字列を返せば
     `handle_data()' を 呼び出します。そうでなければ、
     エラーを処理するために `unknown_charref(REF)' が呼び出されます。
     _Changed in Python version 2.5_

`convert_charref(ref)'
     文字参照を文字列に変換するか、`None' を返します。 REF
     は文字列として渡される参照です。基底クラスでは REF は 0-255
     の範囲の十進数でなければなりません。
     そしてコードポイントをメソッド `convert_codepoint()'
     を使って変換します。もし REF が不正もしくは範囲外ならば、 `None'
     を返します。このメソッドはデフォルト実装の `handle_charref'
     から、あるいは属性値パーザから呼び出されます。 _Added in Python
     version 2.5_

`convert_codepoint(codepoint)'
     コードポイントを `str' の値に変換します。もしそれが適切ならば
     エンコーディングをここで扱うこともできますが、`sgmllib' の
     残りの部分はこの問題に関知しません。 _Added in Python version 2.5_

`handle_entityref(ref)'
     このメソッドは REF を一般エンティティ参照として、 `&REF;'
     形式のエンティティ参照を処理するために 呼び出されます。
     このメソッドは、REF を `convert_entityref()' に渡して
     変換します。変換結果が返された場合、変換された文字を 引数にして
     `handle_data()' を呼び出します; そうでない場合、
     `unknown_entityref(REF)' を呼び出します。 標準では `entitydefs' は
     `&amp;'、 `&apos'、 `&gt;'、 `&lt;'、および `&quot;'
     の変換を定義しています。 _Changed in Python version 2.5_

`convert_entityref(ref)'
     名前付きエンティティ参照を `str' の値に変換するか、または `None'
     を返します。変換結果は再パーズしません。 REF
     はエンティティの名前部分だけ
     です。デフォルトの実装ではインスタンス(またはクラス)変数の
     `entitydefs' というエンティティ名から対応する文字列へのマッピング
     から REF を探します。もし REF に対応する文字列が見つからなければ
     メソッドは `None' を返します。このメソッドは `handle_entityref()'
     のデフォルト実装からおよび属性値パーザから呼び出されます。 _Added
     in Python version 2.5_

`handle_comment(comment)'
     このメソッドはコメントに遭遇した場合に呼び出されます。COMMENT
     引数は文字列で、`<!--' and `-->' デリミタ間の、
     デリミタ自体を除いたテキストが収められています。例えば、コメント
     `<!--text-->' があると、このメソッドは引数 `'text''
     で呼び出されます。基底クラスの実装では何も行いません。

`handle_decl(data)'
     パーザが SGML 宣言を読み出した際に呼び出されるメソッドです。
     実際には、`DOCTYPE' は HTML だけに見られる宣言ですが、
     パーザは宣言間の相違 (や誤った宣言) を判別しません。`DOCTYPE'
     の内部サブセット宣言はサポートされていません。 DECL パラメタは
     `<!'...`>' 記述内の宣言内容
     全体になります。基底クラスの実装では何も行いません。

`report_unbalanced(tag)'
     個のメソッドは対応する開始エレメントのない終了タグが発見された
     時に呼び出されます。

`unknown_starttag(tag, attributes)'
     未知の開始タグを処理するために呼び出されるメソッドです。
     導出クラスで上書きするためのメソッドです; 基底クラスの実装では
     何も行いません。

`unknown_endtag(tag)'
     This method is called to process an unknown end tag.
     未知の終了タグを処理するために呼び出されるメソッドです。
     導出クラスで上書きするためのメソッドです; 基底クラスの実装では
     何も行いません。

`unknown_charref(ref)'
     このメソッドは解決不能な文字参照数値を処理するために呼び出され
     ます。標準で何が処理可能かは `handle_charref()' を参照
     してください。 導出クラスで上書きするためのメソッドです;
     基底クラスの実装では 何も行いません。

`unknown_entityref(ref)'
     未知のエンティティ参照を処理するために呼び出されるメソッドです。
     導出クラスで上書きするためのメソッドです; 基底クラスの実装では
     何も行いません。

上に挙げたメソッドを上書きしたり拡張したりするのとは別に、導出
クラスでは以下の形式のメソッドを定義して、特定のタグを処理する
こともできます。入力ストリーム中のタグ名は大小文字の区別に依存
しません; メソッド名中の TAG は小文字でなければなりません:

`start_TAG(attributes)'
     このメソッドは開始タグ TAG を処理するために呼び出されます。
     `do_TAG()' よりも高い優先順位があります。 ATTRIBUTES 引数は上の
     `handle_starttag()' で記述されて いるのと同じ意味です。

`do_TAG(attributes)'
     このメソッドは `start_TAG' メソッドが定義されていない 開始タグ TAG
     を処理するために呼び出されます。 ATTRIBUTES 引数は上の
     `handle_starttag()' で記述されて いるのと同じ意味です。

`end_TAG()'
     このメソッドは終了タグ TAG を処理するために呼び出されます。

パーザは開始されたエレメントのうち、終了タグがまだ見つかっていない
もののスタックを維持しているので注意してください。 `start_TAG()'
で処理されたタグだけがスタックにプッシュ されます。are pushed on this
stack.  Definition of an それらのタグに対する `end_TAG()'
メソッドの定義は オプションです。`do_TAG()' や `unknown_tag()'
で処理されるタグについては、`end_TAG()' を定義しては いけません;
定義されていても使われることはありません。 あるタグに対して `start_TAG'
および `do_TAG()' メソッドの両方が存在する場合、`start_TAG()'
が優先されます。


File: python-lib-jp.info,  Node: htmllib,  Next: htmlentitydefs,  Prev: sgmllib,  Up: 構造化マークアップツール

8.3 HTML 文書の解析器
=====================

HTML 文書の解析器。

このモジュールでは、ハイパーテキスト記述言語 (HTML, HyperText Mark-up
Language) 形式で書式化されたテキストファイルを解析するための基盤として
役立つクラスを定義しています。このクラスは I/O と直接的には接続
されません -- このクラスにはメソッドを介して文字列形式の入力を
提供する必要があり、出力を生成するには "フォーマッタ (formatter)"
オブジェクトのメソッドを何度か呼び出さなくてはなりません。

`HTMLParser' クラスは、機能を追加するために他のクラスの基底クラス
として利用するように設計されており、ほとんどのメソッドが拡張したり
上書きしたりできるようになっています。 さらにこのクラスは `sgmllib'  モジュール
で定義されている `SGMLParser' クラスから導出されており、その機能
を拡張しています。`HTMLParser' の実装は、RFC 1866 

で解説されている HTML 2.0 記述言語をサポートします。 `formatter'  では
2 つのフォーマッタ オブジェクト実装が提供されています;
フォーマッタのインタフェースに ついての情報は `formatter'
モジュールのドキュメントを参照 してください。 

以下は `sgmllib.SGMLParser' で定義されているインタフェースの 概要です:

   * インスタンスにデータを与えるためのインタフェースは `feed()'
     メソッドで、このメソッドは文字列を引数に取ります。
     このメソッドに一度に与えるテキストは必要に応じて多くも少なくも
     できます; というのは `p.feed(a);p.feed(b)' は `p.feed(a+b)'
     と同じ効果を持つからです。 与えられたデータが完全な HTML
     マークアップ文を含む場合、それらの文は 即座に処理されます;
     不完全なマークアップ構造はバッファに保存されます。
     全ての未処理データを強制的に処理させるには、 `close()'
     メソッドを呼び出します。

     例えば、ファイルの全内容を解析するには:
          parser.feed(open('myfile.html').read())
          parser.close()

     のようにします。

   * HTML タグに対して意味付けを定義するためのインタフェースはとても
     単純です: サブクラスを導出して、`start_TAG()'、
     `end_TAG()'、あるいは `do_TAG()'
     といったメソッドを定義するだけです。
     パーザはこれらのメソッドを適切なタイミングで呼び出します:
     `start_TAG' や `do_TAG()' は `<TAG ...>'
     の形式の開始タグに遭遇した時に呼び出されます; `end_TAG()' は
     `<TAG>' の形式の終了タグに 遭遇した時に呼び出されます。`<H1>' ...
     `</H1>' のように
     開始タグが終了タグと対応している必要がある場合、クラス中で
     `start_TAG()' が定義されていなければなりません; `<P>'
     のように終了タグが必要ない場合、クラス中では `do_TAG()'
     を定義しなければなりません。


このモジュールではパーザクラスと例外を一つづつ定義しています:

`HTMLParser(formatter)'
     基底となる HTML パーザクラスです。XHTML 1.0 仕様
     (`http://www.w3.rog/TR/xhtml1') 勧告で要求されている
     全てのエンティティ名をサポートしています。

`HTMLParseError'
     `HTMLParser' クラスがパーズ処理中にエラーに遭遇した場合に
     送出する例外です。 _Added in Python version 2.4_

See also:
     *Note formatter:: 抽象化された書式イベントの流れを writer
     オブジェクト上の特定の出力イベントに変換するための
     インターフェース。 *Note HTMLParser:: HTML
     パーザのひとつです。やや低いレベル でしか入力を扱えませんが、XHTML
     を扱うことができるように設計 されています。"広く知られている HTML
     (HTML as deployed)" では 使われておらずかつ XHTML
     では正しくないとされる SGML 構文のいくつか は実装されていません。
     *Note htmlentitydefs:: XHTML 1.0 エンティティに対する置換
     テキストの定義。 *Note sgmllib:: `HTMLParser' の基底クラス。

* Menu:

* HTMLParser オブジェクト::


File: python-lib-jp.info,  Node: HTMLParser オブジェクト,  Prev: htmllib,  Up: htmllib

8.3.1 HTMLParser オブジェクト
-----------------------------

タグメソッドに加えて、`HTMLParser' クラスではタグメソッド
で利用するためのいくつかのメソッドとインスタンス変数を提供しています。

`formatter'
     パーザに関連付けられているフォーマッタインスタンスです。

`nofill'
     ブール値のフラグで、空白文字を縮約したくないときには真、縮約するときには
     偽にします。一般的には、この値を真にするのは、`<PRE>' 要素の
     中のテキストのように、文字列データが "書式化済みの (preformatted)"
     場合だけです。標準の値は偽です。この値は `handle_data()' および
     `save_end()' の操作に影響します。

`anchor_bgn(href, name, type)'
     このメソッドはアンカー領域の先頭で呼び出されます。引数は `<A>'
     タグの属性で同じ名前を持つものに対応します。
     標準の実装では、ドキュメント内のハイパーリンク (`<A>' タグの
     `HREF' 属性) を列挙したリスト
     を維持しています。ハイパーリンクのリストはデータ属性 `anchorlist'
     で手に入れることができます。

`anchor_end()'
     このメソッドはアンカー領域の末尾で呼び出されます。標準の
     実装では、テキストの注釈マーカを追加します。マーカは
     `anchor_bgn()' で作られたハイパーリンクリストの インデクス値です。

`handle_image(source, alt[, ismap[, align[, width[, height]]]])'
     このメソッドは画像を扱うために呼び出されます。標準の実装では、
     単に `handle_data()' に ALT の値を渡すだけです。

`save_bgn()'
     文字列データをフォーマッタオブジェクトに送らずにバッファに保存
     する操作を開始します。保存されたデータは `save_end()'
     で取得してください。 `save_bgn()' / `save_end()'
     のペアを入れ子構造にすることはできません。

`save_end()'
     文字列データのバッファリングを終了し、以前 `save_bgn()'
     を呼び出した時点から保存されている全てのデータを返します。
     `nofill' フラグが偽の場合、空白文字は全てスペース文字
     一文字に置き換えられます。予め `save_bgn()' を呼ばないで
     このメソッドを呼び出すと `TypeError' 例外が送出されます。


File: python-lib-jp.info,  Node: htmlentitydefs,  Next: xmlparsersexpat,  Prev: htmllib,  Up: 構造化マークアップツール

8.4 HTML 一般エンティティの定義
===============================

HTML 一般エンティティの定義。

このモジュールでは`entitydefs'、`codepoint2name'、`entitydefs'
の三つの辞書を定義しています。 `entitydefs'は`htmllib' モジュールで
`HTMLParser' クラスの `entitydefs' メンバを定義するために使われます。
このモジュールでは XHTML 1.0
で定義された全てのエンティティを提供しており、 Latin-1 キャラクタセット
(ISO-8859-1)の簡単なテキスト置換を行う事ができます。

`entitydefs'
     各 XHTML 1.0 エンティティ定義について、ISO Latin-1 における置換
     テキストへの対応付けを行っている辞書です。

`name2codepoint'
     HTMLのエンティティ名をUnicodeのコードポイントに変換するための辞書です。
     _Added in Python version 2.3_

`codepoint2name'
     A dictionary that maps Unicode codepoints to HTML entity names.
     UnicodeのコードポイントをHTMLのエンティティ名に変換するための辞書です。
     _Added in Python version 2.3_


File: python-lib-jp.info,  Node: xmlparsersexpat,  Next: xmldom,  Prev: htmlentitydefs,  Up: 構造化マークアップツール

8.5 Expat を使った高速な XML 解析
=================================

Expat による、検証を行わない XML パーザへのインタフェース

_Added in Python version 2.0_

`xml.parsers.expat' モジュールは、検証 (validation) を 行わない XML
パーザ (parser, 解析器)、Expat  への Python インタフェースです。
モジュールは一つの拡張型 `xmlparser' を提供します。これは
XMLパーザの現在の状況を表します。一旦 `xmlparser' オブジェクトを
生成すると、オブジェクトの様々な属性をハンドラ関数 (handler function)
に設定できます。 その後、XML 文書をパーザに入力すると、
XML文書の文字列とマークアップ に応じてハンドラ関数が呼び出されます。

このモジュールでは、Expatパーザへのアクセスを提供するために `pyexpat' モジュールを使用します。
`pyexpat'モジュールの直接使用は撤廃されています。

このモジュールは、例外を一つと型オブジェクトを一つ提供しています。

`ExpatError'
     Expat がエラーを報告したときに例外を送出します。Expatのエラーを
     解釈する上での詳細な情報は、 *Note ExpatError 例外:: の
     "ExpatError Exceptions," を参照してください。

`error'
     `ExpatError'への別名です。

`XMLParserType'
     `ParserCreate()' 関数から返された戻り値の型を示します。

`xml.parsers.expat' モジュールには以下の 2 つの関数が収められて います:

`ErrorString(errno)'
     与えられたエラー番号 ERRNO を解説する文字列を返します。

`ParserCreate([encoding[, namespace_separator]])'
     新しい `xmlparser' オブジェクトを作成し、返します。 ENCODING
     が指定されていた場合、XMLデータで使われている
     文字列のエンコード名でなければなりません。Expatは、Pythonのように多くの
     エンコードをサポートしておらず、またエンコーディングのレパートリを
     拡張することはできません; サポートするエンコードは、UTF-8, UTF-16,
     ISO-8859-1 (Latin1), ASCII です。ENCODINGが
     指定されると、文書に対する明示的、非明示的なエンコード指定を
     上書き (override) します。

     Expat はオプションで XML 名前空間の処理を行うことができます。
     これは引数  NAMESPACE_SEPARATOR に値を指定することで
     有効になります。 この値は、1文字の文字列でなければなりません;
     文字列が誤った長さ を持つ場合には `ValueError' が送出されます
     (`None' は 値の省略と見なされます)
     名前空間の処理が可能なとき、名前空間に属する
     要素と属性が展開されます。要素のハンドラである
     `StartElementHandler' と `EndElementHandler' に渡された
     要素名は、名前空間のURI、名前空間の区切り文字、要素名のローカル部を
     連結したものになります。名前空間の区切り文字が 0 バイト (`chr(0)')
     の場合、名前空間の URI とローカル部は区切り文字なしで
     連結されます。

     たとえば、 NAMESPACE_SEPARATOR に空白文字(` ')がセットされ、
     次のような文書が解析されるとします。

          <?xml version="1.0"?>
          <root xmlns    = "http://default-namespace.org/"
                xmlns:py = "http://www.python.org/ns/">
            <py:elem1 />
            <elem2 xmlns="" />
          </root>

     `StartElementHandler'
     は各要素ごとに次のような文字列を受け取ります。

          http://default-namespace.org/ root
          http://www.python.org/ns/ elem1
          elem2


See also:
     `The Expat XML Parser' {Expatプロジェクトのホームページ}

* Menu:

* XMLParser Objects::
* ExpatError 例外::
* 例 5::
* 内容モデルの記述::
* Expat エラー定数::


File: python-lib-jp.info,  Node: XMLParser Objects,  Next: ExpatError 例外,  Prev: xmlparsersexpat,  Up: xmlparsersexpat

8.5.1 XMLParser Objects
-----------------------

`xmlparser' オブジェクトは以下のようなメソッドを持ちます。

`Parse(data[, isfinal])'
     文字列 DATA の内容を解析し、解析されたデータを処理するための
     適切な関数を呼び出します。このメソッドを最後に呼び出す時は ISFINAL
     を真にしなければなりません。 DATA
     は空の文字列を取ることもできます。

`ParseFile(file)'
     FILE オブジェクトから読み込んだXMLデータを解析します。 FILE には
     `read(NBYTES)' メソッドのみが必要です。
     このメソッドはデータがなくなった場合に空文字列を返さねばなりません。。

`SetBase(base)'
     (XML) 宣言中のシステム識別子中の相対 URI を解決するための、 基底
     URI を設定します。相対識別子の解決はアプリケーションに 任されます:
     この値は関数 `ExternalEntityRefHandler' や
     `NotationDeclHandler'、`UnparsedEntityDeclHandler' に引数 BASE
     としてそのまま渡されます。

`GetBase()'
     以前の `SetBase()' によって設定された基底 URI を文字列の形で
     返します。`SetBase()'が呼ばれていないときには `None' を 返します。

`GetInputContext()'
     現在のイベントを発生させた入力データを文字列として返します。
     データはテキストの入っているエンティティが持っているエンコードに
     なります。
     イベントハンドラがアクティブでないときに呼ばれると、戻り値は
     `None'となります。 _Added in Python version 2.1_

`ExternalEntityParserCreate(context[, encoding])'
     親となるパーザで解析された内容が参照している、外部で解析される
     エンティティを解析するために使える "子の" パーザを作成します。
     CONTEXT パラメータは、以下に記すように `ExternalEntityRefHandler()'
     ハンドラ関数に渡される文字列でなければなりません。子のパーザは
     `ordered_attributes'、`returns_unicode'、 `specified_attributes'
     が現在のパーザの値に設定されて 生成されます。

`UseForeignDTD([flag])'
     FLAGの値をデフォルトのtrueにすると、Expatは代わりのDTDを
     ロードするため、すべての引数に`None' を設定して
     `ExternalEntityRefHandler' を呼び出します。XML文書が
     文書型定義を持っていなければ、 `ExternalEntityRefHandler'
     が呼び出しますが、`StartDoctypeDeclHandler' と
     `EndDoctypeDeclHandler'は呼び出されません。

     FLAG にfalseを与えると、メソッドが前回呼ばれた時のtrueの
     設定が解除されますが、他には何も起こりません。

     このメソッドは `Parse()' または `ParseFile()'
     メソッドが呼び出される前にだけ呼び出されます;これら2つのメソッドの
     どちらかが呼び出されたあとにメソッドが呼ばれると、 `code' に 定数
     `errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING' が
     設定されて例外 `ExpatError' が送出されます。

     _Added in Python version 2.3_

`xmlparser' オブジェクトは次のような属性を持ちます:

`buffer_size'
     `buffer_text' が真の時に使われるバッファのサイズです。
     この値は変更できません。 _Added in Python version 2.3_

`buffer_text'
     この値を真にすると、`xmlparser' オブジェクトが Expatから返された
     もとの内容をバッファに保持するようになります。これにより可能なときに
     何度も `CharacterDataHandler()' を呼び出してしまうようなことを
     避けることができます。Expatは通常、文字列のデータを行末ごと大量に破棄
     するため、かなりパフォーマンスを改善できるはずです。この属性はデフォルト
     では偽で、いつでも変更可能です。 _Added in Python version 2.3_

`buffer_used'
     `buffer_text' が利用可能なとき、バッファに保持されたバイト数です。
     これらのバイトはUTF-8でエンコードされたテキストを表します。この属性は
     `buffer_text' が偽の時には意味がありません。 _Added in Python
     version 2.3_

`ordered_attributes'
     この属性をゼロ以外の整数にすると、報告される(XMLノードの) 属性を
     辞書型ではなくリスト型にします。属性は文書のテキスト中の出現順で示されます。
     それぞれの属性は、2つのリストのエントリ:
     属性名とその値、が与えられます。
     (このモジュールの古いバージョンでも、同じフォーマットが使われています。)
     デフォルトでは、この属性はデフォルトでは偽となりますが、
     いつでも変更可能です。 _Added in Python version 2.1_

`returns_unicode'
     この属性をゼロ以外の整数にすると、ハンドラ関数に Unicode 文字列が
     渡されます。 `returns_unicode' が `False'
     の時には、UTF-8でエンコード されたデータを含む 8
     ビット文字列がハンドラに渡されます。Pythonがユニコード
     サポートつきでビルドされている場合、この値はデフォルトで`True'です。
     _Changed in Python version 1.6_

`specified_attributes'
     ゼロ以外の整数にすると、パーザは文書のインスタンスで特定される
     属性だけを報告し、属性宣言から導出された属性は報告しないようになります。
     この属性が指定されたアプリケーションでは、XMLプロセッサの振る舞いに
     関する標準に従うために必要とされる (文書型)
     宣言によって、どのような
     付加情報が利用できるのかということについて特に注意を払わなければなりません。
     デフォルトで、この属性は偽となりますが、いつでも変更可能です。
     _Added in Python version 2.1_

以下の属性には、 `xmlparser' オブジェクトで最も最近に起きた
エラーに関する値が入っており、また `Parse()' または
`ParseFile()'メソッドが `xml.parsers.expat.ExpatError'
例外を送出した際にのみ正しい値となります。

`ErrorByteIndex'
     エラーが発生したバイトのインデクスです。

`ErrorCode'
     エラーを特定する数値によるコードです。この値は`ErrorString()' に
     渡したり、 `errors' オブジェクトで定義された内容と比較できます。

`ErrorColumnNumber'
     エラーの発生したカラム番号です。

`ErrorLineNumber'
     エラーの発生した行番号です。

以下の属性は `xmlparser' オブジェクトがその時パースしている位置に
関する値を保持しています。コールバックがパースイベントを報告している間、
これらの値はイベントの生成した文字列の先頭の位置を指し示します。
コールバックの外から参照された時には、（対応するコールバックであるかに
かかわらず）直前のパースイベントの位置を示します。 _Added in Python
version 2.4_

`CurrentByteIndex'
     パーサへの入力の、現在のバイトインデックス。

`CurrentColumnNumber'
     パーサへの入力の、現在のカラム番号。

`CurrentLineNumber'
     パーサへの入力の、現在の行番号。

以下に指定可能なハンドラのリストを示します。 `xmlparser' オブジェクト O
に ハンドラを指定するには、`O.HANDLERNAME = FUNC' を使用します。
HANDLERNAME は、以下のリストに挙げた値をとらねば ならず、また FUNC
は正しい数の引数を受理する呼び出し可能な
オブジェクトでなければなりません。引数は特に明記しない限り、すべて
文字列となります。

`XmlDeclHandler(version, encoding, standalone)'
     XML 宣言が解析された時に呼ばれます。XML宣言とは、XML勧告の適用
     バージョン
     (オプション)、文書テキストのエンコード、そしてオプションの
     "スタンドアロン" の宣言です。 VERSION と ENCODING は
     `returns_unicode' 属性によって指示された型を示す文字列となり、
     STANDALONE は、文書がスタンドアロンであると宣言される場合には
     `1'に、文書がスタンドアロンでない場合には `0' に、
     スタンドアロン宣言を省略する場合には `-1' になります。
     このハンドラは Expat のバージョン1.95.0以降のみ使用できます。
     _Added in Python version 2.1_

`StartDoctypeDeclHandler(doctypeName, systemId, publicId, has_internal_subset)'
     Expatが文書型宣言`<!DOCTYPE ...')を解析し始めたときに
     呼び出されます。DOCTYPENAME は、与えられた値がそのまま Expat
     に提供されます。SYSTEMID と PUBLICID パラメタが
     指定されている場合、それぞれシステムと公開識別子を与えます。
     省略する時には`None' にします。文書が内部的な文書宣言のサブセット
     (internal document declaration subset) を持つか、サブセット自体の
     場合、HAS_INTERNAL_SUBSET は true になります。
     このハンドラには、Expat version 1.2以上が必要です。

`EndDoctypeDeclHandler()'
     Expatが文書型宣言の解析を終えたときに呼び出されます。
     このハンドラには、Expat version 1.2以上が必要です。

`ElementDeclHandler(name, model)'
     それぞれの要素型宣言ごとに呼び出されます。NAMEは要素型の名前であり、
     MODEL は内容モデル (content model) の表現です。

`AttlistDeclHandler(elname, attname, type, default, required)'
     ひとつの要素型で宣言される属性ごとに呼び出されます。属性リストの宣言が
     3つの属性を宣言したとすると、このハンドラはひとつの属性に1度づつ、
     3度呼び出されます。 ELNAME
     は要素名であり、これに対して宣言が適用され、ATTNAMEが
     宣言された属性名となります。 属性型は文字列で、TYPE として渡され
     ます; 取りえる値は、`'CDATA'', `'ID'',`'IDREF'', ...  です。
     DEFAULTは、属性が文書のインスタンスによって指定されていないときに
     使用されるデフォルト値を与えます。デフォルト値(`#IMPLIED' values)が
     存在しないときには`None'を与えます。文書のインスタンスによって属性値が
     与えられる必要のあるときにはREQUIREDがtrueになります。
     このメソッドはExpat version 1.95.0 以上が必要です。

`StartElementHandler(name, attributes)'
     要素の開始を処理するごとに呼び出されます。NAME は要素名を格納した
     文字列で、ATTRIBUTES はその値に属性名を対応付ける辞書型です。

`EndElementHandler(name)'
     要素の終端を処理するごとに呼び出されます。

`ProcessingInstructionHandler(target, data)'
     Called for every processing instruction.
     処理命令を処理するごとに呼び出されます。

`CharacterDataHandler(data)'
     文字データを処理するときに呼びだされます。このハンドラは通常の文字データ、
     CDATAセクション、無視できる空白文字列のために呼び出されます。
     これらを識別しなければならないアプリケーションは、要求された情報を
     収集するために `StartCdataSectionHandler',
     `EndCdataSectionHandler', and
     `ElementDeclHandler'コールバックメソッドを使用できます。

`UnparsedEntityDeclHandler(entityName, base, systemId, publicId, notationName)'
     解析されていない (NDATA)
     エンティティ宣言を処理するために呼び出されます。 このハンドラは
     Expat ライブラリのバージョン1.2のためだけに存在します;
     より最近のバージョンでは、
     代わりに`EntityDeclHandler'を使用してください (根底にある Expat
     ライブラリ内の関数は、撤廃されたものであると宣言されています)。

`EntityDeclHandler(entityName, is_parameter_entity, value, base, systemId, publicId, notationName)'
     エンティティ宣言ごとに呼び出されます。パラメタと内部エンティティに
     ついて、VALUE はエンティティ宣言の宣言済みの内容を与える文字列
     となります; 外部エンティティの時には`None' となります。解析済み
     エンティティの場合、NOTATIONNAME パラメタは `None' となり、
     解析されていないエンティティの時には記法 (notation) 名となります。
     IS_PARAMETER_ENTITY は、エンティティがパラメタエンティティの
     場合真に、一般エンティティ (general entitiy) の場合には偽になります
     (ほとんどのアプリケーションでは、一般エンティティのことしか気に
     する必要がありません)。 このハンドラは Expat
     ライブラリのバージョン1.95.0 以降でのみ使用できます。 _Added in
     Python version 2.1_

`NotationDeclHandler(notationName, base, systemId, publicId)'
     記法の宣言 (notation declaration) で呼び出されます。 NOTATIONNAME,
     BASE, SYSTEMID, および PUBLICID
     を与える場合、文字列にします。public な識別子が省略された場合、
     PUBLICID は `None' になります。

`StartNamespaceDeclHandler(prefix, uri)'
     要素が名前空間宣言を含んでいる場合に呼び出されます。名前空間宣言は、
     宣言が配置されている要素に対して `StartElementHandler' が
     呼び出される前に処理されます。

`EndNamespaceDeclHandler(prefix)'
     名前空間宣言を含んでいたエレメントの終了タグに到達したときに
     呼び出されます。このハンドラは、要素に関する名前空間宣言ごとに、
     `StartNamespaceDeclHandler' とは逆の順番で一度だけ呼び
     出され、各名前空間宣言のスコープが開始されたことを示します。
     このハンドラは、要素が終了する際、対応する `EndElementHandler'
     が呼ばれた後に呼び出されます。

`CommentHandler(data)'
     コメントで呼び出されます。DATA はコメントのテキストで、 先頭の
     ``<!-'`-'' と末尾の ``-'`->'' を除きます。

`StartCdataSectionHandler()'
     CDATA セクションの開始時に呼び出されます。CDATA セクションの
     構文的な開始と終了位置を識別できるようにするには、このハンドラと
     `EndCdataSectionHandler' が必要です。

`EndCdataSectionHandler()'
     CDATA セクションの終了時に呼び出されます。

`DefaultHandler(data)'
     XML 文書中で、適用可能なハンドラが指定されていない
     文字すべてに対して呼び出されます。この文字とは、検出されたことが
     報告されるが、ハンドラは指定されていないような コンストラクト
     (construct) の一部である文字を意味します。

`DefaultHandlerExpand(data)'
     `DefaultHandler' と同じですが、内部エンティティの
     展開を禁止しません。エンティティ参照はデフォルトハンドラに
     渡されません。

`NotStandaloneHandler()'
     XML
     文書がスタンドアロンの文書として宣言されていない場合に呼び出されます。
     外部サブセットやパラメタエンティティへの参照が存在するが、XML
     宣言が XML 宣言中で standalone 変数を `yes' に設定していない場合に
     起きます。このハンドラが `0' を返すと、パーザは
     `XML_ERROR_NOT_STANDALONE' を送出します。
     このハンドラが設定されていなければ、パーザは前述の事態で
     例外を送出しません。

`ExternalEntityRefHandler(context, base, systemId, publicId)'
     外部エンティティの参照時に呼び出されます。BASE は現在の基底 (base)
     で、以前の `SetBase()' で設定された値になっています。
     public、および system の識別子である、SYSTEMID とPUBLICID
     が指定されている場合、値は文字列です; public
     識別子が指定されていない 場合、 PUBLICID は `None' になります。
     CONTEXT の値は不明瞭なものであり、以下に記述するようにしか
     使ってはなりません。

     外部エンティティが解析されるようにするには、このハンドラを実装
     しなければなりません。このハンドラは、
     `ExternalEntityParserCreate(CONTEXT)' を使って
     適切なコールバックを指定し、子パーザを生成して、
     エンティティを解析する役割を担います。このハンドラは整数を
     返さねばなりません;  `0' を返した場合、パーザは
     `XML_ERROR_EXTERNAL_ENTITY_HANDLING' エラーを送出します。
     そうでないばあい、解析を継続します。

     このハンドラが与えられておらず、 `DefaultHandler'
     コールバックが指定されていれば、
     外部エンティティは`DefaultHandler' で報告されます。


File: python-lib-jp.info,  Node: ExpatError 例外,  Next: 例 5,  Prev: XMLParser Objects,  Up: xmlparsersexpat

8.5.2 ExpatError 例外
---------------------

`ExpatError' 例外はいくつかの興味深い属性を備えています:

`code'
     特定のエラーにおける Expat の内部エラー番号です。この値は
     このモジュールの`errors' オブジェクトで定義されている
     定数のいずれかに一致します。 _Added in Python version 2.1_

`lineno'
     エラーが検出された場所の行番号です。最初の行の番号は `1' です。
     _Added in Python version 2.1_

`offset'
     エラーが発生した場所の行内でのオフセットです。最初のカラムの番号は
     `0' です。 _Added in Python version 2.1_


File: python-lib-jp.info,  Node: 例 5,  Next: 内容モデルの記述,  Prev: ExpatError 例外,  Up: xmlparsersexpat

8.5.3 例
--------

以下のプログラムでは、与えられた引数を出力するだけの三つのハンドラを
定義しています。

     import xml.parsers.expat

     # 3 handler functions
     def start_element(name, attrs):
         print 'Start element:', name, attrs
     def end_element(name):
         print 'End element:', name
     def char_data(data):
         print 'Character data:', repr(data)

     p = xml.parsers.expat.ParserCreate()

     p.StartElementHandler = start_element
     p.EndElementHandler = end_element
     p.CharacterDataHandler = char_data

     p.Parse("""<?xml version="1.0"?>
     <parent id="top"><child1 name="paul">Text goes here</child1>
     <child2 name="fred">More text</child2>
     </parent>""")

このプログラムの出力は以下のようになります:

     Start element: parent {'id': 'top'}
     Start element: child1 {'name': 'paul'}
     Character data: 'Text goes here'
     End element: child1
     Character data: '\n'
     Start element: child2 {'name': 'fred'}
     Character data: 'More text'
     End element: child2
     Character data: '\n'
     End element: parent


File: python-lib-jp.info,  Node: 内容モデルの記述,  Next: Expat エラー定数,  Prev: 例 5,  Up: xmlparsersexpat

8.5.4 内容モデルの記述
----------------------

内容モデルは入れ子になったタプルを使って記述されています。 各タプルには
4 つの値: 型、限定詞 (quantifier)、名前、そして子の
タプル、が収められています。子のタプルは単に内容モデルを
記述したものです。

最初の二つのフィールドの値は `xml.parsers.expat' モジュールの `model'
オブジェクトで定義されている定数です。これらの定数は 二つのグループ:
モデル型 (model type) グループと限定子 (quantifier)
グループ、に取りまとめられます。

以下にモデル型グループにおける定数を示します:

`XML_CTYPE_ANY'
     モデル名で指定された要素は `ANY' の内容モデルを持つと
     宣言されます。

`XML_CTYPE_CHOICE'
     指定されたエレメントはいくつかのオプションから選択できるようになって
     います; `(A | B | C)' のような内容モデルで用いられます。

`XML_CTYPE_EMPTY'
     `EMPTY' であると宣言されている要素はこのモデル型を持ちます。

`XML_CTYPE_MIXED'

`XML_CTYPE_NAME'

`XML_CTYPE_SEQ'
     順々に続くようなモデルの系列を表すモデルがこのモデル型で表されます。
     `(A, B, C)' のようなモデルで用いられます。

限定子グループにおける定数を以下に示します:

`XML_CQUANT_NONE'
     修飾子 (modifier) が指定されていません。従って `A' のように、
     厳密に一つだけです。

`XML_CQUANT_OPT'
     このモデルはオプションです: `A?' のように、一つか全くないかです。

`XML_CQUANT_PLUS'
     このモデルは (`A+' のように) 一つかそれ以上あります。

`XML_CQUANT_REP'
     このモデルは `A*' のようにゼロ回以上あります。


File: python-lib-jp.info,  Node: Expat エラー定数,  Prev: 内容モデルの記述,  Up: xmlparsersexpat

8.5.5 Expat エラー定数
----------------------

以下の定数は `xml.parsers.expat' モジュールにおける `errors'
オブジェクトで提供されています。これらの定数は、
エラーが発生した際に送出される `ExpatError'
例外オブジェクトのいくつかの属性を解釈する上で便利です。

`errors' オブジェクトは以下の属性を持ちます:

`XML_ERROR_ASYNC_ENTITY'

`XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF'
     属性値中のエンティティ参照が、内部エンティティではなく外部エンティティ
     を参照しました。

`XML_ERROR_BAD_CHAR_REF'
     文字参照が、XML では正しくない (illegal) 文字を参照しました
     (例えば `0' や ``&#0;'')。

`XML_ERROR_BINARY_ENTITY_REF'
     エンティティ参照が、記法 (notation) つきで宣言されている
     エンティティを参照したため、解析できません。

`XML_ERROR_DUPLICATE_ATTRIBUTE'
     一つの属性が一つの開始タグ内に一度より多く使われています。

`XML_ERROR_INCORRECT_ENCODING'

`XML_ERROR_INVALID_TOKEN'
     入力されたバイトが文字に適切に関連付けできない際に送出されます;
     例えば、UTF-8 入力ストリームにおける NUL バイト (値 `0') などです。

`XML_ERROR_JUNK_AFTER_DOC_ELEMENT'
     空白以外の何かがドキュメント要素の後にあります。

`XML_ERROR_MISPLACED_XML_PI'
     入力データの先頭以外の場所に XML 定義が見つかりました。

`XML_ERROR_NO_ELEMENTS'
     このドキュメントには要素が入っていません (XML
     では全てのドキュメントは
     確実にトップレベルの要素を一つ持つよう要求しています)。

`XML_ERROR_NO_MEMORY'
     Expat が内部メモリを確保できませんでした。

`XML_ERROR_PARAM_ENTITY_REF'
     パラメタエンティティが許可されていない場所で見つかりました。

`XML_ERROR_PARTIAL_CHAR'
     入力に不完全な文字が見つかりました。

`XML_ERROR_RECURSIVE_ENTITY_REF'
     エンティティ参照中に、同じエンティティへの別の参照が入っていました;
     おそらく違う名前で参照しているか、間接的に参照しています。

`XML_ERROR_SYNTAX'
     何らかの仕様化されていない構文エラーに遭遇しました。

`XML_ERROR_TAG_MISMATCH'
     終了タグが最も内側で開かれている開始タグに一致しません。

`XML_ERROR_UNCLOSED_TOKEN'
     何らかの (開始タグのような) トークン が閉じられないまま、
     ストリームの終端や次のトークンに遭遇しました。

`XML_ERROR_UNDEFINED_ENTITY'
     定義されていないエンティティへの参照が行われました。

`XML_ERROR_UNKNOWN_ENCODING'
     ドキュメントのエンコードが Expat でサポートされていません。

`XML_ERROR_UNCLOSED_CDATA_SECTION'
     CDATAセクションが閉じられていません。

`XML_ERROR_EXTERNAL_ENTITY_HANDLING'

`XML_ERROR_NOT_STANDALONE'
     XML文書が"standalone"だと宣言されており `NotStandaloneHandler'
     が設定され `0'が
     返されているにもかかわらず、パーサは"standalone"では
     ないと判別しました。

`XML_ERROR_UNEXPECTED_STATE'

`XML_ERROR_ENTITY_DECLARED_IN_PE'

`XML_ERROR_FEATURE_REQUIRES_XML_DTD'
     その操作を完了するにはDTDのサポートが必要ですが、ExpatがDTDの
     サポートをしない設定になっています。これは `xml.parsers.expat'
     モジュールの標準的なビルドでは報告されません。

`XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING'
     パースが始まったあとで動作の変更が要求されました。これはパースが
     開始される前にのみ変更可能です。（現在のところ） `UseForeignDTD()'
     によってのみ送出されます。

`XML_ERROR_UNBOUND_PREFIX'
     名前空間の処理を有効すると宣言されていないプレフィックスが見つかります。

`XML_ERROR_UNDECLARING_PREFIX'
     XML文書はプレフィックスに対応した名前空間宣言を削除しようとしました。

`XML_ERROR_INCOMPLETE_PE'
     パラメータエンティティは不完全なマークアップを含んでいます。

`XML_ERROR_XML_DECL'
     XML文書中に要素がありません。

`XML_ERROR_TEXT_DECL'
     外部エンティティ中のテキスト宣言にエラーがあります。

`XML_ERROR_PUBLICID'
     パブリックID中に許可されていない文字があります。

`XML_ERROR_SUSPENDED'
     要求された操作は一時停止されたパーサで行われていますが、
     許可されていない操作です。このエラーは追加の入力を
     行なおうとしている場合、もしくはパーサが停止しようと
     している場合にも送出されます。

`XML_ERROR_NOT_SUSPENDED'
     パーサを一時停止しようとしましたが、停止されませんでした。

`XML_ERROR_ABORTED'
     Pythonアプリケーションには通知されません。

`XML_ERROR_FINISHED'
     要求された操作で、パース対象となる入力が完了したと判断
     しましたが、入力は受理されませんでした。このエラーは
     追加の入力を行なおうとしている場合、もしくはパーサが
     停止しようとしている場合に送出されます。

`XML_ERROR_SUSPEND_PE'


File: python-lib-jp.info,  Node: xmldom,  Next: xmldomminidom,  Prev: xmlparsersexpat,  Up: 構造化マークアップツール

8.6 文書オブジェクトモデル (DOM) API
====================================

Python のための文書オブジェクトモデル API。

_Added in Python version 2.0_

文書オブジェクトモデル、または "DOM" は、ワールドワイドウェブ
コンソーシアム (World Wide Web Consortium, W3C) による、XML
ドキュメントにアクセスしたり変更を加えたりするための、プログラミング
言語間共通の API です。DOM 実装によって、XML ドキュメントは
ツリー構造として表現されます。また、クライアントコード側で
ツリー構造をゼロから構築できるようになります。さらに、
前述の構造に対して、よく知られたインタフェースをもつ一連の
オブジェクトを通したアクセス手段も提供します。

DOM はランダムアクセスを行うアプリケーションで非常に有用です。 SAX
では、一度に閲覧することができるのはドキュメントのほんの
一部分です。ある SAX 要素に注目している際には、別の要素をアクセス
することはできません。またテキストノードに注目しているときには、
その中に入っている要素をアクセスすることができません。 SAX
によるアプリケーションを書くときには、プログラムがドキュメント内の
どこを処理しているのかを追跡するよう、コードのどこかに記述する
必要があります。SAX 自体がその作業を行ってくれることはありません。
さらに、XML ドキュメントに対する先読み (look ahead) が必要だと
すると不運なことになります。

アプリケーションによっては、ツリーにアクセスできなければ
イベント駆動モデルを実現できません。もちろん、何らかのツリーを SAX
イベントに応じて自分で構築することもできるでしょうが、 DOM
ではそのようなコードを書かなくてもよくなります。 DOM は XML
データに対する標準的なツリー表現なのです。

文書オブジェクトモデルは、W3C によっていくつかの段階、W3C の用語で
言えば "レベル (level)" で定義されています。 Python においては、 DOM
API への対応付け は実質的には DOM レベル~2 勧告に基づいています。
現在はドラフト形式でのみ入手できる レベル~3 仕様への対応付けは、 Python
XML 分科会 (Special Interest Group) により、 PyXML パッケージ
の一部として 開発中です。 DOM レベル~3
サポートの現在の状態についての情報は、 PyXML
パッケージに同梱されているドキュメントを参照してください。

DOM アプリケーションは、普通は XML を DOM に解析するところから始まり
ます。どのようにして解析を行うかについては DOM レベル~1 では全く
カバーしておらず、レベル~2 では限定的な改良だけが行われました: レベル~2
では`Document' を生成するメソッドを提供する `DOMImplementation'
オブジェクトクラスがありますが、 実装に依存しない方法で XML
リーダ(reader)/パーザ(parser)/文書ビルダ (Document builder)
にアクセスする方法はありません。また、既存の `Document'
オブジェクトなしにこれらのメソッドにアクセスする
ような、よく定義された方法もありません。 Python では、各々の DOM 実装で
`getDOMImplementation()' が定義されているはずです。 DOM レベル~3
ではロード(Load)/ストア(Store) 仕様が追加され、リーダの
インタフェースにを定義していますが、Python 標準ライブラリではまだ
利用することができません。

DOM 文書オブジェクトを生成したら、そのプロパティとメソッドを使って XML
文書の一部にアクセスできます。これらのプロパティは DOM
仕様で定義されています; 本リファレンスマニュアルでは、 Python において
DOM 仕様がどのように解釈されているかを記述しています。

W3C から提供されている仕様は、 DOM API を Java、ECMAScript、および OMG
IDL で定義しています。ここで定義されている Python での対応づけは、
大部分がこの仕様の IDL 版に基づいていますが、厳密な準拠は必要と
されていません (実装で IDL の厳密な対応付けをサポートするのは自由
ですが)。API への対応付けに関する詳細な議論は *Note 適合性:: 、
"適合性" を参照してください。

See also:
     `Document Object Model (DOM) Level~2 Specification' {Python DOM
     API が準拠している W3C 勧告。} `Document Object Model (DOM)
     Level~1 Specification' {`xml.dom.minidom' でサポートされている W3C
     の DOM に関する勧告。} `PyXML'{完全な機能をもった DOM
     実装を必要とするユーザは PyXML パッケージを利用すべきです。}
     `Python Language Mapping Specification' {このドキュメントでは OMG
     IDL から Python への対応付けを 記述しています。}

* Menu:

* モジュールの内容::
* DOM 内のオブジェクト::
* 適合性::


File: python-lib-jp.info,  Node: モジュールの内容,  Next: DOM 内のオブジェクト,  Prev: xmldom,  Up: xmldom

8.6.1 モジュールの内容
----------------------

`xml.dom' には、以下の関数が収められています:

`registerDOMImplementation(name, factory)'
     ファクトリ関数 (factory function) FACTORY を名前 NAME で
     登録します。ファクトリ関数は `DOMImplementation' インタフェース
     を実装するオブジェクトを返さなければなりません。ファクトリ関数は
     毎回同じオブジェクトを返すこともでき、呼び出されるたびに、特定の実装
     (例えば実装が何らかのカスタマイズをサポートしている場合) における、
     適切な新たなオブジェクトを返すこともできます。

`getDOMImplementation([name[, features]])'
     適切な DOM 実装を返します NAME は、よく知られた DOM 実装の
     モジュール名か、`None' になります。`None' でない場合、
     対応するモジュールを import して、import が成功した場合
     `DOMImplementation' オブジェクトを返します。NAME が与えられ
     ておらず、環境変数 `PYTHON_DOM' が設定されていた場合、 DOM
     実装を見つけるのに環境変数が使われます。

     NAME が与えられない場合、 利用可能な実装を調べて、 指定された機能
     (feature) セットを持つものを探します。 実装が見つからなければ
     `ImportError' を送出します。 FEATURES のリストは `(FEATURE,
     VERSION)' の ペアからなるシーケンスで、利用可能な
     `DOMImplementation' オブジェクト の `hasFeature()'
     メソッドに渡されます。

いくつかの便利な定数も提供されています:

`EMPTY_NAMESPACE'
     DOM 内のノードに名前空間が何も関連づけられていないことを示すために
     使われる値です。この値は通常、ノードの `namespaceURI' の値
     として見つかったり、名前空間特有のメソッドに対する NAMESPACEURI
     パラメタとして使われます。 _Added in Python version 2.2_

`XML_NAMESPACE'
     (4 節) で定義されている、予約済みプレフィクス (reserved prefix)
     `xml' に関連付けられた名前空間 URI です。 _Added in Python version
     2.2_

`XMLNS_NAMESPACE'
     (1.1.8 節) で定義されている、名前空間宣言への名前空間 URI です。
     _Added in Python version 2.2_

`XHTML_NAMESPACE'
     (3.1.1 節) で定義されている、XHTML 名前空間 URI です。 _Added in
     Python version 2.2_

加えて、 `xml.dom' には基底となる `Node' クラスと DOM
例外クラスが収められています。このモジュールで提供されている `Node'
クラスは DOM 仕様で定義されているメソッドや属性は 何ら実装していません;
これらは具体的な DOM 実装において提供
しなければなりません。このモジュールの一部として提供されている `Node'
クラスでは、具体的な `Node' オブジェクトの `nodeType'
属性として使う定数を提供しています; これらの 定数は、DOM
仕様に適合するため、クラスではなくモジュールのレベルに
配置されています。


File: python-lib-jp.info,  Node: DOM 内のオブジェクト,  Next: 適合性,  Prev: モジュールの内容,  Up: xmldom

8.6.2 DOM 内のオブジェクト
--------------------------

DOM について最も明確に限定しているドキュメントは W3C による DOM
仕様です。

DOM 属性は単純な文字列としてだけではなく、ノードとして操作される
かもしれないので注意してください。とはいえ、そうしなければならない
場合はかなり稀なので、今のところ記述されていません。

インタフェース           節                       目的
------                   -----                    -----
DOMImplementation        *Note DOMImplementation  根底にある実装へのインタフェース。
                         オブジェクト::           
Node                     *Note Node               ドキュメント内の大部分のオブジェクトのに対する基底インタフェース。
                         オブジェクト::           
NodeList                 *Note NodeList           ノードの列に対するインタフェース。
                         オブジェクト::           
DocumentType             *Note DocumentType       ドキュメントを処理するために必要な宣言についての情報。
                         オブジェクト::           
Document                 *Note Document           ドキュメント全体を表現するオブジェクト。
                         オブジェクト::           
Element                  *Note Element            ドキュメント階層内の要素ノード。
                         オブジェクト::           
Attr                     *Note Attr               階層ノード上の属性値。
                         オブジェクト::           
Comment                  *Note Comment            ソースドキュメント内のコメント表現。
                         オブジェクト::           
Text                     *Note Text               ドキュメント内のテキスト記述を含むノード。
                         オブジェクトおよび       
                         CDATASection             
                         オブジェクト::           
ProcessingInstruction    *Note                    処理命令 (processing
                         ProcessingInstruction    instruction) 表現。
                         オブジェクト::           

さらに追加の節として、 Python で DOM を利用するために定義されている
例外について記述しています。

* Menu:

* DOMImplementation オブジェクト::
* Node オブジェクト::
* NodeList オブジェクト::
* DocumentType オブジェクト::
* Document オブジェクト::
* Element オブジェクト::
* Attr オブジェクト::
* NamedNodeMap Objects::
* Comment オブジェクト::
* Text オブジェクトおよび CDATASection オブジェクト::
* ProcessingInstruction オブジェクト::
* 例外 2::


File: python-lib-jp.info,  Node: DOMImplementation オブジェクト,  Next: Node オブジェクト,  Prev: DOM 内のオブジェクト,  Up: DOM 内のオブジェクト

8.6.2.1 DOMImplementation オブジェクト
......................................

`DOMImplementation' インタフェースは、利用している DOM 実装
において特定の機能が利用可能かどうかを決定するための方法を
アプリケーションに提供します。DOM レベル~2 では、 `DOMImplementation'
を使って新たな`Document' オブジェクト や `DocumentType'
オブジェクトを生成する機能も追加しています。

`hasFeature(feature, version)'
     機能名FEATUREとバージョン番号VERSIONで
     識別される機能（feature）が実装されていればtrueを返します。

`createDocument(namespaceUri, qualifiedName, doctype)'
     新たな(DOMのスーパークラスである)`Document'クラスのオブジェクトを返します。
     このクラスはNAMESPACEURIとQUALIFIEDNAMEが設定された子クラス`Element'の
     オブジェクトを所有しています。 DOCTYPEは
     `createDocumentType()'によって生成された
     `DocumentType'クラスのオブジェクト、
     または`None'である必要があります。 Python DOM
     APIでは、子クラスである`Element'を作成しないことを
     示すために、はじめの２つの引数を`None'に設定することができます。

`createDocumentType(qualifiedName, publicId, systemId)'
     新たな`DocumentType'クラスのオブジェクトを返します。
     このオブジェクトはQUALIFIEDNAME、PUBLICID、そして
     SYSTEMID文字列をふくんでおり、XML文書の形式情報を表現しています。


File: python-lib-jp.info,  Node: Node オブジェクト,  Next: NodeList オブジェクト,  Prev: DOMImplementation オブジェクト,  Up: DOM 内のオブジェクト

8.6.2.2 Node オブジェクト
.........................

XML 文書の全ての構成要素は `Node' のサブクラスです。

`nodeType'
     ノード (node) の型を表現する整数値です。型に対応する以下の
     シンボル定数: `ELEMENT_NODE' 、 `ATTRIBUTE_NODE' 、 `TEXT_NODE' 、
     `CDATA_SECTION_NODE' 、 `ENTITY_NODE' 、
     `PROCESSING_INSTRUCTION_NODE' 、 `COMMENT_NODE' 、 `DOCUMENT_NODE'
     、 `DOCUMENT_TYPE_NODE' 、 `NOTATION_NODE' 、 が `Node'
     オブジェクトで定義されています。 読み出し専用の属性です。

`parentNode'
     現在のノードの親ノードか、文書ノードの場合には `None'
     になります。この値は常に `Node' オブジェクトか `None'
     になります。`Element' ノードの場合、この値はルート要素 (root
     element) の場合を除き親要素 (parent element) となり、
     ルート要素の場合には `Document' オブジェクトとなります。 `Attr'
     ノードの場合、この値は常に `None' となります。
     読み出し専用の属性です。

`attributes'
     属性オブジェクトの `NamedNodeMap' です。要素だけがこの属性に
     実際の値を持ちます; その他のオブジェクトでは、この属性を `None'
     にします。 読み出し専用の属性です。

`previousSibling'
     このノードと同じ親ノードを持ち、直前にくるノードです。例えば、
     SELF 要素のの開始タグの直前にくる終了タグを持つ要素です。
     もちろん、XML 文書は要素だけで構成されているだけではないので、
     直前にくる兄弟関係にある要素 (sibling) はテキストやコメント、
     その他になる可能性があります。このノードが親ノードにおける
     先頭の子ノードである場合、属性値は `None' になります。
     読み出し専用の属性です。

`nextSibling'
     このノードと同じ親ノードを持ち、直後にくるノードです。例えば、
     `previousSibling' も参照してください。
     このノードが親ノードにおける末尾頭の子ノードである場合、 属性値は
     `None' になります。 読み出し専用の属性です。

`childNodes'
     このノード内に収められているノードからなるリストです。
     読み出し専用の属性です。

`firstChild'
     このノードに子ノードがある場合、その先頭のノードです。
     そうでない場合 `None' になります。 読み出し専用の属性です。

`lastChild'
     このノードに子ノードがある場合、その末尾のノードです。
     そうでない場合 `None' になります。 読み出し専用の属性です。

`localName'
     `tagName' にコロンがあれば、コロン以降の部分に、なければ `tagName'
     全体になります。値は文字列です。

`prefix'
     `tagName' のコロンがあれば、コロン以前の部分に、なければ
     空文字列になります。値は文字列か、`None' になります。

`namespaceURI'
     要素名に関連付けられた名前空間です。文字列か `None' に
     なります。読み出し専用の属性です。

`nodeName'
     この属性はノード型ごとに異なる意味を持ちます; 詳しくは DOM 仕様を
     参照してください。この属性で得られることになる情報は、全てのノード
     型では `tagName' 、属性では `name' プロパティといった
     ように、常に他のプロパティで得ることができます。全てのノード型で、
     この属性の値は文字列か `None' になります。 読み出し専用の属性です。

`nodeValue'
     この属性はノード型ごとに異なる意味を持ちます; 詳しくは DOM 仕様を
     参照してください。その序今日は `nodeName' と似ています。
     この属性の値は文字列か `None' になります。

`hasAttributes()'
     ノードが何らかの属性を持っている場合に真を返します。

`hasChildNodes()'
     ノードが何らかの子ノードを持っている場合に真を返します。

`isSameNode(other)'
     OTHER がこのノードと同じノードを参照している場合に真を返します。
     このメソッドは、何らかのプロキシ (proxy) 機構を利用するような DOM
     実装で特に便利です (一つ以上のオブジェクトが同じノードを参照
     するかもしれないからです)。

     _Notice:_ このメソッドは DOM レベル~3 API で提案されており、まだ
     "ワーキングドラフト(working draft)" の段階です。しかし、
     このインタフェースだけは議論にはならないと考えられます。 W3C
     による変更は必ずしも Python DOM インタフェースにおける
     このメソッドに影響するとは限りません (ただしこのメソッドに
     対する何らかの新たな W3C API もサポートされるかもしれません)。


`appendChild(newChild)'
     現在のノードの子ノードリストの末尾に新たな子ノードを追加し、
     NEWCHILD を返します。

`insertBefore(newChild, refChild)'
     新たな子ノードを既存の子ノードの前に挿入します。REFCHILD
     は現在のノードの子ノードである場合に限られます; そうでない場合、
     `ValueError' が送出されます。 NEWCHILD が返されます。
     もしREFCHILDが`None'なら、NEWCHILDを子ノードリストの
     最後に挿入します。

`removeChild(oldChild)'
     子ノードを削除します。OLDCHILD はこのノードの子ノードでなければ
     なりません。そうでない場合、`ValueError' が送出されます。
     成功した場合 OLDCHILD が返されます。 OLDCHILD
     をそれ以降使わない場合、`unlink()' メソッドを
     呼び出さなければなりません。

`replaceChild(newChild, oldChild)'
     既存のノードと新たなノードを置き換えます。この操作は OLDCHILD
     が現在のノードの子ノードである場合に限られます; そうでない場合、
     `ValueError' が送出されます。

`normalize()'
     一続きのテキスト全体を一個の `Text' インスタンスとして保存する
     ために隣接するテキストノードを結合します。これにより、多くの
     アプリケーションで DOM ツリーからのテキスト処理が簡単になります。
     _Added in Python version 2.1_

`cloneNode(deep)'
     このノードを複製 (clone) します。DEEP を設定すると、子ノードも
     同様に複製することを意味します。複製されたノードを返します。


File: python-lib-jp.info,  Node: NodeList オブジェクト,  Next: DocumentType オブジェクト,  Prev: Node オブジェクト,  Up: DOM 内のオブジェクト

8.6.2.3 NodeList オブジェクト
.............................

`NodeList'
は、ノードからなるシーケンスを表現します。これらのオブジェクト は DOM
コア勧告 (DOM Core recommendation) において、二通りに使われて います:
`Element' オブジェクトでは、子ノードのリストを提供するのに `NodeList'
を利用します。また、このインタフェースにおける `Node' の
`getElementsByTagName()' および `getElementsByTagNameNS()'
メソッドは、クエリに対する結果 を表現するのに`NodeList' を利用します。

DOM レベル~2 勧告では、これらのオブジェクトに対し、メソッドと属性を
一つづつ定義しています:

`item(i)'
     シーケンスに I
     番目の要素がある場合にはその要素を、そうでない場合には `None'
     を返します。I はゼロよりも小さくてはならず、
     シーケンスの長さ以上であってはなりません。

`length'
     シーケンス中のノードの数です。

この他に、Python の DOM インタフェースでは、`NodeList' オブジェクトを
Python のシーケンスとして使えるようにするサポートが
追加されていることが必要です。`NodeList' の実装では、全て `__len__()'
と `__getitem__()' をサポートしなければ なりません;
このサポートにより、`for' 文内で `NodeList'
にわたる繰り返しと、組み込み関数 `len()'
の適切なサポートができるようになります。

DOM 実装が文書の変更をサポートしている場合、`NodeList' の 実装でも
`__setitem__()' および `__delitem__()' メソッドを
サポートしなければなりません。


File: python-lib-jp.info,  Node: DocumentType オブジェクト,  Next: Document オブジェクト,  Prev: NodeList オブジェクト,  Up: DOM 内のオブジェクト

8.6.2.4 DocumentType オブジェクト
.................................

文書で宣言されている記法 (notation) やエンティティ (entity) に関する
(外部サブセット(external subset) がパーザから利用でき、情報
を提供できる場合にはそれも含めた) 情報は、 `DocumentType'
オブジェクトから手に入れることができます。文書の `DocumentType'
は、`Document' オブジェクトの `doctype' 属性で入手することが できます;
文書の `DOCTYPE' 宣言がない場合、文書の `doctype'
属性は、このインタフェースを持つインスタンスの代わりに `None'
に設定されます。

`DocumentType' は `Node' を特殊化したもので、以下の 属性を加えています:

`publicId'
     文書型定義 (document type definition) の外部サブセットに対する
     公開識別子 (public identifier) です。文字列または `None'
     になります。

`systemId'
     文書型定義 (document type definition) の外部サブセットに対する
     システム識別子 (system identifier) です。文字列の URI または
     `None' になります。

`internalSubset'
     ドキュメントの完全な内部サブセットを与える文字列です。
     サブセットを囲むブラケットは含みません。ドキュメントが内部サブセット
     を持たない場合、この値は `None' です。

`name'
     `DOCTYPE' 宣言でルート要素の名前が与えられている場合、その
     値になります。

`entities'
     外部エンティティの定義を与える `NamedNodeMap' です。
     複数回定義されているエンティティに対しては、最初の定義だけが
     提供されます (その他は XML 勧告での要求仕様によって無視されます)。
     パーザによって情報が提供されないか、エンティティが定義されていない
     場合には、この値は `None' になることがあります。

`notations'
     記法の定義を与える `NamedNodeMap' です。
     複数回定義されている記法名に対しては、最初の定義だけが
     提供されます (その他は XML 勧告での要求仕様によって無視されます)。
     パーザによって情報が提供されないか、エンティティが定義されていない
     場合には、この値は `None' になることがあります。


File: python-lib-jp.info,  Node: Document オブジェクト,  Next: Element オブジェクト,  Prev: DocumentType オブジェクト,  Up: DOM 内のオブジェクト

8.6.2.5 Document オブジェクト
.............................

`Document' は XML ドキュメント全体を表現し、その構成要素
である要素、属性、処理命令、コメント等が入っています。 `Document' は
`Node' からプロパティを継承していることを 思い出してください。

`documentElement'
     ドキュメントの唯一無二のルート要素です。

`createElement(tagName)'
     新たな要素ノードを生成して返します。要素は、生成された時点では
     ドキュメント内に挿入されません。`insertBefore()' や
     `appendChild()' のような他のメソッドの一つを使って
     明示的に挿入を行う必要があります。

`createElementNS(namespaceURI, tagName)'
     名前空間を伴う新たな要素ノードを生成して返します。TAGNAME
     にはプレフィクス (prefix)
     があってもかまいません。要素は、生成された
     時点では文書内に挿入されません。`insertBefore()' や
     `appendChild()' のような他のメソッドの一つを使って
     明示的に挿入を行う必要があります。 `appendChild()'.

`createTextNode(data)'
     パラメタで渡されたデータの入ったテキストノードを生成して返します。
     他の生成 (create) メソッドと同じく、このメソッドは生成された
     ノードをツリーに挿入しません。

`createComment(data)'
     パラメタで渡されたデータの入ったコメントノードを生成して返します。
     他の生成 (create) メソッドと同じく、このメソッドは生成された
     ノードをツリーに挿入しません。

`createProcessingInstruction(target, data)'
     パラメタで渡された TARGET および DATA の入った処理命令
     ノードを生成して返します。他の生成 (create) メソッドと同じく、
     このメソッドは生成されたノードをツリーに挿入しません。

`createAttribute(name)'
     属性ノードを生成して返します。このメソッドは属性ノードを特定の
     要素に関連づけることはしません。新たに生成された属性インスタンス
     を使うには、適切な `Element' オブジェクトの `setAttributeNode()'
     を使わなければなりません。

`createAttributeNS(namespaceURI, qualifiedName)'
     名前空間を伴う新たな属性ノードを生成して返します。TAGNAME
     にはプレフィクス (prefix) があってもかまいません。
     このメソッドは属性ノードを特定の要素に関連づけることはしません。
     新たに生成された属性インスタンスを使うには、適切な `Element'
     オブジェクトの `setAttributeNode()' を使わなければなりません。

`getElementsByTagName(tagName)'
     全ての下位要素 (直接の子要素、子要素の子要素、等) から、特定の
     要素型名を持つものを検索します。

`getElementsByTagNameNS(namespaceURI, localName)'
     全ての下位要素 (直接の子要素、子要素の子要素、等) から、特定の
     名前空間 URI とローカル名 (local name) を持つものを検索します。
     ローカル名は名前空間におけるプレフィクス以降の部分です。


File: python-lib-jp.info,  Node: Element オブジェクト,  Next: Attr オブジェクト,  Prev: Document オブジェクト,  Up: DOM 内のオブジェクト

8.6.2.6 Element オブジェクト
............................

`Element' は `Node' のサブクラスです。このため `Node'
クラスの全ての属性を継承します。

`tagName'
     要素型名です。名前空間使用の文書では、要素型名中にコロンが
     あるかもしれません。値は文字列です。

`getElementsByTagName(tagName)'
     `Document' クラス内における同名のメソッドと同じです。

`getElementsByTagNameNS(tagName)'
     `Document' クラス内における同名のメソッドと同じです。

`hasAttribute(name)'
     指定要素にNAMEで渡した名前の属性が存在していれば true を返します。

`hasAttributeNS(namespaceURI, localName)'
     指定要素にNAMESPACEURIとLOCALNAMEで指定した名前の属性が
     存在していれば true を返します。

`getAttribute(name)'
     NAMEで指定した属性の値を文字列として返します。
     もし、属性が存在しない、もしくは属性に値が設定されていない場合、
     空の文字列が返されます。

`getAttributeNode(attrname)'
     ATTRNAME で指定された属性の `Attr' ノードを返します。

`getAttributeNS(namespaceURI, localName)'
     NAMESPACEURIとLOCALNAMEによって指定した属性の値を
     文字列として返します。
     もし、属性が存在しない、もしくは属性に値が設定されていない場合、
     空の文字列が返されます。

`getAttributeNodeNS(namespaceURI, localName)'
     指定した NAMESPACEURI および LOCALNAME を持つ属性値を
     ノードとして返します。

`removeAttribute(name)'
     名前で指定された属性を削除します。該当する属性がなくても例外は送出
     されません。

`removeAttributeNode(oldAttr)'
     OLDATTR が属性リストにある場合、削除して返します。 OLDATTR
     が存在しない場合、`NotFoundErr' が送出されます。

`removeAttributeNS(namespaceURI, localName)'
     名前で指定された属性を削除します。このメソッドは QNAME では なく
     LOCALNAME を使うので注意してください。該当する
     属性がなくても例外は送出されません。

`setAttribute(name, value)'
     文字列を使って属性値を設定します。

`setAttributeNode(newAttr)'
     新たな属性ノードを要素に追加します。`name' 属性が
     既存の属性に一致した場合、必要に応じて属性を置き換えます。
     置換が生じると、古い属性ノードが返されます。 NEWATTR
     がすでに使われていれば、 `InuseAttributeErr' が送出されます。

`setAttributeNodeNS(newAttr)'
     新たな属性ノードを要素に追加します。`namespaceURI' および
     `localName' 属性が既存の属性に一致した場合、必要に応じて
     属性を置き換えます。置換が生じると、古い属性ノードが返されます。
     NEWATTR がすでに使われていれば、 `InuseAttributeErr'
     が送出されます。

`setAttributeNS(namespaceURI, qname, value)'
     指定された NAMESPACEURI および QNAME で与えられた属性
     の値を文字列で設定します。qname は属性の完全な名前であり、この点が
     上記のメソッドと違うので注意してください。


File: python-lib-jp.info,  Node: Attr オブジェクト,  Next: NamedNodeMap Objects,  Prev: Element オブジェクト,  Up: DOM 内のオブジェクト

8.6.2.7 Attr オブジェクト
.........................

`Attr' は `Node' を継承しており、全ての属性を受け継いで います。

`name'
     要素型名です。名前空間使用の文書では、要素型名中にコロンが
     あるかもしれません。

`localName'
     名前にコロンがあればコロン以降の部分に、なければ名前全体になります。

`prefix'
     名前にコロンがあればコロン以前の部分に、なければ空文字列になります。


File: python-lib-jp.info,  Node: NamedNodeMap Objects,  Next: Comment オブジェクト,  Prev: Attr オブジェクト,  Up: DOM 内のオブジェクト

8.6.2.8 NamedNodeMap Objects
............................

`NamedNodeMap' は `Node' を継承して _いません_ 。

`length'
     属性リストの長さです。

`item(index)'
     特定のインデクスを持つ属性を返します。属性の並び方は任意ですが、
     DOM 文書が生成されている間は一定になります。各要素は属性
     ノードです。属性値はノードの `value' 属性で取得してください。

このクラスをよりマップ型的な動作ができるようにする実験的なメソッド
もあります。そうしたメソッドを使うこともできますし、 `Element'
オブジェクトに対して、標準化された `getAttribute*()'
ファミリのメソッドを使うこともできます。


File: python-lib-jp.info,  Node: Comment オブジェクト,  Next: Text オブジェクトおよび CDATASection オブジェクト,  Prev: NamedNodeMap Objects,  Up: DOM 内のオブジェクト

8.6.2.9 Comment オブジェクト
............................

`Comment' は XML 文書中のコメントを表現します。 `Comment' は `Node'
のサブクラスですが、 子ノードを持つことはありません。

`data'
     文字列によるコメントの内容です。この属性には、コメントの先頭にある
     `<!-'`-' と末尾にある `-'`->' 間の全ての文字
     が入っていますが、`<!-'`-' と`-'`->' 自体は 含みません。


File: python-lib-jp.info,  Node: Text オブジェクトおよび CDATASection オブジェクト,  Next: ProcessingInstruction オブジェクト,  Prev: Comment オブジェクト,  Up: DOM 内のオブジェクト

8.6.2.10 Text オブジェクトおよび CDATASection オブジェクト
..........................................................

`Text' インタフェースは XML 文書内のテキストを表現します。 パーザおよび
DOM 実装が DOM の XML 拡張をサポートしている場合、 CDATA
でマークされた区域 (section) に入れられている部分テキスト は
`CDATASection' オブジェクトに記憶されます。
これら二つのインタフェースは同一のものですが、`nodeType'
属性が異なります。

これらのインタフェースは `Node' インタフェースを拡張したもの
です。しかし子ノードを持つことはできません。

`data'
     文字列によるテキストノードの内容です。

_Notice:_ `CDATASection' ノードの利用は、ノードが完全な CDATA マーク区域
を表現するという意味ではなく、ノードの内容が CDATA 区域の一部である
ということを意味するだけです。 単一の CDATA
セクションは文書ツリー内で複数のノードとして表現
されることがあります。二つの隣接する `CDATASection' ノードが、異なる
CDATA マーク区域かどうかを決定する方法はありません。


File: python-lib-jp.info,  Node: ProcessingInstruction オブジェクト,  Next: 例外 2,  Prev: Text オブジェクトおよび CDATASection オブジェクト,  Up: DOM 内のオブジェクト

8.6.2.11 ProcessingInstruction オブジェクト
...........................................

XML 文書内の処理命令を表現します; `Node' インタフェース
を継承していますが、子ノードを持つことはできません。

`target'
     最初の空白文字までの処理命令の内容です。 読み出し専用の属性です。

`data'
     最初の空白文字以降の処理命令の内容です。


File: python-lib-jp.info,  Node: 例外 2,  Prev: ProcessingInstruction オブジェクト,  Up: DOM 内のオブジェクト

8.6.2.12 例外
.............

_Added in Python version 2.1_

DOM レベル~2 勧告では、単一の例外 `DOMException' と、
どの種のエラーが発生したかをアプリケーションが決定できるようにする
多くの定数を定義しています。 `DOMException'
インスタンスは、特定の例外に関する 適切な値を提供する `code'
属性を伴っています。

Python DOM インタフェースでは、上記の定数を提供していますが、
同時に一連の例外を拡張して、DOM で定義されている各例外コードに対して
特定の例外が存在するようにしています。 DOM
の実装では、適切な特定の例外を送出しなければならず、 各例外は `code'
属性に対応する適切な値を伴わなければ なりません。

`DOMException'
     全ての特定の DOM 例外で使われている基底例外クラスです。この例外
     クラスは直接インスタンス化することができません。

`DomstringSizeErr'
     指定された範囲のテキストが文字列に収まらない場合に送出されます。
     この例外は Python の DOM 実装で使われるかどうかは判っていませんが、
     Python で書かれていない DOM 実装から送出される場合があります。

`HierarchyRequestErr'
     挿入できない型のノードを挿入しようと試みたときに送出されます。

`IndexSizeErr'
     メソッドに与えたインデクスやサイズパラメタが負の値や許容範囲の
     値を超えた際に送出されます。

`InuseAttributeErr'
     文書中にすでに存在する `Attr' ノードを挿入しようと試みた
     際に送出されます。

`InvalidAccessErr'
     パラメタまたは操作が根底にあるオブジェクトでサポートされていない
     場合に送出されます。

`InvalidCharacterErr'
     この例外は、文字列パラメタが、現在使われているコンテキストで XML
     1.0 勧告によって許可されていない場合に送出されます。
     例えば、要素型に空白の入った `Element' ノードを生成
     しようとすると、このエラーが送出されます。

`InvalidModificationErr'
     ノードの型を変更しようと試みた際に送出されます。

`InvalidStateErr'
     定義されていないオブジェクトや、もはや利用できなくなったオブジェクトを
     使おうと試みた際に送出されます。

`NamespaceErr'
     に照らして許可されていない方法でオブジェクトを変更しようと
     試みた場合、この例外が送出されます。

`NotFoundErr'
     参照しているコンテキスト中に目的のノードが存在しない場合に送出される
     例外です。例えば、`NamedNodeMap.removeNamedItem()' は
     渡されたノードがノードマップ中に存在しない場合にこの例外を送出
     します。

`NotSupportedErr'
     要求された方のオブジェクトや操作が実装でサポートされていない場合に
     送出されます。

`NoDataAllowedErr'
     データ属性をサポートしないノードにデータを指定した際に送出されます。

`NoModificationAllowedErr'
     オブジェクトに対して (読み出し専用ノードに対する修正のように)
     許可されていない修正を行おうと試みた際に送出されます。

`SyntaxErr'
     無効または不正な文字列が指定された際に送出されます。

`WrongDocumentErr'
     ノードが現在属している文書と異なる文書に挿入され、
     かつある文書から別の文書へのノードの移行が実装でサポート
     されていない場合に送出されます。

DOM 勧告で定義されている例外コードは、以下のテーブルに従って
上記の例外と対応付けられます:

定数                                 例外
------                               -----
DOMSTRING_SIZE_ERR                   `DomstringSizeErr'
HIERARCHY_REQUEST_ERR                `HierarchyRequestErr'
INDEX_SIZE_ERR                       `IndexSizeErr'
INUSE_ATTRIBUTE_ERR                  `InuseAttributeErr'
INVALID_ACCESS_ERR                   `InvalidAccessErr'
INVALID_CHARACTER_ERR                `InvalidCharacterErr'
INVALID_MODIFICATION_ERR             `InvalidModificationErr'
INVALID_STATE_ERR                    `InvalidStateErr'
NAMESPACE_ERR                        `NamespaceErr'
NOT_FOUND_ERR                        `NotFoundErr'
NOT_SUPPORTED_ERR                    `NotSupportedErr'
NO_DATA_ALLOWED_ERR                  `NoDataAllowedErr'
NO_MODIFICATION_ALLOWED_ERR          `NoModificationAllowedErr'
SYNTAX_ERR                           `SyntaxErr'
WRONG_DOCUMENT_ERR                   `WrongDocumentErr'


File: python-lib-jp.info,  Node: 適合性,  Prev: DOM 内のオブジェクト,  Up: xmldom

8.6.3 適合性
------------

この節では適合性に関する要求と、Python DOM API、W3C DOM 勧告、 および
OMG IDL の Python API への対応付けとの間の関係について 述べます。

* Menu:

* 型の対応付け::
* アクセサメソッド::


File: python-lib-jp.info,  Node: 型の対応付け,  Next: アクセサメソッド,  Prev: 適合性,  Up: 適合性

8.6.3.1 型の対応付け
....................

DOM 仕様で使われている基本的な IDL 型は、以下のテーブルに従って Python
の型に対応付けられています。

IDL 型                               Python 型
------                               -----
boolean                              `IntegerType' (値 `0' または `1')
                                     による
int                                  `IntegerType'
long int                             `IntegerType'
unsigned int                         `IntegerType'

さらに、勧告で定義されている `DOMString' は、Python 文字列 または
Unicode 文字列に対応付けられます。アプリケーションでは、 DOM
から文字列が返される際には常に Unicode を扱えなければ なりません。

IDL の `null' 値は `None' に対応付けられており、 API で `null'
の使用が許されている場所では常に受理されるか、
あるいは実装によって提供されるはずです。


File: python-lib-jp.info,  Node: アクセサメソッド,  Prev: 型の対応付け,  Up: 適合性

8.6.3.2 アクセサメソッド
........................

OMG IDL から Python への対応付けは、 IDL `attribute'
宣言へのアクセサ関数の定義を、Java による対応付けが行うのと
ほとんど同じように行います。

IDL 宣言の対応付け

     readonly attribute string someValue;
              attribute string anotherValue;

は、三つのアクセサ関数: `someValue' に対する "get" メソッド
(`_get_someValue()')、そして`anotherValue' に対する "get" および "set"
メソッド (`_get_anotherValue()' および `_set_anotherValue()')
を生み出します。 とりわけ、対応付けでは、IDL 属性が通常の Python
属性としてアクセス 可能であることは必須ではありません:
`OBJECT.someValue' が 動作することは必須 _ではなく_ 、`AttributeError'
を送出してもかまいません。

しかしながら、Python DOM API では、通常の属性アクセスが動作することが
必須です。これは、Python IDL コンパイラによって生成された典型的な
サロゲーションはまず動作することはなく、DOM オブジェクトが CORBA
を解してアクセスされる場合には、クライアント上で
ラッパオブジェクトが必要であることを意味します。 CORBA DOM
クライアントでは他にもいくつか考慮すべきことがある一方で、 CORBA
を介して DOM を使った経験を持つ実装者はこのことを問題視して
いません。`readonly' であると宣言された属性は、全ての DOM
実装で書き込みアクセスを制限しているとは限りません。

Python DOM API
では、アクセサ関数は必須ではありません。アクセサ関数が提供された場合、
Python IDL 対応付けによって定義された形式をとらなければなりませんが、
属性は Python から直接アクセスすることができるので、それらのメソッドは
必須ではないと考えられます。`readonly' であると宣言された
属性に対しては、 "set" アクセサを提供してはなりません。

このIDLでの定義はW3C DOM
APIの全ての要件を実装しているわけではありません。
例えば、一部のオブジェクトの概念や
`getElementsByTagName()'が"live"であることなどです。 Python DOM API
はこれらの要件を実装することを強制しません。

