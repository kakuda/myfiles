これは python-ref-jp.info、python-ref-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-ref-jp.info,  Node: Top,  Next: 序,  Prev: (dir),  Up: (dir)

Python リファレンスマニュアル
*****************************

* Menu:

* 序::
* 導入::
* 字句解析::
* データモデル::
* 実行モデル::
* 式 expression::
* 単純文 simple statement::
* 複合文 compound statement::
* トップレベル要素::
* 歴史とライセンス::
* 日本語訳について::
* Module Index::
* Class-Exception-Object Index::
* Function-Method-Variable Index::
* Miscellaneous Index::


File: python-ref-jp.info,  Node: 序,  Next: 導入,  Prev: Top,  Up: Top

序
**

Copyright (C) 2001-2006 Python Software Foundation.  All rights
reserved.

Copyright (C) 2000 BeOpen.com.  All rights reserved.

Copyright (C) 1995-2000 Corporation for National Research Initiatives.
All rights reserved.

Copyright (C) 1991-1995 Stichting Mathematisch Centrum.  All rights
reserved.

Translation Copyright (C) 2003, 2004 Python Document Japanese
Translation Project. All rights reserved.

ライセンスおよび許諾に関する完全な情報は、このドキュメントの末尾を
参照してください。

     Python
     はインタプリタ形式の、オブジェクト指向な高レベルプログラミング
     言語で、動的なセマンティクスを持っています。Python
     の高レベルな組み込み
     データ構造は、動的な型付け機能や動的な結合機能と組み合わせることで、
     迅速なアプリケーション開発や既存のソフトウェアコンポーネント間をつなぐ
     スクリプト言語、または糊 (glue) 言語として Python を魅力的な存在に
     しています。Python は単純で学びやすい文法なので、可読性が高まり、
     プログラムのメンテナンスにかかるコストを低減します。 Python
     は、プログラムのモジュール化や再利用を助けるモジュールとパッケージ
     をサポートします。Python インタプリタと多数の標準ライブラリは、
     ほとんどのプラットフォームでソースコード形式でもバイナリ形式でも無料で
     入手することができ、無料で配布することができます。

     このリファレンスマニュアルでは、Python 言語の文法と、"コアとなる
     セマンティクス"
     について記述します。このマニュアルはそっけない書き方
     かもしれませんが、的確かつ完璧な記述を目指しています。
     必須でない組み込みオブジェクト型や組み込み関数、組み込みモジュール
     に関するセマンティクスは、  で述べられています。 形式ばらない
     Python 言語入門には、  を参照してください。 C 言語あるいは C++
     プログラマ向けには、このマニュアルとは別に二つの
     マニュアルがあります:

     では、Python
     拡張モジュールを書くための高レベルな様式について述べています。
     また、 では、C/C++
     プログラマが利用できるインタフェースについて詳細に 記述しています。



File: python-ref-jp.info,  Node: 導入,  Next: 字句解析,  Prev: 序,  Up: Top

1 導入
******

このリファレンスマニュアルは、Python プログラミング言語自体に関する
記述です。チュートリアルとして書かれたものではありません。

私は本マニュアルをできるだけ正確に書こうとする一方で、文法や
字句解析以外の全てについて、形式化された仕様記述ではなく英語を
使うことにしました。そうすることで、このドキュメントが平均的な
読者にとってより読みやすくなっているはずですが、ややあいまいな
部分も残っていることでしょう。
従って、もし読者のあなたが火星から来ている人で、このドキュメントだけ
から Python を再度実装しようとしているのなら、色々と推測しなければ
ならないことがあり、実際にはおそらく全く別の言語を実装する羽目に
なるでしょう。 逆に、あなたが Python を利用しており、Python
言語のある特定の領域に
おいて、厳密な規則が何か疑問に思った場合、その答えはこのドキュメント
で確実に見つけられることでしょう。

もしより形式化された言語定義をお望みなら、あなたの時間を提供して
いただいてかまいません -- もしくは、クローン生成装置でも発明して
ください :-) 。

実装に関する詳細を言語リファレンスのドキュメントに載せすぎるのは
危険なことです -- 実装は変更されるかもしれず、同じ言語でも異なる
実装は異なった動作をするかもしれないからです。一方、広く使われている
Python 実装は現在のところ唯一 (今や別の実装もいくつか存在しますが！)
なので、
特定のクセについては、特に実装によって何らかの制限が加えられている
場合には、触れておく価値があります。従って、このテキスト全体にわたって
短い "実装に関する注釈 (imprementation notes)" がちりばめられて います。

Python 実装はいずれも、数々の組み込みモジュールと標準モジュールが
付属します。これらはここではドキュメント化されていませんが、

でドキュメント化されています。いくつかの組み込みモジュールについて
は、言語定義と重要なかかわりをもっているときについて触れています。

* Menu:

* 別のPythonの実装::
* 本マニュアルにおける表記法::


File: python-ref-jp.info,  Node: 別のPythonの実装,  Next: 本マニュアルにおける表記法,  Prev: 導入,  Up: 導入

1.1 別のPythonの実装
====================

Pythonの実装としては，群を抜いて有名な実装がひとつ存在しています。
それ以外の実装に関しても、特定のユーザ間で興味が持たれています。

よく知られている実装には以下のものがあります:

   * CPython
     これは最も保守されている初代のPython実装で、C言語で書かれています。
     ほとんどの場合、言語の新機能がいち早く実装されます。

   * Jython
     Javaで実装されたPythonです。この実装はJavaアプリケーションのための
     スクリプト言語として，もしくはJavaクラスライブラリを使った
     アプリケーションを作成するために使用することができます。
     また、Javaライブラリのテストを作成するためにも
     しばしば使用されています。さらなる情報については the Jython website
     を参照してください。

   * Python for .NET この実装は内部ではCPythonを使用していますが、
     .NETアプリケーションによって管理されているので、
     .NETライブラリを参照することが可能です。 この実装はBrian
     Lloydによって作成されています。 さならる情報については、Python for
     .NET home page を参照してください。

   * IronPython .NETでPythonを使用するためのもう一つの実装です。
     Python.NETとは異なり、完全にILを生成することができるPythonの実装あり、
     直接Pythonコードを.NETアセンブリにコンパイルします。
     これはJythonの初代の開発者であるJim Huguninによって作られました。
     さらなる情報については the IronPython website を参照してください。

   * PyPy Python自体で書かれたPythonの実装です。つまり、
     バイトコードのインタプリタがPythonで書かれています。
     背後で動作するインタプリタとしてCPythonを使用することで、
     この実装を実行します。 このプロジェクトの一つの目的は、
     （それ自体がPythonで書かれたいますので、）
     その言語自体によってインタプリタを簡単に修正するための
     実験を後押しすることです。 さらなる情報は the PyPy project's home
     page にあります。

これらの各実装はこのマニュアルで文書化された言語とは多少異なっている、
もしくは、標準のPythonドキュメントと何処が異なっているかを定めた情報が
公開されているでしょう。
あなたが使用している実装上で、代替手段を使う必要があるかどうかを
判断するためには、各実装の仕様書を参照してください。


File: python-ref-jp.info,  Node: 本マニュアルにおける表記法,  Prev: 別のPythonの実装,  Up: 導入

1.2 本マニュアルにおける表記法
==============================

字句解析と構文に関する記述では、BNF 文法記法に手を加えたものを
使っています。この記法では、以下のような記述形式をとります: 

`name `lc_letter' (`lc_letter' | "_")*'

`lc_letter "a"..."z"'

最初の行は、`name' が `lc_letter' の後ろに ゼロ個または それ以上の
`lc_letter' とアンダースコアが続いたものであることを 示しています。
そして、`lc_letter' は `a' から `z' までの
何らかの文字一字であることを示します (この規則は、このドキュメントに
記述されている字句規則と構文規則において定義されている名前 (name) で
一貫して使われています)。

各規則は name (規則によって定義されているものの名前) と`::='から
始まります。垂直線 (`|') は、複数の選択項目を分かち書きするときに
使います; この記号は、この記法において最も結合優先度の低い演算子です。
アスタリスク (`*') は、直前にくる要素のゼロ個以上の繰り返しを 表します;
同様に、プラス (`+') は一個以上の繰り返しで、角括弧 (`[ ]')
に囲われた字句は、字句がゼロ個か一個出現する
(別の言い方をすれば、囲いの中の字句はオプションである) ことを示し
ます。`*' および `+' 演算子の結合範囲は可能な限り狭く なっています;
字句のグループ化には丸括弧を使います。
リテラル文字列はクオートで囲われます。空白はトークンを分割している
ときのみ意味を持ちます。規則は通常、一行中に収められています;
多数の選択肢のある規則は、最初の行につづいて、垂直線の後ろに
各々別の行として記述されます。

(上の例のような) 字句定義では、他に二つの慣習が使われています:
三つのドットで区切られている二つのリテラル文字は、二つの文字の ASCII
文字コードにおける (包含的な) 範囲から文字を一字選ぶ
ことを示します。各カッコ中の字句 (`<...>') は、定義済みの
シンボルを記述する非形式的なやりかたです; 例えば、 `制御文字'
を書き表す必要があるときなどに使われることがあります。 

字句と構文規則の定義の間で使われている表記はほとんど同じですが、
その意味には大きな違いがあります: 字句定義は入力ソース中の個々の
文字を取り扱いますが、構文定義は字句解析で生成された一連の
トークンを取り扱います。次節 ("字句解析") における BNF はすべて
字句定義のためのものです; それ以降の章では、構文定義のために
使っています。


File: python-ref-jp.info,  Node: 字句解析,  Next: データモデル,  Prev: 導入,  Up: Top

2 字句解析
**********

Python で書かれたプログラムは _パーザ (parser)_ に読み込まれます。
パーザへの入力は、_字句解析器 (lexical analyzer)_ によって生成
された一連の _トークン (token)_ からなります。この章では、字句解析器
がファイルをトークン列に分解する方法について解説します。 

Python は 7-bit の ASCII 文字セットをプログラムのテキストに 使います。
_Added in Python version 2.3_
以前のバージョンとの互換性のために、Python は 8-bit 文字が見つかっても
警告を出すだけにとどめます; こうした警告は、エンコーディングを明示
したり、バイナリデータの場合には文字ではなくエスケープシーケンス
を使うことで解決できます。

実行時の文字セットは、プログラムが接続されている I/O デバイスにもより
ますが、通常 ASCIIのサブセットです。

*将来のバージョンとの互換性に関する注意:* 8-bit
文字に対する文字セットを ISO Latin-1 (ラテン語系アルファベットを
用いるほとんどの西欧言語をカバーするASCII の上位セット) とみなし
たい気にもなるかもしれません。しかし、おそらく Unicode を編集できる
テキストエディタが将来一般的になるはずです。こうしたエディタでは
一般的に UTF-8 エンコードを使いますが、UTF-8 エンコードは ASCII
の上位セットではあるものの、文字序数 (ordinal) 128-255 の扱いが
非常に異なります。この問題に関してはまだ合意が得られていませんが、
Latin-1 と UTF-8 のどちらかとみなすのは、たとえ現在の実装が Latin-1
びいきのように思えたとしても賢明とはいえません。これはソースコード
文字セットと実行時の文字セットのどちらにも該当します。

* Menu:

* 行構造::
* その他のトークン::
* 識別子 identifier およびキーワード keyword::
* リテラル literal::
* 演算子 operator::
* デリミタ delimiter::


File: python-ref-jp.info,  Node: 行構造,  Next: その他のトークン,  Prev: 字句解析,  Up: 字句解析

2.1 行構造
==========

Python プログラムは多数の _論理行 (logical lines)_ に分割されます。 

* Menu:

* 論理行 logical line::
* 物理行 physical line::
* コメント::
* エンコード宣言 encoding declaration::
* 明示的な行継続::
* 非明示的な行継続::
* 空行::
* インデント::
* トークン間の空白::


File: python-ref-jp.info,  Node: 論理行 logical line,  Next: 物理行 physical line,  Prev: 行構造,  Up: 行構造

2.1.1 論理行 (logical line)
---------------------------

論理行の終端は、トークン NEWLINE で表されます。構文上許されている場合
(複合文: compound statement 中の実行文: statement) を除いて、実行文は
論理行間にまたがることはできません。 論理行は一行またはそれ以上の
_物理行(physical line)_ からなり、
物理行の末尾には明示的または非明示的な _行連結(line joining)_
規則が続きます。 


File: python-ref-jp.info,  Node: 物理行 physical line,  Next: コメント,  Prev: 論理行 logical line,  Up: 行構造

2.1.2 物理行 (physical line)
----------------------------

物理行とは、行終端コードで区切られた文字列のことです。
ソースコード内では、
各プラットフォームごとの標準の行終端コードを使用することができます。
UNIX形式ではASCII LF (行送り: linefeed)文字、 Windows形式ではASCII
配列の CR LF (復帰: return に続いて行送り) 、 Macintosh形式ではASCII CR
(復帰) 文字です。 これら全ての形式のコードは、
違うプラットフォームでも等しく使用することができます。

Pythonに埋め込む場合には、 標準のC言語の改行文字の変換規則 (ASCII
LFを表現した文字コード`\n'が行終端となります) に従って、 Python
APIにソースコードを渡す必要があります。


File: python-ref-jp.info,  Node: コメント,  Next: エンコード宣言 encoding declaration,  Prev: 物理行 physical line,  Up: 行構造

2.1.3 コメント
--------------

コメントは文字列リテラル内に入っていないハッシュ文字 (`#') から
始まり、同じ物理行の末端で終わります。非明示的な行継続規則が適用されて
いない限り、コメントは論理行を終端させます。
コメントは構文上無視されます; コメントはトークンになりません。 


File: python-ref-jp.info,  Node: エンコード宣言 encoding declaration,  Next: 明示的な行継続,  Prev: コメント,  Up: 行構造

2.1.4 エンコード宣言 (encoding declaration)
-------------------------------------------

Python スクリプト中の最初の行か、二行目にあるコメントが正規表現
"coding[=:]\s*([-\w.]+)" にマッチする場合、コメントは エンコード宣言
(encoding declaration) として処理されます;
表現に対する最初のマッチグループがソースコードファイルのエンコードを
指定します。エンコード宣言式として推奨する形式は、GNU Emacs が
認識できる形式

     # -*- coding: <encoding-name> -*-

または、Bram Moolenar による VIM が認識できる形式

     # vim:fileencoding=<encoding-name>

です。さらに、ファイルの先頭のバイト列が UTF-8 バイトオーダ記号
(`'\xef\xbb\xbf'') の場合、ファイルのエンコードは UTF-8
と宣言されているものとします (この機能は Microsoft の `notepad'
やその他のエディタでサポートされています)。

エンコードが宣言されている場合、Python はそのエンコード名を認識
できなければなりません。宣言されたエンコードは全ての字句解析、特に文字列の終端を検出する際や
Unicode リテラルの内容を翻訳する上で用いられます。
文字列リテラルは文法的な解析を行うために Unicode に変換され、
解釈が行われる前に元のエンコードに戻されます。エンコード宣言は
宣言全体が一行に収まっていなければなりません。


File: python-ref-jp.info,  Node: 明示的な行継続,  Next: 非明示的な行継続,  Prev: エンコード宣言 encoding declaration,  Up: 行構造

2.1.5 明示的な行継続
--------------------

二つまたはそれ以上の物理行を論理行としてつなげるためには、
バックスラッシュ文字 (`\') を使って以下のようにします:
物理行が文字列リテラルやコメント中の文字でないバックスラッシュで
終わっている場合、後続する行とつなげて一つの論理行を構成し、
バックスラッシュおよびバックスラッシュの後ろにある行末文字を
削除します。例えば: 
     if 1900 < year < 2100 and 1 <= month <= 12 \
        and 1 <= day <= 31 and 0 <= hour < 24 \
        and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
             return 1

となります。

バックスラッシュで終わる行にはコメントを入れることはできません。
また、バックスラッシュを使ってコメントを継続することはできません。
バックスラッシュが文字列リテラル中にある場合を除き、バックスラッシュの
後ろにトークンを継続することはできません (すなわち、物理行内の文字列
リテラル以外のトークンをバックスラッシュを使って分断することは
できません)。上記以外の場所では、文字列リテラル外にあるバックスラッシュ
はどこにあっても不正となります。


File: python-ref-jp.info,  Node: 非明示的な行継続,  Next: 空行,  Prev: 明示的な行継続,  Up: 行構造

2.1.6 非明示的な行継続
----------------------

丸括弧 (parentheses)、角括弧 (square bracket) 、および 波括弧 (curly
brace) 内の式は、バックスラッシュを使わずに
一行以上の物理行に分割することができます。 例えば:

     month_names = ['Januari', 'Februari', 'Maart',      # These are the
                    'April',   'Mei',      'Juni',       # Dutch names
                    'Juli',    'Augustus', 'September',  # for the months
                    'Oktober', 'November', 'December']   # of the year

非明示的に継続された行にはコメントを含めることができます。
継続行のインデントは重要ではありません。空の継続行を書くことが
できます。非明示的な継続行中には、NEWLINE トークンは存在しません。
非明示的な行の継続は、三重クオートされた文字列 (下記参照)
でも発生します; この場合には、コメントを含めることができません。


File: python-ref-jp.info,  Node: 空行,  Next: インデント,  Prev: 非明示的な行継続,  Up: 行構造

2.1.7 空行
----------

スペース、タブ、フォームフィード、およびコメントのみを含む論理行は
無視されます (すなわち、NEWLINE トークンは生成されません)。
文を対話的に入力している際には、空行の扱いは行読み込み-評価-出力
(read-eval-print) ループの実装によって異なるかもしれません。
標準的な実装では、完全な空行でできた論理行 (すなわち、空白文字も
コメントも全く含まない空行) は、複数行からなる実行文の終端を示します。


File: python-ref-jp.info,  Node: インデント,  Next: トークン間の空白,  Prev: 空行,  Up: 行構造

2.1.8 インデント
----------------

論理行の行頭にある、先頭の空白 (スペースおよびタブ) の連なりは、
その行のインデントレベルを計算するために使われます。インデントレベルは、
実行文のグループ化方法を決定するために用いられます。 

まず、タブは (左から右の方向に) 1 つから 8 つのスペースで置き換えられ、
置き換え後の文字列の終わりの位置までの文字数が 8 の倍数になるように
調整されます (UNIXで使われている規則と同じになるよう意図されています)。
次に、空白文字でない最初の文字までのスペースの総数から、その行の
インデントを決定します。バックスラッシュを使ってインデントを複数の
物理行に分割することはできません; 最初のバックスラッシュまでの空白が
インデントを決定します。

*プラットフォーム間の互換性に関する注意:* 非 UNIX
プラットフォームにおけるテキストエディタの性質上、一つの
ソースファイル内でタブとインデントを混在させて使うのは賢明では
ありません。また、プラットフォームによっては、最大インデントレベルを
明示的に制限しているかもしれません。

フォームフィード文字が行の先頭にあっても構いません; フォームフィード
文字は上のインデントレベル計算時には無視されます。フォームフィード
文字が先頭の空白中の他の場所にある場合、その影響は未定義です
(例えば、スペースの数を 0 にリセットするかもしれません)。

連続する行における各々のインデントレベルは、 INDENT および DEDENT
トークンを生成するために使われます。
トークンの生成はスタックを用いて以下のように行われます。 

ファイル中の最初の行を読み出す前に、スタックにゼロが一つ積まれ (push
され) ます; このゼロは決して除去 (pop) されることはありません。
スタックの先頭に積まれてゆく数字は、常にスタックの末尾から先頭にかけて
厳密に増加するようになっています。各論理行の開始位置において、
その行のインデントレベル値がスタックの先頭の値と比較されます。値が
等しければ何もしません。インデントレベル値がスタック上の値よりも
大きければ、インデントレベル値はスタックに積まれ、INDENT トークンが
一つ生成されます。インデントレベル値がスタック上の値よりも小さい場合、
その値はスタック内のいずれかの値と_等しくなければなりません_ ;
スタック上のインデントレベル値よりも大きい値はすべて除去され、
値が一つ除去されるごとに DEDENT トークンが一つ生成されます。ファイルの
末尾では、スタックに残っているゼロより大きい値は全て除去され、
値が一つ除去されるごとに DEDENT トークンが一つ生成されます。

以下の例に正しく (しかし当惑させるように) インデントされた Python
コードの一部を示します:

     def perm(l):
             # Compute the list of all permutations of l
         if len(l) <= 1:
                       return [l]
         r = []
         for i in range(len(l)):
                  s = l[:i] + l[i+1:]
                  p = perm(s)
                  for x in p:
                   r.append(l[i:i+1] + x)
         return r

以下の例は、様々なインデントエラーになります:

      def perm(l):                       # error: first line indented
     for i in range(len(l)):             # error: not indented
         s = l[:i] + l[i+1:]
             p = perm(l[:i] + l[i+1:])   # error: unexpected indent
             for x in p:
                     r.append(l[i:i+1] + x)
                 return r                # error: inconsistent dedent

(実際は、最初の 3 つのエラーはパーザによって検出されます; 最後の
エラーのみが字句解析器で見つかります -- `return r' の
インデントは、スタックから逐次除去されていくどのインデントレベル値とも
一致しません)


File: python-ref-jp.info,  Node: トークン間の空白,  Prev: インデント,  Up: 行構造

2.1.9 トークン間の空白
----------------------

論理行の先頭や文字列の内部にある場合を除き、空白文字であるスペース、
タブ、およびフォームフィードは、トークンを分割するために自由に
利用することができます。二つのトークンを並べて書くと別のトークンと
してみなされてしまうような場合には、トークンの間に空白が必要と なります
(例えば、ab は一つのトークンですが、 a b は二つのトークンと なります)。


File: python-ref-jp.info,  Node: その他のトークン,  Next: 識別子 identifier およびキーワード keyword,  Prev: 行構造,  Up: 字句解析

2.2 その他のトークン
====================

NEWLINE、INDENT、および DEDENT の他、以下のトークンのカテゴリ: _識別子
(identifier)_、_キーワード(keyword)_、_リテラル_、 _演算子 (operator)_
、_デリミタ (delimiter)_ が存在します。 空白文字
(上で述べた行終端文字以外) はトークンではありませんが、
トークンを区切る働きがあります。
トークンの解析にあいまいさが生じた場合、トークンは左から右に読んで
不正でないトークンを構築できる最長の文字列を含むように構築されます。


File: python-ref-jp.info,  Node: 識別子 identifier およびキーワード keyword,  Next: リテラル literal,  Prev: その他のトークン,  Up: 字句解析

2.3 識別子 (identifier) およびキーワード (keyword)
==================================================

識別子 (または _名前 (name)_) は、以下の字句定義で記述されます: 

`identifier (`letter'|"_") (`letter' | `digit' | "_")*'

`letter `lowercase' | `uppercase''

`lowercase "a"..."z"'

`uppercase "A"..."Z"'

`digit "0"..."9"'

識別子の長さには制限がありません。大小文字は区別されます。

* Menu:

* キーワード keyword::
* 予約済みの識別子種 reserved classes of identifiers::


File: python-ref-jp.info,  Node: キーワード keyword,  Next: 予約済みの識別子種 reserved classes of identifiers,  Prev: 識別子 identifier およびキーワード keyword,  Up: 識別子 identifier およびキーワード keyword

2.3.1 キーワード (keyword)
--------------------------

以下の識別子は、予約語、または Python 言語における _キーワード
(keyword)_ として使われ、通常の識別子として
使うことはできません。キーワードは厳密に下記の通りに綴らなければ
なりません: 

     and       del       from      not       while
     as        elif      global    or        with
     assert    else      if        pass      yield
     break     except    import    print
     class     exec      in        raise
     continue  finally   is        return
     def       for       lambda    try

_Changed in Python version 2.4_

_Changed in Python version 2.6_


File: python-ref-jp.info,  Node: 予約済みの識別子種 reserved classes of identifiers,  Prev: キーワード keyword,  Up: 識別子 identifier およびキーワード keyword

2.3.2 予約済みの識別子種 (reserved classes of identifiers)
----------------------------------------------------------

ある種の (キーワードを除く) 識別子には、特殊な意味があります。
これらの識別子種は、先頭や末尾にあるアンダースコア文字のパターンで
区別されます:

``_*''
     この識別子は `from MODULE import *' で import されません。
     対話インタプリタでは、最も最近行われた値評価の結果を記憶するために
     特殊な識別子 `_' が使われます; この識別子は `__builtin__'
     モジュール内に記憶されます。対話モードでない場合、`_' には
     特殊な意味はなく、定義されていません。~*Note import 文:: 節、
     "`import' 文" を参照してください。

     _Note:_ 名前 `_' は、しばしば国際化 (internationalization) と共に
     用いられます; この慣習についての詳しい情報は、 `gettext' module を
     参照してください。

``__*__''
     システムで定義された (system-defined) 名前です。これらの名前は
     インタプリタと (標準ライブラリを含む) 実装上で定義されています;
     アプリケーション側では、この名前規約を使って別の名前を定義しようと
     すべきではありません。この種の名前のうち、Python で定義されている
     名前のセットは、将来のバージョンで拡張される可能性があります。
     ~*Note 特殊メソッド名:: 節、"特殊なメソッド名" を参照してください。

``__*''
     クラスプライベート (class-private) な名前です。このカテゴリに属する
     名前は、クラス定義のコンテキスト上で用いられた場合、基底クラスと
     導出クラスの "プライベートな"
     属性間で名前衝突が起こるのを防ぐために 書き直されます。 ~*Note
     識別子 identifier、または名前 name:: 節、"識別子 (名前)"
     を参照してください。



File: python-ref-jp.info,  Node: リテラル literal,  Next: 演算子 operator,  Prev: 識別子 identifier およびキーワード keyword,  Up: 字句解析

2.4 リテラル (literal)
======================

リテラル (literal) とは、いくつかの組み込み型の定数を表記したものです。

* Menu:

* 文字列リテラル::
* 文字列リテラルの結合 concatenation::
* 数値リテラル::
* 整数および長整数リテラル::
* 浮動小数点数リテラル::
* 虚数 imaginary リテラル::


File: python-ref-jp.info,  Node: 文字列リテラル,  Next: 文字列リテラルの結合 concatenation,  Prev: リテラル literal,  Up: リテラル literal

2.4.1 文字列リテラル
--------------------

文字列リテラルは以下の字句定義で記述されます: 

`stringliteral [`stringprefix'](`shortstring' | `longstring')'

`stringprefix "r" | "u" | "ur" | "R" | "U" | "UR" | "Ur" | "uR"'

`shortstring "'" `shortstringitem'* "'" | '"' `shortstringitem'* '"''

`longstring "'''" `longstringitem'* "'''"'

` | '"""' `longstringitem'* '"""''

`shortstringitem `shortstringchar' | `escapeseq''

`longstringitem `longstringchar' | `escapeseq''

`shortstringchar <any source character except "\" or newline or the quote>'

`longstringchar <any source character except "\">'

`escapeseq "\" <any ASCII character>'

上記の生成規則で示されていない文法的な制限が一つあります。それは
文字列リテラルの `stringprefix' と残りの部分の間に
空白を入れてはならないということです。ソースコード文字セット (source
character set) はエンコード宣言で決まります．エンコード
宣言がない場合には ASCII になります．*Note エンコード宣言 encoding
declaration:: 節を 参照してください．

より平易な説明: 文字列リテラルは、対応する一重引用符 (`'') または
二重引用符 (`"') で囲われます。また、対応する三連の一重引用符
や二重引用符で囲うこともできます (通常、_三重クオート文字列:
triple-quoted string_ として 参照されます)。バックスラッシュ (`\')
文字を使って、
ある文字を例えば改行文字やバックスラッシュ自体、クオート文字といった
別の意味を持つようにエスケープすることができます。
文字列リテラルの前には、オプションとして `r' または `R'
一文字を接頭してもかまいません; このような文字列は "raw 文字列 (raw
string)" と呼ばれ、バックスラッシュによるエスケープシーケンスの
解釈規則が異なります。`u' や `U' を接頭すると、 文字列は Unicode 文字列
(Unicode string) になります。Unicode 文字列は Unicode
コンソーシアムおよび ISO~10646 で定義されている Unicode 文字セット
を使います。Unicode 文字列では、文字セットに加えて、以下で説明するような
エスケープシーケンスを利用できます。二つの接頭文字を組み合わせることも
できます; この場合、`u' は `r' より前に出現しなくては なりません。

三重クオート文字列中には、三連のエスケープされないクオート文字で
文字列を終端してしまわないかぎり、エスケープされていない改行やクオートを
書くことができます (さらに、それらはそのまま文字列中に残ります)。
(ここでいう "クオート" とは、文字列の囲みを開始するときに使った文字
を示し、`'' か `"' のいずれかです)。

`r' または `R' 接頭文字がつかないかぎり、
文字列中のエスケープシーケンスは標準 C で使われているのと同様の
法則にしたがって解釈されます。以下に Python で認識されるエスケープ
シーケンスを示します: 

エスケープシーケンス     意味                     備考
------                   -----                    -----
\NEWLINE                 無視                     
\\                       バックスラッシュ (`\')   
\'                       一重引用符 (`'')         
\"                       二重引用符 (`"')         
\a                       ASCII 端末ベル (BEL)     
\b                       ASCII バックスペース     
                         (BS)                     
\f                       ASCII フォームフィード   
                         (FF)                     
\n                       ASCII 行送り (LF)        
\N{NAME}                 Unicode                  
                         データベース中で名前     
                         NAME を持つ文字          
                         (Unicode のみ)           
\r                       ASCII 復帰 (CR)          
\t                       ASCII 水平タブ (TAB)     
\uXXXX                   16-bit の 16 進数値      (1)
                         XXXX を持つ文字          
                         (Unicode のみ)           
\UXXXXXXXX               32-bit の 16 進数値      (2)
                         XXXXXXXX を持つ文字      
                         (Unicode のみ)           
\v                       ASCII 水平タブ (VT)      
\OOO                     8 進数値 OOO を持つ文字  (3,5)
\xHH                     16 進数値 HH を持つ文字  (4,5)

備考:

   * (1)
     サロゲートペアの断片を形成する個々のコード単位は、このエスケープ
     シーケンスでエンコードすることができます。

   * (2) Unicode 文字はすべてこの方法でエンコードできますが、 Python が
     16-bit コード単位を扱うようにコンパイルされている
     (デフォルトの設定です) 場合、基本多言語面 (Basic Multilingual
     Plane, BMP) 外の文字はサロゲートペア (surrogate pair)
     を使ってエンコードする
     ことになります。サロゲートペアの断片を形成する個々のコード単位は
     このエスケープシーケンスを使ってエンコードすることができます。

   * (3) 標準 C と同じく、最大で 3 桁の 8 進数まで受理します。

   * (4) 標準 C とは違い、最大で 2 桁の 16 進数しか受理されません。

   * (5) 文字列リテラル中では， 16 進および 8 進エスケープはエスケープの
     示すバイト文字になります．そのバイト文字がソース文字セットで
     エンコードされている保証はありません．Unicode リテラル中では，
     エスケープ文字はエスケープ文字の表現する値を持つ Unicode 文字に
     なります．

標準の C とは違い、認識されなかったエスケープシーケンスはそのまま
文字列中に残されます。すなわち。
_バックスラッシュも文字列中に残ります。_ (この挙動はデバッグの
際に便利です: エスケープシーケンスを誤入力した場合、その結果として
出力に失敗しているのが用意にわかります) テーブル中で "(Unicode のみ)"
と書かれたエスケープシーケンスは、非 Unicode
文字列リテラル中では認識されないエスケープシーケンスのカテゴリに
分類されるので注意してください。

接頭文字 `r' または `R' がある場合、バックスラッシュ
の後にくる文字はそのまま文字列中に入り、_バックスラッシュは全て
文字列中に残されます_。例えば、文字列リテラル `r"\n"' は二つの文字:
バックスラッシュと小文字の `n' からなる文字列を表すことに
なります。引用符はバックスラッシュでエスケープすることができますが、
バックスラッシュ自体も残ってしまいます; 例えば、`r"\""' は不正でない
文字列リテラルで、バックスラッシュと二重引用符からなる文字列を表します;
`r"\"' は正しくない文字列リテラルです (raw 文字列を奇数個連なった
バックスラッシュで終わらせることはできません)。厳密にいえば、
(バックスラッシュが直後のクオート文字をエスケープしてしまうため) _raw
文字列を単一のバックスラッシュで終わらせることはできない_
ということになります。また、バックスラッシュの直後に改行がきても、
行継続を意味する_のではなく_ 、それら二つの文字として解釈されるので
注意してください。

`r' および `R' 接頭文字を `u' や `U'
と合わせて使った場合、`\uXXXX'および `\UXXXXXXXX'
エスケープシーケンスは処理されますが、 _その他のバックスラッシュは
すべて文字列中に残されます_ 。例えば、文字列リテラル `ur"\u0062\n"'
は、3つの Unicode 文字: `LATIN SMALL LETTER B' (ラテン小文字
B)、`REVERSE SOLIDUS' (逆向き斜線)、 および `LATIN SMALL LETTER N'
(ラテン小文字 N) を表します。
バックスラッシュの前にバックスラッシュをつけてエスケープすることは
できます; しかし、バックスラッシュは両方とも文字列中に残されます。
その結果、`\uXXXX' エスケープシーケンスは、バックスラッシュが
奇数個連なっている場合にのみ認識されます。


File: python-ref-jp.info,  Node: 文字列リテラルの結合 concatenation,  Next: 数値リテラル,  Prev: 文字列リテラル,  Up: リテラル literal

2.4.2 文字列リテラルの結合 (concatenation)
------------------------------------------

複数の文字列リテラルは、互いに異なる引用符を使っていても
(空白文字で区切って) 隣接させることができ、その意味は各々の文字列を
結合したものと同じになります。したがって、`"hello" 'world'' は
`"helloworld"' と同じになります。この機能を使うと、長い文字列を
分離して、複数行にまたがらせる際に便利です。また、部分文字列ごとに
コメントを追加することもできます。例えば:

     re.compile("[A-Za-z_]"       # letter or underscore
                "[A-Za-z0-9_]*"   # letter, digit or underscore
               )

この機能は文法レベルで定義されていますが、スクリプトをコンパイルする
際の処理として実現されることに注意してください。実行時に文字列表現を
結合したければ、 `+' 演算子を使わなければなりません。また、リテラルの
結合においては、結合する各要素に異なる引用符形式を使える (raw 文字列
と三重引用符を混ぜることさえできます) ので注意してください。


File: python-ref-jp.info,  Node: 数値リテラル,  Next: 整数および長整数リテラル,  Prev: 文字列リテラルの結合 concatenation,  Up: リテラル literal

2.4.3 数値リテラル
------------------

数値リテラルは 4 種類あります: 整数 (plain integer)、長整数 (long
integer)、浮動小数点数 (floating point number)、そして虚数 (imaginary
number) です。複素数のためのリテラルはありません (複素数は実数と
虚数の和で作ることができます)。

数値リテラルには符号が含まれていないことに注意してください; `-1'
のような句は、実際には単項演算子 (unary operator) ``-'' とリテラル `1'
を組み合わせたものです。


File: python-ref-jp.info,  Node: 整数および長整数リテラル,  Next: 浮動小数点数リテラル,  Prev: 数値リテラル,  Up: リテラル literal

2.4.4 整数および長整数リテラル
------------------------------

整数および長整数リテラルは以下の字句定義で記述されます:

`longinteger `integer' ("l" | "L")'

`integer `decimalinteger' | `octinteger' | `hexinteger''

`decimalinteger `nonzerodigit' `digit'* | "0"'

`octinteger "0" `octdigit'+'

`hexinteger "0" ("x" | "X") `hexdigit'+'

`nonzerodigit "1"..."9"'

`octdigit "0"..."7"'

`hexdigit `digit' | "a"..."f" | "A"..."F"'

長整数を表す末尾の文字は小文字の `l' でも大文字の `L'
でもかまいませんが、`l' は `1' に良く似ているので、 常に `L'
を使うよう強く勧めます。

整数で表現できる最大の値よりも大きい整数のリテラル (例えば 32-bit
整数を使っている場合には 2147483647) は、
長整数として表現できる値であれば受理されます。 (1)
値がメモリ上に収まるかどうかという問題を除けば、長整数リテラルには値域の
制限がありません。

整数リテラル (最初の行) と長整数リテラル (二行目および三行目) の例を
以下に示します:

     7     2147483647                        0177
     3L    79228162514264337593543950336L    0377L   0x100000000L
           79228162514264337593543950336             0xdeadbeef

---------- Footnotes ----------

(1) バージョン 2.4 以前の Python では， 8 進および 16 進のリテラル
のうち，通常の整数型として表現可能な値より大きく，かつ符号無しの 32-bit
(32-bit 演算を使う計算機の場合) 整数で表現できる最大値，すなわち
4294967296 よりも小さな数は，リテラルを符号無し整数として表現した値から
4294967296 を引いて得られる負の整数として扱っていました．


File: python-ref-jp.info,  Node: 浮動小数点数リテラル,  Next: 虚数 imaginary リテラル,  Prev: 整数および長整数リテラル,  Up: リテラル literal

2.4.5 浮動小数点数リテラル
--------------------------

浮動小数点数リテラルは以下の字句定義で記述されます:

`floatnumber `pointfloat' | `exponentfloat''

`pointfloat [`intpart'] `fraction' | `intpart' "."'

`exponentfloat (`intpart' | `pointfloat') `exponent''

`intpart `digit'+'

`fraction "." `digit'+'

`exponent ("e" | "E") ["+" | "-"] `digit'+'

浮動小数点数における整数部と指数部は 8 進数のように見えることも
ありますが、10 を基数として解釈されるので注意してください。
例えば、`077e010' は正しい表記であり、`77e10' と同じ数を 表します。
浮動小数点数リテラルの取りうる値の範囲は実装に依存します。
浮動小数点数リテラルの例をいくつか示します:

     3.14    10.    .001    1e100    3.14e-10    0e0

数値リテラルには符号が含まれていないことに注意してください; `-1'
のような句は、実際には単項演算子 (unary operator) ``-'' とリテラル `1'
を組み合わせたものです。


File: python-ref-jp.info,  Node: 虚数 imaginary リテラル,  Prev: 浮動小数点数リテラル,  Up: リテラル literal

2.4.6 虚数 (imaginary) リテラル
-------------------------------

虚数リテラルは以下のような字句定義で記述されます:

`imagnumber (`floatnumber' | `intpart') ("j" | "J")'

虚数リテラルは、実数部が 0.0 の複素数を表します。複素数は二つ組の
浮動小数点型の数値で表され、それぞれの数値は浮動小数点型と同じ定義域の
範囲を持ちます。実数部がゼロでない浮動小数点を生成するには、`(3+4j)'
のように虚数リテラルに浮動小数点数を加算します。以下に虚数リテラルの
例をいくつか示します:

     3.14j   10.j    10j     .001j   1e100j  3.14e-10j


File: python-ref-jp.info,  Node: 演算子 operator,  Next: デリミタ delimiter,  Prev: リテラル literal,  Up: 字句解析

2.5 演算子 (operator)
=====================

以下のトークンは演算子です: 

     +       -       *       **      /       //      %
     <<      >>      &       |       ^       ~
     <       >       <=      >=      ==      !=      <>

比較演算子 `<>' と `!=' は、同じ演算子について別の書き方をした
ものです。書き方としては `!=' を推奨します; `<>' は時代遅れの
書き方です。


File: python-ref-jp.info,  Node: デリミタ delimiter,  Prev: 演算子 operator,  Up: 字句解析

2.6 デリミタ (delimiter)
========================

以下のトークンは文法上のデリミタとして働きます: 

     (       )       [       ]       {       }      @
     ,       :       .       `       =       ;
     +=      -=      *=      /=      //=     %=
     &=      |=      ^=      >>=     <<=     **=

浮動小数点数や虚数リテラル中にピリオドがあってもかまいません。
ピリオド三つの列はスライス表記における省略符号 (ellipsis) として
特別な意味を持っています。リスト後半の累算代入演算子 (augmented
assignment operator) は、字句的にはデリミタとして振舞いますが、
演算も行います。

以下の印字可能 ASCII 文字は、他のトークンの一部として特殊な意味を
持っていたり、字句解析器にとって重要な意味を持っています:

     '       "       #       \

以下の印字可能 ASCII 文字は、Python では使われていません。これらの
文字が文字列リテラルやコメントの外にある場合、無条件にエラーとなります: 

     $       ?


File: python-ref-jp.info,  Node: データモデル,  Next: 実行モデル,  Prev: 字句解析,  Up: Top

3 データモデル
**************

* Menu:

* オブジェクト、値、および型::
* 標準型の階層::
* 新スタイルと旧スタイル::
* 特殊メソッド名::


File: python-ref-jp.info,  Node: オブジェクト、値、および型,  Next: 標準型の階層,  Prev: データモデル,  Up: データモデル

3.1 オブジェクト、値、および型
==============================

Python における "オブジェクト (object)" とは、データを抽象的に
表したものです。Python プログラムにおけるデータは全て、オブジェクトま
たはオブジェクト間の関係として表されます。(ある意味では、プログラムコー
ドもまたオブジェクトとして表されます。これはフォン・ノイマン: Von
Neumann の "プログラム記憶方式コンピュータ: stored program computer"
のモデルに適合します。) 

オブジェクトはアイデンティティ値 (identity) 、型 (type) 、そして値
(value) を持ちます。オブジェクトが一度生成されると、そのオブジェクトの
_アイデンティティ値_ は決して変化することがありません; アイデンティ
ティ値をオブジェクトのメモリ上のアドレスと考えてもかまいません。 演算子
``is'' は、二つのオブジェクト間のアイデンティティ値を比 較します; 関数
`id()'  は、オブジェクトのアイデ ンティティ値を表す整数
(現在の実装ではオブジェクトのメモリ上のアドレス) を返します。
オブジェクトの "型" もまた変わることがありません。 (1)
オブジェクトの型は、そのオブジェクトのサポートする操作
("長さを持っているか？" など) を決定し、その型のオブジェクトが
取りうる値について定義しています。 `type()'  関数は、オブジェクトの型
(型自体も一つのオブジェクトです) を返します。オブジェクトによっては、
_値 (value)_ を変えることができます。値を変えることができる
オブジェクトは _変更可能 (mutable)_ であるといいます; 値を
一度設定すると、その後は変えることができないオブジェクトは _変更不能
(immutable)_ であると呼びます。
(変更不能なコンテナオブジェクトが変更可能なオブジェクトへの参照を
含んでいる場合、その値は後者のオブジェクトの変更によって変わる
場合があります; その場合でも、コンテナの含んでいるオブジェクトの
集まりは変わらないため、コンテナは変更不能と考えます。したがって、
変更不能性 (immutability) は、厳密には変更できない値を持っている
こととは違い、もっと微妙な概念です。)
オブジェクトの変更可能性は型で決定されます; 例えば、数値、文字列、
およびタプルは変更不能であり、辞書やリストは変更可能です。 

オブジェクトを明示的に破壊することはできません; しかし、オブジェクト
に到達不能 (unreachable) になると、ガベージコレクション
(garbage-collection)
によって処理されます。実装では、ごみ収集を遅らせたり、全く行わない
ようにすることができます -- 到達可能なオブジェクトをごみ収集処理して
しまわないかぎり、どう実装するかは実装品質の問題です。 (実装上の注意:
現在の実装では参照カウント (reference-counting) 手順を
使っており、(オプションとして) 循環参照を行っているごみオブジェクトを
遅延検出します。この実装ではほとんどのオブジェクトを到達不能になると
同時に処理することができますが、循環参照を含むごみオブジェクトの収集が
確実に行われるよう保証しているわけではありません。循環参照を持つごみ
オブジェクト収集の制御については、  を 参照してください。) 

実装のトレース機能やデバッグ機能を使えば、通常は収集されてしまう
ようなオブジェクトを生かしておくことがあるので注意してください。 また、
``try'...`except'' 文を使って例外を捕捉できる
ようにすると、オブジェクトを生かしておくことがあります。

オブジェクトによっては、開かれたファイルやウィンドウといった、 "外部
(external) の" リソースに対する参照を行っています。
これらのリソースは、オブジェクトがごみ収集された際に解放される
ものと理解されていますが、ごみ収集が行われる保証はないので、
こうしたオブジェクトでは外部リソースを明示的に解放する 方法、大抵は
`close()' メソッドを提供しています。 こうしたオブジェクトは明示的に
close するよう強く奨めます。 操作をする際には、``try'...`finally''
文を使うと 便利です。

他のオブジェクトに対する参照をもつオブジェクトもあります; これらは
_コンテナ (container)_ と呼ばれます。コンテナオブジェクトの例
として、タプル、リスト、および辞書が挙げられます。オブジェクトへの
参照自体がコンテナの値の一部です。ほとんどの場合、コンテナの値と
いうと、コンテナに入っているオブジェクトの値のことを指し、それら
オブジェクトのアイデンティティではありません; しかしながら、
コンテナの変更可能性について述べる場合、今まさにコンテナに入っている
オブジェクトのアイデンティティのことを指します。したがって、
(タプルのように) 変更不能なオブジェクトが変更可能なオブジェクト
への参照を含む場合、その値が変化するのは変更可能なオブジェクトが
変更された時、ということになります。 

型はオブジェクトの動作のほとんど全てに影響します。オブジェクトの
アイデンティティが重要かどうかでさえ、ある意味では型に左右されます:
変更不能な型では、新たな値を計算するような操作を行うと、実際には同じ
型と値を持った既存のオブジェクトへの参照を返すことがありますが、
変更可能なオブジェクトではそのような動作は起こりえません。例えば、 `a =
1; b = 1' とすると、 `a' と `b' は値 1 を持つ
同じオブジェクトを参照するときもあるし、そうでないときもあります。
これは実装に依存します。しかし、 `c = []; d = []' とすると、 `c' と `d'
はそれぞれ
二つの異なった、互いに一意な、新たに作成された空のリストを参照する
ことが保証されています。 (`c = d = []' とすると、 `c' と `d'
の両方に同じ オブジェクトを代入します)

---------- Footnotes ----------

(1) Python 2.2 以降、型とクラスの段階的な統合が始まっている
ため、このドキュメントで主張されている内容が 100% 正確で完全と
いうわけではなくなりました: 例えば、場合によっては、ある管理された
条件下でなら、オブジェクトの型を_変更することができます_。
このマニュアルに大幅な改訂が施されるまでは、このドキュメントでの
記述は、"旧クラス型 (classic class)" に関してのみ
信頼できる内容と考えねばなりません。Python 2.2 および 2.3 では、
互換性のためにクラシックなクラスがまだデフォルトとなっています。
更なる情報は`http://www.python.org/doc/newstyle.html'を
参照してください。


File: python-ref-jp.info,  Node: 標準型の階層,  Next: 新スタイルと旧スタイル,  Prev: オブジェクト、値、および型,  Up: データモデル

3.2 標準型の階層
================

以下は Python に組み込まれている型のリストです。(C、Java、または
実装に使われているその他の言語で書かれた) 拡張モジュールでは、
その他に新たな型を定義することができます。将来のバージョンの Python
では、型の階層に新たな型 (整数を使って効率的に記憶される
有理数型、など) を追加することができるかもしれません。 

以下に説明する型のいくつかには、`特殊属性 (special attribute)'
と題された段落が連ねられています。これらの属性は実装へのアクセス
手段を提供するもので、一般的な用途に利用するためのものではありません。
特殊属性の定義は将来変更される可能性があります。 

`None'
     この型には単一の値しかありません。この値を持つオブジェクトはただ
     一つしか存在しません。このオブジェクトは組み込み名 `None'
     でアクセスされます。このオブジェクトは、様々な状況で値が
     存在しないことをしめします。例えば、明示的に値を返さない関数 は
     `None' を返します。`None' の真値 (truth value) は 偽 (false) です。 

`NotImplemented'
     この型には単一の値しかありません。この値を持つオブジェクトはただ
     一つしか存在しません。このオブジェクトは組み込み名 `NotImplemented'
     でアクセスされます。数値演算に関するメソッドや拡張比較 (rich
     comparison)
     メソッドは、被演算子が該当する演算を行うための実装をもたない場合、
     この値を返すことがあります。(演算子によっては、インタプリタが
     関連のある演算を試したり、他の代替操作を行います。) 真値は真 (true)
     です。 

`Ellipsis'
     この型には単一の値しかありません。この値を持つオブジェクトはただ
     一つしか存在しません。このオブジェクトは組み込み名 `Ellipsis'
     でアクセスされます。スライス内に `...' 構文がある場合に
     使われます。真値は真 (true)です。 

`Numbers'
     数値リテラルによって作成されたり、算術演算や組み込みの算術関数に
     よって返されるオブジェクトです。数値オブジェクトは変更不能です;
     一度値が生成されると、二度と変更されることはありません。Python
     の数値オブジェクトはいうまでもなく数学で言うところの数値と
     強く関係していますが、コンピュータ内で数値を表現する際に伴う
     制限を受けています。 

     Python は整数、浮動小数点数、複素数の間で区別を行っています:

    `整数型 (integer)'
          整数型は、整数(正の数および負の数)を表す数学的集合内における要素を
          表現する型です。 

          以下に三つの整数型を示します:

         `(通常の) 整数型 (plain integer)'
               -2147483648 から 2147483647 までの整数を表現します
               (基本ワードサイズ: natural word size
               がより大きなマシンではより大きな定義域になることも
               あります。より小さくなることはありません。)
               演算の結果が定義域を超えた値になった場合、結果は通常長整数で
               返されます (場合によっては、 `OverflowError' が送出され
               ます) 。 シフト演算やマスク演算のために、整数は 32
               ビット以上の 2 の補数で 表されたバイナリ表現を持つ
               (すなわち、4294967296 の異なったビット
               パターン全てが異なる値を持つ) と仮定されています。 

         `長整数型 (long integer)'
               長整数は無限の定義域を持ち、利用可能な (仮想)
               メモリサイズの制限
               のみをうけます。長整数はシフト演算やマスク演算のためにバイナリ表現を
               もつものと仮定されます。負の数は符号ビットが左に無限に延びているような
               錯覚を与える 2 の補数表現の変型で表されます。 

         `ブール型 (boolean)'
               ブール型は、真値 False または True
               を表現します。ブール型の オブジェクトは False と True
               を表現する二つのオブジェクト
               だけです。ブール型は整数のサブタイプで、ほとんどの演算コンテキストに
               おいてブール型値はそれぞれ 0 または 1
               のように振舞います。
               ただし、文字列に変換されたときのみ、それぞれ文字列
               `"False"' および `"True"' が返されます。 

          整数表現に関する規則は、シフト演算やマスク演算において、負の整数
          も含めて最も有意義な解釈ができるように、かつ通常の整数と長整数
          との間で定義域を切り替える際にできるだけ混乱しないように決められて
          います。左シフト以外の演算では、演算結果がオーバフローを起こさずに
          整数の定義域の値になる場合は、長整数を使った場合でも、被演算子に
          整数と長整数を混合した場合でも同じ結果になります。 

    `浮動小数点数型 (floating point number)'
          この型は計算機レベルで倍精度とされている浮動小数点数を
          表現します。表現可能な値の範囲やオーバフローの扱いは、
          根底にある計算機アーキテクチャ (と C または Java 実装)
          次第です。 Python は単精度の浮動小数点数をサポートしません;
          単精度の
          数を使う理由は、通常プロセッサやメモリ使用量の節約ですが、
          こうした節約は Python
          でオブジェクトを扱う際のオーバヘッドに比べれば
          微々たるものにすぎません。従って、わざわざ浮動小数点型を 2
          つも 定義してPython 言語を難解にする理由はどこにもないのです。 

    `複素数型 (complex number)'
          この型は、計算機レベルで倍精度とされている浮動小数点を 2
          つ一組
          にして複素数を表現します。浮動小数点について述べたのと同じ性質
          が当てはまります。複素数 `z' の実数部および虚数部は、
          それぞれ読み出し専用属性 `z.real' および `z.imag'
          で取り出すことができます。 


`シーケンス型 (sequence)'
     この型は、有限の順序集合 (ordered set) を表現します。要素は非負の
     整数でインデクス化されています。組み込み関数 `len()'  を使うと、シーケンスの要素数を返します。
     シーケンスの長さが N の場合、インデクスは 0, 1, ..., N-1
     からなる集合です。シーケンス A の要素 I は `A[I]' で選択します。 

     シーケンスはスライス操作 (slice) もサポートしています: `A[I:J]'
     とすると、 I `<=' K `<' J であるインデクス K
     をもつ全ての要素を選択します。
     式表現としてスライスを用いた場合、スライスは同じ型をもつ新たなシーケンスを
     表します。新たなシーケンス内では、インデクス集合が 0
     から始まるように インデクスの値を振りなおします。 

     シーケンスによっては、 第三の "ステップ (step)" パラメタを持つ
     "拡張スライス (extended slice)" もサポートしています: `A[I:J:K]'
     は、 `X = I + N*K', N `>=' `0' かつ I `<=' X `<' J であるような
     インデクス X を持つような A 全ての要素を選択します。 

     シーケンスは、変更可能なものか、そうでないかで区別されています:

    `変更不能なシーケンス (immutable sequence)'
          変更不能なシーケンス型のオブジェクトは、一度生成されるとその値を
          変更することができません。 (オブジェクトに他のオブジェクトへの
          参照が入っている場合、参照されているオブジェクトは変更可能な
          オブジェクトでもよく、その値は変更される可能性があります;
          しかし、変更不能なオブジェクトが直接参照しているオブジェクトの
          集合自体は、変更することができません。) 

          以下の型は変更不能なシーケンス型です:

         `文字列型 (string)'
               文字列の各要素は文字 (character) です。文字型 (character
               type) は存在しません;
               単一の文字は、要素が一つだけの文字列として
               表現されます。各文字は (少なくとも) 8-bit
               のバイト列を表現します。 組み込み関数 `chr()'  および
               `ord()'  を使うと、文字と非負の整数で表された
               バイト値の間で変換を行えます。0-127
               の値を持つバイト値は、通常 同じ ASCII
               値をもつ文字を表現していますが、値をどう解釈するかは
               プログラムにゆだねられています。文字列データ型はまた、例えば
               ファイルから読み出されたデータを記憶するといった用途で、バイト値の
               アレイを表現するために用いられます。 

               (ネイティブの文字セットが
               ASCIIでないシステムでは、`chr()' や `ord()' が ASCII と
               EBCDIC との間で対応付けを行っており、 文字列間の比較で
               ASCII 順が守られる限り、文字列の内部表現として EBCDIC
               を使ってもかまいません。誰か他にもっとましなルールをお持ちですか?)  

         `Unicode 文字列型'
               Unicode オブジェクトの各要素は Unicode コード単位です。
               Unicode コード単位とは、単一の Unicode
               オブジェクトで、Unicode 序数を 表現する 16-bit または
               32-bit の値を保持できるものです (この序数の最大値は
               `sys.maxunicode' で与えられており、コンパイル時に Python
               がどう設定されているかに依存します)。 Unicode
               オブジェクト内 にサロゲートペア (surrogate pair)
               があってもよく、Python は サロゲートペアを二つの別々の
               Unicode 要素として報告します。 組み込み関数 `unichr()'  および
               `ord()'  は、コード単位と非負の整数で表された Unicode
               標準 3.0 で定義された Unicode
               序数との間で変換を行います。
               他の文字エンコード形式との相互変換は、 Unicode メソッド
               `encode()' および組み込み関数 `unicode()' で行うことができます。 

         `タプル型 (tuple)'
               タプルの要素は任意の Python オブジェクトにできます。
               二つまたはそれ以上の要素からなるタプルは、個々の要素を表現する
               式をカンマで区切って構成します。単一の要素からなるタプル
               (単集合 `singleton') を作るには、要素を表現する式の直後に
               カンマをつけます (単一の式だけではタプルを形成しません。
               これは、式をグループ化するのに丸括弧を使えるようにしなければ
               ならないからです)
               。要素の全くない丸括弧の対を作ると空のタプルに なります。 


    `変更可能なシーケンス型 (mutable sequence)'
          変更可能なシーケンスは、作成した後で変更することができます。
          変更可能なシーケンスでは、添字表記やスライス表記を使って指定された要素に
          代入を行うことができ、`del' (delete) 文を使って要素を
          削除することができます。 

          Python
          に最初から組み込まれている変更可能なシーケンス型は、今のところ
          一つだけです:

         `リスト型 (list)'
               リストの要素は任意の Python
               オブジェクトにできます。リストは、
               角括弧の中にカンマで区切られた式を並べて作ります。
               (長さが 0 や 1
               のシーケンスを作るために特殊な場合分けは必要ないことに
               注意してください。) 


          拡張モジュール `array'  では、別の
          変更可能なシーケンス型を提供しています。


`マップ型 (mapping)'
     任意のインデクス集合でインデクス化された、有限のオブジェクトからなる
     集合を表現します。添字表記 `a[k]' は、`k' でインデクス指定
     された要素を `a' から選択します; 選択された要素は式の中で
     使うことができ、代入や `del' 文の対象にすることができます。
     組み込み関数 `len()' は、マップ内の要素数を返します。 

     Python に最初から組み込まれているマップ型は、今のところ
     一つだけです:

    `辞書型 (dictionary)'
          ほとんどどんな値でもインデクスとして使えるような、
          有限個のオブジェクトからなる集合を表します。キー値 (key)
          として使えない
          値は、リストや辞書を含む値や、アイデンティティではなく値でオブジェクトが
          比較される、その他の変更可能な型です。これは、辞書型を効率的に
          実装する上で、キーのハッシュ値が一定であることが必要だからです。
          数値型をキーに使う場合、キー値は通常の数値比較における規則に
          従います: 二つの値が等しくなる場合 (例えば `1' と `1.0')、
          互いに同じ辞書のエントリを表すインデクスとして使うことができます。

          辞書は変更可能な型です; 辞書は `{...}' 表記で生成します
          (~*Note 辞書表現:: 節, "辞書表現" を参照してください)。

          拡張モジュール `dbm'  、 `gdbm'  、および `bsddb'  では、別のマップ型を提供
          しています。


`呼び出し可能型 (callable type)'
     関数呼び出し操作 (~*Note 呼び出し call:: 節、"呼び出し (call)"
     参照) を行うことができる型です: 

    `ユーザ定義関数 (user-defined function)'
          ユーザ定義関数オブジェクトは、関数定義を行うことで生成されます
          (~*Note 関数定義:: 節、"関数定義" 参照)。関数は、仮引数
          (formal parameter) リストと同じ数の要素が入った引数リストと
          ともに呼び出されます。 

          特殊属性:

          Attribute            Meaning              
          ------               -----                -----
          func_doc             関数のドキュメンテーション文字列です。書き込み可能
                               ドキュメンテーションがない場合は
                               `None' になります。  
          __doc__              `func_doc'           書き込み可能
                               の別名です。         
          func_name            関数の名前です。     書き込み可能
          __name__             `func_name'          書き込み可能
                               の別名です。         
          __module__           関数が定義されているモジュールの名前です。書き込み可能
                               モジュール名がない場合は
                               `None' になります。  
          func_defaults        デフォルト値を持つ引数に対するデフォルト値が書き込み可能
                               収められたタプルで、デフォルト値を持つ引数がない場合には
                               `None' になります。  
          func_code            コンパイルされた関数本体を表現するコード書き込み可能
                               オブジェクトです。   
          func_globals         関数のグローバル変数の入った辞書読み出し専用
                               (への参照) です --   
                               この辞書は、関数が定義されているモジュールのグローバルな名前空間を決定します。
          func_dict            任意の関数属性をサポートするための名前空間が書き込み可能
                               収められています。   
          func_closure         `None'               読み出し専用
                               または関数の個々の自由変数
                               (引数以外の変数)     
                               に対して値を結び付けている
                               セル (cell)          
                               群からなるタプルになります。

          「書き込み可能」
          とラベルされている属性のほとんどは、代入された値の
          型をチェックします。

          _Changed in Python version 2.4_

          関数オブジェクトはまた、任意の属性を設定したり取得したりできます。
          この機能は、例えば関数にメタデータを付与したい場合などに使えます。
          関数の get や set には、通常のドット表記を使います。
          _現在の実装では、ユーザ定義の関数でのみ属性をサポートしているので
          注意して下さい。組み込み関数の属性は将来サポートする予定です。_

          関数定義に関するその他の情報は、関数のコードオブジェクトから得られます;
          後述の内部型 (internal type) に関する説明を参照してください。

    `ユーザ定義メソッド (user-defined method)'
          ユーザ定義のメソッドオブジェクトは、クラスやクラスインスタンス
          (あるいは `None') を任意の呼び出し可能オブジェクト (通常は
          ユーザ定義関数) と結合し (combine) ます。 

          読み出し専用の特殊属性: `im_self' は
          クラスインスタンスオブジェクトで、`im_func' は関数オブジェクト
          です; `im_class' は結合メソッド (bound method) において
          `im_self' が属しているクラスか、あるいは非結合メソッド
          (unbound method) において、要求されたメソッドを定義している
          クラスです; `__doc__' はメソッドのドキュメンテーション文字列
          (`im_func.__doc__' と同じ) です; `__name__' はメソッドの 名前
          (`im_func.__name__' と同じ) です; `__module__' は
          メソッドが定義されているモジュールの名前になるか、モジュール名が
          ない場合は `None' になります。 _Changed in Python version 2.2_ 

          メソッドもまた、根底にある関数オブジェクトの任意の関数属性 に
          (値の設定はできませんが) アクセスできます。

          クラスの属性を (おそらくクラスのインスタンスを介して)
          取得する際には、
          その属性がユーザ定義の関数オブジェクト、非結合 (unbound)
          のユーザ定義
          メソッドオブジェクト、あるいはクラスメソッドオブジェクトであれば、
          ユーザ定義メソッドオブジェクトが生成されることがあります。
          属性がユーザ定義メソッドオブジェクトの場合、属性を取得する対象の
          オブジェクトが属するクラスがもとのメソッドオブジェクトが定義されている
          クラスと同じクラスであるか、またはそのサブクラスであれば、新たな
          メソッドオブジェクトだけが生成されます。
          それ以外の場合には、もとのメソッドオブジェクトがそのまま使われます。

          クラスからユーザ定義関数オブジェクトを取得する方法でユーザ定義
          メソッドオブジェクトを生成すると、 `im_self' 属性は `None'
          になり、メソッドオブジェクトは非結合 (unbound)
          であるといいます。クラスのインスタンスからユーザ定義関数
          オブジェクトを取得する方法でユーザ定義メソッドオブジェクトを
          生成すると、`im_self' 属性はインスタンスになり、
          メソッドオブジェクトは結合 (bound) であるといいます。
          どちらの場合も、新たなメソッドの `im_class' 属性は、
          メソッドの取得が行われたクラスになり、`im_func' 属性は
          もとの関数オブジェクトになります。 

          クラスやインスタンスから他のユーザ定義メソッドオブジェクトを
          取得する方法でユーザ定義メソッドオブジェクトを生成した場合、
          その動作は関数オブジェクトの場合と同様ですが、新たなインスタンスの
          `im_func' 属性はもとのメソッドオブジェクトの属性ではなく、
          新たなインスタンスの属性になります。 

          クラスやインスタンスからクラスメソッドオブジェクトを取得する
          方法でユーザ定義メソッドオブジェクトを生成した場合、
          `im_self' 属性はクラス自体 (`im_class' 属性と 同じ)
          となり、`im_func' 属性はクラスメソッドの根底に
          ある関数オブジェクトになります。 

          非結合ユーザ定義メソッドオブジェクトの呼び出しの際には、
          根底にある関数 (`im_func') が呼び出されます。このとき、
          最初の引数は適切なクラス (`im_class') またはサブクラスの
          インスタンスでなければならないという制限が課されています。

          結合ユーザ定義メソッドオブジェクトの呼び出しの際には、
          根底にある関数 (`im_func') が呼び出されます。このとき、
          クラスインスタンス (`im_self') が引数の先頭に挿入され
          ます。例えば、関数 `f()' の定義が入ったクラスを `C' とし、`x'
          を `C' のインスタンスとすると、 `x.f(1)' の呼び出しは `C.f(x,
          1)' と同じになります。

          ユーザ定義メソッドオブジェクトがクラスオブジェクトから導出される際、
          `im_self' に記憶されている "クラスインスタンス" はクラス
          自体になります。これは、`x.f(1)' や `C.f(1)' の呼び出しが
          根底にある関数を `f' としたときの呼び出し `f(C,1)' と
          等価になるようにするためです。

          関数オブジェクトから (結合または非結合の)
          メソッドオブジェクトへの
          変換は、クラスやインスタンスから属性を取り出すたびに行われるので
          注意してください。場合によっては、属性をローカルな変数に代入して
          おき、その変数を使って関数呼び出しを行うと効果的な最適化になります。
          また、上記の変換はユーザ定義関数に対してのみ起こるので注意してください;
          その他の呼び出し可能オブジェクト
          (および呼び出し可能でない全ての オブジェクト)
          は、変換を受けずに取り出されます。それから、
          クラスインスタンスの属性になっているユーザ定義関数は、結合メソッドに
          変換できないと知っておくことも重要です; 結合メソッドへの変換が
          行われるのは、関数がクラスの一属性である場合 _だけ_ です。

    `ジェネレータ関数 (generator function)'
          `yield' 文 (~*Note yield 文:: 節、"`yield' 文" 参照)
          を使う関数またはメソッドは、"ジェネレータ関数" ("generator
          function") と呼ばれます。このような関数は、呼び出された
          際に、常にイテレータオブジェクトを返します。このイテレータオブジェクトは
          関数の本体を実行するために用いられます: イテレータの `next()'
          メソッドを呼び出すと、`yield' 文で値を出力する処理まで関数の
          実行が行われます。関数が `return'
          文を実行するか、関数を最後まで
          実行し終えると、`StopIteration' 例外が送出され、イテレータが
          返す値の集合はそこで終わります。

    `組み込み関数 (built-in function)'
          組み込み関数オブジェクトはC関数へのラッパです。組み込み関数の例は
          `len()' や `math.sin()' (`math' は標準の組み込み モジュール)
          です。引数の数や型は C 関数で決定されています。
          読み出し専用の特殊属性: `__doc__' は関数のドキュメンテーション
          文字列です。ドキュメンテーションがない場合は `None'
          になります; `__name__' は関数の名前です; `__self__' は `None'
          に設定されています (組み込みメソッドの節も参照してください);
          `__module__' は、関数が定義されているモジュールの名前です。
          モジュール名がない場合は `None' になります。 

    `組み込みメソッド (built-in method)'
          実際には組み込み関数を別の形で隠蔽したもので、こちらの場合には
          C 関数に渡される何らかのオブジェクトを非明示的な外部引数として
          持っています。組み込みメソッドの例は、ALIST
          をリストオブジェクト としたときの `ALIST.append()' です。
          この場合には、読み出し専用の属性 `__self__' は ALIST
          で表されるオブジェクトになります。 

    `クラス型 (class type)'
          クラス型、あるいは "新しいクラス型 (new-style class)"
          や呼び出し可能
          オブジェクトです。クラス型オブジェクトは通常、そのクラスの新たな
          インスタンスを生成する際のファクトリクラスとして振舞いますが、
          `__new__()' をオーバライドして、バリエーションを持たせることも
          できます。呼び出しの際に使われた引数は `__new__()' に渡され、
          さらに典型的な場合では新たなインスタンスを初期化するために
          `__init__()' に渡されます。

    `旧クラス型 (classic class)'
          (旧)
          クラスオブジェクトは後で詳しく説明します。クラスオブジェクトが
          呼び出されると、新たにクラスインスタンス (後述)
          が生成され、返されます。 この操作には、クラスの `__init__()'
          メソッドの呼び出し (定義されている場合)
          が含まれています。呼び出しの際に使われた引数は、 すべて
          `__init__()' メソッドに渡されます。 `__init__()'
          メソッドがない場合、クラスは引数なしで呼び出さなければ
          なりません。 

    `クラスインスタンス (class instance)'
          クラスインスタンスは後で詳しく説明します。クラスインスタンスは
          クラスが `__call__()' メソッドを持っている場合にのみ呼び出す
          ことができます; `x(arguments)' とすると、
          `x.__call__(arguments)' 呼び出しを短く書けます。


`モジュール (module)'
     モジュールは `import' 文で import します (~*Note import 文:: 節、
     "`import' 文" 参照)。 モジュールオブジェクトは、辞書オブジェクト
     (モジュール内で定義されて いる関数が func_globals
     属性で参照している辞書です) で実装された
     名前空間を持っています。属性への参照は、この辞書に対する検索
     (lookup) に翻訳されます。例えば、`m.x' は `m.__dict__["x"]'
     と同じです。
     モジュールオブジェクトには、モジュールを初期化するために使われる
     コードオブジェクトは入っていません (一度初期化が終わればもう必要
     ないからです)。

     属性の代入を行うと、モジュールの名前空間辞書の内容を更新します。
     例えば、 `m.x = 1' は `m.__dict__["x"] = 1' と同じです。

     読み出し専用の特殊属性: `__dict__' はモジュールの名前空間で、
     辞書オブジェクトです。 

     定義済みの (書き込み可能な) 属性: `__name__'
     はモジュールの名前です; `__doc__' は関数のドキュメンテーション
     文字列です。ドキュメンテーションがない場合は `None' になります;
     モジュールがファイルからロードされた場合、 `__file__' はロード
     されたモジュールファイルのパス名です。インタプリタに静的にリンクされて
     いる C{} モジュールの場合、`__file__' 属性はありません;
     共有ライブラリから動的にロードされた拡張モジュールの場合、この属性は
     共有ライブラリファイルのパス名になります。 

`クラス'
     クラスオブジェクトはクラス定義 (~*Note クラス定義:: 節、
     "クラス定義" 参照)
     で生成されます。クラスは辞書で実装された名前空間を持っています。
     クラス属性への参照は、この辞書に対する検索 (lookup)
     に翻訳されます。例えば、`C.x' は `C.__dict__["x"]' と同じです。
     属性がこの検索で見つからない場合、現在のクラスの基底クラスへと
     検索を続けます。検索は深さ優先 (depth-first)、かつ基底クラスの
     挙げられているリスト中の左から右 (left-to-right) の順番で行われ
     ます。

     クラス (`C' とします) への属性参照で、要求している属性が
     ユーザ定義関数オブジェクトや、`C' やその基底クラスに関連付け
     られている非結合のユーザ定義メソッドオブジェクトである場合、
     `im_class' 属性が `C' であるような非結合ユーザ定義
     メソッドオブジェクトに変換されます。
     要求している属性がクラスメソッドオブジェクトの場合、 `im_class'
     とその `im_self' 属性がどちらも `C'
     であるようなユーザ定義メソッドオブジェクトに変換されます。
     要求している属性が静的メソッドオブジェクトの場合、静的メソッド
     オブジェクトでラップされたオブジェクトに変換されます。
     クラスから取り出した属性と実際に `__dict__' に入っている
     ものが異なるような他の場合については、 ~*Note デスクリプタ
     descriptor の実装:: 節を 参照してください。 

     クラス属性を代入すると、そのクラスの辞書だけが更新され、基底クラスの
     辞書は更新しません。 

     クラスオブジェクトを呼び出す (上記を参照) と、クラスインスタンスを
     生成します (下記を参照)。 

     特殊属性: `__name__' はクラス名です; `__module__'
     はクラスが定義されているモジュールの名前です; `__dict__'
     はクラスの名前空間が入った辞書です; `__bases__'
     は基底クラスの入った (空、あるいは単要素を取りえる)
     タプルで、基底クラスリストの順番になっています; `__doc__' は
     クラスのドキュメンテーション文字列です。ドキュメンテーション文字列が
     ない場合には `None' になります。 

`クラスインスタンス'
     クラスインスタンスはクラスオブジェクト (上記参照) を呼び出して
     生成します。クラスインスタンスは辞書で実装された名前空間を持って
     おり、属性参照の時にはこの辞書が最初に検索されます。
     辞書内に属性が見つからず、かつインスタンスのクラスに該当する
     属性名がある場合、検索はクラス属性にまで広げられます。
     見つかったクラス属性がユーザ定義関数オブジェクトや、
     インスタンスのクラス (`C' とします) やその基底クラスに関連
     付けられている非結合のユーザ定義メソッドオブジェクトの場合、
     `im_class' 属性が `C' で `im_self' 属性が
     インスタンスになっている結合ユーザ定義メソッドオブジェクトに変換
     されます。静的メソッドやクラスメソッドオブジェクトもまた、 `C'
     から取り出した場合と同様に変換されます; 上記の "クラス"
     を参照してください。 クラスから取り出した属性と実際に `__dict__'
     に入っている ものが異なるような他の場合については、 ~*Note
     デスクリプタ descriptor の実装:: 節を 参照してください。
     クラス属性が見つからず、かつオブジェクトのクラスが `__getattr__()'
     メソッドを持っている場合、このメソッドを
     呼び出して属性名の検索を充足させます。 

     属性の代入や削除を行うと、インスタンスの辞書を更新しますが、クラスの
     辞書を更新することはありません。クラスで `__setattr__()' や
     `__delattr__()' メソッドが定義されている場合、直接インスタンスの
     辞書を更新する代わりにこれらのメソッドが呼び出されます。 

     クラスインスタンスは、ある特定の名前のメソッドを持っている
     場合、数値型やシーケンス型、あるいはマップ型のように振舞うことが
     できます。~*Note 特殊メソッド名:: 節、 "特殊メソッド名" を参照
     してください。 

     特殊属性: `__dict__' は属性の辞書です; `__class__'
     はインスタンスのクラスです。 

`ファイル (file)'
     ファイル  オブジェクトは開かれたファイルを表します。
     ファイルオブジェクトは組み込み関数 `open()' 

     や、 `os.popen()', `os.fdopen()', および socke オブジェクトの
     `makefile()' メソッド
     (その他の拡張モジュールで提供されている関数やメソッド) で生成
     されます。 `sys.stdin', `sys.stdout' および `sys.stderr'
     といったオブジェクトは、 インタプリタの標準入力 、標準出力、および標準エラー出力
     ストリームに対応するよう初期化されます。ファイルオブジェクトに
     関する完全な記述については、 を参照してください。 

`内部型 (internal type)'
     インタプリタが内部的に使っているいくつかの型は、ユーザに公開されています。
     これらの定義は将来のインタプリタのバージョンでは変更される可能性が
     ありますが、ここでは記述の完全性のために触れておきます。 

    `コードオブジェクト'
          コードオブジェクトは _バイトコンパイルされた (byte-compiled)_
          実行可能な Python コード、別名 _バイトコード (bytecode)_ を
          表現します。コードオブジェクトと関数オブジェクトの違いは、
          関数オブジェクトが関数のグローバル変数
          (関数を定義しているモジュールの グローバル)
          に対して明示的な参照を持っているのに対し、コードオブジェクト
          にはコンテキストがないということです;
          また、関数オブジェクトでは
          デフォルト引数値を記憶できますが、コードオブジェクトではできません
          (実行時に計算される値を表現するため)。関数オブジェクトと違い、
          コードオブジェクトは変更不可能で、変更可能なオブジェクトへの参照を
          (直接、間接に関わらず) 含みません。 

          読み出し専用の特殊属性: `co_name' は関数名を表します;
          `co_argcount' は固定引数 (positional argument) の数です;
          `co_nlocals' は関数が使う (引数を含めた) ローカル変数の数です;
          `co_varnames' はローカル変数名の入ったタプルです (引数名
          から始まっています); `co_cellvars' はネストされた関数で
          参照されているローカル変数の名前が入ったタプルです;
          `co_freevars' は自由変数の名前が入ったタプルです。 `co_code'
          はバイトコード列を表現している文字列です; `co_consts'
          はバイトコードで使われているリテラルの入った タプルです;
          `co_names' はバイトコードで使われている名前
          の入ったタプルです; `co_filename' はバイトコードのコンパイル
          が行われたファイル名です; `co_firstlineno' は関数の最初の
          行番号です; `co_lnotab' はバイトコードオフセットから行番号
          への対応付けをコード化した文字列です
          (詳細についてはインタプリタの
          ソースコードを参照してください); `co_stacksize' は関数で
          (ローカル変数の分も含めて) 必要なスタックサイズです;
          `co_flags' はインタプリタ用の様々なフラグをコード化した
          整数です。

          以下のフラグビットが `co_flags' で定義されています: `0x04'
          ビットは、関数が `*arguments' 構文を使って
          任意の数の固定引数を受理できる場合に立てられます; `0x08'
          ビットは、関数が `**keywords' 構文を使って
          キーワード引数を受理できる場合に立てられます; `0x20'
          ビットは、関数がジェネレータである場合に立てられます。 

          将来機能 (future feature) 宣言 (`from __future__ import
          division') もまた、`co_flags'
          のビットを立てることで、コードオブジェクトが
          特定の機能を有効にしてコンパイルされていることを示します:
          `0x2000' ビットは、関数が将来機能を有効にしてコンパイルされて
          いる場合に立てられます; 以前のバージョンの Python では、`0x10'
          および `0x1000' ビットが使われていました。

          `co_flags' のその他のビットは将来に内部的に利用するために
          予約されています。

          コードオブジェクトが関数を表現している場合、`co_consts'
          の最初の 要素は関数のドキュメンテーション文字列 

          になります。ドキュメンテーション文字列が定義されていない場合には
          `None' になります。

    `フレーム (frame) オブジェクト'
          フレームオブジェクトは実行フレーム (execution frame)
          を表します。
          実行フレームはトレースバックオブジェクト内に出現します
          (下記参照)。 

          読み出し専用の特殊属性: `f_back' は (呼び出し側にとっての)
          以前のスタックフレームです。呼び出し側がスタックフレームの最下段で
          ある場合には `None' です; `f_code' は現在のフレームで
          実行しようとしているコードオブジェクトです; `f_locals'
          はローカル変数を検索するために使われる辞書です; `f_globals'
          はグローバル変数用です; `f_builtins' は組み込みの (Python
          固有の) 名前です; `f_restricted' は、関数が制限つき実行
          (restricted execution)
          モードで実行されているかどうかを示すフラグです; `f_lasti'
          は厳密な命令コード
          (コードオブジェクト中のバイトコード文字列への インデクス)
          です。 

          書き込み可能な特殊属性: `f_trace' が `None' でない場合、
          各ソースコード行の先頭で呼び出される関数になります;
          `f_exc_type', `f_exc_value', `f_exc_traceback'
          は、現在のフレームが以前に引き起こした例外が提供する親フレーム内で
          もっとも最近捕捉された例外を表します
          (それ以外の場合は、これらはNoneになります。); `f_lineno'
          はフレーム中における現在の行番号です -- トレース関数 (trace
          function) 側でこの値に書き込みを行うと、指定した行にジャンプ
          します (最下段の実行フレームにいるときのみ) 。デバッガでは、
          f_fileno を書き込むことで、ジャンプ命令 (Set Next Statement
          命令とも 呼ばれます) を実装できます。 

    `トレースバック (traceback) オブジェクト'
          トレースバックオブジェクトは例外のスタックトレースを表現します。
          トレースバックオブジェクトは例外が発生した際に生成されます。
          例外ハンドラを検索して実行スタックを戻っていく際、戻ったレベル
          毎に、トレースバックオブジェクトが現在のトレースバックの前に
          挿入されます。例外ハンドラに入ると、スタックトレースを
          プログラム側で利用できるようになります (~*Note try 文:: 節
          "`try' 文" を参照)。 トレースバックは `sys.exc_traceback'
          として得ることができ、 `sys.exc_info()'
          が返すタプルの三番目の要素としても得られます.
          インタフェースとしては後者の方が推奨されていますが、これは
          プログラムがマルチスレッドを使っている場合に正しく動作するからです。
          プログラムに適切なハンドラがない場合、スタックトレースは
          (うまく 書式化されて) 標準エラーストリームに書き出されます;
          インタプリタが
          対話的に実行されている場合、`sys.last_traceback' として
          得ることもできます。 

          読み出し専用の特殊属性: `tb_next' はスタックトレース内の
          (例外の発生しているフレームに向かって) 次のレベルです。
          次のレベルが存在しない場合には `None' になります; `tb_frame'
          は現在のレベルにおける実行フレームを指します; `tb_lineno'
          は例外の発生した行番号です; `tb_lasti'
          は厳密な命令コードです。トレースバック内の行番号や最後に実行された
          命令は、`try' 文内で例外が発生し、かつ対応する `except' 節や
          `finally' 節がない場合には、
          フレームオブジェクト内の行番号とは異なるかもしれません。 

    `スライス (slice) オブジェクト'
          スライスオブジェクトは _拡張スライス構文 (extended slice
          syntax)_
          が使われた際にスライスを表現するために使われます。拡張スライス構文とは、
          二つのコロンや、コンマで区切られた複数のスライスや省略符号
          (ellipse) を使ったスライスで、例えば `a[i:j:step]' 、 `a[i:j,
          k:l]' 、 あるいは `a[..., i:j]'
          です。スライスオブジェクトは組み込み関数 `slice()'  で生成されます。

          読み出し専用の特殊属性: `start' は下境界 (lower bound) です;
          `stop' は上境界 (upper bound) です; `step' はステップ値 (step
          value) です; それぞれ省略されている場合には `None'
          になります。 これらの属性は任意の型の値をとることができます。 

          スライスオブジェクトはメソッドを一つサポートします:

         `indices(self, length)'
               このメソッドは単一の整数引数 LENGTH を取り、LENGTH
               個の要素からなるシーケンスに適用した際にスライスオブジェクトから提供
               することになる、拡張スライスに関する情報を計算します。
               このメソッドは三つの整数からなるタプルを返します;
               それぞれ START および STOP のインデクスと、STEP または
               スライス間の幅に対応します。インデクス値がないか、範囲外の値
               である場合、通常のスライスに対して一貫性のあるやりかたで扱われます。
               _Added in Python version 2.3_

    `静的メソッド (static method) オブジェクト'
          静的メソッドは、上で説明したような関数オブジェクトからメソッド
          オブジェクトへの変換を阻止するための方法を提供します。静的メソッド
          オブジェクトは他の何らかのオブジェクト、通常はユーザ定義メソッド
          オブジェクトを包むラッパです。静的メソッドをクラスやクラスインスタンス
          から取得すると、実際に返されるオブジェクトはラップされたオブジェクト
          になり、それ以上は変換の対象にはなりません。静的メソッドオブジェクト
          は通常呼び出し可能なオブジェクトをラップしますが、静的オブジェクト自体は
          呼び出すことができません。静的オブジェクトは組み込みコンストラクタ
          `staticmethod()' で生成されます。

    `クラスメソッドオブジェクト'
          クラスメソッドオブジェクトは、静的メソッドオブジェクトに似て、
          別のオブジェクトを包むラッパであり、そのオブジェクトをクラスや
          クラスインスタンスから取り出す方法を代替します。
          このようにして取得したクラスメソッドオブジェクトの動作については、
          上の "ユーザ定義メソッド (user-defined method)"
          で説明されています。
          クラスメソッドオブジェクトは組み込みのコンストラクタ
          `classmethod()' で生成されます。




File: python-ref-jp.info,  Node: 新スタイルと旧スタイル,  Next: 特殊メソッド名,  Prev: 標準型の階層,  Up: データモデル

3.3 新スタイルと旧スタイル
==========================

クラスとインスタンスは好みに合わせて2種類の方法で記述することができます:
旧スタイルもしくはクラシックスタイルと新スタイルです。

Python
2.1以降では、ユーザが好んで指定した場合のみ旧スタイルが使用されます。
(旧スタイルの)クラスの概念と型の概念には関連性があります:
もしXが旧スタイルのクラスのインスタンスだった場合、
`x.__class__'というコードはクラスXを指定しますが、
`type(x)'は常に`<type'instance'>'となります。
これは、すべての旧スタイルのインスタンスが、それらのクラスがどのクラスであるか
にかかわらず、`instance'と呼ばれる一つの内蔵型として
実行されるということを反映しています。

新スタイルのクラスは、クラスと型を統一するためにPython
2.2で導入されました。
新スタイルのクラスはユーザ定義型と少しも変わりません。
もし、Xが新スタイルクラスのインスタンスであった場合、
`type(x)'は`x.__class__'と同じになります。

新スタイルクラスを導入する一番の理由は、メタモデルを用いた
統一的なオブジェクトモデルを提供することにあります。 これには、
また、ほとんどの組み込み型のサブクラスが作成できる、
属性を計算するための"デスクリプタ"の導入できる等の利点があります。

互換性のために、デフォルトではクラスは旧スタイルになります。
新スタイルのクラスは、他の新スタイルクラス
(すなわち型)を親クラスとして定義する、
もしくは、他の親クラスが必要ない場合に "最上位型" `object'
を継承することで 作成することができます。
新スタイルクラスの動作は旧スタイルクラスの動作とは、
`type'が何を返すかといったことをはじめ、何点か重要な部分が異なります。
特殊メソッドの呼び出しなど、これらの変更は新オブジェクトモデルの基盤となっています。
それ以外の部分は、多重継承時のメソッドの解決順などのように、
互換性の問題で以前は実装が不可能であった"修正"が新クラスに含まれています。

このマニュアルは新スタイルのクラスに対しては最新情報を含んでいません。
より詳細な情報を得たい場合は、
`http://www.python.org/doc/newstyle.html'を参照してください。

旧クラスを廃止にして、新クラスのセマンティクスのみを残すことが計画されています。
この変更は、Python 3.0で採用されることになるでしょう。 {new-style} {classic} {old-style}


File: python-ref-jp.info,  Node: 特殊メソッド名,  Prev: 新スタイルと旧スタイル,  Up: データモデル

3.4 特殊メソッド名
==================

特殊な名前をもったメソッドを定義することで、特殊な構文 (算術演算や
添え字表記、スライス表記のような) 特定の演算をクラスで実装することが
できます。 これは、個々のクラスが Python
言語で提供されている演算子に対応した
独自の振る舞いをできるようにするための、"演算子のオーバロード"
("operator overloading") に対する Python のアプローチです。
例えば、あるクラスが `__getitem__()' という名前のメソッドを定義
しており、`x' がこのクラスのインスタンスであるとすると、 `x[i]' は
`x.__getitem__(i)' と等価 (1) になります。特に注釈の
ない限り、適切なメソッドが定義されていない場合にこのような演算を行おうと
すると例外が送出されます。 

組み込み型をエミュレーションするようなクラスを実装する際には、
エミューレーションの実装をモデル化しようとしているオブジェクトで
意味のある範囲だけにとどめることが重要です。
例えば、シーケンスによっては個々の要素の取り出し操作が意味のある操作で
ある一方、スライスの抽出が意味をなさないことがあります。 (W3C
ドキュメントオブジェクトモデルにおける `NodeList'
インタフェースがその一例です。)

* Menu:

* 基本的なカスタマイズ::
* 属性値アクセスをカスタマイズする::
* クラス生成をカスタマイズする::
* 呼び出し可能オブジェクトをエミュレートする::
* コンテナをエミュレートする::
* シーケンス型エミュレーションで使われるその他のメソッド::
* 数値型をエミュレーションする::
* 型強制規則 coercion rule::
* with文とコンテキストマネージャ::

---------- Footnotes ----------

(1) この部分およびそれ以外の説明は、新スタイルクラスのインスタンス
についても概ね当てはまります。


File: python-ref-jp.info,  Node: 基本的なカスタマイズ,  Next: 属性値アクセスをカスタマイズする,  Prev: 特殊メソッド名,  Up: 特殊メソッド名

3.4.1 基本的なカスタマイズ
--------------------------

`__new__(cls[, args...])'
     クラス CLS の新しいインスタンスを作るために呼び出されます。
     `__new__()' は静的メソッドで (このメソッドは特別扱いされている
     ので、明示的に静的メソッドと宣言する必要はありません)、インスタンスを
     生成するよう要求されているクラスを第一引数にとります。残りの引数はオブ
     ジェクトのコンストラクタの式 (クラスの呼び出し文) に渡されます。
     `__new__()' の戻り値は新しいオブジェクトのインスタンス (通常は CLS
     のインスタンス) でなければなりません。

     典型的な実装では、クラスの新たなインスタンスを生成するときには
     `super(CURRENTCLASS, CLS).__new__(CLS[, ...])'
     に適切な引数を指定してスーパクラスの `__new__()'  メソッドを呼
     び出し、新たに生成されたインスタンスに必要な変更を加えてから返します。

     `__new__()' が CLS のインスタンスを返した場合、 `__init__(SELF[,
     ...])' のようにしてインスタンスの `__init__()'
     が呼び出されます。このとき、SELF は新たに生成
     されたインスタンスで、残りの引数は `__new__()' に渡された引数と
     同じになります。

     `__new__()' が CLS のインスタンスを返さない場合、インスタ ンスの
     `__init__()' メソッドは呼び出されません。

     `__new__()' の主な目的は、変更不能な型 (int, str, tuple など)
     のサブクラスでインスタンス生成をカスタマイズすることにあります。

`__init__(self[, ...])'
     インスタンスが生成された際に呼び出されるコンストラクタ
     (constructor) です。 引数はそのクラスのコンストラクタ式に渡した引数になります。
     基底クラスが`__init__()' メソッドを持っている場合、 導出クラスの
     `__init__()' メソッドでは、 例えば `BaseClass.__init__(SELF,
     [ARGS...])' の ように、必要ならば明示的に基底クラスの`__init__()'
     メソッドを
     呼び出して、インスタンスの基底クラスに関わる部分が正しく初期化される
     ようにしなければなりません。コンストラクタには、値を返してはならない
     という特殊な制限があります; 値を返すようにすると、実行時に
     `TypeError' の送出を引き起こします。

`__del__(self)'
     インスタンスが消滅させられる際に呼び出されます。このメソッドは
     デストラクタ (destructor)  とも呼ばれます。
     基底クラスが`__del__()' メソッドを持っている場合、 導出クラスの
     `__del__()' メソッドでは、必要ならば明示的に
     基底クラスの`__del__()' メソッドを
     呼び出して、インスタンスの基底クラスに関わる部分が正しく消滅処理
     されるようにしなければなりません。 `__del__()'
     メソッドでインスタンスに対する新たな参照を
     作ることで、インスタンスの消滅を遅らせることができます
     (とはいえ、推奨しません！)。このようにすると、新たに作成された
     参照がその後削除された際にもう一度 `__del__()' メソッド
     が呼び出されます。
     インタプリタが終了する際に残っているオブジェクトに対して、
     `__del__()' メソッドが呼び出される保証はありません。 

     _Notice:_ `del x' は直接 `x.__del__()' を呼び出しません -- 前者は
     `x' への参照カウント (reference count) を 1 つ減らし、 後者は `x'
     への参照カウントがゼロになった際にのみ呼び出されます。
     オブジェクトへの参照カウントがゼロになるのを妨げる可能性のある
     よくある状況には、以下のようなものがあります: 複数のオブジェクト間
     における循環参照
     (二重リンクリストや、親と子へのポインタを持つツリー データ構造);
     例外を捕捉した関数におけるスタックフレーム上にある
     オブジェクトへの参照 (`sys.exc_traceback' に記憶されている
     トレースバックが、スタックフレームを生き延びさせます);
     または、対話モードでハンドルされなかった例外を送出した
     スタックフレーム上にあるオブジェクトへの参照 (`sys.last_traceback'
     に記憶されているトレースバックが、
     スタックフレームを生き延びさせます);
     最初の状況については、明示的に循環参照を壊すしか解決策は
     ありません; 後者の二つの状況は、`None' を `sys.exc_traceback' や
     `sys.last_traceback' に
     入れることで解決できます。ごみオブジェクトと化した循環参照は、
     オプションの循環参照検出機構 (cycle detector) が有効にされて
     いる場合 (これはデフォルトの設定です) には検出されますが、
     検出された循環参照を消去するのは Python レベルで `__del__()'
     メソッドが定義されていない場合だけです。 `__del__()'
     メソッドが循環参照検出機構でどのように 扱われるか、とりわけ
     `garbage' 値の記述に関しては、 `gc' モジュール の
     ドキュメントを参照してください。

     _Notice:_ [warning] `__del__()'
     メソッドの呼び出しが起きるのは不安定な状況 なので、`__del__()'
     の実行中に発生した例外は無視され、 代わりに `sys.stderr'
     に警告が出力されます。また、 (例えばプログラムの実行終了による)
     モジュールの削除に伴って `__del__()'
     が呼び出される際には、`__del__()'
     メソッドが参照している他のグローバル変数はすでに削除されている
     かもしれません。この理由から、 `__del__()' メソッドでは
     外部の不変関係を維持する上で絶対最低限必要なことだけをすべき
     です。バージョン 1.5 からは、単一のアンダースコアで始まるような
     グローバル変数は、他のグローバル変数が削除される前にモジュール
     から削除されるように Python 側で保証しています; これらの
     アンダースコア付きグローバル変数は、`__del__()' が呼び
     出された際に、import されたモジュールがまだ残っているか確認
     する上で役に立ちます。


`__repr__(self)'
     組み込み関数`repr()'  や、文字列への 変換 (逆クオート表記: reverse
     quote) の際に呼び出され、 オブジェクトを表す "公式の (official)"
     文字列を計算します。
     可能な場合には、この値は同じ値を持ったオブジェクトを
     (適切な環境で) 再生成するために使えるような有効な Python 式に
     似せるべきです。それが不可能なら、`<...SOME USEFUL
     DESCRIPTION...>' 形式の文字列を返してください。
     戻り値は文字列オブジェクトでなければなりません。 クラスが
     `__repr__()' を定義しているが `__str__()'
     を定義していない場合、そのクラスのインスタンスに対する "非公式の
     (informal)" 文字列表現が必要なときにも `__repr__()' が使われます。

     この関数はデバッグの際によく用いられるので、たくさんの情報を
     含み、あいまいでないような表記にすることが重要です。 

`__str__(self)'
     組み込み関数 `str()'  および `print'  文によって呼び出され、
     オブジェクトを表す "非公式の" 文字列を計算します。
     このメソッドは、有効な Python 式を返さなくても良いという点で、
     `__repr__()' と異なります: その代わり、より便利で分かりやすい
     表現を返すようにしてください。戻り値は文字列オブジェクトで
     なければなりません。

`__lt__(self, other)'

`__le__(self, other)'

`__eq__(self, other)'

`__ne__(self, other)'

`__gt__(self, other)'

`__ge__(self, other)'
     _Added in Python version 2.1_ これらのメソッドは "拡張比較 (rich
     comparison)" メソッドと呼ばれ、 下記の `__cmp__()'
     に優先して呼び出されます。
     演算子シンボルとメソッド名の対応は以下の通りです: `X<Y' は
     `X.__lt__(Y)' を呼び出します; `X<=Y' は `X.__le__(Y)'
     を呼び出します; `X==Y' は `X.__eq__(Y)' を呼び出します; `X!=Y'
     および `X<>Y' は `X.__ne__(Y)' を呼び出します; `X>Y' は
     `X.__gt__(Y)' を呼び出します; `X>=Y' は `X.__ge__(Y)'
     を呼び出します。
     これらのメソッドは任意の値を返すことができますが、比較演算子が
     ブール値のコンテキストで使われた場合、戻り値はブール値として
     解釈可能でなければなりません。そうでない場合には `TypeError'
     が送出されます。 慣習的には、 `False' は偽値、 `True'
     は真値として用いられ ます。

     比較演算子間には、暗黙的な論理関係はありません。すなわち、 `X==Y'
     が真である場合、暗黙のうちに `X!=Y' が偽になるわけではありません。
     従って、`__eq__()' を実装する際、演算子が期待通りに
     動作するようにするために `__ne__()' も定義する必要があります。

     これらのメソッドには、(左引数が演算をサポートしないが、右引数は
     サポートする場合に用いられるような) 鏡像となる (引数を入れ替えた)
     バージョンは存在しません; むしろ、`__lt__()' と `__gt__()'
     は互いに鏡像であり、`__le__()' と `__ge__()' 、および `__eq__()' と
     `__ne__()' はそれぞれ互いに鏡像です。

     拡張比較メソッドの引数には型強制 (coerce) が起こりません。
     与えられた引数ペアの間で演算が実装されていない場合、拡張比較
     メソッドは `NotImplemented' を返します。

`__cmp__(self, other)'
     拡張比較 (上参照) が定義されていない場合、比較演算によって
     呼び出されます。`self < other' である場合には負の値、 `self ==
     other' ならばゼロ、`self > other' であれば
     正の値を返さなければなりません。演算 `__cmp__()' 、`__eq__()'
     および `__ne__()' がいずれも定義されていない場合、
     クラスインスタンスはオブジェクトのアイデンティティ ("アドレス")
     で比較されます。自作の比較演算をサポートするオブジェクトや、
     辞書のキーとして使えるオブジェクトを生成するには、 `__hash__()'
     に関する記述を参照してください。 (注意: `__cmp__()'
     が例外を伝播しないという制限は Python 1.5 から除去されました。) 

`__rcmp__(self, other)'
     _Changed in Python version 2.1_

`__hash__(self)'
     辞書演算  の際にキーとなるオブジェクトに対して
     呼び出されたり、組み込み関数 `hash()' から呼び出されたり します。
     辞書演算におけるハッシュ値として利用できる、32 ビットの
     整数を返さなければなりません。
     このメソッドに必要な性質は、比較結果が等価であるオブジェクトは
     同じハッシュ値をもつということです; オブジェクト間で比較を
     行う際には、オブジェクトの各要素に対するハッシュ値を
     (排他的論理和をとるなどして) 何らかの方法で混合するよう勧めます。
     クラスが `__cmp__()' メソッドを定義していない場合、 `__hash__()'
     メソッドも定義してはなりません; クラスが `__cmp__()' または
     `__eq__()' を定義しているが、 `__hash__()'
     を定義していない場合、インスタンスを
     辞書のキーとして使うことはできません。
     クラスが変更可能なオブジェクトを定義しており、`__cmp__()' または
     `__eq__()' メソッドを実装している場合、`__hash__()'
     を定義してはなりません。これは、辞書の実装においてハッシュ値が変更不能
     であることが要求されているからです (オブジェクトのハッシュ値が変化
     すると、キーが誤ったハッシュバケツ: hash bucket に入っていることに
     なってしまいます)。

     _Changed in Python version 2.5_


`__nonzero__(self)'
     真値テストや組み込み演算 `bool()' を実現するために呼び出され ます;
     `False' または `True' か、等価な整数値 `0' または `1'
     を返さなければなりません。
     このメソッドが定義されていない場合、`__len__()' (下記参照)
     が定義されていれば呼び出されます。`__len__()' と `__nonzero__()'
     のどちらもクラスで定義されていない場合、
     そのクラスのインスタンスはすべて真の値を持つものとみなされます。 

`__unicode__(self)'
     組み込み関数 `unicode()'  を実現 するために呼び出されます。Unicode
     オブジェクトを返さなければ
     なりません。このメソッドが定義されていなければ、文字列への
     変換が試みられ、その結果がデフォルトの文字エンコードを用いて
     Unicode に変換されます。


File: python-ref-jp.info,  Node: 属性値アクセスをカスタマイズする,  Next: クラス生成をカスタマイズする,  Prev: 基本的なカスタマイズ,  Up: 特殊メソッド名

3.4.2 属性値アクセスをカスタマイズする
--------------------------------------

以下のメソッドを定義して、クラスインスタンスへの属性値アクセス (
属性値の使用、属性値への代入、`x.name' の削除) の意味を
カスタマイズすることができます。

`__getattr__(self, name)'
     属性値の検索を行った結果、通常の場所に属性値が見つからなかった
     場合 (すなわち、`self' のインスタンス属性でなく、かつクラスツリー
     にも見つからなかった場合) に呼び出されます。 このメソッドは
     (計算された) 属性値を返すか、`AttributeError'
     例外を送出しなければなりません。

     通常のメカニズムを介して属性値が見つかった場合、`__getattr__()'
     は呼び出されないので注意してください。(`__getattr__()' と
     `__setattr__()' の間は意図的に非対称性にされています。
     これは`__getattr__()' および `__setattr__()' 双方に
     とっての効率性という理由と、こうしなければ `__setattr__()'
     がインスタンスの他の属性値にアクセスする方法がなくなるためです。
     少なくともインスタンス変数に対しては、値をインスタンスの属性値
     辞書に挿入しないようにして
     (代わりに他のオブジェクトに挿入することで)
     属性値が完全に制御されているように見せかけられることに注意してください。
     新スタイルクラスで実際に完全な制御を行う方法は、以下の
     `__getattribute__()' メソッドを参照してください。 

`__setattr__(self, name, value)'
     属性値への代入が試みられた際に呼び出されます。このメソッドは
     通常の代入メカニズム (すなわち、インスタンス辞書への値の代入)
     の代わりに呼び出されます。 NAME は属性名で、VALUE
     はその属性に代入する値です。

     `__setattr__()' の中でインスタンス属性値への代入が必要
     な場合、単に `self.NAME = value' としてはなりません --
     このようにすると、自分自身に対する再帰呼び出しがおきてしまいます。
     その代わりに、インスタンス属性の辞書に値を挿入してください。
     例えば、`self.__dict__[NAME] = value' とします。
     新しい形式のクラスでは、インスタンス辞書にアクセスするのではなく、
     基底クラスのメソッドを同じ属性名で呼び出します。例えば、
     `object.__setattr__(self, name, value)' とします。 

`__delattr__(self, name)'
     `__setattr__()' に似ていますが、代入ではなく値の削除を
     行います。このメソッドを実装するのは、オブジェクトにとって `del
     obj.NAME' が意味がある場合だけにしなければなりません。

* Menu:

* 新しい形式のクラスのための別の属性アクセス::
* デスクリプタ descriptor の実装::
* デスクリプタを呼び出す::
* __slots__::


File: python-ref-jp.info,  Node: 新しい形式のクラスのための別の属性アクセス,  Next: デスクリプタ descriptor の実装,  Prev: 属性値アクセスをカスタマイズする,  Up: 属性値アクセスをカスタマイズする

3.4.2.1 新しい形式のクラスのための別の属性アクセス
..................................................

以下のメソッドは新しい形式のクラス (new-style class) のみに
適用されます。

`__getattribute__(self, name)'
     クラスのインスタンスに対する属性アクセスを実装するために、無条件に
     呼び出されます。クラスが `__getattr__()' も定義している
     場合、`__getattr__()' は 、
     `__getattribute__()'で明示的に呼び出すか、 `AttributeError'
     例外を送出しない限り呼ばれないでしょう。
     呼び出されることはありません。このメソッドは (計算された) 属性値を
     返すか、`AttributeError' 例外を送出します。
     このメソッドが再帰的に際限なく呼び出されてしまうのを防ぐため、
     実装の際には常に、例えば `object.__getattribute__(self, name)'
     のように基底クラスのメソッドを同じ属性名を使って呼び出し、
     必要な属性値全てにアクセスしなければなりません。


File: python-ref-jp.info,  Node: デスクリプタ descriptor の実装,  Next: デスクリプタを呼び出す,  Prev: 新しい形式のクラスのための別の属性アクセス,  Up: 属性値アクセスをカスタマイズする

3.4.2.2 デスクリプタ (descriptor) の実装
........................................

以下のメソッドは、デスクリプタメソッドを持っているクラス (いわゆる
_デスクリプタ (descriptor)_ クラス) のインスタンスが
別の新たな形式のクラス、いわゆる _オーナ (owner)_ クラスの
クラス辞書に存在する場合にのみ適用されます。 以下の例での "属性"
とは、属性の名前が オーナクラスの `__dict__' に入っているプロパティ
(porperty) を検索するためのキーになっているような属性を指します。

`__get__(self, instance, owner)'
     オーナクラスやの属性を取得する (クラス属性へのアクセス) 際や、
     オーナクラスのインスタンスの属性を取得する (インスタンス属性への
     アクセス) 場合に呼び出されます。OWNER は常にオーナクラスです。
     一方、INSTANCE は属性へのアクセスを仲介するインスタンスか 属性が
     OWNER を介してアクセスされる場合は `None' に
     なります。このメソッドは (計算された) 属性値を返すか、
     `AttributeError' 例外を送出しなければなりません。

`__set__(self, instance, value)'
     オーナクラスのインスタンス INSTANCE 上の属性を新たな値 VALUE
     に設定する際に呼び出されます。

`__delete__(self, instance)'
     オーナクラスのインスタンス INSTANCE 上の属性を削除する際に
     呼び出されます。


File: python-ref-jp.info,  Node: デスクリプタを呼び出す,  Next: __slots__,  Prev: デスクリプタ descriptor の実装,  Up: 属性値アクセスをカスタマイズする

3.4.2.3 デスクリプタを呼び出す
..............................

一般にデスクリプタとは、 特殊な "束縛に関する動作 (binding behaviour)"
をもつオブジェクト属性のことです。デスクリプタは、デスクリプタ
プロトコル (descriptor protocol) のメソッド: `__get__()', `__set__()',
および `__delete__()'
を使って、属性アクセスをオーバライドしているものです。
これらのメソッドのいずれかがオブジェクトに対して定義されている場合、
オブジェクトはデスクリプタであるといいます。

属性アクセスのデフォルトの動作は、オブジェクトの辞書から値を取り出したり、
値を設定したり、削除したりするというものです。例えば、`a.x' による
属性の検索では、まず `a.__dict__['x']' 、次に `type(a).__dict__['x']'
、そして`type(a)' の基底クラスで
メタクラスでないものに続く、といった具合に連鎖が起こります。

しかしながら、検索対象となる値が、デスクリプタメソッドのいずれかを
定義しているオブジェクトの属性値である場合、Python はデフォルトの動作を
オーバライドして、デスクリプタメソッドの方を呼び出します。

前後する呼び出し連鎖の中のどこでデスクリプタメソッドが呼び出されるかは、
どのデスクリプタメソッドが定義されているかと、どうやってデスクリプタ
メソッドが呼ばれるかに依存します。デスクリプタは新しい形式のオブジェクトや
クラス (`object()' や `type()' をサブクラス化したもの) だけに
対して呼び出されるので注意してください。

デスクリプタ呼び出しの基点となるのは、属性名への束縛 (binding)
、すなわち `a.x' です。引数がどのようにデスクリプタに結合されるかは `a'
に 依存します:

   * 直接呼出し (Direct Call) 最も単純で、かつめったに使われない
     呼び出し操作は、コード中で直接デスクリプタメソッドの呼び出し:
     `x.__get__(a)' を行うというものです。

   * インスタンス束縛 (Instance Binding) 新しい形式のクラスの
     インスタンスに対する束縛では、`a.x' は呼び出し:
     `type(a).__dict__['x'].__get__(a, type(a))' に変換されます。

   * クラス束縛 (Class Binding) 新しい形式のクラスに対する束縛では、
     `A.x' は呼び出し: `A.__dict__['x'].__get__(None, A)'
     に変換されます。

   * スーパクラス束縛 (Super Binding) `a' が `super'
     のインスタンスである場合、束縛 `super(B, obj).m()' を行うと まず
     `A' 、続いて `B'に対して `obj.__class_.__mro__' を
     検索し、次に呼び出し: `A.__dict__['m'].__get__(obj, A)' で
     デスクリプタを呼び出します。


インスタンス束縛では、デスクリプタ呼び出しの優先順位はどのデスクリプタが
定義されているかに依存します。データデスクリプタでは、 `__get__()' と
`__set__()' を定義します。非データ デスクリプタには `__get__()'
メソッドしかありません。
インスタンス辞書内で属性値が再定義されても、データデスクリプタは常に
この値をオーバライドします。対照的に、非データデスクリプタの
場合には、属性値はインスタンス側でオーバライドされます。

(`staticmethod()' や `classmethod()' を含む) Python
メソッドは、非データデスクリプタとして実装されています。その結果、
インスタンスではメソッドを再定義したりオーバライドできます。
このことにより、個々のインスタンスが同じクラスの他のインスタンスと
互いに異なる動作を獲得することができます。

`property()' 関数はデータデスクリプタとして実装されています。
従って、インスタンスはあるプロパティの動作をオーバライドすることが
できません。


File: python-ref-jp.info,  Node: __slots__,  Prev: デスクリプタを呼び出す,  Up: 属性値アクセスをカスタマイズする

3.4.2.4 __slots__
.................

デフォルトでは、新旧どちらのクラスも、属性の記憶領域として使うための
辞書を持っています。この仕様は、ほとんどインスタンス変数を持たない
ようなオブジェクトの場合には記憶領域の無駄遣いになります。
記憶領域の消費量は、大量のインスタンスを生成する際には深刻です。

このデフォルトの設定は、新たな形式のクラス定義において __SLOTS__ を
定義することでオーバライドできます。__SLOTS_ 宣言はインスタンス
変数のシーケンスを受け取ります。各々のインスタンス上には、各変数の値を
記憶するのにちょうど必要な量だけの記憶領域を確保します。
各々のインスタンスに対して __DICT__ が生成されることがないので、
記憶領域が節約されます。

`__slots__'
     このクラス変数には、文字列、反復可能オブジェクト、あるいはインスタンスが
     用いる変数名を表す文字列からなるシーケンスを代入することができます。
     この変数が新しい形式のクラスで定義されている場合、__SLOTS__
     は、各インスタンスに対して宣言された変数に必要な記憶領域を確保し、
     __DICT__ と__WEAKREF__ が自動的に生成されないようにします。 _Added
     in Python version 2.2_

__SLOTS__ を利用する際の注意

   * __DICT__ 変数がない場合、__SLOTS__ に列挙されていない
     新たな変数をインスタンスに代入することはできません。
     列挙されていない変数名を使って代入しようとした場合、
     `AttributeError' が送出されます。
     新たな変数を動的に代入したいのなら、__SLOTS__ を宣言する際に
     `'__dict__'' を変数名のシーケンスに追加してください。

     _Changed in Python version 2.3_

   * __SLOTS__ を定義しているクラスの各インスタンスに __WEAKREF__
     変数がない場合、インスタンスに対する弱参照 (weak reference)
     はサポートされません。 弱参照のサポートが必要なら、 __SLOTS__
     を宣言する際に `'__weakref__''
     を変数名のシーケンスに追加してください。 _Changed in Python
     version 2.3_

   * __SLOTS__ は、クラスのレベルで各変数に対するデスクリプタ (*Note
     デスクリプタ descriptor の実装:: を参照)
     を使って実装されます。その結果、 __SLOTS__
     に定義されているインスタンス変数のデフォルト値は
     クラス属性を使って設定できなくなっています; そうしないと、
     デスクリプタによる代入をクラス属性が上書きしてしまうからです。

   * あるクラスで、基底クラスですでに定義されているスロットを
     定義した場合、基底クラスのスロットで定義されているインスタンス変数は
     (デスクリプタを基底クラスから直接取得しない限り) アクセスできなく
     なります。これにより、プログラムの趣意が不定になってしまいます。
     将来は、この問題を避けるために何らかのチェックが追加されるかもしれません。

   * __SLOTS__ 宣言が動作するのは、定義が行われたクラスだけに
     限られています。その結果、サブクラスでは、__SLOTS__ を定義
     しない限り __DICT__ を持つことになります。

   * __SLOTS__ は、`long'、 `str'、および `tuple' といった、"可変長
     (variable-length)" の組み込み型
     から導出されたクラスでは動作しません。

   * __SLOTS__ には、文字列でない反復可能オブジェクトを
     代入することができます。辞書型も使うことができます; しかし将来、
     辞書の各キーに相当する値に何らかの特殊な意味が割り当てられる
     かもしれません。



File: python-ref-jp.info,  Node: クラス生成をカスタマイズする,  Next: 呼び出し可能オブジェクトをエミュレートする,  Prev: 属性値アクセスをカスタマイズする,  Up: 特殊メソッド名

3.4.3 クラス生成をカスタマイズする
----------------------------------

デフォルトでは、新スタイルクラスは `type()' を使って構築
されます。クラス定義が別の名前空間に読み込まれ、 クラス名は `type(name,
bases, dict)' の結果に結合されます。

クラス定義が読み込まれる際、__METACLASS__ が定義されていれば、 `type()'
の代わりに __METACLASS__ が指している
呼び出し可能オブジェクトが呼び出されます。 これによって、

   * クラスが生成される前にクラス辞書を変更する

   * 他のクラスのインスタンスを返す - 本質的にはファクトリ関数の役割を
     果たす

といった、クラス生成のプロセスを監視したり置き換えたりする
クラスや関数を書くことができます。

`__metaclass__'
     この変数は `name'、`bases'、および `dict' を引数として
     取るような任意の呼び出し可能オブジェクトにできます。
     クラス生成の際、組み込みの `type()' の代わりに、指定された
     呼び出しオブジェクトが呼び出されます。 _Added in Python version
     2.2_

以下に優先順で並んだ規則によって、適切なメタクラスが決定されます:

   * `dict['__metaclass__']' があればそれを使います。

   * それ以外の場合で、最低でも一つ基底クラスを持っているなら、
     基底クラスのメタクラス (__CLASS__ 属性を探し、なければ
     基底クラスの型) を使います。

   * それ以外の場合で、__metaclass__ という名前のグローバル変数
     があれば、それをつかいます。

   * それ以外の場合には、旧スタイルのメタクラス (types.ClassType)
     を使います。


メタクラスは限りない潜在的利用価値を持っています。これまで試されて
きたアイデアには、ログ記録、インタフェースのチェック、
自動デリゲーション、自動プロパティ生成、プロキシ、フレームワーク、
そして自動リソースロック／同期といったものがあります。


File: python-ref-jp.info,  Node: 呼び出し可能オブジェクトをエミュレートする,  Next: コンテナをエミュレートする,  Prev: クラス生成をカスタマイズする,  Up: 特殊メソッド名

3.4.4 呼び出し可能オブジェクトをエミュレートする
------------------------------------------------

`__call__(self[, args...])'
     インスタンスが関数として "呼ばれた" 際に呼び出されます;
     このメソッドが定義されている場合、`X(arg1, arg2, ...)' は
     `X.__call__(arg1, arg2, ...)' を短く書いたものに なります。 


File: python-ref-jp.info,  Node: コンテナをエミュレートする,  Next: シーケンス型エミュレーションで使われるその他のメソッド,  Prev: 呼び出し可能オブジェクトをエミュレートする,  Up: 特殊メソッド名

3.4.5 コンテナをエミュレートする
--------------------------------

以下のメソッドを定義して、コンテナオブジェクトを実装することができます。
コンテナは通常、(リストやタプルのような) シーケンスや、(辞書のような)
マップ型を指しますが、他のコンテナも同じように表現することができます。
最初の一連のメソッドは、シーケンスをエミュレートしたり、マップ型を
エミュレートするために使われます; その違いとして、シーケンスの場合には、
キーとして許されているのが、シーケンスの長さが N であるときの `0 <= K <
N' なる整数 K か、あるいは
要素の範囲を表すスライスオブジェクトでなければならないということです。
(後方互換性のため、`__getslice__()' (以下参照) を
定義して、拡張されていない単純なスライスを扱うようにもできます。)
変更可能なシーケンスでは、Python の標準リストオブジェクトのように、
メソッド `append()'、 `count()'、 `index()'、`extend()'、`insert()'、
`pop()'、 `remove()'、`reverse()'、および`sort()' を
提供しなければなりません。 マップ型でも、Python
の標準辞書オブジェクトのように、 `keys()'、 `values()'、 `items()'、
`has_key()'、 `get()'、 `clear()'、 `setdefault()'、`iterkeys()'、
`itervalues()'、 `iteritems()'、 `pop()'、 `popitem()'、 `copy()'、
および `update()' といったメソッドをマップ型
で提供するよう推奨しています。`UserDict' モジュールでは、
これらのメソッドを`__getitem__()'、 `__setitem__()'、
`__delitem__()'、および `keys()' といった基本セットから
作成する上で役に立つ `DictMixin' クラスを提供しています。
最後に、シーケンス型では以下に述べるメソッド群 `__add__()'、
`__radd__()'、 `__iadd__()'、`__mul__()'、 `__rmul__()'、および
`__imul__()'  を定義して、 (シーケンス間の結合を意味する) 加算操作と
(要素の繰り返しを 意味する) 乗算操作を実装しなければなりません;
`__coerce__()' や、その他の数値演算子を定義してはなりません。
マップでもシーケンスでも、`in' 演算子が有効利用できるように
`__contains__()' メソッドの定義を推奨します; マップ型では、 `in'
は`has_key()' と等価でなければなりません; シーケンスでは、
シーケンス内の値にわたって検索を行わなければなりません。さらに、
マップでもシーケンスでも、コンテナ内にわたる反復操作ができるようにするため、
`__iter__()' を実装するよう勧めます; マップ型の場合、 `__iter__()' は
`iterkeys()' と等価でなければなりません;
シーケンスの場合、シーケンス内の値にわたって反復操作を行わなければなりません。 

`__len__(self)'
     組み込み関数 `len()'  を実現するために
     呼び出されます。オブジェクトの長さを `>=' 0 である整数で
     返さなければなりません。また、オブジェクトが `__nonzero__()'
     メソッドを定義しておらず、`__len__()' メソッドがゼロを
     返す場合には、ブール演算コンテキストでは偽であるとみなされます。 

`__getitem__(self, key)'
     `SELF[KEY]' の値評価 (evaluation) を実現するために 呼び出されます。
     シーケンスの場合、キーとして整数とスライスオブジェクトを受理できなければ
     なりません。   (シーケンス型をエミュレートする場合)
     負のインデクスの解釈は `__getitem__()' メソッド次第と
     なります。KEY が不適切な型であった場合、`TypeError'
     を送出してもかまいません; (負のインデクス値に対して何らかの解釈
     を行った上で) KEY がシーケンスのインデクス集合外の値である場合、
     `IndexError' を送出しなければなりません。 マップ型の場合は、KEY
     に誤りがある場合 （コンテナに含まれていない場合）、 `IndexError'
     を送出しなければなりません。 _Note:_ `for'
     ループでは、シーケンスの終端を正しく検出できるように
     するために、不正なインデクスに対して `IndexError'
     が送出されるものと期待しています。

`__setitem__(self, key, value)'
     `SELF[KEY]' に対する代入を実現するために呼び出されます。
     `__getitem__()' と同じ注意事項があてはまります。
     このメソッドを実装できるのは、あるキーに対する値の変更をサポートしているか、
     新たなキーを追加できるようなマップの場合と、ある要素を置き換えることができる
     シーケンスの場合だけです。不正な KEY に対しては、`__getitem__()'
     メソッドと同様の例外の送出を行わなければなりません。

`__delitem__(self, key)'
     `SELF[KEY]' の削除を実現するために呼び出されます。 `__getitem__()'
     と同じ注意事項があてはまります。
     このメソッドを実装できるのは、キーの削除をサポートしているマップの場合と、
     要素を削除できるシーケンスの場合だけです。 不正な KEY
     に対しては、`__getitem__()'
     メソッドと同様の例外の送出を行わなければなりません。

`__iter__(self)'
     このメソッドは、コンテナに対してイテレータが要求された際に呼び出されます。
     このメソッドは、コンテナ内の全てのオブジェクトにわたる反復処理ができる
     ような、新たなイテレータオブジェクトを返さなければなりません。
     マップの場合、コンテナ内のキーに渡る反復処理でなければならず、
     かつ`iterkeys()' によって利用できなければなりません。

     イテレータオブジェクトでもこのメソッドを実装する必要があります;
     イテレータの場合、自分自身を返さなければなりません。イテレータオブジェクト
     に関するより詳細な情報は、

     の "イテレータ型" を参照してください。

メンバシップテスト演算子 (`in' および `not in') は通常、
シーケンスに渡る反復処理を使って実装されます。しかし、コンテナオブジェクト
で以下の特殊メソッドを定義して、より効率的な実装を行ったり、オブジェクト
がシーケンスでなくてもよいようにできます。

`__contains__(self, item)'
     メンバシップテスト演算を実現するために呼び出されます。 ITEM が
     SELF 内に存在する場合には真を、そうでない場合には
     偽を返さなければなりません。マップオブジェクトの場合、値やキーと値の
     組ではなく、キーに対するメンバシップテストを考えなければなりません。


File: python-ref-jp.info,  Node: シーケンス型エミュレーションで使われるその他のメソッド,  Next: 数値型をエミュレーションする,  Prev: コンテナをエミュレートする,  Up: 特殊メソッド名

3.4.6 シーケンス型エミュレーションで使われるその他のメソッド
------------------------------------------------------------

以下のオプションとなるメソッドを定義して、シーケンスオブジェクトをより高度に
エミュレーションできます。変更不能なシーケンスのメソッドでは、
`__getslice__()' が定義できるだけです; 変更可能なシーケンスでは
三つのメソッド全てを定義できます。

`__getslice__(self, i, j)'
     _This is deprecated in Python 2.0.  スライスオブジェクトは
     `__getitem__()' メソッドの
     パラメタとしてサポートするようになりました。_

     `SELF[I:J]' の値評価を実現するために呼び出され
     ます。返されるオブジェクトは SELF と同じ型でなければなりません。
     スライス表記で I や J がない場合には、それぞれゼロや `sys.maxint'
     に置き換えられるので注意してください。
     スライスに負のインデクスが用いられた場合、シーケンスの長さがインデクス値に
     加算されます。インスタンスが `__len__()' メソッドを実装して
     いない場合には、`AttributeError' が送出されます。
     この計算の結果、インデクス値が負でなくなるという保証はありません。
     シーケンスの長さよりも大きなインデクス値は修正されません。
     `__getslice__()' が定義されていない場合、代わりに
     スライスオブジェクトが生成されて `__getitem__()' に渡されます。

`__setslice__(self, i, j, sequence)'
     `SELF[I:J]' への代入を実現するために呼び出され ます。I および J
     に関しては、`__getslice__()' と同じ注釈があてはまります。

     このメソッドは撤廃されています。 `__setslice__()' がないか、
     `SELF[I:J:K]' 形式の拡張スライス の場合には、`__setslice__()'
     が呼ばれる代わりにスライス オブジェクトが生成され、`__setitem__()'
     に渡されます。

`__delslice__(self, i, j)'
     `SELF[I:J]' の削除を実現するために 呼び出されます。I および J
     に関しては、`__getslice__()' と同じ注釈があてはまります。

     このメソッドは撤廃されています。 `__delslice__()' がないか、
     `SELF[I:J:K]' 形式の拡張スライス の場合には、`__delslice__()'
     が呼ばれる代わりにスライス オブジェクトが生成され、`__delitem__()'
     に渡されます。

これらのメソッドは、単一のコロンを使った単一のスライスで、かつ
スライスメソッドが利用できるときにだけ呼び出されることに注意
してください。拡張スライス表記を含んでいるスライス表記や、
スライスメソッドがない場合、`__getitem__()'、 `__setitem__()'
、あるいは `__delitem__()' が
スライスオブジェクトを引数として呼び出されます。

以下の例は、プログラムやモジュールを以前のバージョンの Python
に対して互換性を持たせる方法を示したものです (`__getitem__()'、
`__setitem__()' 、および `__delitem__()'
は引数としてスライスオブジェクトを サポートするものと仮定します):

     class MyClass:
         ...
         def __getitem__(self, index):
             ...
         def __setitem__(self, index, value):
             ...
         def __delitem__(self, index):
             ...

         if sys.version_info < (2, 0):
             # They won't be defined if version is at least 2.0 final

             def __getslice__(self, i, j):
                 return self[max(0, i):max(0, j):]
             def __setslice__(self, i, j, seq):
                 self[max(0, i):max(0, j):] = seq
             def __delslice__(self, i, j):
                 del self[max(0, i):max(0, j):]
         ...

`max()' を呼び出していることに注意してください; この呼び出し
`__*slice__()' メソッド呼び出される前に、負のインデクス値を処理
しておくために必要です。 負のインデクス値が使われた場合、 `__*item__()'
メソッドは与えら れた値をそのまま使いますが、`__*slice__()' メソッドは
"調理済みの (cooked)" 形式になったインデクス値を受け取ります。
負のインデクス値が使われると、メソッドを呼び出す前に、常にシーケンスの長さを
インデクス値に加算します (加算してもまだ負の値となっていてもかまいませ
ん);
これは、組み込みシーケンス型における慣習的な負のインデクス処理方法で、
`__*item__()' メソッドでも同様の処理を行うよう期待しています。
しかし、ここではすでに負のインデクス値の処理を行っているので、負のイン
デクスを渡すべきではありません; インデクス値は、`__*item__()'
メソッドに渡される前に、シーケンスのインデクス集合の境界に制限されていなけれ
ばなりません。`max(0, i)' を呼び出せば、適切な値を返すので便利です。


File: python-ref-jp.info,  Node: 数値型をエミュレーションする,  Next: 型強制規則 coercion rule,  Prev: シーケンス型エミュレーションで使われるその他のメソッド,  Up: 特殊メソッド名

3.4.7 数値型をエミュレーションする
----------------------------------

以下のメソッドを定義して、数値型オブジェクトをエミュレートすることがで
きます。特定の種類の数値型ではサポートされていないような演算に対応する
メソッド (非整数の数値に対するビット単位演算など) は、未定義のままにし
ておかなければなりません。

`__add__(self, other)'

`__sub__(self, other)'

`__mul__(self, other)'

`__floordiv__(self, other)'

`__mod__(self, other)'

`__divmod__(self, other)'

`__pow__(self, other[, modulo])'

`__lshift__(self, other)'

`__rshift__(self, other)'

`__and__(self, other)'

`__xor__(self, other)'

`__or__(self, other)'
     これらのメソッドは、二項算術演算 ( `+', `-', `*', `//', `%',
     `divmod()' , `pow()' , `**', `<<', `>>', `&', `^', `|')
     を実現するために呼び出されます。例えば、式 X`+'Y の場合、X が
     `__add__()' メソッドをもつクラスのインスタン
     スであれば、`X.__add__(Y)' が呼び出されます。 `__divmod__()'
     メソッドは、`__floordiv__()' と `__mod__()'
     を使った場合と等価にならなければなりません; `__truediv__()'
     (下記参照) と関連づける必要はありません。
     組み込みの三項演算子バージョンの関数 `pow()'  をサポートする場合には、
     `__pow__()' は、オプションとなる第三の引数を受け取れなくては
     なりません。

     こらのメソッドが渡された引き数に対する操作を提供していない場合には、
     `NotImplemented' を送出しなければなりません。

`__div__(self, other)'

`__truediv__(self, other)'
     除算演算 (`/') は、これらのメソッドで実現されています。
     `__truediv__()' は、 `__future__.division' が有効であると
     きに使われます。それ以外の場合には `__div__()' が使われますs。
     二つのメソッドのうち一方しか定義されていなければ、オブジェクトは
     他方の演算コンテキストをサポートしなくなります; このとき、
     `TypeError' が送出されます。

`__radd__(self, other)'

`__rsub__(self, other)'

`__rmul__(self, other)'

`__rdiv__(self, other)'

`__rtruediv__(self, other)'

`__rfloordiv__(self, other)'

`__rmod__(self, other)'

`__rdivmod__(self, other)'

`__rpow__(self, other)'

`__rlshift__(self, other)'

`__rrshift__(self, other)'

`__rand__(self, other)'

`__rxor__(self, other)'

`__ror__(self, other)'
     これらのメソッドは二項算術演算 (`+', `-', `*', `/', `%', `divmod()' ,
     `pow()' , `**', `<<', `>>', `&', `^', `|')
     を実現しますが、メソッド呼び出しが行われ る被演算子が逆転して
     (reflected, swapped: 入れ替えられて) います。
     これらの関数は、左側の被演算子が対応する演算をサポートしておらず
     かつ両者の演算子が異なる場合にのみ呼び出されます。(1)

     例えば、X`-'Y の式を評価する場合、 Y が `__rsub__()'
     メソッドを持つクラスのインスタンスであ って、しかも `X.__sub__(Y)'
     が NOTIMPLEMENTED を返す場合には、 `Y.__rsub__(X)'
     が呼び出されます。

     ただし、三項演算子 `pow()'  が `__rpow__()' を呼ぶことは
     ないので注意してください (型強制の規則が非常に難解になるからです)。

     _Note:_ 右側の被演算子の型が左側の被演算子の型のサブクラスであり、
     このサブクラスであるメソッドに対する逆転メソッドが定義されている場合には、
     左側の被演算子の非逆転メソッドが呼ばれる前に、このメソッドが呼ばれます。
     この振る舞いにより、サブクラスが親の操作をオーバーライドすることが
     可能になります。

`__iadd__(self, other)'

`__isub__(self, other)'

`__imul__(self, other)'

`__idiv__(self, other)'

`__itruediv__(self, other)'

`__ifloordiv__(self, other)'

`__imod__(self, other)'

`__ipow__(self, other[, modulo])'

`__ilshift__(self, other)'

`__irshift__(self, other)'

`__iand__(self, other)'

`__ixor__(self, other)'

`__ior__(self, other)'
     これらのメソッドは、累算算術演算 (augmented arithmetic operations,
     `+=', `-=', `*=', `/=', `%=', `**=', `<'`<=', `>'`>=', `&=',
     `**=', `<'`<=', `>'`>=', `&=', `^=', `|=')
     を実現するために呼び出されます。
     これらのメソッドは、演算をその場で(SELF を変更する形で)
     行うよう試み、その結果(変更された SELF またはその代わり
     のもの)を返さなければなりません。
     特定のメソッドが定義されていない場合、その累算算術演算は通常のメソッド
     で代用されます。例えば、X`+='Y を評価する際、 X が `__iadd__()'
     メソッドを持つクラスのインスタンスで あれば、`X.__iadd__(Y)'
     が呼び出されます。反対に、 X が `__iadd()'
     メソッドを持たないクラスのインスタンスで あれば、X`+'Y に基づいて
     `X.__add__(Y)' および `Y.__radd__(X)' を考慮します。

`__neg__(self)'

`__pos__(self)'

`__abs__(self)'

`__invert__(self)'
     単項算術演算 (`-', `+', `abs()'  および `~{}')
     を実現するために呼び出されます。

`__complex__(self)'

`__int__(self)'

`__long__(self)'

`__float__(self)'
     組み込み関数 `complex()' , `int()' , `long()' , および `float()'  を実現するために呼び出さ
     れます。適切な型の値を返さなければなりません。

`__oct__(self)'

`__hex__(self)'
     組み込み関数 `oct()'  および `hex()' を実現するために呼び出されます。文字列型を返さなければなりません。

`__index__(self)'
     `operator.index()' を実装するために呼び出されます。
     また、（スライシング）のように Python
     が整数オブジェクトを必要とする 場合には何処でも呼び出されます。
     整数（int もしくは long） を返す必要があります。 _Added in Python
     version 2.5_

`__coerce__(self, other)'
     "型混合モード (mixed-mode)" での数値間の算術演算を実現するために
     呼び出されます。 SELF と OTHER を共通の数値型に変換して、 2
     要素のタプルにして返すか、不可能な場合には `None' を返さなけれ
     ばなりません。共通の型が `other' の型になる場合、 `None' を
     返すだけで十分です。この場合、インタプリタはもう一方のオブジェクトを調
     べて型強制を行おうとするからです
     (とはいえ、もう一方の値の型が実装上変 更できない場合には、ここで
     SELF を OTHER の型に変換してお いた方が便利です)。戻り値に
     `NotImplemented' を使うのは、 `None' を返すのと同じです。

---------- Footnotes ----------

(1)  同じ型の操作に対しては、
（`__add__()'のような）逆転できないメソッドが失敗した時と
同じような想定のもと処理されます。
これは、逆転したメソッドを呼び出すことができないからです。


File: python-ref-jp.info,  Node: 型強制規則 coercion rule,  Next: with文とコンテキストマネージャ,  Prev: 数値型をエミュレーションする,  Up: 特殊メソッド名

3.4.8 型強制規則 (coercion rule)
--------------------------------

本節では、型強制 (coercion) に関する規則について記述します。
プログラム言語が進化するにつれ、型強制規則について正確に
記述するのは難しくなってゆきます; 従って、あるバージョンのある
実装について記述するのは望ましくありません。その代わりに、
型強制に関する非公式的なガイドラインを示しておきます。 Python 3.0
からは、型強制がサポートされなくなる予定です。

   * % 演算子の左被演算子が文字列か Unicode オブジェクトの場合、
     型強制は起きず、文字列としての書式化操作が呼び出されます。

   * 型強制演算の定義はもはや推奨されていません。
     型強制を定義していない混合型 (mixed-mode) 演算は、
     もとの引数をそのまま演算操作に渡すようになっています。

   * 新しい形式のクラス (`object' から導出されたもの) が、
     二項演算子に対して `__coerce__()' メソッドを呼び出すことは
     ありません。; `__coerce__()' が呼び出されるのは、組み込み 関数
     `coerce()' が呼び出されたときだけです。

   * 事実上、 `NotImplemented' を返す演算子は、全く実装されていないも
     のとして扱われます。

   * 以下の説明では、`__op__()' および `__rop__()' は、演算子
     に相当する一般的なメソッド名を表すために使われます; `__iop__'
     はインプレース演算子を表します。例えば、演算子 ``+'' の場合、
     `__add__()' および `__radd__()' がそれぞれ左右の被演算子
     用の二項演算子として使われ、`__iadd__()' がインプレース演算用の演
     算子として使われる、といった具合です。

   * オブジェクト X および Y に対して、 まず `X.__op__(Y)'
     が試されます。この演算が実装されて いないか、`NotImplemented'
     を返す場合、次に `Y.__rop__(X)'
     が試されます。この演算も実装されていな いか、`NotImplemented'
     を返すなら、 `TypeError'
     例外が送出されます。ただし、以下の例外があるので参照してください:

   * 前項に対する例外:
     左被演算子が組み込み型や新スタイルクラスのインスタンスで
     あり、かつ右被演算子が左被演算子と同じクラスか適切なサブクラスのインス
     タンスであり、さらに親クラスの`__rop__()'メソッドをオーバライドしている場合、
     左被演算子の `__op__()' メソッドを試す _前に_ 右被演算子の
     `__rop__()' が試されます。
     これは、サブクラス側で二項演算子を完全にオーバライドできるようにするた
     めです。そうしなければ、常に左被演算子の `__op__()'
     メソッドが右被演算子を 受理してしまいます:
     あるクラスのインスタンスが被演算子になるとされてい
     る場合、そのサブクラスのインスタンスもまた受理可能だからです。

   * 双方の被演算子が型強制を定義している場合、型強制は被演算子の型の
     `__op__()' や `__rop__()' メソッドが呼び出される前に呼
     び出され、それより早くなることはありません。型強制の結果、型強制を行う
     ことになったいずれの被演算子とも異なる型が返された場合、返されたオブジェ
     クトの新たな型を使って、この過程が部分的に再度行われます。

   * (``+='' のような) インプレース型の演算子を用いる際、左被演算子が
     `__iop__()' を実装していれば、`__iop__()' が呼び出され、
     型強制は一切行われません。演算が `__op__()' かつ/または
     `__rop__()' に帰着した場合、通常の型強制規則が適用されます。

   * X`+'Y において、 X が結合 (concatenation) 演算
     を実装しているシーケンスであれば、シーケンスの結合が実行されます。

   * X`*'Y において、一方の演算子が繰り返し (repeat) 演算
     を実装しているシーケンスであり、かつ他方が整数 (`int' または
     `long') である場合、シーケンスの繰り返しが実行されます。

   * (`__eq__()' などのメソッドで実装されている) 拡張比較は、決して
     型強制を行いません。(`__cmp__()' で実装されている) 三値比較
     (three-way comparison)
     は、他の二項演算子で行われているのと同じ条件で 型強制を受けます。

   * 現在の実装では、組み込み数値型 `int', `long' および `float'
     は型強制を行いません; 一方、`complex' は型強制
     を使います。こうした違いは、これらの型をサブクラス化する際に顕在化して
     きます。そのうち、 `complex' 型についても型強制を避けるよう修正
     されるかもしれません。これらの型は全て、関数 `coerce()' から
     利用するための `__coerce__()' メソッドを実装しています。



File: python-ref-jp.info,  Node: with文とコンテキストマネージャ,  Prev: 型強制規則 coercion rule,  Up: 特殊メソッド名

3.4.9 with文とコンテキストマネージャ
------------------------------------

_Added in Python version 2.5_

"コンテキストマネージャ"とは、
`with'文の実行時にランタイムコンテキストを定義する オブジェクトです。
コンテキストマネージャは、
コードブロックを実行するために必要な入り口および出口の処理を扱います。
コンテキストマネージャは通常、 `with'文（*Note with
文::の章を参照）により起動されますが、
これらのメソッドを直接呼び出すことで起動することもできます。

コンテキストマネージャの代表的な使い方としては、
様々なグローバル情報の保存および更新、リソースのロックとアンロック、
ファイルのオープンとクローズなどが挙げられます。

コンテキストマネージャのより詳細な情報は、

にある "Context Types" を参照してください。

`__enter__(self)'
     コンテキストマネージャのの入り口で実行される処理です。
     `with'文は、文の`as'節で規定された値を返す
     このメソッドを呼び出します。

`__exit__(self, exc_type, exc_value, traceback)'
     コンテキストマネージャの出口で実行される処理です。
     パラメータは、コンテキストが終了した原因となった例外について
     説明しています。 コンテキストが例外を送出せず終了した場合は、
     全ての引き数に `None' が設定されます。

     もし、例外が送出され、かつメソッドが例外を抑制したい場合
     （すなわち、例外が伝播されるのを防ぎたい場合）、 このメソッドは
     True を返す必要があります。 そうでなければ、このメソッドの終了後、
     例外は通常通り伝播することになります。

     `__exit__()'メソッドは受け取った例外を再度
     送出すべきではありません。
     これは、呼び出し側の責任でおこなってください。

See also:
    *PEP0343 The "with" statement*
          Python の `with' 文の 仕様、背景、および例が記載されています。



File: python-ref-jp.info,  Node: 実行モデル,  Next: 式 expression,  Prev: データモデル,  Up: Top

4 実行モデル
************

* Menu:

* 名前づけと束縛 naming and binding::
* 例外::


File: python-ref-jp.info,  Node: 名前づけと束縛 naming and binding,  Next: 例外,  Prev: 実行モデル,  Up: 実行モデル

4.1 名前づけと束縛 (naming and binding)
=======================================

"名前 (name)"  とは、オブジェクトを参照する
ものを指します。名前への束縛 (name binding) 操作を行うと、
名前を導入できます。プログラムテキスト中に名前が出現するたびに、
その名前が使われている最も内側の関数ブロック中で作成された "束縛
(binding)"  を使って名前の 参照が行われます。

"ブロック (block)"  は、Python のプログラムテキスト
からなる断片で、一つの実行単位となるものです。
モジュール、関数本体、そしてクラス定義はブロックです。
また、対話的に入力された個々のコマンドもブロックです。
スクリプトファイル (インタプリタに標準入力として与えたり、
コマンドラインの第一引数として指定したファイル) は、コードブロック
です。スクリプトコマンド (インタプリタのコマンドライン上で `*-c*'
オプションを使って指定したコマンド) もコードブロック です。組み込み関数
`eval()' や `exec' 文に 渡した文字列もコードブロックになります。
組み込み関数 `input()' から読み取られ、評価される
式もまた、コードブロックです。

コードブロックは、"実行フレーム (execution frame)"  上で実行されます。実行フレームには、
(デバッグに使われる) 管理情報が収められています。また、
現在のコードブロックの実行が完了した際に、どのようにプログラムの
実行を継続するかを決定しています。

"スコープ (scope)"  は、ある名前があるブロック内で
参照できるかどうかを決めます。ローカル変数があるブロック内で定義されて
いる場合、変数のスコープはそのブロックを含みます。関数ブロック内で
名前の定義を行った場合、その名前に対して別の束縛を行っている
ブロックを除いた、関数内の全てのブロックを含むようにスコープが
拡張されます。
クラス内で定義された名前のスコープは、クラスのブロック内に制限
されます; スコープがメソッドのコードブロックを含むよう拡張される
ことはありません。

ある名前がコードブロック内で使われると、その名前を最も近傍から囲う
ようなスコープ (最内スコープ: nearest enclosing scope) を使って束縛の
解決を行います。こうしたスコープからなる、あるコードブロック内で
参照できるスコープ全ての集合は、ブロックの "環境 (environment)"  と呼ばれます。

ある名前がブロック内で束縛されている場合、名前はそのブロックに
おけるローカル変数 (local variable) です。
ある名前がモジュールレベルで束縛されている場合、名前は グローバル変数
(global variable) です。
(モジュールコードブロックの変数は、ローカル変数でもあるし、
グローバル変数でもあります。)
ある変数がコードブロック内で使われているが、そのブロックでは定義
されていない場合、変数は "自由変数 (free variable)" です。

ある名前の定義がどこにもない場合、 `NameError' 例外が送出されます。名前がまだ束縛されていないローカルな変数を参照
した場合、`UnboundLocalError' 

例外が送出されます。`UnboundLocalError' は、 `NameError'
のサブクラスです。

名前への束縛は、以下の文構成 (construct): 関数の仮引数 (formal
parameter) 指定、`import' 文、クラスや関数の定義 (定義を行ったブロック中
で、クラスや関数名の束縛が行われます)、代入時に、代入対象が識別子
である場合、`for' ループのヘッダ、または第二形式の `except'
文ヘッダ、で行われます。 "`from...import *'"  形式の import 文は、
import しようとするモジュール内で定義されている名前について、
アンダースコアから始まっている名前以外の全てを束縛します。
この形式は、モジュールレベルでしか使うことができません。

`del' 文で指定された対象は、(`del' の意味付けは、 実際は名前の解放
(unbind) ですが) 文の目的上、束縛済みのもの
とみなされます。外側のスコープで参照されている名前の解放は、
不正な操作になります; コンパイラは `SyntaxError' を 報告するでしょう。

代入文や import 文はいずれも、クラスや関数定義、モジュールレベル
(トップレベルのコードブロック) 内で起こります。

ある名前束縛操作がコードブロック内のどこかにある場合、ブロック
内でその名前を使うと、全て現在のブロックで束縛されている名前を
指すものとみなされます。このため、ある名前が束縛される前に
ブロック内で使われるとエラーを引き起こす可能性があります。

この規則はやや微妙です。Python には宣言文がなく、コードブロックの
どこで名前束縛操作を行ってもかまいません。
あるコードブロックにおけるローカル変数は、
ブロック全体から名前束縛操作が行われている部分を走査して決定 します。

global 文で指定された名前がブロック内にある場合、その名前は
常にトップレベルの名前空間で束縛された名前を参照します。
それらの名前はグローバル名前空間、すなわちコードブロックが収め
られているモジュールの名前空間とモジュール名 `__builtin__'
で表される組み込み名前空間、を検索することによって、トップレベルの
名前空間で解決されます。グローバル名前空間は、常に最初に検索
されます。名前がグローバル名前空間中に見つからない場合、組み込み
名前空間が検索されます。global 文は、その名前が使われている全て
の文に先立って記述されていなければなりません。

あるコードブロックの実行時に関連付けられる組み込み名前空間は、
実際にはコードブロックのグローバル名前空間内に入っている名前
`__builtins__' を参照する形になっています; `__builtins__'
は辞書かモジュール (後者の場合にはモジュールの辞書が使われます)
でなければなりません。デフォルトで `__main__' モジュール中においては、
`__builtins__' は組み込みモジュール `__builtin__' です (注意: 's'
なし)； それ以外のモジュールでは、`__builtins__' は `__builtin__'
モジュール それ自身の辞書のエイリアスです。`__builtins__'
はユーザが作成した辞書を 設定して、弱い形態の制限実行 を作成することが可能です。

_Notice:_ ユーザは `__builtins__' に触れるべきではありません；これは
くれぐれも実装の詳細であるのです。組み込みの名前空間の中の値を
オーバーライドしたいユーザは、`__builtin__' ('s'はありません)
モジュールを `import' して、その属性を好きに変更するべきです。

あるモジュールの名前空間は、そのモジュールが最初に import された
時に自動的に作成されます。スクリプトの主モジュール (main module)は 常に
`__main__'  と呼ばれます。

グローバル文は、同じブロックの束縛操作と同じスコープを持ちます。
ある自由変数の最内スコープに global 文がある場合、その自由変数は
グローバル変数とみなされます。

クラス定義は一つの実行文で、名前の使用や定義を行います。クラス定義
への参照は、通常の名前解決規則に従います。
クラス定義の名前空間は、そのクラスの属性辞書になります。
クラスのスコープで定義された名前は、メソッドからは見えません。

* Menu:

* 動的な機能とのやりとり::


File: python-ref-jp.info,  Node: 動的な機能とのやりとり,  Prev: 名前づけと束縛 naming and binding,  Up: 名前づけと束縛 naming and binding

4.1.1 動的な機能とのやりとり
----------------------------

自由変数の入った入れ子スコープ (nested scope) を併用すると、 Python
の文が不正な文になる場合がいくつかあります。

ある変数がスコープの外側から参照された場合、その名前に対する
削除操作は不正になります。この場合、コンパイル時にエラーが
報告されることになります。

ワイルドカード形式の import 文  -- `import *' --
を関数内で使った場合や、関数が自由変数を含んでいたり、自由変数
を伴う入れ子ブロックである場合、コンパイラは `SyntaxError' を
送出します。

`exec' が関数内で使われており、関数が自由変数を含んでいたり、
自由変数を伴う入れ子ブロックである場合、`exec' に明示的に
ローカル名前空間を指定しないかぎりコンパイラは SyntaxError を
送出します。 (別の言い方をすれば、`exec obj'
は不正になることがあり、`exec obj in ns' はならない、という ことです。)

`eval()'、 `execfile()'、および `input()' 関数、そして `exec'
文は、名前の解決を行う際に、現在の環境
に対して完全にアクセスできるわけではありません。名前が呼び出し側の
ローカル名前空間やグローバル名前空間から解決されることはあります。
自由変数は最内名前空間ではなく、グローバル名前空間から解決されます。 (1)

`exec' 文と、関数 `eval()' および `execfile()'
にはオプションの引数があり、グローバルおよび
ローカル名前空間をオーバライドできます。名前空間を一つしか指定
しなければ、両方の名前空間として使われます。

---------- Footnotes ----------

(1)
この制限は、上記の操作によって実行されるコードが、モジュールをコンパイルしたときには利用できないために起こります。


File: python-ref-jp.info,  Node: 例外,  Prev: 名前づけと束縛 naming and binding,  Up: 実行モデル

4.2 例外
========

例外とは、コードブロックの通常の制御フローを中断して、
エラーやその他の例外的な状況を処理できるようにするための 手段です。
例外はエラーが検出された時点で _送出 (raise)_  されます;
例外は、エラーが発生部の周辺のコードブロックか、エラーが発生した
コードブロック直接または間接的に呼び出しているコードブロック で _処理
(handle)_  することが できます。 

Python インタプリタは、ランタイムエラー (ゼロによる除算など) が
検出されると例外を送出します。Python プログラムから、`raise'
文を使って明示的に例外を送出することもできます。 例外ハンドラ
(exception handler) は、 `try' ... `except'
文で指定することができます。`try' ... `finally'
節を使うとクリーンアップコード (cleanup code) を指定できます。
このコードは例外は処理しませんが、先行するコードブロックで例外が
起きても起きなくても実行されます。

Python は、エラー処理に "プログラムの終了 (termination)"  モデルを用いています:
例外ハンドラは、
プログラムに何が発生したかを把握することができ、ハンドラの外側の
レベルに処理を継続することはできますが、(問題のあったコード部分を
最初から実行しなおすのでない限り) エラーの原因を修復したり、
実行に失敗した操作をやり直すことはできません。

例外が全く処理されない場合、インタプリタはプログラムの実行を終了させる
か、対話メインループに処理を戻します。どちらの場合も、 例外が
`SystemExit' でない限りバックトレース (backtrace) を出力します。

例外は、クラスインスタンスによって識別されます。 `except'
節はインスタンスのクラスにもとづいて選択されます：
これはインスタンスのクラスか、そのベースクラスを参照します。この
インスタンスはハンドラによって受け取られ、例外条件に関する追加情報を
伝えることができます。

例外は文字列 (strings) によっても識別することができ、このような場合には
`except' 節はオブジェクトの同一性によって選択されます。
任意の値をハンドラに渡される識別文字列に伴って送出することができます。

_This is deprecated in Python 2.5.
文字列の例外は新規のコードでは使うべきではありません。 これは Python
の将来のバージョンではサポートされないでしょう。
古いコードは代わりにクラスによる例外を使うように書き直すべきです。_

_Notice:_ [warning] 例外に対するメッセージは、Python API
仕様には含まれていません。 メッセージの内容は、ある Python
のバージョンから次のバージョンに
なるときに、警告なしに変更される可能性があります。したがって、
複数バージョンのインタプリタで動作するようなコードにおいては、
例外メッセージの内容に依存した記述をすべきではありません。

`try' 文については、~*Note try 文:: 節、 `raise' 文については ~*Note
raise 文:: 節も参照してください。


File: python-ref-jp.info,  Node: 式 expression,  Next: 単純文 simple statement,  Prev: 実行モデル,  Up: Top

5 式 (expression)
*****************

この章では、Python の式における個々の要素の意味について解説します。

*表記法に関する注意:* この章と以降の章での拡張BNF (extended BNF)
表記は、字句解析規則ではなく、構文規則を記述する
ために用いられています。ある構文規則 (のある表現方法) が、以下の形式

     [*]

`name `othername''

で記述されていて、この構文特有の意味付け (semantics)
が記述されていない場合、 `name'
の形式をとる構文の意味付けは、`othername' の意味付けと同じになります。 

* Menu:

* 算術変換 arithmetic conversion::
* アトム、原子的要素 atom::
* 一次語 primary::
* べき乗演算 power operator::
* 単項算術演算 unary arithmetic operation::
* 二項算術演算 binary arithmetic operation::
* シフト演算 shifting operation::
* ビット単位演算の二項演算 binary bit-wise operation::
* 比較 comparison::
* ブール演算 boolean operation::
* ラムダ lambda::
* 式のリスト::
* 評価順序::
* まとめ::


File: python-ref-jp.info,  Node: 算術変換 arithmetic conversion,  Next: アトム、原子的要素 atom,  Prev: 式 expression,  Up: 式 expression

5.1 算術変換 (arithmetic conversion)
====================================

以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と
書かれている場合、引数は ~*Note 型強制規則 coercion rule::
に記載されている
型強制規則に基づいて型強制されます。引数がいずれも標準の数値型
である場合、以下の型強制が適用されます:

   * 片方の引数が複素数型であれば、他方は複素数型に変換されます;

   * それ以外の場合で、片方の引数が浮動小数点数であれば、他方は
     浮動小数点型に変換されます;

   * それ以外の場合で、片方の引数が長整数型であれば、他方は
     長整数型に変換されます;

   * それ以外の場合で、両方の引数が通常の整数型であれば、変換の
     必要はありません。

特定の演算子 (文字列を左引数とする `%' 演算子など) では、さらに
別の規則が適用されます。拡張をおこなうことで、個々の演算子に対する
型強制を定義できます。


File: python-ref-jp.info,  Node: アトム、原子的要素 atom,  Next: 一次語 primary,  Prev: 算術変換 arithmetic conversion,  Up: 式 expression

5.2 アトム、原子的要素 (atom)
=============================

アトム (原子的要素: atom) は、式を構成する基本単位です。もっとも単純な
アトムは、識別子またはリテラルになります。逆クオートや丸括弧、波括弧、
または角括弧で囲われた形式 (form) もまた、文法的にはアトムに分類
されます。アトムの構文定義は以下のようになります:

`atom `identifier' | `literal' | `enclosure''

`enclosure `parenth_form' | `list_display''

` | `generator_expression' | `dict_display''

` | `string_conversion''

* Menu:

* 識別子 identifier、または名前 name::
* リテラル::
* 丸括弧形式 parenthesized form::
* リスト表現::
* ジェネレータ式::
* 辞書表現::
* 文字列変換::


File: python-ref-jp.info,  Node: 識別子 identifier、または名前 name,  Next: リテラル,  Prev: アトム、原子的要素 atom,  Up: アトム、原子的要素 atom

5.2.1 識別子 (identifier、または名前 (name))
--------------------------------------------

アトムの形になっている識別子 (identifier) は名前 (name) です。
名前づけや束縛については、*Note 名前づけと束縛 naming and binding::
節を参照してください。

名前があるオブジェクトに束縛されている場合、名前アトムを評価すると
そのオブジェクトになります。名前が束縛されていない場合、アトムを
評価しようとすると`NameError' 例外を送出します。 

*プライベートな名前の難号化 (mangling):* クラス定義内にテキストの形で書かれた識別子で、二つ以上のアンダースコア
から始まり、末尾が二つ以上のアンダースコアになっていないものは、
そのクラスの "プライベートな名前 (private name)" とみなされます。
プライベートな名前は、コードが生成される前に、より長い形式の名前に
変換されます。この変換では、クラス名の先頭にあるアンダースコアを全て
はぎとり、先頭にアンダースコアを一つ挿入して、名前の前に付加します。
例えば、クラス `Ham' 内の識別子 `__spam' は、 `_Ham__spam'
に変換されます。変換は識別子が使われている構文的
コンテキストとは独立しています。変換された名前が非常に長い (255
文字以上) の場合には、実装によっては名前の切り詰めが起きる
かもしれません。クラス名がアンダースコアだけから成り立つ場合には、
変換は行われません。


File: python-ref-jp.info,  Node: リテラル,  Next: 丸括弧形式 parenthesized form,  Prev: 識別子 identifier、または名前 name,  Up: アトム、原子的要素 atom

5.2.2 リテラル
--------------

Python では、文字列リテラルと、様々な数値リテラルをサポートしています:

`literal `stringliteral' | `integer' | `longinteger''

` | `floatnumber' | `imagnumber''

リテラルを評価すると、指定した型 (文字列、整数、長整数、
浮動小数点数、複素数) の指定した値を持つオブジェクトになります。
浮動小数点や虚数 (複素数) リテラルの場合、値は近似値になる場合
があります。詳しくは *Note リテラル literal:: を参照してください。
リテラルは全て変更不能なデータ型に対応します。このため、オブジェクト
のアイデンティティはオブジェクトの値ほど重要ではありません。
同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルが
プログラムの同じ場所由来のものであっても、そうでなくても)
同じオブジェクトを指しているか、まったく同じ値を持つ別の
オブジェクトになります。 


File: python-ref-jp.info,  Node: 丸括弧形式 parenthesized form,  Next: リスト表現,  Prev: リテラル,  Up: アトム、原子的要素 atom

5.2.3 丸括弧形式 (parenthesized form)
-------------------------------------

丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:

`parenth_form "(" [`expression_list'] ")"'

丸括弧で囲われた式のリストは、個々の式が表現するものになります:
リスト内に少なくとも一つのカンマが入っていた場合、タプルになります;
そうでない場合、式のリストを構成している単一の式自体の値になります。

中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。
タプルは変更不能なので、リテラルと同じ規則が適用されます (すなわち、
空のタプルが二箇所で使われると、それらは同じオブジェクトになることも
あるし、ならないこともあります)。 

タプルは丸括弧で作成されるのではなく、カンマによって作成される
ことに注意してください。例外は空のタプルで、この場合には
丸括弧が_必要です_ -- 丸括弧のつかない、 "何も記述しない式 (nothing)"
を使えるようにしてしまうと、
文法があいまいなものになってしまい、よくあるタイプミスが検出されなく
なってしまいます。 


File: python-ref-jp.info,  Node: リスト表現,  Next: ジェネレータ式,  Prev: 丸括弧形式 parenthesized form,  Up: アトム、原子的要素 atom

5.2.4 リスト表現
----------------

リスト表現は、角括弧で囲われた式の系列です。系列は空の系列であっても
かまいません:

`test `or_test' | `lambda_form''

`testlist `test' ( "," `test' )* [ "," ]'

`list_display "[" [`listmaker'] "]"'

`listmaker `expression' ( `list_for' | ( "," `expression' )* [","] )'

`list_iter `list_for' | `list_if''

`list_for "for" `expression_list' "in" `testlist' [`list_iter']'

`list_if "if" `test' [`list_iter']'

リスト表現は、新に作成されたリストオブジェクトを表します。
新たなリストの内容は、式のリストを与えるか、リストの内包表記 (list
comprehension) で指定します。 カンマで区切られた式のリストを与えた場合、リストの各要素は左から
右へと順に評価され、評価された順番にリスト内に配置されます。
リストの内包表記を与える場合、内包表記はまず単一の式、続いて
少なくとも一つの `for' 節、続いてゼロ個以上の `for' 節か、`if'
節になります。 この場合、新たに作成されるリストの各要素は、各々の `for'
や `if' 節を左から右の順にネストしたブロックとみなして実行し、
ネストの最内ブロックに到達する度に式を評価した値となります。 (1) 

---------- Footnotes ----------

(1) Python 2.3 では、リスト内包が `for' の中で使う制御
変数を内包表記を書いたスコープに「漏らして」しまう仕様になって
いました。この挙動は撤廃されたので、将来のバージョンでバグが修正
されれば、この挙動に依存したコードは動作しなくなります。


File: python-ref-jp.info,  Node: ジェネレータ式,  Next: 辞書表現,  Prev: リスト表現,  Up: アトム、原子的要素 atom

5.2.5 ジェネレータ式
--------------------

ジェネレータ式 (generator expression) とは、丸括弧を使ったコンパクトな
ジェネレータ表記法です:

`generator_expression "(" `test' `genexpr_for' ")"'

`genexpr_for "for" `expression_list' "in" `test' [`genexpr_iter']'

`genexpr_iter `genexpr_for' | `genexpr_if''

`genexpr_if "if" `test' [`genexpr_iter']'

ジェネレータ式は新たなジェネレータオブジェクトを生み出します。 ジェネレータ式は単一の式の後ろに少なくとも一つの
`for' 節と、場合によりさらに複数の`for' または `if' 節を
続けたものです。 新たなジェネレータが繰り返す値は、各`for' および `if'
節をブロックとして、左から右へとネストし、
その最内ブロックの中で式を評価した結果を出力しているものと みなせます。

ジェネレータ式の使う変数の評価は、ジェネレータオブジェクトに対して
`next()' メソッドを呼び出すまで遅延されます。とはいえ、
もっとも左に位置する `for' 節はただちに評価されるため、
ジェネレータ式の最左 `for' 節のエラーは、ジェネレータ式を
使っているコードの他のエラーに先立って起きることがあります。 それ以後の
`for' 節は、先行する `for' ループに
依存しているため、直ちには評価されません。

例: `(x*y for x in range(10) for y in bar(x))'

関数の唯一の引数として渡す場合には、丸括弧を省略できます。
詳しくは*Note 呼び出し call:: 節を参照してください。


File: python-ref-jp.info,  Node: 辞書表現,  Next: 文字列変換,  Prev: ジェネレータ式,  Up: アトム、原子的要素 atom

5.2.6 辞書表現
--------------

辞書表現は、波括弧で囲われた、キーと値のペアからなる系列です。
系列は空の系列であってもかまいません: 

`dict_display "{" [`key_datum_list'] "}"'

`key_datum_list `key_datum' ("," `key_datum')* [","]'

`key_datum `expression' ":" `expression''

辞書表現は、新たな辞書オブジェクトを表します。 

キー/データのペアは、左から右へと評価され、その結果が辞書の各
エントリを決定します: 各キーオブジェクトは、対応するデータを
辞書に記憶するためのキーとして用いられます。

キーの値として使える型に関する制限は、*Note 新スタイルと旧スタイル::
節ですでに 列挙しています。(一言でいうと、キーは変更可能なオブジェクトを
全て排除したハッシュ可能な型でなければなりません。)
重複するキー間で衝突が起きても、衝突が検出されることはありません;
あるキーに対して、最後に渡されたデータ (プログラムテキスト上では、
辞書表記の最も右側値となるもの) が使われます。 


File: python-ref-jp.info,  Node: 文字列変換,  Prev: 辞書表現,  Up: アトム、原子的要素 atom

5.2.7 文字列変換
----------------

文字列変換は、逆クオート (reverse quite, 別名バッククオート: backward
quote) で囲われた式のリストです:

`string_conversion "`" `expression_list' "`"'

文字列変換は、逆クオート内の式リストを評価して、評価結果の
オブジェクトを各オブジェクトの型特有の規則に従って文字列に 変換します。

オブジェクトが文字列、数値、`None' か、それらの型のオブジェクト
のみを含むタプル、リストまたは辞書の場合、評価結果の文字列は 有効な
Python 式となり、組み込み関数 `eval()' に渡した 場合に同じ値となります
(浮動小数点が含まれている場合には近似値の 場合もあります)。

(特に、文字列を変換すると、値を安全に出力するために文字列の両側に
クオートが付けられ、"変 (funny) な" 文字はエスケープシーケンスに
変換されます。)

再帰的な構造をもつオブジェクト (例えば自分自身を直接または間接的に
含むリストや辞書) では、`...' を使って再帰的参照であることが
示され、オブジェクトの評価結果は `eval()' に渡しても
等価な値を得ることができません (`SyntaxError' が 送出されます)。 

組み込み関数 `repr()' は、括弧内の引数に対して、
逆クオート表記で囲われた中身と全く同じ変換を実行します。 組み込み関数
`str()' は似たような動作をしますが、
もっとユーザフレンドリな変換になります。 


File: python-ref-jp.info,  Node: 一次語 primary,  Next: べき乗演算 power operator,  Prev: アトム、原子的要素 atom,  Up: 式 expression

5.3 一次語 (primary)
====================

一次語は、言語において最も結合の強い操作を表します。
文法は以下のようになります:

`primary `atom' | `attributeref' | `subscription' | `slicing' | `call''

* Menu:

* 属性参照::
* 添字表記 subscription::
* スライス表記 slicing::
* 呼び出し call::


File: python-ref-jp.info,  Node: 属性参照,  Next: 添字表記 subscription,  Prev: 一次語 primary,  Up: 一次語 primary

5.3.1 属性参照
--------------

属性参照は、一次語の後ろにピリオドと名前を連ねたものです:

`attributeref `primary' "." `identifier''

一次語の値評価結果は、例えばモジュール、リスト、インスタンスと
いった、属性参照をサポートする型でなければなりません。
オブジェクトは次に、指定した名前が識別子名と
なっているような属性を生成するよう問い合わせされます。
問い合わせた属性が得られない場合、例外 `AttributeError'  が送出
されます。それ以外の場合、オブジェクトは属性オブジェクトの型と
値を決定し、生成して返します。同じ属性参照を複数回評価したとき、
互いに異なる属性オブジェクトになることがあります。 


File: python-ref-jp.info,  Node: 添字表記 subscription,  Next: スライス表記 slicing,  Prev: 属性参照,  Up: 一次語 primary

5.3.2 添字表記 (subscription)
-----------------------------

添字表記は、シーケンス (文字列、タプルまたはリスト) やマップ (辞書)
オブジェクトから、要素を一つ選択します: 

`subscription `primary' "[" `expression_list' "]"'

一次語の値評価結果は、シーケンス型かマップ型のオブジェクトでなければなりません。

一次語がマップであれば、式リストの値評価結果はマップ内のいずれかの
キー値に相当するオブジェクトにならなければなりません。添字表記は、
そのキーに対応するマップ内の値 (value) を選択します。
(式リストの要素が単独である場合を除き、式リストはタプルでなければ
なりません。)

一次語がシーケンスの場合、式 (リスト) の値評価結果は (通常の)
整数でなければ なりません。値が負の場合、シーケンスの長さが加算されます
(`x[-1]' が`x' の最後の要素を指すことになります)。
加算結果はシーケンス内の要素数よりも小さな非負の整数とならなければなりません。
添字表記は、添字と同じシーケンス中の (ゼロから数えた)
インデクスを持つ要素を 選択します。

文字列型の要素は文字 (character) です。文字は個別の型ではなく、 1
文字だけからなる文字列です。 


File: python-ref-jp.info,  Node: スライス表記 slicing,  Next: 呼び出し call,  Prev: 添字表記 subscription,  Up: 一次語 primary

5.3.3 スライス表記 (slicing)
----------------------------

スライス表記はシーケンスオブジェクト (文字列、タプルまたはリスト)
におけるある
範囲の要素を選択します。スライス表記は式として用いたり、代入や `del'
文の
対象として用いたりできます。スライス表記の構文は以下のようになります: 

`slicing `simple_slicing' | `extended_slicing''

`simple_slicing `primary' "[" `short_slice' "]"'

`extended_slicing `primary' "[" `slice_list' "]"'

`slice_list `slice_item' ("," `slice_item')* [","]'

`slice_item `expression' | `proper_slice' | `ellipsis''

`proper_slice `short_slice' | `long_slice''

`short_slice [`lower_bound'] ":" [`upper_bound']'

`long_slice `short_slice' ":" [`stride']'

`lower_bound `expression''

`upper_bound `expression''

`stride `expression''

`ellipsis "..."'

上記の形式的な構文法にはあいまいさがあります: 式リストに見えるものは、
スライスリストにも見えるため、添字表記はスライス表記としても解釈されうる
ということです。
この場合には、(スライスリストの評価結果が、適切なスライスや省略表記
(ellipsis) にならない場合)、スライス表記としての解釈よりも添字表記
としての解釈の方が高い優先順位を持つように定義することで、構文法をより
難解にすることなくあいまいさを取り除いています。同様に、
スライスリストが厳密に一つだけの短いスライスで、末尾にカンマが
続いていない場合、拡張スライスとしての解釈より、単純なスライスとして
の解釈が優先されます。 

単純なスライスに対する意味付けは以下のようになります。
一次語の値評価結果は、シーケンス型のオブジェクトでなければなりません。
下境界および上境界を表す式がある場合、それらの値評価結果は整数で
なくてはなりません; デフォルトの値は、それぞれゼロと `sys.maxint'
です。どちらかの境界値が負である場合、
シーケンスの長さが加算されます。こうして、スライスは I および J
をそれぞれ指定した下境界、上境界として、 インデクス K が `I <= K < J'
となる全ての 要素を選択します。
選択の結果、空のシーケンスになることもあります。I や J が
有効なインデクス範囲の外側にある場合でも、エラーにはなりません
(範囲外の要素は存在しないので、選択されないだけです)。

拡張スライスに対する意味付けは、以下のようになります。
一次語の値評価結果は、辞書型のオブジェクトでなければなりません。
また、辞書は以下に述べるようにしてスライスリストから生成された
キーによってインデクス指定できなければなりません。
スライスリストに少なくとも一つのカンマが含まれている場合、
キーは各スライス要素を値変換したものからなるタプルになります;
それ以外の場合、単一のスライス要素自体を値変換したものがキーになります。
一個の式でできたスライス要素の変換は、その式になります。
省略表記スライス要素の変換は、組み込みの `Ellipsis' オブジェクト
になります。適切なスライスの変換は、スライスオブジェクト (*Note
新スタイルと旧スタイル:: 参照) で、`start', `stop' および `step'
属性は、それぞれ指定した下境界、上境界、および とび幅 (stride)
になります。式がない場合には、`None' に置き換え られます。 


File: python-ref-jp.info,  Node: 呼び出し call,  Prev: スライス表記 slicing,  Up: 一次語 primary

5.3.4 呼び出し (call)
---------------------

呼び出し (call) は、呼び出し可能オブジェクト (callable object, 例えば
関数など) を、引数列とともに呼び出します。引数列は空のシーケンスでも
かまいません: 

`call `primary' "(" [`argument_list' [","]] ")"'
     {`primary' "(" [`argument_list' [","] | `test' `genexpr_for' ] ")"}

`argument_list `positional_arguments' ["," `keyword_arguments']'

`                      ["," "*" `expression']'

`                      ["," "**" `expression']'

` | `keyword_arguments' ["," "*" `expression']'

`                     ["," "**" `expression']'

` | "*" `expression' ["," "**" `expression']'

` | "**" `expression''

`positional_arguments `expression' ("," `expression')*'

`keyword_arguments `keyword_item' ("," `keyword_item')*'

`keyword_item `identifier' "=" `expression''

固定引数やキーワード引数の後ろにカンマをつけてもかまいません。
構文の意味付けに影響を及ぼすことはありません。

一次語の値評価結果は、呼び出し可能オブジェクトでなければなりません
(ユーザ定義関数、組み込み関数、組み込みオブジェクトのメソッド、
クラスオブジェクト、クラスインスタンスのメソッド、そして特定の
クラスインスタンス自体が呼び出し可能です; 拡張によって、
その他の呼び出し可能オブジェクト型を定義することができます)。
引数式は全て、呼び出しを試みる前に値評価されます。 仮引数 (formal
parameter) リストの構文については、*Note 関数定義:: を参照してください。

キーワード引数が存在する場合、以下のようにして最初に固定引数
(positional argument) に変換されます。まず、値の入っていない
スロットが仮引数に対して生成されます。N 個の固定引数が
ある場合、固定引数は先頭の N スロットに配置されます。
次に、各キーワード引数について、識別子を使って対応するスロット
を決定します (識別子が最初の仮引数パラメタ名と同じなら、最初の
スロットを使う、といった具合です)。スロットがすでにすべて埋まって
いたなら、`TypeError' 例外が送出されます。
それ以外の場合、引数値をスロットに埋めていきます。 (式が `None'
であっても、その式でスロットを埋めます)。
全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに
対応する関数定義時のデフォルト値で埋めます。(デフォルト値は、
関数が定義されたときに一度だけ計算されます; 従って、リストや
辞書のような変更可能なオブジェクトがデフォルト値として使われると、
対応するスロットに引数を指定しない限り、このオブジェクトが全ての
呼び出しから共有されます; このような状況は通常避けるべきです。)
デフォルト値が指定されていない、値の埋められていないスロットが
残っている場合、`TypeError' 例外が送出されます。
そうでない場合、値の埋められたスロットからなるリストが呼び出しの
引数として使われます。

仮引数スロットの数よりも多くの固定引数がある場合、構文 `*identifier'
を使って指定された仮引数がないかぎり、 `TypeError' 例外が送出されます;
仮引数 `*identifier' がある場合、
この仮引数は余分な固定引数が入ったタプル (もしくは、余分な
固定引数がない場合には空のタプル) を受け取ります。

キーワード引数のいずれかが仮引数名に対応しない場合、構文 `**identifier'
を使って指定された仮引数がない限り、 `TypeError' 例外が送出されます;
仮引数 `**identifier' がある場合、
この仮引数は余分なキーワード引数が入った (キーワードをキーとし、
引数値をキーに対応する値とした) 辞書を受け取ります。
余分なキーワード引数がない場合には、空の (新たな) 辞書を 受け取ります。

関数呼び出しの際に `*expression' 構文が使われる場合、 `expression'
の値評価結果はシーケンスでなくてはなりません。
このシーケンスの要素は、追加の固定引数のように扱われます;
すなわち、固定引数 X1,...,XN と、 Y1,...,YM になるシーケンス
`expression' を使った 場合、M+N 個の固定引数 X1,...,XN,Y1,...,YM
を使った呼び出しと同じになります。

上記の仕様による結果として、`*expression' 構文は たとえキーワード引数
_以降に_ あっても、キーワード引数 _以前に_ (`**expression'
引数があればさらにその後に - 下記参照) 処理されます。従って:

     >>> def f(a, b):
     ...  print a, b
     ...
     >>> f(b=1, *(2,))
     2 1
     >>> f(a=1, *(2,))
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: f() got multiple values for keyword argument 'a'
     >>> f(1, *(2,))
     1 2

となります。

キーワード引数と `*expression' 構文を同じ呼び出しに使うことは
あまりないので、実質的には上記のような混乱が生じることはありません。

関数呼び出しで `**expression' 構文が使われた場合、 `expression'
の値評価結果は辞書 (またはそのサブクラス) で
なければなりません。辞書の内容は追加のキーワード引数として扱われ
ます。明示的なキーワード引数が `expression' 内のキーワード
と重複した場合には、`TypeError' 例外が送出されます。

`*identifier' や `**identifier' 構文を使った仮引数は、
固定引数スロットやキーワード引数名にすることができません。 `(sublist)'
構文を使った仮引数は、キーワード引数名には 使えません; sublist
は、リスト全体が一つの無名の引数スロット に対応しており、sublist
中の引数は、他の全てのパラメタに対する
処理が終わった後に、通常のタプル形式の代入規則を使ってスロットに
入れられます。

呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。
`None' を返す場合もあります。戻り値がどのように算出されるかは、
呼び出し可能オブジェクトの形態によって異なります。

呼び出し可能オブジェクトが。。。

`ユーザ定義関数のとき:'
     関数のコードブロックに引数リストが
     渡され、実行されます。コードブロックは、まず仮引数を実引数に 結合
     (bind) します; この動作については *Note 関数定義::
     で記述しています。 コードブロックで `return'
     文が実行される際に、関数呼び出しの 戻り値 (return value)
     が決定されます。 

`組み込み関数や組み込みメソッドのとき:'
     結果はインタプリタに 依存します;
     組み込み関数や組み込みメソッドの詳細は、 を参照してください。 

`クラスオブジェクトのとき:'
     そのクラスの新しいインスタンスが 返されます。 

`クラスインスタンスメソッドのとき:'
     対応するユーザ定義の関数
     が呼び出されます。このとき、呼び出し時の引数リストより一つ長い
     引数リストで呼び出されます: インスタンスが引数リストの先頭に追加
     されます。 

`クラスインスタンスのとき:'
     クラスで `__call__()' メソッドが定義されていなければなりません;
     `__call__()' メソッドが呼び出された場合と同じ効果をもたらします。 



File: python-ref-jp.info,  Node: べき乗演算 power operator,  Next: 単項算術演算 unary arithmetic operation,  Prev: 一次語 primary,  Up: 式 expression

5.4 べき乗演算 (power operator)
===============================

べき乗演算は、左側にある単項演算子よりも強い結合優先順位 があります;
一方、右側にある単項演算子よりは低い結合優先順位に
なっています。構文は以下のようになります:

`power `primary' ["**" `u_expr']'

従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われて
いない場合、演算子は右から左へと評価されます (この演算規則は、
被演算子の評価順序を縛る規則ではありません)。

べき乗演算子は、二つの引数で呼び出される組み込み関数 `pow()'
と同じ意味付けを持っています。引数はまず共通の型に変換されます。
結果の型は、型強制後の引数の型になります。

引数型を混合すると、二項算術演算における型強制規則が適用されます。
整数や長整数の被演算子の場合、第二引数が負でない限り、結果は
(型強制後の) 被演算子と同じになります; 第二引数が負の場合、
全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。
例えば、`10**2' は `100' を返しますが、`10**-2' は `0.01' を返します。
(上述の仕様のうち、最後のものは Python 2.2 で追加されました。 Python
2.1 以前では、双方の引数が
整数型で、第二引数が負の場合、例外が送出されていました。)

`0.0' を負の数でべき乗すると、`ZeroDivisionError'
を送出します。負の数を小数でべき乗すると `ValueError' になります。


File: python-ref-jp.info,  Node: 単項算術演算 unary arithmetic operation,  Next: 二項算術演算 binary arithmetic operation,  Prev: べき乗演算 power operator,  Up: 式 expression

5.5 単項算術演算 (unary arithmetic operation)
=============================================

全ての単項算術演算 (およびビット単位演算子) は、同じ優先順位を
持っています:

`u_expr `power' | "-" `u_expr' | "+" `u_expr' | "{~}" `u_expr''

単項演算子 `-' (マイナス) は、引数となる数値の符号を反転 (invert)
します。 

単項演算子 `+' (プラス) は、数値引数を変更しません。 

単項演算子 `~' (逆転) は、整数または長整数の引数を ビット単位反転
(bit-wise invert) します。 `x' の ビット単位反転は、 `-(x+1)'
として定義されています。 この演算子は整数にのみ適用されます。 

上記の三つはいずれも、引数が正しい型でない場合には `TypeError'
例外が送出されます。 


File: python-ref-jp.info,  Node: 二項算術演算 binary arithmetic operation,  Next: シフト演算 shifting operation,  Prev: 単項算術演算 unary arithmetic operation,  Up: 式 expression

5.6 二項算術演算 (binary arithmetic operation)
==============================================

二項算術演算は、慣習的な優先順位を踏襲しています。
演算子のいずれかは、特定の非数値型にも適用されるので注意して
ください。べき乗 (power) 演算子を除き、演算子には二つのレベル、
すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子
しかありません:

`m_expr `u_expr' | `m_expr' "*" `u_expr' | `m_expr' "//" `u_expr' | `m_expr' "/" `u_expr''

` | `m_expr' "%" `u_expr''

`a_expr `m_expr' | `a_expr' "+" `m_expr' | `a_expr' "-" `m_expr''

`*' (乗算: multiplication) 演算は、引数間の積になります。
引数の組は、双方ともに数値型であるか、片方が整数 (通常の整数または
長整数) 型で他方がシーケンス型かのどちらかでなければなりません。
前者の場合、数値は共通の型に変換された後乗算されます。
後者の場合、シーケンスの繰り返し操作が行われます。繰り返し数を負に
すると、空のシーケンスになります。 

`/' (除算: division) および `//' (切り捨て除算: floor division)
は、引数間の商になります。数値引数はまず共通の型に変換されます。
整数または長整数の除算結果は、同じ型の整数になります; この場合、
結果は数学的な除算に関数 `floor' を適用したものになります。
ゼロによる除算を行うと `ZeroDivisionError' 例外を送出 します。 

`%' (モジュロ: modulo) 演算は、第一引数を第二引数で除算
したときの剰余になります。数値引数はまず共通の型に変換されます。
右引数値がゼロの場合には、`ZeroDivisionError' 例外が
送出されます。引数値は浮動小数点でもよく。例えば `3.14%0.7' は `0.34'
になります (`3.14' は `4*0.7 + 0.34'
だからです)。モジュロ演算子は常に第二引数と同じ符号 (またはゼロ)
の結果になります; モジュロ演算の結果の絶対値は、常に第二引数
の絶対値よりも小さくなります。(1) 

整数による除算演算やモジュロ演算は、恒等式: `x == (x/y)*y + (x%y)'
と関係しています。整数除算や モジュロはまた、組み込み関数 `divmod()':
`divmod(x, y) == (x/y, x%y)' と関係しています。
これらの恒等関係は浮動小数点の場合には維持されません; `x/y' が
`floor(x/y)' や `floor(x/y) - 1' に
置き換えられた場合、これらの恒等式は近似性を維持します。 (2)

数値に対するモジュロ演算の実行に加えて、`%' 演算子は 文字列 (string)
とユニコードオブジェクトにオーバーロードされ、 文字列の書式化
(文字列の挿入としても知られる) を行います。 文字列の書式化の構文は  の
"シーケンス型" で説明されています。

_This is deprecated in Python 2.3.
切り捨て除算演算子、モジュロ演算子、および `divmod()'
関数は、複素数に対してはもはや定義されて
いません。目的に合うならば、代わりに `abs()' を使って
浮動小数点に変換してください。_

`+' (加算) 演算は、引数を加算した値を返します。
引数は双方とも数値型か、双方とも同じ型のシーケンスでなければなりません。
前者の場合、数値は共通の型に変換され、加算されます。
後者の場合、シーケンスは結合 (concatenate) されます。 

`-' (減算) 演算は、引数間で減算を行った値を返します。
数値引数はまず共通の型に変換されます。 

---------- Footnotes ----------

(1)  `abs(x%y) < abs(y)' は数学的には真となりますが、浮動小数点
に対する演算の場合には、値丸め (roundoff) のために数値計算的に
真にならない場合があります。例えば、Python の浮動小数点型が IEEE754
倍精度数型になっているプラットフォームを仮定すると、 `-1e-100 % 1e100'
は `1e100' と同じ符号になるはず なのに、計算結果は `-1e-100 + 1e100'
となります。これは 数値計算的には厳密に `1e100' と等価です。`math'
モジュールの関数 `fmod()' は、最初の引数と符号が一致する
ような値を返すので、上記の場合には `-1e-100' を返します。
どちらのアプローチが適切かは、アプリケーションに依存します。

(2)  x が y の整数倍に非常に近い場合、丸め誤差によって `floor(x/y)'  は
`(x-x%y)/y' よりも大きな値になる可能性があります。 そのような場合、
Python は`divmod(x,y)[0] * y + x %{} y'  が `x'
に非常に近くなるという関係を保つために、後者の値を 返します。


File: python-ref-jp.info,  Node: シフト演算 shifting operation,  Next: ビット単位演算の二項演算 binary bit-wise operation,  Prev: 二項算術演算 binary arithmetic operation,  Up: 式 expression

5.7 シフト演算 (shifting operation)
===================================

シフト演算は、算術演算よりも低い優先順位を持っています:

`shift_expr `a_expr' | `shift_expr' ( "<{}<" | ">{}>" ) `a_expr''

シフトの演算子は整数または長整数を引数にとります。
引数は共通の型に変換されます。シフト演算では、最初の引数を
二つ目の引数に応じたビット数だけ、左または右にビットシフト します。

N ビットの右シフトは、`pow(2,N)' による除算 として定義されています。 N
ビットの左シフトは、 `pow(2,N)' による乗算として定義されています;
整数の場合、桁あふれ (overflow) のチェックはされないので、
演算によって末端のビットは捨てられます。また、結果の絶対値が `pow(2,
31)' よりも小さくない場合には、符号の反転が起こります。
負のビット数でシフトを行うと、 `ValueError' 例外を 送出します。 


File: python-ref-jp.info,  Node: ビット単位演算の二項演算 binary bit-wise operation,  Next: 比較 comparison,  Prev: シフト演算 shifting operation,  Up: 式 expression

5.8 ビット単位演算の二項演算 (binary bit-wise operation)
========================================================

以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:

`and_expr `shift_expr' | `and_expr' "&" `shift_expr''

`xor_expr `and_expr' | `xor_expr' "^" `and_expr''

`or_expr `xor_expr' | `or_expr' "|" `xor_expr''

`&' 演算子は、引数間でビット単位の AND をとった値になります。
引数は整数または長整数でなければなりません。引数は共通の型に変換
されます。 

`^' 演算子は、引数間でビット単位の XOR (排他的 OR) をとった値に
なります。
引数は整数または長整数でなければなりません。引数は共通の型に変換
されます。 

`|' 演算子は、引数間でビット単位の OR (非排他的 OR) をとった値に
なります。
引数は整数または長整数でなければなりません。引数は共通の型に変換
されます。 


File: python-ref-jp.info,  Node: 比較 comparison,  Next: ブール演算 boolean operation,  Prev: ビット単位演算の二項演算 binary bit-wise operation,  Up: 式 expression

5.9 比較 (comparison)
=====================

C 言語と違って、Python における比較演算子は同じ優先順位をもっており、
全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。
また、`a < b < c' が数学で伝統的に用いられているのと同じ解釈に なる点も
C 言語と違います: 

`comparison `or_expr' ( `comp_operator' `or_expr' )*'

`comp_operator "<" | ">" | "==" | ">=" | "<=" | "<>" | "!="'

` | "is" ["not"] | ["not"] "in"'

比較演算の結果はブール値: `True' または `False' になります。

比較はいくらでも連鎖することができます。例えば `x < y <= z' は `x < y
and y <= z' と等価になります。ただしこの場合、前者では `y'
はただ一度だけ評価される点が異なります (どちらの場合でも、 `x < y'
が偽になると `z' の値はまったく評価されません)。 

形式的には、 A, B, C, ..., Y, Z が式で、OPA, OPB, ..., OPY
が比較演算子で ある場合、A OPA B OPB C ...Y OPY Z は A OPA B `and' B
OPB C `and' ...  Y OPY Z
と等価になります。ただし、前者では各式は多くても一度
しか評価されません。

A OPA B OPB C と書いた場合、 A から C までの範囲
にあるかどうかのテストを指すのではないことに注意してください。
例えば、`x < y > z' は (きれいな書き方ではありませんが)
完全に正しい文法です。

`<>' と `!=' の二つの形式は等価です; C との整合性を
持たせるためには、`!=' を推奨します; 以下で `!=' について
触れている部分では、`<>' を使うこともできます。 `<>'
のような書き方は、現在では古い書き方とみなされています。

演算子 `<', `>', `==', `>=', `<=', および `!='
は、二つのオブジェクト間の値を比較します。オブジェクトは
同じ型である必要はありません。双方のオブジェクトが数値であれば、
共通型への変換が行われます。それ以外の場合、異なる型のオブジェクトは
_常に_ 不等であるとみなされ、一貫してはいるが規定されていない
方法で並べられます。組み込み型でないオブジェクト比較の振る舞いは
`__cmp__' メソッドや `__gt__' といったリッチな比較メソッドを
定義することでコントロールすることができます。これは ~*Note
特殊メソッド名:: セクションで 説明されています。

(このような比較演算の変則的な定義は、ソートのような操作や、 `in'
および`not in' といった演算子の定義を
単純化するためのものです。将来、異なる型のオブジェクト間における
比較規則は変更されるかもしれません。)

同じ型のオブジェクト間における比較は、型によって異なります:

   * 数値間の比較では、算術的な比較が行われます。

   * 文字列間の比較では、各文字に対する等価な数値型 (組み込み関数
     `ord()' の結果) を使って辞書的な (lexicographically)
     比較が行われます。Unicode および 8
     ビット文字列は、この動作に関しては 完全に互換です。

   *
     タプルやリスト間の比較では、対応する各要素の比較結果を使って辞書的な
     比較が行われます。このため、二つのシーケンスを等価にするためには、各要素が
     完全に等価でなくてはならず、シーケンスは同じ型で同じ長さをもっていなければ
     なりません。

     二つのシーケンスが等価でない場合、異なる値を持つ最初の要素間での比較に
     従った順序関係になります。例えば、`cmp([1,2,x], [1,2,y])' は
     `cmp(x,y)' と等しい結果を返します。片方の要素に対応する要素が
     他方にない場合、より短いシーケンスが前に並びます (例えば、 `[1,2]
     < [1,2,3]' となります)。

   * マップ (辞書) 間の比較では、(key, value) からなるリストをソート
     したものが等しい場合に等価になります。(1)
     等価性評価以外の結果は一貫したやりかたで解決されるか、定義されないか
     のいずれかです。(2)

   *
     その他のほとんどの組み込み型のオブジェクト比較では、同じオブジェクトでないかぎり
     等価にはなりません；あるオブジェクトの他のオブジェクトに対する
     大小関係は任意に決定され、一つのプログラムの実行中は一貫した
     ものとなります。


演算子 `in' および `not in' は、集合内の要素であるか どうか
(メンバシップ、membership) を調べます。 `X in S' は、X が集合 S
のメンバである 場合には真となり、それ以外の場合には偽となります。 `X
not in S' は `X in S' の否定 (negation)
を返します。集合メンバシップテストは、伝統的には
シーケンス型に限定されてきました; すなわち、あるオブジェクトがある集合
のメンバとなるのは、集合がシーケンス型であり、シーケンスがオブジェクトと等価な
要素を含む場合でした。しかしながら、現在ではオブジェクトがシーケンスで
なくてもメンバシップテストをサポートしています。特に、 辞書型では、`KEY
in DICT' と書くことで、
うまい具合にメンバシップテストをサポートしています; 他のマップ型も
これに倣っているかもしれません。

リストやタプル型については、`X in Y' は `X == Y[I]'
となるようなインデクス I
が存在するとき、かつそのときに限り真になります。

Unicode 文字列または文字列型については、`X in Y' は X が Y
の部分文字列であるとき、かつそのときに限り
真になります。この演算と等価なテストは `y.find(x) != -1' です。 X
および Y は同じ型である必要はないので注意してください。
すなわち、`u'ab' in 'abc'' は `True' を返すことになります。
空文字列は、他のどんな文字列に対しても常に部分文字列とみなされます。
従って、`"" in "abc"' は `True' を返すことになります。 _Changed in
Python version 2.3_

`__contains__()' メソッドの定義されたユーザ定義クラスでは、 `X in Y'
が真となるのは `Y.__contains__(X)'
が真となるとき、かつそのときに限ります。

`__contains__()' は定義していないが `__getitem__()'
は定義しているようなユーザ定義クラスでは、 `X in Y' は `X == Y[I]'
となるような非負の整数インデクス I
が存在するとき、かつそのときにかぎり真となります。 インデクス I
が負である場合に `IndexError' 例外が 送出されることはありません。
(別の何らかの例外が送出された場合、 例外は `in'
から送出されたかのようになります)。

演算子 `not in' は、`in' の真値に対する逆転として定義されて います。 

演算子 `is' および `is not' は、オブジェクトの
アイデンティティに対するテストを行います: `X is Y' は、 X と Y
が同じオブジェクト を指すとき、かつそのときに限り真になります。 `X is
not Y' は、`is' の真値を逆転したもの になります。 

---------- Footnotes ----------

(1) 実装では、この
演算をリストを構築したりソートしたりすることなく効率的に 行います。

(2) Python の初期のバージョンでは、ソートされた (key, value)
のリストに対して辞書的な比較を行っていましたが、
これは等価性の計算のようなよくある操作を実現するには非常に
コストの高い操作でした。もっと以前のバージョンの Python では、辞書は
アイデンティティだけで比較されていました。しかしこの仕様は、 `@'
との比較によって辞書が空であるか確かめられると期待して
いた人々を混乱させていました。


File: python-ref-jp.info,  Node: ブール演算 boolean operation,  Next: ラムダ lambda,  Prev: 比較 comparison,  Up: 式 expression

5.10 ブール演算 (boolean operation)
===================================

ブール演算は、全ての Python
演算子の中で、最も低い優先順位になっています:

`expression `or_test' [`if' `or_test' `else' `test'] | `lambda_form''

`or_test `and_test' | `or_test' "or" `and_test''

`and_test `not_test' | `and_test' "and" `not_test''

`not_test `comparison' | "not" `not_test''

ブール演算のコンテキストや、式が制御フロー文中で使われる最には、
以下の値: `False'、`None' 、すべての型における数値のゼロ、空の文字列と
コンテナ (文字列、タプル、リスト、辞書、set、frozenset を含む) は偽
(false) であると 解釈されます。それ以外の値は真 (true)
であると解釈されます。

演算子 `not' は、引数が偽である場合には `1' を、それ以外の 場合には `0'
になります。 

式 `X if C else Y' はまず C を評価 (X では_ない_です)します； もし C が
true な場合、X が評価されてその値が返されます；そうでなければ、Y が
評価されてその値が返されます。_Added in Python version 2.5_

式 `X and Y' は、まず X を評価します; X が偽なら、X の値を返します;
それ以外の場合には、 Y の値を評価し、その結果を返します。 

式 `X or Y' は、まず X を評価します; X が真なら、X の値を返します;
それ以外の場合には、 Y の値を評価し、その結果を返します。 

(`and' も `not' も、返す値を `0' や `1' に
制限するのではなく、最後に評価した引数の値を返すので注意してください。
この仕様は、例えば `s' を文字列として、`s' が空文字列の
場合にデフォルトの値に置き換えるような場合に、`s or 'foo''
と書くと期待通りの値になるために便利なことがあります。 `not'
は、式の値でなく独自に値を作成して返すので、
引数と同じ型の値を返すような処理に煩わされることはありません。 例えば、
`not 'foo'' は、 `''' ではなく `0' になります)


File: python-ref-jp.info,  Node: ラムダ lambda,  Next: 式のリスト,  Prev: ブール演算 boolean operation,  Up: 式 expression

5.11 ラムダ (lambda)
====================

`lambda_form "lambda" [`parameter_list']: `expression''

ラムダ形式 (lambda form, ラムダ式 (lambda expression)) は、
構文法的には式と同じ位置付けになります。ラムダは、無名関数を作成
できる省略記法です; 式 `lambda ARGUMENTS: EXPRESSION'
は、関数オブジェクトになります。ラムダが表す無名オブジェクトは、
以下のコード

     def name(arguments):
         return expression

で定義された関数と同様に動作します。

引数リストの構文法については、*Note 関数定義:: 節を参照してください。
ラムダ形式で作成された関数は、実行文 (statement) を含むことができない
ので注意してください。


File: python-ref-jp.info,  Node: 式のリスト,  Next: 評価順序,  Prev: ラムダ lambda,  Up: 式 expression

5.12 式のリスト
===============

`expression_list `expression' ( "," `expression' )* [","]'

少なくとも一つのカンマを含む式のリストは、タプルになります。
タプルの長さは、リスト中の式の数に等しくなります。
リスト中の式は左から右へと順に評価されます。 

単一要素のタプル (別名_単集合 (singleton)_) を作りたければ、
末尾にカンマが必要です。単一の式だけで、末尾にカンマをつけない場合
には、タプルではなくその式の値になります (空のタプルを作りたいなら、
中身が空の丸括弧ペア: `()' を使います。) 


File: python-ref-jp.info,  Node: 評価順序,  Next: まとめ,  Prev: 式のリスト,  Up: 式 expression

5.13 評価順序
=============

Python は、式を左から右へと順に評価してゆきます。
ただし、代入式を評価する最には、代入演算子の右側項が左側項よりも
先に評価されるので注意してください。

以下に示す実行文の各行での評価順序は、添え字の数字順序と同じ になります:

     expr1, expr2, expr3, expr4
     (expr1, expr2, expr3, expr4)
     {expr1: expr2, expr3: expr4}
     expr1 + expr2 * (expr3 - expr4)
     func(expr1, expr2, *expr3, **expr4)
     expr3, expr4 = expr1, expr2


File: python-ref-jp.info,  Node: まとめ,  Prev: 評価順序,  Up: 式 expression

5.14 まとめ
===========

以下の表は、Python における演算子を、優先順位  の最も低い
(結合度が最も低い) ものから最も高い (結合度が最も高い)
ものの順に並べたものです。
同じボックス内に示された演算子は同じ優先順位を持ちます。演算子の
文法が示されていないかぎり、演算子は全て二項演算子です。
同じボックス内の演算子は、左から右へとグループ化されます
(値のテストを含む比較演算子を除きます。比較演算子は、左から右に連鎖
します -- *Note 比較 comparison::
を参照してください。また、べき乗演算子も
除きます。べき乗演算子は右から左にグループ化されます)。

演算子                               説明
------                               -----
`lambda'                             ラムダ式
`or'                                 ブール演算 OR
`and'                                ブール演算 AND
`not' X                              ブール演算 NOT
`in', `not' `in'                     メンバシップテスト
`is', `is not'                       アイデンティティテスト
`<', `<=', `>', `>=', `<>', `!=',    比較
`=='                                 
`|'                                  ビット単位 OR
`^'                                  ビット単位 XOR
`&'                                  ビット単位 AND
`<<', `>>'                           シフト演算
`+', `-'                             加算および減算
`*', `/', `%'                        乗算、除算、剰余
`+X', `-X'                           正符号、負符号
`~X'                                 ビット単位 NOT
`**'                                 べき乗
`X.ATTRIBUTE'                        属性参照
`X[INDEX]'                           添字指定
`X[INDEX:INDEX]'                     スライス操作
`F(ARGUMENTS...)'                    関数呼び出し
`(EXPRESSIONS...)'                   式結合またはタプル表現
`[EXPRESSIONS...]'                   リスト表現
`{KEY:DATUM...}'                     辞書表現
``EXPRESSIONS...`'                   文字列への型変換


File: python-ref-jp.info,  Node: 単純文 simple statement,  Next: 複合文 compound statement,  Prev: 式 expression,  Up: Top

6 単純文 (simple statement)
***************************

単純文とは、単一の論理行内に収められる文です。
単一の行内には、複数の単純文をセミコロンで区切って入れることが
できます。単純文の構文は以下の通りです:

`simple_stmt `expression_stmt''

` | `assert_stmt''

` | `assignment_stmt''

` | `augmented_assignment_stmt''

` | `pass_stmt''

` | `del_stmt''

` | `print_stmt''

` | `return_stmt''

` | `yield_stmt''

` | `raise_stmt''

` | `break_stmt''

` | `continue_stmt''

` | `import_stmt''

` | `global_stmt''

` | `exec_stmt''

* Menu:

* 式文 expression statement::
* Assert 文 assert statement::
* 代入文 assignment statement::
* pass 文::
* del 文::
* print 文::
* return 文::
* yield 文::
* raise 文::
* break 文::
* continue 文::
* import 文::
* global 文::
* exec 文::


File: python-ref-jp.info,  Node: 式文 expression statement,  Next: Assert 文 assert statement,  Prev: 単純文 simple statement,  Up: 単純文 simple statement

6.1 式文 (expression statement)
===============================

式文は、 (主に対話的な使い方では) 値を計算して出力するために
使ったり、(通常は) プロシジャ (procedure: 有意な結果を返さない
関数のことです; Python では、プロシジャは値 `None' を返します)
を呼び出すために使います。その他の使い方でも式文を使うことができ
ますし、有用なこともあります。式文の構文は以下の通りです:

`expression_stmt `expression_list''

式文は式のリスト (単一の式のこともあります) を値評価します。 

対話モードでは、値が `None' でない場合、値を組み込み関数 `repr()'  で文字列に変換して、
その結果のみからなる一行を標準出力に書き出します (~*Note print 文::
節参照)。 (`None'
になる式文の値は書き出されないので、プロシジャ呼び出しを
行っても出力は得られません。) 


File: python-ref-jp.info,  Node: Assert 文 assert statement,  Next: 代入文 assignment statement,  Prev: 式文 expression statement,  Up: 単純文 simple statement

6.2 Assert 文 (assert statement)
================================

Assert 文  は、プログラム内にデバッグ用アサーション (debugging
assertion) を仕掛けるための便利な方法です:

`assert_stmt "assert" `expression' ["," `expression']'

単純な形式 `assert expression' は、

     if __debug__:
        if not expression: raise AssertionError

と等価です。拡張形式 `assert expression1, expression2' は、

     if __debug__:
        if not expression1: raise AssertionError, expression2

と等価です。

上記の等価関係は、 `__debug__'  と `AssertionError'  が、同名の組み込み
変数を参照しているという前提の上に成り立っています。現在の実装では、
組み込み変数 `__debug__' は通常の状況では `True'
であり、最適化がリクエストされた場合（コマンドラインオプション -O）は
`False' です。現状のコード生成器は、コンパイル時に最適化が要求されて
いると assert 文に対するコードを全く出力しません。
実行に失敗した式のソースコードをエラーメッセージ内に入れる必要は
ありません; メッセージはスタックトレース内で表示されます。

`__debug__' への代入は不正な操作です。組み込み変数の値は、
インタプリタが開始するときに決定されます。


File: python-ref-jp.info,  Node: 代入文 assignment statement,  Next: pass 文,  Prev: Assert 文 assert statement,  Up: 単純文 simple statement

6.3 代入文 (assignment statement)
=================================

代入文  は、名前を値に (再) 束縛したり、
変更可能なオブジェクトの属性や要素を変更したりするために使われます: 

`assignment_stmt (`target_list' "=")+ `expression_list''

`target_list `target' ("," `target')* [","]'

`target `identifier''

` | "(" `target_list' ")"'

` | "[" `target_list' "]"'

` | `attributeref''

` | `subscription''

` | `slicing''

(末尾の三つのシンボルの構文については ~*Note 一次語 primary:: 節を
参照してください。)

代入文は式のリスト (これは単一の式でも、
カンマで区切られた式リストでもよく、後者はタプルになることを
思い出してください) を評価し、得られた単一の結果オブジェクトを
ターゲット (target) のリストに対して左から右へと代入してゆきます。 

代入はターゲット (リスト) の形式に従って再帰的に行われます。
ターゲットが変更可能なオブジェクト (属性参照、添字表記、またはスライス)
の一部である場合、この変更可能なオブジェクトは最終的に代入を
実行して、その代入が有効な操作であるか判断しなければなりません。
代入が不可能な場合には例外を発行することもできます。型ごとに
みられる規則や、送出される例外は、そのオブジェクト型定義
で与えられています (~*Note 新スタイルと旧スタイル::
節を参照してください).  

ターゲットリストへのオブジェクトの代入は、以下のようにして再帰的に
定義されています。 

   * ターゲットリストが単一のターゲットからなる場合: オブジェクトはその
     ターゲットに代入されます。

   * ターゲットリストが、カンマで区切られた複数のターゲットからなる
     リストの場合: オブジェクトはターゲットリスト中のターゲット数と
     同じ数の要素からなるシーケンスでなければならず、その各要素は左から
     右へと対応するターゲットに代入されます。(これは Python 1.5
     で緩和された規則です; 以前のバージョンでは、代入するオブジェクトは
     タプルでなければなりませんでした。文字列もシーケンスなので、今では
     `a, b = "xy"' のような代入は文字列が正しい長さを持つ限り
     正規の操作になります。)


単一のターゲットへの単一のオブジェクトの代入は、以下のようにして
再帰的に定義されています。

   * ターゲットが識別子 (名前) の場合:

        * 名前が現在のコードブロック内の `global' 文に書かれて
          いない場合: 名前は現在のローカル名前空間内のオブジェクトに
          束縛されます。 

        * それ以外の場合:
          名前は現在のグローバル名前空間内のオブジェクトに
          束縛されます。


     名前がすでに束縛済みの場合、再束縛 (rebind) がおこなわれます。
     再束縛によって、以前その名前に束縛されていたオブジェクトの
     参照カウント (reference count) がゼロになった場合、オブジェクトは
     解放 (deallocate) され、デストラクタ (destructor ) が (存在すれば)
     呼び出されます。

   * ターゲットが丸括弧や角括弧で囲われたターゲットリストの場合:
     オブジェクトはターゲットリスト中のターゲット数と
     同じ数の要素からなるシーケンスでなければならず、その各要素は左から
     右へと対応するターゲットに代入されます。

   * ターゲットが属性参照の場合: 参照されている一次語の式
     が値評価されます。値は代入可能な属性を伴うオブジェクトでなければ
     なりません; そうでなければ、 `TypeError' が送出されます。
     次に、このオブジェクトに対して、被代入オブジェクトを指定した属性
     に代入してよいか問い合わせます; 代入を実行できない場合、 例外
     (通常は `AttributeError' ですが、必然ではありません) を送出します。 

   * ターゲットが添字表記の場合: 参照されている一次語の式
     が値評価されます。まず、値は変更可能な (リストのような)
     シーケンスオブジェクト か、 (辞書のような)
     マップオブジェクトでなければなりません。
     次に、添字表記の表す式が値評価されます。 

     一次語が変更可能な (リストのような) シーケンスオブジェクトの場合、
     まず添字は整数でなければなりません。添字が負数の場合、シーケンスの
     長さが加算されます。添字は最終的に、シーケンスの長さよりも小さな
     非負の整数でなくてはなりません。次に、添字をインデクスに
     持つ要素に非代入オブジェクトを代入してよいか、シーケンスに問い合わせ
     ます。範囲を超えたインデクスに対しては`IndexError' が送出されます
     (添字指定されたシーケンスに代入を行っても、
     リスト要素の新たな追加はできません)。 

     一次語が (辞書のような) マップオブジェクトの場合、まず添字は
     マップのキー型と互換性のある型でなくてはなりません。
     次に、添字を被代入オブジェクトに関連付けるようなキー/データ
     の対を生成するようマップオブジェクトに問い合わせます。
     この操作では、既存のキー/値の対を同じキーと別の値で置き換えても
     よく、(同じ値を持つキーが存在しない場合)
     新たなキー/値の対を挿入しても かまいません。 

   * ターゲットがスライスの場合: 参照されている一次語の式
     が値評価されます。まず、値は変更可能な (リストのような)
     シーケンスオブジェクト
     でなければなりません。被代入オブジェクトは同じ型を持ったシーケンスオブジェクト
     でなければなりません。次に、スライスの下境界と上境界を示す式があれば
     評価されます; デフォルト値はそれぞれゼロとシーケンスの長さです。
     上下境界は整数にならなければなりません。いずれかの境界が負数に
     なった場合、シーケンスの長さが加算されます。最終的に、境界は
     ゼロからシーケンスの長さまでの内包になるようにクリップされます。
     最後に、スライスを被代入オブジェクトで置き換えてよいかシーケンスオブジェクトに
     問い合わせます。オブジェクトで許されている限り、スライスの長さは
     被代入シーケンスの長さと異なっていてよく、この場合にはターゲットシーケンスの
     長さが変更されます。 


(現在の実装では、ターゲットの構文は式の構文と同じであるとみなされて
おり、無効な構文はコード生成フェーズ中に詳細なエラーメッセージを
伴って拒否されます。)

警告: 代入の定義では、左辺値と右辺値がオーバラップするような代入
(例えば、`a, b = b, a' を行うと、二つの変数を入れ替えます) を
定義しても `安全 (safe)' に代入できますが、代入対象となる 変数群
_の間で_ オーバラップがある場合は安全ではありません！
例えば、以下のプログラムは `[0, 2]' を出力してしまいます:

     x = [0, 1]
     i = 0
     i, x[i] = 1, 2
     print x

* Menu:

* 累算代入文 augmented assignment statement::


File: python-ref-jp.info,  Node: 累算代入文 augmented assignment statement,  Prev: 代入文 assignment statement,  Up: 代入文 assignment statement

6.3.1 累算代入文 (augmented assignment statement)
-------------------------------------------------

累算代入文は、二項演算と代入文を組み合わせて一つの文にしたものです: 

`augmented_assignment_stmt `target' `augop' `expression_list''

`augop "+=" | "-=" | "*=" | "/=" | "%=" | "**="'

` | ">{}>=" | "<{}<=" | "&=" | "^=" | "|="'

累算代入文は、ターゲット (通常の代入文と違って、アンパックは
起こりません) と式リストを評価し、それら二つの被演算子間で特定の累算
代入型の二項演算を行い、結果をもとのターゲットに代入します。
ターゲットは一度しか評価されません。

`x += 1' のような累算代入式は、`x = x + 1' のように書き換えて
ほぼ同様の動作にできますが、厳密に等価にはなりません。累算代入の
方では、`x' は一度しか評価されません。また、実際の処理として、
可能ならば _インプレース (in-place)_ 演算が実行されます。
これは、代入時に新たなオブジェクトを生成してターゲットに代入するの
ではなく、以前のオブジェクトの内容を変更するということです。

累算代入文で行われる代入は、タプルへの代入や、一文中に複数の
ターゲットが存在する場合を除き、通常の代入と同じように扱われます。
同様に、累算代入で行われる二項演算は、場合によって _インプレース演算_
が行われることを除き、通常の二項演算 と同じです。

属性参照のターゲットの場合、代入前の初期値は `getattr()' で
取り出され、演算結果は `setattr()' で代入されます。
二つのメソッドが同じ変数を参照するという必然性はないので注意してください。
例えば:

     class A:
         x = 3    # class variable
     a = A()
     a.x += 1     # writes a.x as 4 leaving A.x as 3

のように、`getattr()' がクラス変数を参照していても、 `setattr()'
はインスタンス変数への書き込みを行ってしまいます。


File: python-ref-jp.info,  Node: pass 文,  Next: del 文,  Prev: 代入文 assignment statement,  Up: 単純文 simple statement

6.4 `pass' 文
=============

`pass_stmt "pass"'

`pass' はヌル操作 (null operation) です -- `pass'
が実行されても、何も起きません。`pass' は、例えば: 

     def f(arg): pass    # a function that does nothing (yet)

     class C: pass       # a class with no methods (yet)

のように、構文法的には文が必要だが、コードとしては何も実行したく
ない場合のプレースホルダとして有用です。


File: python-ref-jp.info,  Node: del 文,  Next: print 文,  Prev: pass 文,  Up: 単純文 simple statement

6.5 `del' 文
============

`del_stmt "del" `target_list''

オブジェクトの削除 (deletion) は、代入の定義と非常に似た方法で
再帰的に定義されています。ここでは完全な詳細を記述するよりも
いくつかのヒントを述べるにとどめます。 

ターゲットリストに対する削除は、各々のターゲットを左から右へと
順に再帰的に削除します。

名前に対して削除を行うと、ローカルまたはグローバル名前空間での
その名前の束縛を解除します。どちらの名前空間かは、名前が同じコード
ブロック内の `global' 文で宣言されているかどうかによります。
名前が未束縛 (unbound) であるばあい、`NameError' 例外 が送出されます。 

ネストしたブロック中で自由変数  になっている
ローカル名前空間上の名前に対する削除は不正な操作になります

属性参照、添字表記、およびスライスの削除操作は、対象となる一次語
オブジェクトに渡されます; スライスの削除は一般的には適切な
型の空のスライスを代入するのと等価です (が、この仕様自体も
スライスされるオブジェクトで決定されています)。 


File: python-ref-jp.info,  Node: print 文,  Next: return 文,  Prev: del 文,  Up: 単純文 simple statement

6.6 `print' 文
==============

`print_stmt "print" ( [`expression' ("," `expression')* [","]]'

` | ">>" `expression' [("," `expression')+ [","]] )'

`print' は、式を逐次的に評価し、得られたオブジェクトを
標準出力に書き出します。オブジェクトが文字列でなければ、まず文字列
変換規則を使って文字列に変換され、次いで (得られた文字列か、オリジナル
の文字列が) 書き出されます。出力系の現在の書き出し位置が行頭にある
と考えられる場合を除き、各オブジェクトの出力前にスペースが一つ出力
されます。行頭にある場合とは、(1) 標準出力にまだ何も書き出されて
いない場合、(2) 標準出力に最後に書き出された文字が `\n' である、または
(3) 標準出力に対する最後の書き出し操作が `print'
文によるものではない場合、です。(こうした理由から、
場合によっては空文字を標準出力に書き出すと便利なことがあります。)
_Note:_ 組み込みのファイルオブジェクトでない、ファイルオブジェクト
に似た動作をするオブジェクトでは、組み込みのファイルオブジェクト
が持つ上記の性質を適切にエミュレートしていないことがあるため、
当てにしないほうがよいでしょう。 

`print' 文がカンマで終了していない限り、末尾には文字 `\n'
が書き出されます。この仕様は、文に予約語 `print'
がある場合のみの動作です。 

標準出力は、組み込みモジュール `sys' 内で `stdout'
という名前のファイルオブジェクトとして定義されています。
該当するオブジェクトが存在しないか、オブジェクトに `write()'
メソッドがない場合、`RuntimeError' 例外が送出されます。.  

`print' には、上で説明した構文の第二形式で定義されている 拡張形式  があります。
この形式は、"山形 `print' 表記 (`print' chevron)"
と呼ばれます。この形式では、`>>' の直後にくる最初の 式の値評価結果は
"ファイル類似 (file-like)" なオブジェクト、とりわけ 上で述べたように
`write()' メソッドを持つオブジェクトで
なければなりません。この拡張形式では、ファイルオブジェクトを指定する
式よりも後ろの式が、指定されたファイルオブジェクトに出力されます。
最初の式の値評価結果が `None' になった場合、 `sys.stdout'
が出力ファイルとして使われます。


File: python-ref-jp.info,  Node: return 文,  Next: yield 文,  Prev: print 文,  Up: 単純文 simple statement

6.7 `return' 文
===============

`return_stmt "return" [`expression_list']'

`return' は、関数定義内で構文法的にネストして現れますが、
ネストしたクラス定義内には現れません。 

式リストがある場合、リストが値評価されます。それ以外の場合は `None'
で置き換えられます。

`return' を使うと、式リスト (または `None')
を戻り値として、現在の関数呼び出しから抜け出します。

`return' によって、`finally' 節をともなう `try'
文の外に処理が引き渡されると、実際に関数から抜ける前に `finally'
節が実行されます。 

ジェネレータ関数の場合には、`return' 文の中に `expression_list'
を入れることはできません。
ジェネレータ関数の処理コンテキストでは、単体の `return'
はジェネレータ処理を終了し `StopIteration' を送出させる ことを示します。


File: python-ref-jp.info,  Node: yield 文,  Next: raise 文,  Prev: return 文,  Up: 単純文 simple statement

6.8 `yield' 文
==============

`yield_stmt "yield" `expression_list''

`yield' 文は、ジェネレータ関数 (generator function) を
定義するときだけ使われ、かつジェネレータ関数の本体の中でだけ
用いられます。 関数定義中で `yield' 文を使うだけで、関数定義は通常の関数
でなくジェネレータ関数になります。

ジェネレータ関数が呼び出されると、ジェネレータイテレータ (generator
iterator)、一般的にはジェネレータ (generator) を
返します。ジェネレータ関数の本体は、ジェネレータの `next()'
が例外を発行するまで繰り返し呼び出して実行します。

`yield' 文が実行されると、現在のジェネレータの状態は 凍結 (freeze)
され、`expression_list' の値が `next()'
の呼び出し側に返されます。ここでの "凍結" は、ローカルな変数への
束縛、命令ポインタ (instruction pointer)、および内部実行スタック
(internal evaluation stack) を含む、全てのローカルな状態が保存される
ことを意味します: すなわち、必要な情報を保存しておき、次に `next()'
が呼び出された際に、関数が `yield' 文をあたかも
もう一つの外部呼出しであるかのように処理できるようにします。

Python バージョン 2.5 では、`yield' 文が `try' ...  `finally'
構造における `try'
節で許されるようになりました。ジェネレータが終了（finalized）される
（参照カウントがゼロになるか、ガベージコレクションされる)
までに再開されなければ、 ジェネレータ-イテレータの `close()'
メソッドが呼ばれ、 留保されている `finally'
節が実行できるようになります。

_Notice:_ Python 2.2 では、`generators' 機能が有効になっている場合にのみ
`yield' 文を使えます。Python 2.3 では、常に有効になっています。
`__future__' import 文を使うと、この機能を有効にできます:

     from __future__ import generators

See also:
    *PEP0255 単純なジェネレータ*
          Python へのジェネレータと `yield' 文の導入提案

    *PEP0342 改善されたジェネレータによるコルーチン (Coroutine)*
          その他のジェネレータの改善と共に、 `yield' が `try' ...
          `finally' ブロックの中に存在することを 可能にするための提案



File: python-ref-jp.info,  Node: raise 文,  Next: break 文,  Prev: yield 文,  Up: 単純文 simple statement

6.9 `raise' 文
==============

`raise_stmt "raise" [`expression' ["," `expression' ["," `expression']]]'

式を伴わない場合、`raise' は現在のスコープで最終的に有効に
なっている例外を再送出します。そのような例外が現在のスコープで
アクティブでない場合、`TypeError' 例外が送出されて、
これがエラーであることを示します (IDLE で実行した場合は、 代わりに
exception{Queue.Empty} 例外を送出します)。 

それ以外の場合、`raise' は式を値評価して、三つのオブジェクトを
取得します。このとき、`None' を省略された式の値として使います。
最初の二つのオブジェクトは、例外の _型 (type)_ と 例外の _値 (value)_
を決定するために用いられます。

最初のオブジェクトがインスタンスである場合、例外の型はインスタンス
のクラスになり、インスタンス自体が例外の値になります。このとき
第二のオブジェクトは `None' でなければなりません。

最初のオブジェクトがクラスの場合、例外の型になります。
第二のオブジェクトは、例外の値を決めるために使われます:
第二のオブジェクトがインスタンスならば、そのインスタンスが
例外の値になります。第二のオブジェクトがタプルの場合、
クラスのコンストラクタに対する引数リストとして使われます; `None'
なら、空の引数リストとして扱われ、それ以外の型
ならコンストラクタに対する単一の引数として扱われます。
このようにしてコンストラクタを呼び出して生成したインスタンス
が例外の値になります。

第三のオブジェクトが存在し、かつ `None' でなければ、
オブジェクトはトレースバック  オブジェクト でなければなりません (~*Note
標準型の階層:: 節参照)。また、
例外が発生した場所は現在の処理位置に置き換えられます。
第三のオブジェクトが存在し、オブジェクトがトレースバック
オブジェクトでも `None' でもなければ、`TypeError'
例外が送出されます。`raise' の三連式型は、`except'
節から透過的に例外を再送出するのに便利ですが、再送出すべき
例外が現在のスコープで発生した最も新しいアクティブな例外で
ある場合には、式なしの `raise' を使うよう推奨します。

例外に関する追加情報は ~*Note 例外:: 節にあります。また、
例外処理に関する情報は ~*Note try 文:: 節にあります。


File: python-ref-jp.info,  Node: break 文,  Next: continue 文,  Prev: raise 文,  Up: 単純文 simple statement

6.10 `break' 文
===============

`break_stmt "break"'

`break' 文は `for' ループや `while' ループ内の
ネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義
には現れません。 

`break' 文は、文を囲う最も内側のループを終了させ、 ループにオプションの
`else' 節がある場合には `else' 節に飛びます。 

`for' ループを `break' によって終了すると、
ループ制御ターゲットはその時の値を保持します。 

`break' が `finally' 節を伴う `try' 文の
外側に処理を渡す際には、ループを実際に抜ける前にその`finally'
節が実行されます。 


File: python-ref-jp.info,  Node: continue 文,  Next: import 文,  Prev: break 文,  Up: 単純文 simple statement

6.11 `continue' 文
==================

`continue_stmt "continue"'

`continue' 文は `for' ループや `while' ループ内の
ネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義、
`finally' 文の中には現れません。(1)

`continue' 文は、文を囲う最も内側のループの次の周期に 処理を継続します。 

---------- Footnotes ----------

(1) `except' 節や `else' 節中に置くことはできます。`try' 文に置けない
という制限は、実装側の不精によるもので、そのうち改善されることでしょう。


File: python-ref-jp.info,  Node: import 文,  Next: global 文,  Prev: continue 文,  Up: 単純文 simple statement

6.12 `import' 文
================

`import_stmt "import" `module' ["as" `name'] ( "," `module' ["as" `name'] )*'

` | "from" `module' "import" `identifier' ["as" `name']'

`   ( "," `identifier' ["as" `name'] )*'

` | "from" `module' "import" "(" `identifier' ["as" `name']'

`   ( "," `identifier' ["as" `name'] )* [","] ")"'

` | "from" `module' "import" "*"'

`module (`identifier' ".")* `identifier''

import 文は、(1) モジュールを探し、必要なら初期化 (initialize) する;
(`import' 文のあるスコープにおける) ローカルな名前空間で
名前を定義する、の二つの段階を踏んで初期化されます。 第一形式 (`from'
のない形式) は、上記の段階をリスト中にある
各識別子に対して繰り返し実行していきます。 `from' のある形式では、(1)
を一度だけ行い、次いで (2) を 繰り返し実行します。

組み込みモジュールや拡張モジュールの "初期化" は、ここでは
初期化関数の呼び出しを意味します。モジュールは初期化を行うために
かならず初期化関数を提供しなければなりません
(リファレンス実装では、関数名はモジュール名の前に "init" を
つけたものになっています); Python で書かれたモジュールの "初期化"
は、モジュール本体の 実行を意味します。

Python 処理系は、すでに初期化済みのモジュールや、初期化中のモジュール
をモジュール名でインデクス化したテーブルを維持しています。
このテーブルは `sys.modules' からアクセスできます。
モジュール名がこのテーブル内にあるなら、段階 (1) は完了しています。
そうでなければ、処理系はモジュール定義の検索を開始します。モジュール
が見つかった場合、モジュールを読み込み (load) ます。モジュール検索や
読み込みプロセスの詳細は、実装やプラットフォームに依存します。
一般的には、ある名前のモジュールを検索する際、まず同名の "組み込み
(built-in)" モジュールを探し、次に `sys.path'
で列挙されている場所を探します。 

組み込みモジュールが見つかった場合  、
組み込みの初期化コードが実行され、段階 (1) を完結します。
合致するファイルが見つからなかった場合、 `ImportError'  が送出されます。 ファイルが見つかった場合、ファイルを構文解析して実行可能な
コードブロックにします。構文エラーが起きた場合、 `SyntaxError'  が送出されます。
それ以外の場合、まず指定された名前をもつ空のモジュールを作成し、
モジュールテーブルに挿入します。次に、このモジュールの実行コンテキスト
下でコードブロックを実行します。実行中に例外が発生すると、段階 (1)
を終了 (terminate) します。

段階 (1) が例外を送出することなく完了したなら、段階 (2) を開始 します。

`import' 文の第一形式は、ローカルな名前空間に置かれた
モジュール名をモジュールオブジェクトに束縛し、import すべき
次の識別子があればその処理に移ります。モジュール名の後ろに `as'
がある場合、`as' の後ろの名前はモジュールの
ローカルな名前として使われます。

`from' 形式は、モジュール名の束縛を行いません: `from' 形式では、段階
(1) で見つかったモジュール内から、
識別子リストの各名前を順に検索し、見つかったオブジェクトを識別子の
名前でローカルな名前空間において束縛します。 `import'
の第一形式と同じように、"`as' localname"
で別名を与えることができます。指定された名前が見つからない場合、
`ImportError' が送出されます。識別子のリストを星印 (`*')
で置き換えると、モジュールで公開されている名前 (public name) 全てを
`import' 文のある場所のローカルな 名前空間に束縛します。。。 

モジュールで _公開されている名前 (public names)_ は、
モジュールの名前空間内にある `__all__' という名前の変数
を調べて決定します; `__all__' が定義されている場合、 `__all__'
はモジュールで定義されていたり、import されている
ような名前の文字列からなるシーケンスでなければなりません。 `__all__'
内にある名前は、全て公開された名前であり、 実在するものとみなされます。
`__all__' が定義されていない場合、モジュールの名前空間に
見つかった名前で、アンダースコア文字 (`_') で始まっていない
全ての名前が公開された名前になります。 `__all__' には、公開されている
API 全てを入れなければなりません。 `__all__' には、(モジュール内で
import されて使われている ライブラリモジュールのように) API
を構成しない要素を意に反して
公開してしまうのを避けるという意図があります。 

`*' を使った `from' 形式は、モジュールのスコープ内
だけに作用します。関数内でワイルドカードの import 文 -- `import *' --
を使い、関数が自由変数を伴うネストされたブロック
であったり、ブロックを含んでいる場合、コンパイラは `SyntaxError'
を送出します。

*階層的なモジュール名:* モジュール名に一つまたはそれ以上のドットが入っている場合、
モジュール検索パスは違った扱われ方をします。最後のドットまでの
各識別子からなる列は、"パッケージ (package)" を見つけるために使われます;
次に、パッケージ内から各識別子が 検索されます。パッケージとは、一般には
`sys.path' 上のディレクトリ のサブディレクトリで、`__init__.py'.  ファイルを持つものです。
[XXX この説明については、ここでは今のところこれ以上詳しく書けません;
詳細や、パッケージ内モジュールの検索がどのように行われるかは、
`http://www.python.org/doc/essays/packages.html' を参照 してください]

どのモジュールがロードされるべきかを動的に決めたいアプリケーションの
ために、組み込み関数 `__import__()' が提供されています; 詳細は、 の
組み込み関数 を参照してください。 

* Menu:

* future 文 future statement::


File: python-ref-jp.info,  Node: future 文 future statement,  Prev: import 文,  Up: import 文

6.12.1 future 文 (future statement)
-----------------------------------

"future 文"  は、 将来の特定の Python
のリリースで利用可能になるような構文や意味付け
を使って、特定のモジュールをコンパイルさせるための、コンパイラに
対する指示句 (directive) です。 future
文は、言語仕様に非互換性がもたらされるような、将来の Python
のバージョンに容易に移行できるよう意図されています。 future
文によって、新たな機能が標準化されたリリースが
出される前に、その機能をモジュール単位で使えるようにします。

     [*]

`future_statement "from" "__future__" "import" feature ["as" name] ("," feature ["as" name])*'

` | "from" "__future__" "import" "(" feature ["as" name] ("," feature ["as" name])* [","] ")"'

`feature identifier'

`name identifier'

future 文は、モジュールの先頭周辺に書かなければなりません。 future
文の前に書いてよい内容は:

   * the module docstring (if any),

   * comments,

   * blank lines, and

   * other future statements.


です。

Python 2.3 が feature 文で新たに認識するようになった機能は、
`generators'、`division'、および `nested_scopes' です。 `generators'
および `nested_scopes' は Python 2.3
では常に有効になっているので、冗長な機能名といえます。

future 文は、コンパイル時に特別なやり方で認識され、扱われます:
言語の中核をなす構文構成 (construct) に対する意味付けが変更されて
いる場合、変更部分はしばしば異なるコードを生成することで実現
されています。新たな機能によって、(新たな予約語のような)
互換性のない新たな構文が取り入れられることさえあります。
この場合、コンパイラはモジュールを別のやりかたで解析する必要が
あるかもしれません。こうしたコード生成に関する決定は、
実行時まで先延ばしすることはできません。

これまでの全てのリリースにおいて、コンパイラはどの機能が定義済み
かを知っており、future 文に未知の機能が含まれている場合には
コンパイル時エラーを送出します。

future 文の実行時における直接的な意味付けは、import 文と同じです。
標準モジュール `__future__' があり、これについては後で述べます。
`__future__' は、future 文が実行される際に通常の方法で import されます。

future 文の実行時における特別な意味付けは、future 文で有効化される
特定の機能によって変わります。

以下の文:

     import __future__ [as name]

には、何ら特殊な意味はないので注意してください。

これは future 文ではありません; この文は通常の import 文であり、
その他の特殊な意味付けや構文的な制限はありません。

future 文の入ったモジュール `M' 内で使われている `exec'
文、組み込み関数 `compile()' や `execfile()'
によってコンパイルされるコードは、デフォルトの設定では、 future
文に関係する新たな構文や意味付けを使うようになっています。 Python 2.2
からは、この仕様を `compile()' のオプション引数
で制御できるようになりました -- 詳細は  で
この関数に関するドキュメントを参照してください。

対話的インタプリタのプロンプトでタイプ入力した future 文は、
その後のインタプリタセッション中で有効になります。インタプリタ を `-i'
オプションで起動して実行すべきスクリプト名を 渡し、スクリプト中に
future 文を入れておくと、新たな機能は
スクリプトが実行された後に開始する対話セッションで有効になります。


File: python-ref-jp.info,  Node: global 文,  Next: exec 文,  Prev: import 文,  Up: 単純文 simple statement

6.13 `global' 文
================

`global_stmt "global" `identifier' ("," `identifier')*'

`global' 文は、現在のコードブロック全体で維持される宣言文
です。`global' 文は、列挙した識別子をグローバル変数として
解釈するよう指定することを意味します。 `global'
を使わずにグローバル変数に代入を行うことは
不可能ですが、自由変数を使えばその変数をグローバルであると宣言せずに
グローバル変数を参照することができます。 

`global' 文で列挙する名前は、同じコードブロック中で、
プログラムテキスト上 `global' 文より前に使っては なりません。

`global' 文で列挙する名前は、`for' ループの
ループ制御ターゲットや、`class' 定義、関数定義、 `import'
文内で仮引数として使ってはなりません。

(現在の実装では、後ろ二つの制限については強制していませんが、
プログラムでこの緩和された仕様を乱用すべきではありません。
将来の実装では、この制限を強制したり、暗黙のうちにプログラム
の意味付けを変更したりする可能性があります。)

*プログラマのための注意点:* `global' はパーザに対する指示句 (directive)
です。 この指示句は、`global' 文と同時に読み込まれたコード
に対してのみ適用されます。特に、`exec' 文内に入っている `global'
文は、`exec' 文を _含んでいる_
コードブロック内に効果を及ぼすことはなく、`exec' 文内に
含まれているコードは、`exec' 文を含むコード内での `global'
文に影響を受けません。同様のことが、関数 `eval()'、 `execfile()'
、および `compile()' にも当てはまります。 


File: python-ref-jp.info,  Node: exec 文,  Prev: global 文,  Up: 単純文 simple statement

6.14 `exec' 文
==============

`exec_stmt "exec" `expression' ["in" `expression' ["," `expression']]'

この文は、Python コードの動的な実行をサポートします。
最初の式の値評価結果は文字列か、開かれたファイルオブジェクトか、
コードオブジェクトでなければなりません。文字列の場合、 一連の Python
実行文として解析し、(構文エラーが生じない限り)
実行します。開かれたファイルであれば、ファイルを `EOF'
まで読んで解析し、実行します。コードオブジェクトなら、単にこれを実行します。全ての
場合で、実行されたコードはファイル入力として有効であることが
期待されます (セクション~*Note ファイル入力::、"ファイル入力"を参照)。
`return' と `yield' 文は、`exec' 文に
渡されたコードの文脈中においても関数定義の外では使われない点に
注意してください。

いずれの場合でも、オプションの部分が省略されると、コードは
現在のスコープ内で実行されます。`in' の後ろに一つだけ
式を指定する場合、その式は辞書でなくてはならず、
グローバル変数とローカル変数の両方に使われます。
これらはそれぞれグローバル変数とローカル変数として使われます。 LOCALS
を指定する場合は何らかのマップ型オブジェクトに せねばなりません．
_Changed in Python version 2.4_

`exec' の副作用として実行されるコードで設定された変数名に
対応する名前の他に、追加のキーを辞書に追加することがあります。
例えば、現在の実装では、組み込みモジュール `__builtin__'
の辞書に対する参照を、`__builtins__' (!) というキーで追加
することがあります。 

*プログラマのためのヒント:* 式の動的な評価は、組み込み関数 `eval()'
でサポートされています 組み込み関数 `globals()' および `locals()' は、
それぞれ現在のグローバル辞書とローカル辞書を返すので、 `exec'
に渡して使うと便利です。 


File: python-ref-jp.info,  Node: 複合文 compound statement,  Next: トップレベル要素,  Prev: 単純文 simple statement,  Up: Top

7 複合文 (compound statement)
*****************************

複合文には、他の文 (のグループ) が入ります; 複合文は、中に入っている
他の文の実行の制御に何らかのやり方で影響を及ぼします。
一般的には、複合文は複数行にまたがって書かれますが、
全部の文を一行に連ねた単純な書き方もあります。

`if'、`while' 、および `for' 文は、
伝統的な制御フロー構成を実現します。`try' は例外処理
かつ/または一連の文に対するクリーンアップコードを指定します。
関数とクラス定義もまた、構文法的には複合文です。

複合文は、一つまたはそれ以上の `節 (clause)' からなります。
一つの節は、ヘッダと `スイート (suite)' からなります。
特定の複合文を構成する節のヘッダ部分は、全て同じインデント
レベルになります。各々の節ヘッダ行は一意に識別されるキーワード
から始まり、コロンで終わります。スイートは、ヘッダのコロンの後ろに
セミコロンで区切られた一つまたはそれ以上の単純文を並べるか、
ヘッダ行後のインデントされた文の集まりです。
後者の形式のスイートに限り、ネストされた複合文を入れることが できます;
以下の文は、`else' 節がどの `if' 節
に属するかがはっきりしないという理由から不正になります:

     if test1: if test2: print x

また、このコンテキスト中では、セミコロンはコロンよりも強い結合を
表すことにも注意してください。従って、以下の例では、`print'
は全て実行されるか、されないかのどちらかです:

     if x < y < z: print x; print y; print z

まとめると、以下のようになります:

`compound_stmt `if_stmt''

` | `while_stmt''

` | `for_stmt''

` | `try_stmt''

` | `with_stmt''

` | `funcdef''

` | `classdef''

`suite `stmt_list' NEWLINE | NEWLINE INDENT `statement'+ DEDENT'

`statement `stmt_list' NEWLINE | `compound_stmt''

`stmt_list `simple_stmt' (";" `simple_stmt')* [";"]'

文は常に `NEWLINE'  か、その後に `DEDENT'
が続いたもので終了することに注意してください。  また、オプションの継続節は常にあるキーワード
から始まり、このキーワードから複合文を開始することはできないため、
曖昧さは存在しないことにも注意してください (Python では、
`ぶら下がり(dangling) `else'' 問題を、ネストされた `if'
文はインデントさせること解決しています)。 

以下の節における文法規則の記述方式は、明確さのために、
各節を別々の行に書くようにしています。

* Menu:

* if 文::
* while 文::
* for 文::
* try 文::
* with 文::
* 関数定義::
* クラス定義::


File: python-ref-jp.info,  Node: if 文,  Next: while 文,  Prev: 複合文 compound statement,  Up: 複合文 compound statement

7.1 `if' 文
===========

`if' 文は、条件分岐を実行するために使われます:

`if_stmt "if" `expression' ":" `suite''

` ( "elif" `expression' ":" `suite' )*'

` ["else" ":" `suite']'

`if' 文は、式を一つ一つ評価してゆき、真になるまで続けて、
真になった節のスイートだけを選択します (真: true と偽: false の定義
については、~*Note ブール演算 boolean operation::
節を参照してください); 次に、選択した スイートを実行します (または、
`if' 文の他の部分を実行 したり、評価したりします)
全ての式が偽になった場合、 `else' 節があれば、そのスイート
が実行されます。 


File: python-ref-jp.info,  Node: while 文,  Next: for 文,  Prev: if 文,  Up: 複合文 compound statement

7.2 `while' 文
==============

`while' 文は、式の値が真である間、実行を繰り返すために使われます:

`while_stmt "while" `expression' ":" `suite''

` ["else" ":" `suite']'

`while' 文は式を繰り返し真偽評価し、真であれば最初の
スイートを実行します。式が偽であれば (最初から偽になっていることも
ありえます)、`else' 節がある場合にはそれを実行し、 ループを終了します。 

最初のスイート内で `break' 文が実行されると、`else' 節の
スイートを実行することなくループを終了します。 `continue'
文が最初のスイート内で実行されると、
スイート内にある残りの文の実行をスキップして、式の真偽評価に戻ります。 


File: python-ref-jp.info,  Node: for 文,  Next: try 文,  Prev: while 文,  Up: 複合文 compound statement

7.3 `for' 文
============

`for' 文は、シーケンス (文字列、タプルまたはリスト) や、その他の
反復可能なオブジェクト (iterable object) 内の要素に渡って反復処理を
行うために使われます: 

`for_stmt "for" `target_list' "in" `expression_list' ":" `suite''

` ["else" ":" `suite']'

式リストは一度だけ評価されます; 結果はイテレーション可能オブジェクト
にならねばなりません。`expression_list' の結果に対してイテレータ
を生成し、その後、シーケンスの各要素についてインデクスの小さい順に
一度だけスイートを実行します。
このときシーケンス内の要素が通常の代入規則を使ってターゲットリスト
に代入され、その後スイートが実行されます。全ての要素を使い切ると
(シーケンスが空の場合にはすぐに)、 `else' 節があればそれが
実行され、ループを終了します。 

最初のスイート内で `break' 文が実行されると、`else' 節の
スイートを実行することなくループを終了します。 `continue'
文が最初のスイート内で実行されると、
スイート内にある残りの文の実行をスキップして、式の真偽評価に戻ります。 

スイートの中では、ターゲットリスト内の変数に代入を行えます;
この代入によって、次に代入される要素に影響を及ぼすことはありません。

ループが終了してもターゲットリストは削除されませんが、シーケンスが
空の場合には、ループでの代入は全く行われません。 ヒント: 組み込み関数
`range()' は、 Pascal 言語における `for i := a to b do' の効果を
エミュレートするのに適した数列を返します; すなわち、 `range(3)'
はリスト `[0, 1, 2]' を返します。 

_ループ中のシーケンスの変更には微妙な問題があります (これは
変更可能なシーケンス、すなわちリストで起こります)。
どの要素が次に使われるかを追跡するために、内部的なカウンタが
使われており、このカウンタは反復処理を行うごとに加算されます。
このカウンタがシーケンスの長さに達すると、ループは終了します。
このことは、スイート中でシーケンスから現在の (または以前の) 要素を
除去すると、(次の要素のインデクスは、すでに取り扱った要素の
インデクスになるために) 次の要素が飛ばされることを意味します。
同様に、スイート中でシーケンス中の現在の要素以前に要素を挿入すると、
ループ中で現在の要素が再度扱われることになります。
こうした仕様は、厄介なバグになります。シーケンス全体に相当するスライスを
使って一時的なコピーを作ると、これを避けることができます。 

_

     for x in a[:]:
         if x < 0: a.remove(x)


File: python-ref-jp.info,  Node: try 文,  Next: with 文,  Prev: for 文,  Up: 複合文 compound statement

7.4 `try' 文
============

`try' 文は、ひとまとめの文に対して、例外処理かつ/または
クリーンアップコードを指定します:

`try_stmt try1_stmt | try2_stmt'

`try1_stmt "try" ":" `suite''

` ("except" [`expression' ["," `target']] ":" `suite')+'

` ["else" ":" `suite']'

` ["finally" ":" `suite']'

`try2_stmt "try" ":" `suite''

` "finally" ":" `suite''

_Changed in Python version 2.5_

`except' 節は一つまたはそれ以上の例外ハンドラを指定します。 `try'
節内で全く例外が起きなければ、どの例外ハンドラも 実行されません。`try'
スイート内で例外が発生すると、
例外ハンドラの検索が開始されます。この検索では、`except'
節を逐次調べて、発生した例外に合致するまで続けます。 式を伴わない
`except' 節を使う場合、最後に書かなければ なりません; この `except'
節は全ての例外に合致します。 式を伴う `except'
節に対しては、式が値評価され、 返されたオブジェクトが例外と "互換である
(compatible)"
場合にその節が合致します。ある例外に対してオブジェクトが互換で
あるのは、 それが例外オブジェクトのクラスかベースクラスの場合、または
例外と互換性のある要素が入ったタプルである場合、または、
(非推奨であるところの)
文字列による例外の場合は、送出された文字列そのものである場合です
(注意点として、オブジェクトのアイデンティティが一致しなければいけません。
つまり、同じ文字列オブジェクトなのであって、単なる同じ値を持つ文字列ではありません)。 

例外がどの `except' 節にも合致しなかった場合、現在の
コードを囲うさらに外側、そして呼び出しスタックへと検索を続けます。 (1)

`except' 節のヘッダにある式を値評価するときに例外が発生
すると、元々のハンドラ検索はキャンセルされ、新たな例外に対する
例外ハンドラの検索を現在の `except' 節の外側のコードや
呼び出しスタックに対して行います (`try' 文全体が
例外を発行したかのように扱われます)。

合致する except 節が見つかると、その `except' 節は その except
節で指定されているターゲットに代入されて、 もし存在する場合、加えて
except 節スイートが実行されます。 全ての except
節は実行可能なブロックを持っていなければ
なりません。このブロックの末尾に到達すると、通常は `try' 文
全体の直後に実行を継続します。(このことは、同じ例外に対してネスト
した二つの例外ハンドラが存在し、内側のハンドラ内の `try' 節
で例外が発生した場合、外側のハンドラは例外を処理しないことを意味
します。)

`except' 節のスイートが実行される前に、例外に関する 詳細が `sys'  モジュール内の三つの
変数に代入されます: `sys.exc_type' は、例外を示すオブジェクト
を受け取ります; `sys.exc_value' は例外のパラメタを受け取ります;
`sys.exc_traceback' は、プログラム上の例外が発生した位置を
識別するトレースバックオブジェクト (~*Note 標準型の階層:: 節参照)
を受け取ります。 これらの詳細はまた、関数 `sys.exc_info()' を介して
入手することもできます。この関数は タプル `(EXC_TYPE, EXC_VALUE,
EXC_TRACEBACK)'
を返します。ただしこの関数に対応する変数の使用は、スレッドを使った
プログラムで安全に使えないため撤廃されています。 Python 1.5
からは、例外を処理した関数から戻るときに、以前の値 (関数呼び出し前の値)
に戻されます。 

オプションの `else' 節は、実行の制御が `try' 節
の末尾に到達した場合に実行されます。(2) `else'
節内で起きた例外は、`else' 節に先行する `except'
節で処理されることはありません。 

`finally' が存在する場合、これは 'クリーンアップ' ハンドラを
指定しています。`except' や `else' 節を含む `try' 節が
実行されます。それらの節のいずれかで例外が発生して処理されない場合、
その例外は一時的に保存されます。`finally' 節が実行されます。
もし保存された例外が存在する場合、それは `finally' 節の最後で
再送出されます。 `finally' 節で別の例外が送出されたり、`return' や
`break' 節が実行された場合、保存されていた
例外は失われます。例外情報は、`finally' 節の実行中には
プログラムで取得することができません。 

`try'...`finally' 文の `try' スイート内で `return'、 `break'、または
`continue' 文が 実行された場合、`finally' 節も `抜け出る途中に (on the
way out)' 実行されます。 

例外に関するその他の情報は ~*Note 例外:: 節にあります。また、 `raise'
文の使用による例外の生成に関する情報は、 ~*Note raise 文::
節にあります。

---------- Footnotes ----------

(1) 例外は、例外を打ち消す `finally' 節が無い場合にのみ
呼び出しスタックへ伝わります。

(2)  現在、制御が "末尾に到達する" のは、例外が発生したり、
`return'、`continue'、または `break' 文 が実行される場合を除きます。


File: python-ref-jp.info,  Node: with 文,  Next: 関数定義,  Prev: try 文,  Up: 複合文 compound statement

7.5 `with' 文
=============

_Added in Python version 2.5_

`with' 文は、ブロックの実行を、コンテキストマネージャによって定義された
メソッドでラップするために使われます（~*Note
with文とコンテキストマネージャ:: セクションを
参照してください）。これにより、よくある `try'...`except'...`finally'
利用パターンを カプセル化して便利に再利用することができます。

`with_stmt "with" `expression' ["as" target] ":" `suite''

`with' 文の実行は以下のように進行します：

  1. コンテキスト式を評価し、コンテキストマネージャを取得します。

  2. コンテキストマネージャの `__enter__()' メソッドが呼ばれます。

  3. ターゲットが `with' 文に含まれる場合、 `__enter__()'
     からの戻り値がこれに代入されます。

     _Note:_ `with' 文は、`__enter__()' メソッドがエラーなく
     終了した場合には `__exit__()'
     が常に呼ばれることを保証します。ですので、もしエラーが
     ターゲットリストへの代入中にエラーが発生した場合には、これは
     そのスイートの中で発生したエラーと同じように扱われます。

  4. スイートが実行されます。

  5. コンテキストマネージャの `__exit__()' メソッドが呼ばれます。もし
     例外がスイートを終了させる場合、その型、値、そして
     トレースバックが `__exit__()'
     へ引数として渡されます。そうでなければ、 3 つの `None'
     引数が与えられます。

     スイートが例外により終了した場合、 `__exit__()'
     メソッドからの戻り値は偽（false）であり、例外が
     再送出されます。この戻り値が真（true）ならば例外は抑制され、そして
     実行は `with' 文に続く分へ継続されます。

     もしそのスイートが例外でない何らかの理由で終了した場合、その
     `__exit__()' からの戻り値は無視されて、実行は
     発生した終了の種類に応じた通常の位置から継続します。


_Notice:_ Python 2.5 では、`with' 文は `with_statement' 機能が有効に
された場合にだけ許可されます。これは Python 2.6
では常に有効になります。`__future__' インポート文が
この機能を有効にするために利用できます：

     from __future__ import with_statement

See also:
    *PEP0343 The "with" statement*
          Python の `with' 文の 仕様、背景、そして実例



File: python-ref-jp.info,  Node: 関数定義,  Next: クラス定義,  Prev: with 文,  Up: 複合文 compound statement

7.6 関数定義
============

関数定義は、ユーザ定義関数オブジェクトを定義します (~*Note
新スタイルと旧スタイル:: 節参照): 

`funcdef [`decorators'] "def" `funcname' "(" [`parameter_list'] ")" ":" `suite''

`decorators `decorator'+'

`decorator "@" `dotted_name' ["(" [`argument_list' [","]] ")"] NEWLINE'

`dotted_name `identifier' ("." `identifier')*'

`parameter_list (`defparameter' ",")*'

` (~~"*" `identifier' [, "**" `identifier']'

`  | "**" `identifier''

`  | `defparameter' [","] )'

`defparameter `parameter' ["=" `expression']'

`sublist `parameter' ("," `parameter')* [","]'

`parameter `identifier' | "(" `sublist' ")"'

`funcname `identifier''

関数定義は実行可能な文です。関数定義を実行すると、現在のローカルな
名前空間内で関数名を関数オブジェクト (関数の実行可能コードを
くるむラッパ) に束縛します。この関数オブジェクトには、関数が呼び出された
際に使われるグローバルな名前空間として、現在のグローバルな名前空間
への参照が入っています。 

関数定義は関数本体を実行しません; 関数本体は関数が呼び出された
時にのみ実行されます。

関数定義は一つまたは複数のデコレータ式 (decorator expression) でラップ
できます。デコレータ式は関数を定義する時点で、関数定義の入っているスコープ
において評価されます。デコレータは呼び出し可能オブジェクトを返さねば
なりません。また、デコレータのとれる引数は関数オブジェクトひとつだけです。
デコレータの返す値は関数オブジェクトではなく、関数名にバインドされます。
複数のデコレータを入れ子にして適用してもかまいません。例えば、以下のような
コード:

     @f1(arg)
     @f2
     def func(): pass

は、

     def func(): pass
     func = f1(arg)(f2(func))

と同じです。

一つ以上のトップレベルのパラメタに  PARAMETER `=' EXPRESSION
の形式がある場合、関数は "デフォルトのパラメタ値 (default parameter
values)" を持つと
いいます。デフォルト値を伴うパラメタに対しては、関数呼び出しの
際に対応するパラメタが省略されると、パラメタの値はデフォルト値で
置き換えられます。 あるパラメタがデフォルト値を持つ場合、それ以後の
パラメタは全てデフォルト値を持たなければなりません -- これは
文法的には表現されていない構文上の制限です。 

*デフォルトパラメタ値は関数定義を実行する際に値評価されます。*
これは、デフォルトパラメタの式は関数を定義するときにただ一度だけ評価され、
同じ "計算済みの" 値が全ての呼び出しで使われることを意味します。
デフォルトパラメタ値がリストや辞書のような変更可能なオブジェクトである
場合、この使用を理解しておくことは特に重要です: 関数でこのオブジェクト
を (例えばリストに要素を追加して) 変更する と、実際のデフォルト
値が変更されてしまいます。一般には、これは意図しない動作です。
このような動作を避けるには、デフォルト値に `None' を使い、
この値を関数本体の中で明示的にテストします。例えば以下のようにします:

     def whats_on_the_telly(penguin=None):
         if penguin is None:
             penguin = []
         penguin.append("property of the zoo")
         return penguin

関数呼び出しの意味付けに関する詳細は、~*Note 呼び出し call::
節で述べられて います。
関数呼び出しを行うと、パラメタリストに記述された全てのパラメタ
に対して、固定引数、キーワード引数、デフォルト引数のいずれか
から値を代入します。"`*identifier'" 形式が存在する場合、
余った固定引数を受け取るタプルに初期化されます。この変数の
デフォルト値は空のタプルです。"`**identifier'" 形式が
存在する場合、余ったキーワード引数を受け取るタプルに初期化されます。
デフォルト値は空の辞書です。

式で直接使うために、無名関数 (名前に束縛されていない関数) を作成する
ことも可能です。無名関数の作成には、~*Note ラムダ lambda::
節で記述されている ラムダ形式 (lambda form)
を使います。ラムダ形式は、単純化された
関数定義を行うための略記法にすぎません; "`def'" 文で定義
された関数は、ラムダ形式で定義された関数と全く同様に引渡したり、
他の名前に代入したりできます。実際には、"`def'" 形式は複数の
式を実行できるという点でより強力です。 

*プログラマのための注釈:* 関数は一級の (first-class) オブジェクト
です。関数定義内で"`def'" 形式を実行すると、戻り値として返したり
引き渡したりできるローカルな関数を定義します。
ネストされた関数内で自由変数を使うと、`def' 文の入っている
関数のローカル変数にアクセスすることができます。詳細は ~*Note
名前づけと束縛 naming and binding:: 節を参照してください。


File: python-ref-jp.info,  Node: クラス定義,  Prev: 関数定義,  Up: 複合文 compound statement

7.7 クラス定義
==============

クラス定義は、クラスオブジェクトを定義します (~*Note
新スタイルと旧スタイル:: 節参照): 

`classdef "class" `classname' [`inheritance'] ":" `suite''

`inheritance "(" [`expression_list'] ")"'

`classname `identifier''

クラス定義は実行可能な文です。クラス定義では、まず継承リストがあれば
それを評価します。継承リストの各要素の値評価結果はクラスオブジェクトか、
サブクラス可能なクラス型でなければなりません。
次にクラスのスイートが新たな実行フレーム内で、
新たなローカル名前空間と元々のグローバル名前空間を使って実行されます
(~*Note 名前づけと束縛 naming and binding:: 節を参照してください)。
(通常、スイートには関数定義のみが含まれます) クラスのスイートを
実行し終えると、実行フレームは無視されますが、ローカルな
名前空間は保存されます。次に、基底クラスの継承リストを使って
クラスオブジェクトが生成され、ローカルな名前空間を属性値辞書
として保存します。最後に、もとのローカルな名前空間において、クラス名が
このクラスオブジェクトに束縛されます。 

*プログラマのための注釈:* クラス定義内で定義された変数は
クラス変数です; クラス変数は全てのインスタンス間で共有されます。
インスタンス変数を定義するには、`__init__()' メソッドや
他のメソッド中で変数に値を与えます。クラス変数もインスタンス変数も
"`self.name'" 表記でアクセスすることができます。この表記で
アクセスする場合、インスタンス変数は同名のクラス変数を隠蔽します。
変更不能な値をもつクラス変数は、インスタンス変数のデフォルト値と
して使えます。
新スタイルクラスでは、デスクリプタを使ってインスタンス変数の振舞い
を変更できます。


File: python-ref-jp.info,  Node: トップレベル要素,  Next: 歴史とライセンス,  Prev: 複合文 compound statement,  Up: Top

8 トップレベル要素
******************

Python インタプリタは、標準入力や、プログラムの引数として与えられた
スクリプト、対話的にタイプ入力された命令、モジュールのソースファイルな
ど、様々な入力源から入力を得ることができます。この章では、それぞれの場
合に用いられる構文法について説明しています。

* Menu:

* 完全な Python プログラム::
* ファイル入力::
* 対話的入力::
* 式入力::


File: python-ref-jp.info,  Node: 完全な Python プログラム,  Next: ファイル入力,  Prev: トップレベル要素,  Up: トップレベル要素

8.1 完全な Python プログラム
============================

言語仕様の中では、その言語を処理するインタプリタがどのように起動される
かまで規定する必要はないのですが、完全な Python プログラムについての概
念を持っておくと役に立ちます。完全な Python プログラムは、最小限に初期
化された環境: 全ての組み込み変数と標準モジュールが利用可能で、かつ
`sys' (様々なシステムサービス)、`__builtin__' (組み込み
関数、例外、および `None')、`__main__' の 3 つを除く全ての
モジュールが初期化されていない状態で動作します。`__main__' は、
完全なプログラムを実行する際に、ローカルおよびグローバルな名前空間を提
供するために用いられます。 

完全な Python プログラムの構文は、下の節で述べるファイル入力の
ためのものです。

インタプリタは、対話的モード (interactive mode) で起動されることもあり
ます; この場合、インタプリタは完全なプログラムを読んで実行するのではな
く、一度に単一の実行文 (複合文のときもあります) を読み込んで実行します。
初期状態の環境は、完全なプログラムを実行するときの環境と同じです; 各実
行文は、`__main__' の名前空間内で実行されます。 

UNIXの環境下では、完全なプログラムをインタプリタに渡すには三通りの
方法があります: 第一は、 `-c' STRING コマンドラインオ
プションを使う方法、第二はファイルを第一コマンドライン引数として指定す
る方法、そして最後は標準入力から入力する方法です。ファイルや標準入力が
tty (端末) デバイスの場合、インタプリタは対話モードに入ります; そうで
ない場合、ファイルを完全なプログラムとして実行します。 


File: python-ref-jp.info,  Node: ファイル入力,  Next: 対話的入力,  Prev: 完全な Python プログラム,  Up: トップレベル要素

8.2 ファイル入力
================

非対話的なファイルから読み出された入力は、全て同じ形式:

`file_input (NEWLINE | `statement')*'

をとります。この構文法は、以下の状況で用いられます:

   * (ファイルや文字列内の) 完全な Python プログラムを構文解析するとき;

   * モジュールを構文解析するとき;

   * `exec' で渡された文字列を構文解析するとき;



File: python-ref-jp.info,  Node: 対話的入力,  Next: 式入力,  Prev: ファイル入力,  Up: トップレベル要素

8.3 対話的入力
==============

対話モードでの入力は、以下の文法の下に構文解析されます:

`interactive_input [`stmt_list'] NEWLINE | `compound_stmt' NEWLINE'

対話モードでは、(トップレベルの) 複合文の最後に空白行を入れなくてはな
らないことに注意してください; これは、複合文の終端をパーザが検出するた
めの手がかりとして必要です。


File: python-ref-jp.info,  Node: 式入力,  Prev: 対話的入力,  Up: トップレベル要素

8.4 式入力
==========

式入力には二つの形式があります。双方とも、先頭の空白を無視します。
`eval()' に対する文字列引数は、以下の形式をとらなければ なりません: 

`eval_input `expression_list' NEWLINE*'

`input()' で読み込まれる入力行は、以下の形式をとらなければ なりません: 

`input_input `expression_list' NEWLINE'

注意: 文としての解釈を行わない `生の (raw)' 入力行を読み出すためには、
組み込み関数 `raw_input()' や、ファイルオブジェクトの `readline()'
メソッドを使うことができます。 


File: python-ref-jp.info,  Node: 歴史とライセンス,  Next: 日本語訳について,  Prev: トップレベル要素,  Up: Top

Appendix A 歴史とライセンス
***************************

* Menu:

* Python の歴史::
* Terms and conditions for accessing or otherwise using Python::
* Licenses and Acknowledgements for Incorporated Software::


File: python-ref-jp.info,  Node: Python の歴史,  Next: Terms and conditions for accessing or otherwise using Python,  Prev: 歴史とライセンス,  Up: 歴史とライセンス

A.1 Python の歴史
=================

Python は 1990 年代の始め、オランダにある Stichting Mathematisch
Centrum (CWI, `http://www.cwi.nl/' 参照) で Guido van Rossum によって
ABC と呼ばれる言語の後継言語として生み 出されました。その後多くの人々が
Python に貢献していますが、 Guido は今日でも Python
製作者の先頭に立っています。

1995 年、 Guido は米国ヴァージニア州レストンにある Corporation for
National Reserch Initiatives (CNRI, `http://www.cnri.reston.va.us/'
参照) で Python の開発に携わり、
いくつかのバージョンをリリースしました。

2000 年 3 月、 Guido と Python のコア開発チームは BeOpen.com に 移り、
BeOpen PythonLabs チームを結成しました。同年 10 月、 PythonLabs
チームは Digital Creations (現在の Zope Corporation,
`http://www.zope.com/' 参照) に移りました。 そして 2001 年、 Python
に関する知的財産を保有するための非営利組織 Python Software Foundation
(PSF、 `http://www.python.org/psf/' 参照) を立ち上げました。このとき
Zope Corporation は PSF の賛助会員に なりました。

Python のリリースは全てオープンソース (オープンソースの定義は
`http://www.opensource.org/' を参照してください) です。
歴史的にみて、ごく一部を除くほとんどの Python リリースは GPL
互換になっています; 各リリースについては下表にまとめてあります。

リリース       ベース         年             権利           GPL 互換
------         ------         ------         ------         ------
0.9.0 thru     n/a            1991-1995      CWI            yes
1.2                                                         
1.3 thru       1.2            1995-1999      CNRI           yes
1.5.2                                                       
1.6            1.5.2          2000           CNRI           no
2.0            1.6            2000           BeOpen.com     no
1.6.1          1.6            2001           CNRI           no
2.1            2.0+1.6.1      2001           PSF            no
2.0.1          2.0+1.6.1      2001           PSF            yes
2.1.1          2.1+2.0.1      2001           PSF            yes
2.2            2.1.1          2001           PSF            yes
2.1.2          2.1.1          2002           PSF            yes
2.1.3          2.1.2          2002           PSF            yes
2.2.1          2.2            2002           PSF            yes
2.2.2          2.2.1          2002           PSF            yes
2.2.3          2.2.2          2002-2003      PSF            yes
2.3            2.2.2          2002-2003      PSF            yes
2.3.1          2.3            2002-2003      PSF            yes
2.3.2          2.3.1          2003           PSF            yes
2.3.3          2.3.2          2003           PSF            yes
2.3.4          2.3.3          2004           PSF            yes
2.3.5          2.3.4          2005           PSF            yes
2.4            2.3            2004           PSF            yes
2.4.1          2.4            2005           PSF            yes
2.4.2          2.4.1          2005           PSF            yes
2.4.3          2.4.2          2006           PSF            yes
2.5            2.4            2006           PSF            yes

_Note:_ 「GPL 互換」という表現は、Python が GPL で配布されていると
いう意味ではありません。Python のライセンスは全て、 GPL と違い、
変更したバージョンを配布する際に変更をオープンソースにしなくても
かまいません。 GPL 互換のライセンスの下では、GPL でリリースされて
いる他のソフトウェアと Python を組み合わせられますが、それ以外の
ライセンスではそうではありません。

Guido の指示の下、これらのリリースを可能にしてくださった多くの
ボランティアのみなさんに感謝します。


File: python-ref-jp.info,  Node: Terms and conditions for accessing or otherwise using Python,  Next: Licenses and Acknowledgements for Incorporated Software,  Prev: Python の歴史,  Up: 歴史とライセンス

A.2 Terms and conditions for accessing or otherwise using Python
================================================================

                *PSF LICENSE AGREEMENT FOR PYTHON 2.5*

  1. This LICENSE AGREEMENT is between the Python Software Foundation
     ("PSF"), and the Individual or Organization ("Licensee") accessing
     and otherwise using Python 2.5 software in source or binary form
     and its associated documentation.

  2. Subject to the terms and conditions of this License Agreement, PSF
     hereby grants Licensee a nonexclusive, royalty-free, world-wide
     license to reproduce, analyze, test, perform and/or display
     publicly, prepare derivative works, distribute, and otherwise use
     Python 2.5 alone or in any derivative version, provided, however,
     that PSF's License Agreement and PSF's notice of copyright, i.e.,
     "Copyright (C) 2001-2006 Python Software Foundation; All Rights
     Reserved" are retained in Python 2.5 alone or in any derivative
     version prepared by Licensee.

  3. In the event Licensee prepares a derivative work that is based on
     or incorporates Python 2.5 or any part thereof, and wants to make
     the derivative work available to others as provided herein, then
     Licensee hereby agrees to include in any such work a brief summary
     of the changes made to Python 2.5.

  4. PSF is making Python 2.5 available to Licensee on an "AS IS"
     basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
     DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.5
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
     2.5 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS
     AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON
     2.5, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY
     THEREOF.

  6. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  7. Nothing in this License Agreement shall be deemed to create any
     relationship of agency, partnership, or joint venture between PSF
     and Licensee.  This License Agreement does not grant permission to
     use PSF trademarks or trade name in a trademark sense to endorse
     or promote products or services of Licensee, or any third party.

  8. By copying, installing or otherwise using Python 2.5, Licensee
     agrees to be bound by the terms and conditions of this License
     Agreement.

             *BEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0*

        *BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1*

  1. This LICENSE AGREEMENT is between BeOpen.com ("BeOpen"), having an
     office at 160 Saratoga Avenue, Santa Clara, CA 95051, and the
     Individual or Organization ("Licensee") accessing and otherwise
     using this software in source or binary form and its associated
     documentation ("the Software").

  2. Subject to the terms and conditions of this BeOpen Python License
     Agreement, BeOpen hereby grants Licensee a non-exclusive,
     royalty-free, world-wide license to reproduce, analyze, test,
     perform and/or display publicly, prepare derivative works,
     distribute, and otherwise use the Software alone or in any
     derivative version, provided, however, that the BeOpen Python
     License is retained in the Software, alone or in any derivative
     version prepared by Licensee.

  3. BeOpen is making the Software available to Licensee on an "AS IS"
     basis.  BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO
     AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  4. BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE
     SOFTWARE FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE,
     OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY
     THEREOF.

  5. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  6. This License Agreement shall be governed by and interpreted in all
     respects by the law of the State of California, excluding conflict
     of law provisions.  Nothing in this License Agreement shall be
     deemed to create any relationship of agency, partnership, or joint
     venture between BeOpen and Licensee.  This License Agreement does
     not grant permission to use BeOpen trademarks or trade names in a
     trademark sense to endorse or promote products or services of
     Licensee, or any third party.  As an exception, the "BeOpen
     Python" logos available at http://www.pythonlabs.com/logos.html
     may be used according to the permissions granted on that web page.

  7. By copying, installing or otherwise using the software, Licensee
     agrees to be bound by the terms and conditions of this License
     Agreement.

               *CNRI LICENSE AGREEMENT FOR PYTHON 1.6.1*

  1. This LICENSE AGREEMENT is between the Corporation for National
     Research Initiatives, having an office at 1895 Preston White Drive,
     Reston, VA 20191 ("CNRI"), and the Individual or Organization
     ("Licensee") accessing and otherwise using Python 1.6.1 software in
     source or binary form and its associated documentation.

  2. Subject to the terms and conditions of this License Agreement, CNRI
     hereby grants Licensee a nonexclusive, royalty-free, world-wide
     license to reproduce, analyze, test, perform and/or display
     publicly, prepare derivative works, distribute, and otherwise use
     Python 1.6.1 alone or in any derivative version, provided,
     however, that CNRI's License Agreement and CNRI's notice of
     copyright, i.e., "Copyright (C) 1995-2001 Corporation for National
     Research Initiatives; All Rights Reserved" are retained in Python
     1.6.1 alone or in any derivative version prepared by Licensee.
     Alternately, in lieu of CNRI's License Agreement, Licensee may
     substitute the following text (omitting the quotes): "Python 1.6.1
     is made available subject to the terms and conditions in CNRI's
     License Agreement.  This Agreement together with Python 1.6.1 may
     be located on the Internet using the following unique, persistent
     identifier (known as a handle): 1895.22/1013.  This Agreement may
     also be obtained from a proxy server on the Internet using the
     following URL: `http://hdl.handle.net/1895.22/1013'."

  3. In the event Licensee prepares a derivative work that is based on
     or incorporates Python 1.6.1 or any part thereof, and wants to make
     the derivative work available to others as provided herein, then
     Licensee hereby agrees to include in any such work a brief summary
     of the changes made to Python 1.6.1.

  4. CNRI is making Python 1.6.1 available to Licensee on an "AS IS"
     basis.  CNRI MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, CNRI MAKES NO AND
     DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 1.6.1
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  5. CNRI SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
     1.6.1 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING
     PYTHON 1.6.1, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE
     POSSIBILITY THEREOF.

  6. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  7. This License Agreement shall be governed by the federal
     intellectual property law of the United States, including without
     limitation the federal copyright law, and, to the extent such U.S.
     federal law does not apply, by the law of the Commonwealth of
     Virginia, excluding Virginia's conflict of law provisions.
     Notwithstanding the foregoing, with regard to derivative works
     based on Python 1.6.1 that incorporate non-separable material that
     was previously distributed under the GNU General Public License
     (GPL), the law of the Commonwealth of Virginia shall govern this
     License Agreement only as to issues arising under or with respect
     to Paragraphs 4, 5, and 7 of this License Agreement.  Nothing in
     this License Agreement shall be deemed to create any relationship
     of agency, partnership, or joint venture between CNRI and
     Licensee.  This License Agreement does not grant permission to use
     CNRI trademarks or trade name in a trademark sense to endorse or
     promote products or services of Licensee, or any third party.

  8. By clicking on the "ACCEPT" button where indicated, or by copying,
     installing or otherwise using Python 1.6.1, Licensee agrees to be
     bound by the terms and conditions of this License Agreement.

                                ACCEPT

         *CWI LICENSE AGREEMENT FOR PYTHON 0.9.0 THROUGH 1.2*

Copyright (C) 1991 - 1995, Stichting Mathematisch Centrum Amsterdam,
The Netherlands.  All rights reserved.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Stichting Mathematisch
Centrum or CWI not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior permission.

STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE FOR
ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


File: python-ref-jp.info,  Node: Licenses and Acknowledgements for Incorporated Software,  Prev: Terms and conditions for accessing or otherwise using Python,  Up: 歴史とライセンス

A.3 Licenses and Acknowledgements for Incorporated Software
===========================================================

This section is an incomplete, but growing list of licenses and
acknowledgements for third-party software incorporated in the Python
distribution.

* Menu:

* Mersenne Twister::
* Sockets::
* Floating point exception control::
* MD5 message digest algorithm::
* Asynchronous socket services::
* Cookie management::
* Profiling::
* Execution tracing::
* UUencode and UUdecode functions::
* XML Remote Procedure Calls::


File: python-ref-jp.info,  Node: Mersenne Twister,  Next: Sockets,  Prev: Licenses and Acknowledgements for Incorporated Software,  Up: Licenses and Acknowledgements for Incorporated Software

A.3.1 Mersenne Twister
----------------------

The `_random' module includes code based on a download from
`http://www.math.keio.ac.jp/~matumoto/MT2002/emt19937ar.html'.  The
following are the verbatim comments from the original code:

     A C-program for MT19937, with initialization improved 2002/1/26.
     Coded by Takuji Nishimura and Makoto Matsumoto.

     Before using, initialize the state by using init_genrand(seed)
     or init_by_array(init_key, key_length).

     Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
     All rights reserved.

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.

      3. The names of its contributors may not be used to endorse or promote
         products derived from this software without specific prior written
         permission.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

     Any feedback is very welcome.
     http://www.math.keio.ac.jp/matumoto/emt.html
     email: matumoto@math.keio.ac.jp


File: python-ref-jp.info,  Node: Sockets,  Next: Floating point exception control,  Prev: Mersenne Twister,  Up: Licenses and Acknowledgements for Incorporated Software

A.3.2 Sockets
-------------

The `socket' module uses the functions, `getaddrinfo', and
`getnameinfo', which are coded in separate source files from the WIDE
Project, `http://www.wide.ad.jp/about/index.html'.

     Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
     All rights reserved.

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. Neither the name of the project nor the names of its contributors
        may be used to endorse or promote products derived from this software
        without specific prior written permission.

     THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
     GAI_ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
     FOR GAI_ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     HOWEVER CAUSED AND ON GAI_ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN GAI_ANY WAY
     OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.


File: python-ref-jp.info,  Node: Floating point exception control,  Next: MD5 message digest algorithm,  Prev: Sockets,  Up: Licenses and Acknowledgements for Incorporated Software

A.3.3 Floating point exception control
--------------------------------------

The source for the `fpectl' module includes the following notice:

          ---------------------------------------------------------------------
         /                       Copyright (c) 1996.                           \
        |          The Regents of the University of California.                 |
        |                        All rights reserved.                           |
        |                                                                       |
        |   Permission to use, copy, modify, and distribute this software for   |
        |   any purpose without fee is hereby granted, provided that this en-   |
        |   tire notice is included in all copies of any software which is or   |
        |   includes  a  copy  or  modification  of  this software and in all   |
        |   copies of the supporting documentation for such software.           |
        |                                                                       |
        |   This  work was produced at the University of California, Lawrence   |
        |   Livermore National Laboratory under  contract  no.  W-7405-ENG-48   |
        |   between  the  U.S.  Department  of  Energy and The Regents of the   |
        |   University of California for the operation of UC LLNL.              |
        |                                                                       |
        |                              DISCLAIMER                               |
        |                                                                       |
        |   This  software was prepared as an account of work sponsored by an   |
        |   agency of the United States Government. Neither the United States   |
        |   Government  nor the University of California nor any of their em-   |
        |   ployees, makes any warranty, express or implied, or  assumes  any   |
        |   liability  or  responsibility  for the accuracy, completeness, or   |
        |   usefulness of any information,  apparatus,  product,  or  process   |
        |   disclosed,   or  represents  that  its  use  would  not  infringe   |
        |   privately-owned rights. Reference herein to any specific  commer-   |
        |   cial  products,  process,  or  service  by trade name, trademark,   |
        |   manufacturer, or otherwise, does not  necessarily  constitute  or   |
        |   imply  its endorsement, recommendation, or favoring by the United   |
        |   States Government or the University of California. The views  and   |
        |   opinions  of authors expressed herein do not necessarily state or   |
        |   reflect those of the United States Government or  the  University   |
        |   of  California,  and shall not be used for advertising or product   |
         \  endorsement purposes.                                              /
          ---------------------------------------------------------------------


File: python-ref-jp.info,  Node: MD5 message digest algorithm,  Next: Asynchronous socket services,  Prev: Floating point exception control,  Up: Licenses and Acknowledgements for Incorporated Software

A.3.4 MD5 message digest algorithm
----------------------------------

The source code for the `md5' module contains the following notice:

       Copyright (C) 1999, 2002 Aladdin Enterprises.  All rights reserved.

       This software is provided 'as-is', without any express or implied
       warranty.  In no event will the authors be held liable for any damages
       arising from the use of this software.

       Permission is granted to anyone to use this software for any purpose,
       including commercial applications, and to alter it and redistribute it
       freely, subject to the following restrictions:

       1. The origin of this software must not be misrepresented; you must not
          claim that you wrote the original software. If you use this software
          in a product, an acknowledgment in the product documentation would be
          appreciated but is not required.
       2. Altered source versions must be plainly marked as such, and must not be
          misrepresented as being the original software.
       3. This notice may not be removed or altered from any source distribution.

       L. Peter Deutsch
       ghost@aladdin.com

       Independent implementation of MD5 (RFC 1321).

       This code implements the MD5 Algorithm defined in RFC 1321, whose
       text is available at
     	http://www.ietf.org/rfc/rfc1321.txt
       The code is derived from the text of the RFC, including the test suite
       (section A.5) but excluding the rest of Appendix A.  It does not include
       any code or documentation that is identified in the RFC as being
       copyrighted.

       The original and principal author of md5.h is L. Peter Deutsch
       <ghost@aladdin.com>.  Other authors are noted in the change history
       that follows (in reverse chronological order):

       2002-04-13 lpd Removed support for non-ANSI compilers; removed
     	references to Ghostscript; clarified derivation from RFC 1321;
     	now handles byte order either statically or dynamically.
       1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
       1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5);
     	added conditionalization for C++ compilation from Martin
     	Purschke <purschke@bnl.gov>.
       1999-05-03 lpd Original version.


File: python-ref-jp.info,  Node: Asynchronous socket services,  Next: Cookie management,  Prev: MD5 message digest algorithm,  Up: Licenses and Acknowledgements for Incorporated Software

A.3.5 Asynchronous socket services
----------------------------------

The `asynchat' and `asyncore' modules contain the following notice:

      Copyright 1996 by Sam Rushing

                              All Rights Reserved

      Permission to use, copy, modify, and distribute this software and
      its documentation for any purpose and without fee is hereby
      granted, provided that the above copyright notice appear in all
      copies and that both that copyright notice and this permission
      notice appear in supporting documentation, and that the name of Sam
      Rushing not be used in advertising or publicity pertaining to
      distribution of the software without specific, written prior
      permission.

      SAM RUSHING DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
      INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
      NO EVENT SHALL SAM RUSHING BE LIABLE FOR ANY SPECIAL, INDIRECT OR
      CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
      OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
      NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
      CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


File: python-ref-jp.info,  Node: Cookie management,  Next: Profiling,  Prev: Asynchronous socket services,  Up: Licenses and Acknowledgements for Incorporated Software

A.3.6 Cookie management
-----------------------

The `Cookie' module contains the following notice:

      Copyright 2000 by Timothy O'Malley <timo@alum.mit.edu>

                     All Rights Reserved

      Permission to use, copy, modify, and distribute this software
      and its documentation for any purpose and without fee is hereby
      granted, provided that the above copyright notice appear in all
      copies and that both that copyright notice and this permission
      notice appear in supporting documentation, and that the name of
      Timothy O'Malley  not be used in advertising or publicity
      pertaining to distribution of the software without specific, written
      prior permission.

      Timothy O'Malley DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
      SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS, IN NO EVENT SHALL Timothy O'Malley BE LIABLE FOR
      ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
      WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
      WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
      ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.


File: python-ref-jp.info,  Node: Profiling,  Next: Execution tracing,  Prev: Cookie management,  Up: Licenses and Acknowledgements for Incorporated Software

A.3.7 Profiling
---------------

The `profile' and `pstats' modules contain the following notice:

      Copyright 1994, by InfoSeek Corporation, all rights reserved.
      Written by James Roskind

      Permission to use, copy, modify, and distribute this Python software
      and its associated documentation for any purpose (subject to the
      restriction in the following sentence) without fee is hereby granted,
      provided that the above copyright notice appears in all copies, and
      that both that copyright notice and this permission notice appear in
      supporting documentation, and that the name of InfoSeek not be used in
      advertising or publicity pertaining to distribution of the software
      without specific, written prior permission.  This permission is
      explicitly restricted to the copying and modification of the software
      to remain in Python, compiled Python, or other languages (such as C)
      wherein the modified or derived code is exclusively imported into a
      Python module.

      INFOSEEK CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
      SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
      FITNESS. IN NO EVENT SHALL INFOSEEK CORPORATION BE LIABLE FOR ANY
      SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
      RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
      CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
      CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


File: python-ref-jp.info,  Node: Execution tracing,  Next: UUencode and UUdecode functions,  Prev: Profiling,  Up: Licenses and Acknowledgements for Incorporated Software

A.3.8 Execution tracing
-----------------------

The `trace' module contains the following notice:

      portions copyright 2001, Autonomous Zones Industries, Inc., all rights...
      err...  reserved and offered to the public under the terms of the
      Python 2.2 license.
      Author: Zooko O'Whielacronx
      http://zooko.com/
      mailto:zooko@zooko.com

      Copyright 2000, Mojam Media, Inc., all rights reserved.
      Author: Skip Montanaro

      Copyright 1999, Bioreason, Inc., all rights reserved.
      Author: Andrew Dalke

      Copyright 1995-1997, Automatrix, Inc., all rights reserved.
      Author: Skip Montanaro

      Copyright 1991-1995, Stichting Mathematisch Centrum, all rights reserved.

      Permission to use, copy, modify, and distribute this Python software and
      its associated documentation for any purpose without fee is hereby
      granted, provided that the above copyright notice appears in all copies,
      and that both that copyright notice and this permission notice appear in
      supporting documentation, and that the name of neither Automatrix,
      Bioreason or Mojam Media be used in advertising or publicity pertaining to
      distribution of the software without specific, written prior permission.


File: python-ref-jp.info,  Node: UUencode and UUdecode functions,  Next: XML Remote Procedure Calls,  Prev: Execution tracing,  Up: Licenses and Acknowledgements for Incorporated Software

A.3.9 UUencode and UUdecode functions
-------------------------------------

The `uu' module contains the following notice:

      Copyright 1994 by Lance Ellinghouse
      Cathedral City, California Republic, United States of America.
                             All Rights Reserved
      Permission to use, copy, modify, and distribute this software and its
      documentation for any purpose and without fee is hereby granted,
      provided that the above copyright notice appear in all copies and that
      both that copyright notice and this permission notice appear in
      supporting documentation, and that the name of Lance Ellinghouse
      not be used in advertising or publicity pertaining to distribution
      of the software without specific, written prior permission.
      LANCE ELLINGHOUSE DISCLAIMS ALL WARRANTIES WITH REGARD TO
      THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
      FITNESS, IN NO EVENT SHALL LANCE ELLINGHOUSE CENTRUM BE LIABLE
      FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
      WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
      ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
      OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

      Modified by Jack Jansen, CWI, July 1995:
      - Use binascii module to do the actual line-by-line conversion
        between ascii and binary. This results in a 1000-fold speedup. The C
        version is still 5 times faster, though.
      - Arguments more compliant with python standard


File: python-ref-jp.info,  Node: XML Remote Procedure Calls,  Prev: UUencode and UUdecode functions,  Up: Licenses and Acknowledgements for Incorporated Software

A.3.10 XML Remote Procedure Calls
---------------------------------

The `xmlrpclib' module contains the following notice:

          The XML-RPC client interface is

      Copyright (c) 1999-2002 by Secret Labs AB
      Copyright (c) 1999-2002 by Fredrik Lundh

      By obtaining, using, and/or copying this software and/or its
      associated documentation, you agree that you have read, understood,
      and will comply with the following terms and conditions:

      Permission to use, copy, modify, and distribute this software and
      its associated documentation for any purpose and without fee is
      hereby granted, provided that the above copyright notice appears in
      all copies, and that both that copyright notice and this permission
      notice appear in supporting documentation, and that the name of
      Secret Labs AB or the author not be used in advertising or publicity
      pertaining to distribution of the software without specific, written
      prior permission.

      SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
      TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
      ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
      BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
      DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
      WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
      ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
      OF THIS SOFTWARE.


File: python-ref-jp.info,  Node: 日本語訳について,  Next: Module Index,  Prev: 歴史とライセンス,  Up: Top

Appendix B 日本語訳について
***************************

* Menu:

* このドキュメントについて::
* 翻訳者一覧 敬称略::
* 25 差分翻訳者一覧 敬称略::


File: python-ref-jp.info,  Node: このドキュメントについて,  Next: 翻訳者一覧 敬称略,  Prev: 日本語訳について,  Up: 日本語訳について

B.1 このドキュメントについて
============================

この文書は、Pythonドキュメント翻訳プロジェクトによる Python Language
Reference の日本語訳版です。日本語訳に対する質問や提案などが
ありましたら、Pythonドキュメント翻訳プロジェクトのメーリングリスト

`http://www.python.jp/mailman/listinfo/python-doc-jp'

または、プロジェクトのバグ管理ページ

`http://sourceforge.jp/tracker/?atid=116&group_id=11&func=browse'

までご報告ください。


File: python-ref-jp.info,  Node: 翻訳者一覧 敬称略,  Next: 25 差分翻訳者一覧 敬称略,  Prev: このドキュメントについて,  Up: 日本語訳について

B.2 翻訳者一覧 (敬称略)
=======================

2.3.2 和訳 Yasushi Masuda <y.masuda at acm.org> (Feb 3, 2004)\ 2.3.3
差分 Yasushi Masuda (May 31, 2004)\ 2.4 差分 Yasushi Masuda (May 20,
2006)


File: python-ref-jp.info,  Node: 25 差分翻訳者一覧 敬称略,  Prev: 翻訳者一覧 敬称略,  Up: 日本語訳について

B.3 2.5 差分翻訳者一覧 (敬称略)
===============================

Toshiyuki Kawanishi, hkurosawa


File: python-ref-jp.info,  Node: Module Index,  Next: Class-Exception-Object Index,  Prev: 日本語訳について,  Up: Top

Module Index
************

 [index ]
* Menu:

* __abs__:                               数値型をエミュレーションする.
                                                              (line 151)
* __and__:                               数値型をエミュレーションする.
                                                              (line  30)
* __builtin__ <1>:                       完全な Python プログラム.
                                                              (line  14)
* __builtin__:                           exec 文.             (line  32)
* __divmod__:                            数値型をエミュレーションする.
                                                              (line  22)
* __eq__:                                基本的なカスタマイズ.
                                                              (line 132)
* __float__:                             数値型をエミュレーションする.
                                                              (line 163)
* __floordiv__:                          数値型をエミュレーションする.
                                                              (line  18)
* __ge__:                                基本的なカスタマイズ.
                                                              (line 138)
* __gt__:                                基本的なカスタマイズ.
                                                              (line 136)
* __hex__:                               数値型をエミュレーションする.
                                                              (line 169)
* __iand__:                              数値型をエミュレーションする.
                                                              (line 128)
* __idiv__:                              数値型をエミュレーションする.
                                                              (line 114)
* __ifloordiv__:                         数値型をエミュレーションする.
                                                              (line 118)
* __ilshift__:                           数値型をエミュレーションする.
                                                              (line 124)
* __imod__:                              数値型をエミュレーションする.
                                                              (line 120)
* __imul__:                              数値型をエミュレーションする.
                                                              (line 112)
* __int__:                               数値型をエミュレーションする.
                                                              (line 159)
* __invert__:                            数値型をエミュレーションする.
                                                              (line 153)
* __ior__:                               数値型をエミュレーションする.
                                                              (line 132)
* __ipow__:                              数値型をエミュレーションする.
                                                              (line 122)
* __irshift__:                           数値型をエミュレーションする.
                                                              (line 126)
* __isub__:                              数値型をエミュレーションする.
                                                              (line 110)
* __itruediv__:                          数値型をエミュレーションする.
                                                              (line 116)
* __ixor__:                              数値型をエミュレーションする.
                                                              (line 130)
* __le__:                                基本的なカスタマイズ.
                                                              (line 130)
* __long__:                              数値型をエミュレーションする.
                                                              (line 161)
* __lshift__:                            数値型をエミュレーションする.
                                                              (line  26)
* __main__ <1>:                          完全な Python プログラム.
                                                              (line  14)
* __main__:                              名前づけと束縛 naming and binding.
                                                              (line 113)
* __mod__:                               数値型をエミュレーションする.
                                                              (line  20)
* __mul__:                               数値型をエミュレーションする.
                                                              (line  16)
* __ne__:                                基本的なカスタマイズ.
                                                              (line 134)
* __or__:                                数値型をエミュレーションする.
                                                              (line  34)
* __pos__:                               数値型をエミュレーションする.
                                                              (line 149)
* __pow__:                               数値型をエミュレーションする.
                                                              (line  24)
* __rand__:                              数値型をエミュレーションする.
                                                              (line  82)
* __rdiv__:                              数値型をエミュレーションする.
                                                              (line  66)
* __rdivmod__:                           数値型をエミュレーションする.
                                                              (line  74)
* __rfloordiv__:                         数値型をエミュレーションする.
                                                              (line  70)
* __rlshift__:                           数値型をエミュレーションする.
                                                              (line  78)
* __rmod__:                              数値型をエミュレーションする.
                                                              (line  72)
* __rmul__:                              数値型をエミュレーションする.
                                                              (line  64)
* __ror__:                               数値型をエミュレーションする.
                                                              (line  86)
* __rpow__:                              数値型をエミュレーションする.
                                                              (line  76)
* __rrshift__:                           数値型をエミュレーションする.
                                                              (line  80)
* __rshift__:                            数値型をエミュレーションする.
                                                              (line  28)
* __rsub__:                              数値型をエミュレーションする.
                                                              (line  62)
* __rtruediv__:                          数値型をエミュレーションする.
                                                              (line  68)
* __rxor__:                              数値型をエミュレーションする.
                                                              (line  84)
* __sub__:                               数値型をエミュレーションする.
                                                              (line  14)
* __truediv__:                           数値型をエミュレーションする.
                                                              (line  52)
* __xor__:                               数値型をエミュレーションする.
                                                              (line  32)
* array:                                 標準型の階層.        (line 209)
* bsddb:                                 標準型の階層.        (line 237)
* dbm:                                   標準型の階層.        (line 237)
* gdbm:                                  標準型の階層.        (line 237)
* sys <1>:                               完全な Python プログラム.
                                                              (line  14)
* sys <2>:                               try 文.              (line  61)
* sys <3>:                               import 文.           (line  43)
* sys:                                   print 文.            (line  32)


File: python-ref-jp.info,  Node: Class-Exception-Object Index,  Next: Function-Method-Variable Index,  Prev: Module Index,  Up: Top

Class, Exception, and Object Index
**********************************

 [index ]
* Menu:

* AssertionError:                        Assert 文 assert statement.
                                                              (line  23)
* AttributeError:                        属性参照.            (line  14)
* Boolean:                               標準型の階層.        (line  83)
* built-in function <1>:                 呼び出し call.       (line 136)
* built-in function:                     標準型の階層.        (line 404)
* built-in method <1>:                   呼び出し call.       (line 136)
* built-in method:                       標準型の階層.        (line 412)
* callable <1>:                          呼び出し call.       (line   8)
* callable:                              標準型の階層.        (line 242)
* class <1>:                             クラス定義.          (line   7)
* class <2>:                             呼び出し call.       (line 139)
* class:                                 標準型の階層.        (line 433)
* class instance <1>:                    呼び出し call.       (line 145)
* class instance:                        標準型の階層.        (line 433)
* code:                                  標準型の階層.        (line 570)
* complex:                               標準型の階層.        (line 110)
* dictionary <1>:                        代入文 assignment statement.
                                                              (line 111)
* dictionary <2>:                        添字表記 subscription.
                                                              (line   7)
* dictionary <3>:                        辞書表現.            (line  15)
* dictionary <4>:                        基本的なカスタマイズ.
                                                              (line 184)
* dictionary:                            標準型の階層.        (line 224)
* Ellipsis:                              標準型の階層.        (line  38)
* file <1>:                              式入力.              (line  17)
* file:                                  標準型の階層.        (line 542)
* floating point:                        標準型の階層.        (line 102)
* frame:                                 標準型の階層.        (line 620)
* function <1>:                          関数定義.            (line   7)
* function <2>:                          呼び出し call.       (line 132)
* function:                              標準型の階層.        (line 249)
* generator <1>:                         ジェネレータ式.      (line  17)
* generator:                             標準型の階層.        (line 597)
* generator expression:                  ジェネレータ式.      (line  17)
* immutable:                             標準型の階層.        (line 139)
* immutable sequence:                    標準型の階層.        (line 139)
* ImportError:                           import 文.           (line  47)
* instance <1>:                          呼び出し call.       (line 145)
* instance:                              標準型の階層.        (line 433)
* integer:                               標準型の階層.        (line  52)
* list <1>:                              代入文 assignment statement.
                                                              (line 103)
* list <2>:                              スライス表記 slicing.
                                                              (line  10)
* list <3>:                              添字表記 subscription.
                                                              (line   7)
* list <4>:                              属性参照.            (line  17)
* list <5>:                              リスト表現.          (line  31)
* list:                                  標準型の階層.        (line 206)
* long integer:                          標準型の階層.        (line  73)
* mapping <1>:                           代入文 assignment statement.
                                                              (line 111)
* mapping <2>:                           添字表記 subscription.
                                                              (line   7)
* mapping:                               標準型の階層.        (line 218)
* method <1>:                            呼び出し call.       (line 136)
* method:                                標準型の階層.        (line 301)
* module <1>:                            属性参照.            (line  17)
* module:                                標準型の階層.        (line 444)
* mutable <1>:                           代入文 assignment statement.
                                                              (line   7)
* mutable:                               標準型の階層.        (line 194)
* mutable sequence:                      標準型の階層.        (line 194)
* NameError:                             識別子 identifier、または名前 name.
                                                              (line  12)
* None:                                  標準型の階層.        (line  22)
* NotImplemented:                        標準型の階層.        (line  32)
* numeric:                               標準型の階層.        (line  46)
* plain integer:                         標準型の階層.        (line  66)
* recursive:                             文字列変換.          (line  26)
* RuntimeError:                          print 文.            (line  32)
* sequence <1>:                          for 文.              (line   8)
* sequence <2>:                          代入文 assignment statement.
                                                              (line 103)
* sequence <3>:                          比較 comparison.     (line 126)
* sequence <4>:                          スライス表記 slicing.
                                                              (line  10)
* sequence <5>:                          添字表記 subscription.
                                                              (line   7)
* sequence:                              標準型の階層.        (line 117)
* slice:                                 コンテナをエミュレートする.
                                                              (line  52)
* StopIteration:                         yield 文.            (line   8)
* string <1>:                            スライス表記 slicing.
                                                              (line  10)
* string <2>:                            添字表記 subscription.
                                                              (line   7)
* string:                                標準型の階層.        (line 155)
* SyntaxError:                           import 文.           (line  48)
* traceback <1>:                         try 文.              (line  65)
* traceback <2>:                         raise 文.            (line  34)
* traceback:                             標準型の階層.        (line 663)
* tuple <1>:                             式のリスト.          (line  10)
* tuple <2>:                             スライス表記 slicing.
                                                              (line  10)
* tuple <3>:                             添字表記 subscription.
                                                              (line   7)
* tuple:                                 標準型の階層.        (line 187)
* TypeError:                             単項算術演算 unary arithmetic operation.
                                                              (line  21)
* unicode:                               標準型の階層.        (line 177)
* user-defined function <1>:             関数定義.            (line   7)
* user-defined function <2>:             呼び出し call.       (line 132)
* user-defined function:                 標準型の階層.        (line 249)
* user-defined method:                   標準型の階層.        (line 301)
* ValueError:                            シフト演算 shifting operation.
                                                              (line  19)
* ZeroDivisionError:                     二項算術演算 binary arithmetic operation.
                                                              (line  29)


File: python-ref-jp.info,  Node: Function-Method-Variable Index,  Next: Miscellaneous Index,  Prev: Class-Exception-Object Index,  Up: Top

Function, Method, and Variable Index
************************************

 [index ]
* Menu:

* __add__:                               数値型をエミュレーションする.
                                                              (line  12)
* __call__:                              呼び出し可能オブジェクトをエミュレートする.
                                                              (line   7)
* __cmp__:                               基本的なカスタマイズ.
                                                              (line 169)
* __coerce__:                            数値型をエミュレーションする.
                                                              (line 179)
* __complex__:                           数値型をエミュレーションする.
                                                              (line 157)
* __contains__:                          コンテナをエミュレートする.
                                                              (line  99)
* __del__:                               基本的なカスタマイズ.
                                                              (line  45)
* __delattr__:                           属性値アクセスをカスタマイズする.
                                                              (line  46)
* __delete__:                            デスクリプタ descriptor の実装.
                                                              (line  27)
* __delitem__:                           コンテナをエミュレートする.
                                                              (line  73)
* __delslice__:                          シーケンス型エミュレーションで使われるその他のメソッド.
                                                              (line  38)
* __div__:                               数値型をエミュレーションする.
                                                              (line  50)
* __enter__:                             with文とコンテキストマネージャ.
                                                              (line  25)
* __exit__:                              with文とコンテキストマネージャ.
                                                              (line  30)
* __get__:                               デスクリプタ descriptor の実装.
                                                              (line  14)
* __getattr__:                           属性値アクセスをカスタマイズする.
                                                              (line  11)
* __getattribute__:                      新しい形式のクラスのための別の属性アクセス.
                                                              (line  10)
* __getitem__:                           コンテナをエミュレートする.
                                                              (line  50)
* __getslice__:                          シーケンス型エミュレーションで使われるその他のメソッド.
                                                              (line  12)
* __hash__:                              基本的なカスタマイズ.
                                                              (line 184)
* __iadd__:                              数値型をエミュレーションする.
                                                              (line 108)
* __import__:                            import 文.           (line 103)
* __index__:                             数値型をエミュレーションする.
                                                              (line 172)
* __init__:                              基本的なカスタマイズ.
                                                              (line  33)
* __iter__:                              コンテナをエミュレートする.
                                                              (line  81)
* __len__:                               コンテナをエミュレートする.
                                                              (line  43)
* __lt__:                                基本的なカスタマイズ.
                                                              (line 128)
* __metaclass__:                         クラス生成をカスタマイズする.
                                                              (line  23)
* __neg__:                               数値型をエミュレーションする.
                                                              (line 147)
* __new__:                               基本的なカスタマイズ.
                                                              (line   7)
* __nonzero__:                           基本的なカスタマイズ.
                                                              (line 208)
* __oct__:                               数値型をエミュレーションする.
                                                              (line 167)
* __radd__:                              数値型をエミュレーションする.
                                                              (line  60)
* __rcmp__:                              基本的なカスタマイズ.
                                                              (line 181)
* __repr__:                              基本的なカスタマイズ.
                                                              (line 104)
* __set__:                               デスクリプタ descriptor の実装.
                                                              (line  23)
* __setattr__:                           属性値アクセスをカスタマイズする.
                                                              (line  31)
* __setitem__:                           コンテナをエミュレートする.
                                                              (line  65)
* __setslice__:                          シーケンス型エミュレーションで使われるその他のメソッド.
                                                              (line  29)
* __slots__:                             __slots__.           (line  19)
* __str__:                               基本的なカスタマイズ.
                                                              (line 120)
* __unicode__:                           基本的なカスタマイズ.
                                                              (line 217)
* abs:                                   数値型をエミュレーションする.
                                                              (line 153)
* chr:                                   標準型の階層.        (line 148)
* cmp:                                   基本的なカスタマイズ.
                                                              (line 178)
* compile:                               global 文.           (line  34)
* complex:                               数値型をエミュレーションする.
                                                              (line 163)
* divmod:                                数値型をエミュレーションする.
                                                              (line  35)
* eval <1>:                              式入力.              (line   7)
* eval <2>:                              exec 文.             (line  37)
* eval:                                  global 文.           (line  34)
* execfile:                              global 文.           (line  34)
* float:                                 数値型をエミュレーションする.
                                                              (line 163)
* globals:                               exec 文.             (line  37)
* hex:                                   数値型をエミュレーションする.
                                                              (line 169)
* id:                                    オブジェクト、値、および型.
                                                              (line  18)
* indices:                               標準型の階層.        (line 692)
* input:                                 式入力.              (line  11)
* int:                                   数値型をエミュレーションする.
                                                              (line 163)
* len <1>:                               コンテナをエミュレートする.
                                                              (line  43)
* len:                                   標準型の階層.        (line 115)
* locals:                                exec 文.             (line  37)
* long:                                  数値型をエミュレーションする.
                                                              (line 163)
* oct:                                   数値型をエミュレーションする.
                                                              (line 169)
* open:                                  標準型の階層.        (line 543)
* ord:                                   標準型の階層.        (line 149)
* pow:                                   数値型をエミュレーションする.
                                                              (line  35)
* range:                                 for 文.              (line  35)
* raw_input:                             式入力.              (line  17)
* repr <1>:                              式文 expression statement.
                                                              (line  16)
* repr <2>:                              文字列変換.          (line  31)
* repr:                                  基本的なカスタマイズ.
                                                              (line 104)
* slice:                                 標準型の階層.        (line 682)
* str <1>:                               文字列変換.          (line  31)
* str:                                   基本的なカスタマイズ.
                                                              (line 120)
* type:                                  オブジェクト、値、および型.
                                                              (line  23)
* unichr:                                標準型の階層.        (line 172)
* unicode <1>:                           基本的なカスタマイズ.
                                                              (line 217)
* unicode:                               標準型の階層.        (line 177)

