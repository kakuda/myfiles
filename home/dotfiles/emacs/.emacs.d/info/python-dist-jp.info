これは python-dist-jp.info、python-dist-jp.texi より makeinfo
バージョン 4.8 によって作成されました。

19th September, 2006


File: python-dist-jp.info,  Node: Top,  Next: Distutilsの紹介,  Prev: (dir),  Up: (dir)

Python モジュールの配布
***********************

Copyright (C) 2001-2006 Python Software Foundation.  All rights
reserved.

Copyright (C) 2000 BeOpen.com.  All rights reserved.

Copyright (C) 1995-2000 Corporation for National Research Initiatives.
All rights reserved.

Copyright (C) 1991-1995 Stichting Mathematisch Centrum.  All rights
reserved.

See the end of this document for complete license and permissions
information.

     このドキュメントでは、 Python モジュール配布ユーティリティ (Python
     Distribution Utilities, "Distutils") について、
     モジュール開発者の視点に立ち、多くの人々がビルド/リリース/インストール
     の負荷をほとんどかけずに Python モジュールや拡張モジュールを
     入手できるようにする方法について述べます。

* Menu:

* Distutilsの紹介::
* setup スクリプトを書く::
* setup 設定ファイル setup configuration file を書く::
* ソースコード配布物を作成する::
* ビルド済み配布物を作成する::
* パッケージインデクスに登録する::
* Uploading Packages to the Package Index::
* 例::
* Distutilsの拡張::
* リファレンスマニュアル::
* API リファレンス::
* 日本語訳について::
* Class-Exception-Object Index::
* Function-Method-Variable Index::
* Miscellaneous Index::


File: python-dist-jp.info,  Node: Distutilsの紹介,  Next: setup スクリプトを書く,  Prev: Top,  Up: Top

1 Distutilsの紹介
*****************

このドキュメントで扱っている内容は、 Distutils を使った Python
モジュールの配布で、とりわけ開発者/配布者の役割に重点を置いています:
Python モジュールのインストールに関する情報を探しているのなら、
マニュアル を参照してください。

* Menu:

* 概念と用語::
* 簡単な例::
* Python 一般の用語::
* Distutils 固有の用語::


File: python-dist-jp.info,  Node: 概念と用語,  Next: 簡単な例,  Prev: Distutilsの紹介,  Up: Distutilsの紹介

1.1 概念と用語
==============

Distutils の使い方は、モジュール開発者とサードパーティ製のモジュールを
インストールするユーザ/管理者のどちらにとってもきわめて単純です。
開発者側のやるべきことは (もちろん、しっかりした実装で、詳しく
文書化され、よくテストされたコードを書くことは別として！) 以下の
項目になります:
   * setup スクリプト (`setup.py' という名前にするのがならわし) を書く

   * (必要があれば) setup 設定ファイルを書く

   * ソースコード配布物を作成する

   * (必要があれば) 一つまたはそれ以上のビルド済み (バイナリ) 形式の
     配布物を作成する

これらの作業については、いずれもこのドキュメントで扱っています。

全てのモジュール開発者が複数の実行プラットフォームを利用できるわけでは
ないので、全てのプラットフォーム向けにビルド済みの配布物を提供して
もらえると期待するわけにはいきません。ですから、仲介を行う人々、
いわゆる _パッケージ作成者 (packager)_ がこの問題を解決すべく
立ち上がってくれることが望ましいでしょう。パッケージ作成者は
モジュール開発者がリリースしたソースコード配布物を、一つまたはそれ以上
のプラットフォーム上でビルドして、得られたビルド済み配布物をリリース
することになります。したがって、ほとんどの一般的なプラットフォームに
おけるユーザは、setup スクリプト一つ実行せず、コードを一行たりとも
コンパイルしなくても、使っているプラットフォーム向けのきわめて普通の
方法でほとんどの一般的な Python モジュール配布物をインストールできる
でしょう。


File: python-dist-jp.info,  Node: 簡単な例,  Next: Python 一般の用語,  Prev: 概念と用語,  Up: Distutilsの紹介

1.2 簡単な例
============

setup スクリプトは通常単純なものですが、Python で書かれているため、ス
クリプト中で何かを処理しようと考えたとき特に制限はありません。とはい
え、 setup スクリプト中に何かコストの大きな処理を行うときは十分
注意してください。 autoconf 形式の設定スクリプトとは違い、 setup
スクリプトはモジュール
配布物をビルドしてインストールする中で複数回実行されることがあります。

`foo.py' という名前のファイルに収められている `foo' という
名前のモジュールを配布したいだけなら、setup スクリプトは以下のような
単純なものになります:

     from distutils.core import setup
     setup(name='foo',
           version='1.0',
           py_modules=['foo'],
           )

以下のことに注意してください:
   * Distutils に与えなければならない情報のほとんどは、 `setup()'
     関数のキーワード引数として与えます。

   * キーワード引数は二つのカテゴリ: パッケージのメタデータ
     (パッケージ名、バージョン番号) 、パッケージに何が収められているか
     の情報 (上の場合は pure Python
     モジュールのリスト)、に行き着きます。

   * モジュールはファイル名ではなく、モジュール名で指定します
     (パッケージと拡張モジュールについても同じです)

   * 作者名、電子メールアドレス、プロジェクトの URL といった
     追加のメタデータを入れておくよう奨めます (~*Note setup
     スクリプトを書く:: の 例を参照してください)

このモジュールのソースコード配布物を作成するには、 上記のコードが入った
setup スクリプト `setup.py' を作成して、以下のコマンド:

     python setup.py sdist

を実行します。

この操作を行うと、アーカイブファイル (例えば UNIXでは tarball、Windows
では ZIP ファイル) を作成します。アーカイブファイル には、setup
スクリプト `setup.py' と、配布したいモジュール `foo.py'
が入っています。アーカイブファイルの名前は `foo-1.0.targ.gz' (または
`.zip') になり、展開すると ディレクトリ `foo-1.0' を作成します。

エンドユーザが `foo' モジュールをインストールしたければ、
`foo-1.0.tar.gz' (または `.zip') をダウンロードし、
パッケージを展開して、以下のスクリプトを -- `foo-1.0' ディレクトリ中で
-- 実行します:

     python setup.py install

この操作を行うと、インストールされている Python での適切な
サードパーティ製モジュール置き場に`foo.py' を完璧に コピーします．

ここで述べた簡単な例では、 Distutils の基本的な概念のいくつかを
示しています。まず、開発者とインストール作業者は同じ基本
インタフェース、すなわち setup スクリプトを使っています。
二人の作業の違いは、使っている Distutils _コマンド (command)_
にあります: `sdist' コマンドは、ほぼ完全に開発者だけが
対象となる一方、`install' はどちらかというとインストール 作業者向けです
(とはいえ、ほとんどの開発者は自分のコードをインストール
したくなることがあるでしょう)。

ユーザにとって本当に簡単なものにしたいのなら、一つまたはそれ以上の
ビルド済み配布物を作ってあげられます。例えば、Windows マシン
上で作業をしていて、他の Windows
ユーザにとって簡単な配布物を提供したいのな ら、実行可能な形式の
(このプラットフォーム向けのビルド済み配布物としては もっとも適切な)
インストーラを作成できます。これには `bdist_wininst' を使います。例えば:

     python setup.py bdist_wininst

とすると、実行可能なインストーラ形式、`foo-1.0.win32.exe' が
現在のディレクトリに作成されます。

その他の有用な配布形態としては、`bdist_rpm' に実装 されている RPM
形式、 Solaris `pkgtool' (`bdist_pkgtool') 、 HP-UX `swinstall'
(`bdist_sdux') があります。例えば、以下のコマンドを実行すると、
`foo-1.0.noarch.rpm' という名前の RPM ファイルを作成します:

     python setup.py bdist_rpm

(`bdist_rpm' コマンドは `rpm' コマンドを使うため、 Red Hat Linux や
SuSE Linux、 Mandrake Linux といった RPM ベースの
システムで実行しなければなりません)

どの配布形式が利用できるかは、

     python setup.py bdist --help-formats

を実行すれば分かります。


File: python-dist-jp.info,  Node: Python 一般の用語,  Next: Distutils 固有の用語,  Prev: 簡単な例,  Up: Distutilsの紹介

1.3 Python 一般の用語
=====================

このドキュメントを読んでいるのなら、モジュール (module)、
拡張モジュール (extension) などが何を表すのかをよく知っているかも
しれません。とはいえ、読者がみな共通のスタートポイントに 立って
Distutils の操作を始められるように、ここで一般的な Python 用語
について以下のような用語集を示しておきます:
`モジュール (module)'
     Python においてコードを再利用する際の 基本単位:
     すなわち、他のコードから import されるひとかたまりのコード
     です。ここでは、三種類のモジュール: pure Python モジュール、
     拡張モジュール、パッケージが関わってきます。

`pure Python モジュール'
     Python で書かれ、単一の `.py' ファイル内に収められたモジュールです
     (`.pyc' かつ/または `.pyo' ファイルと関連があります) 。 "pure
     モジュール (pure module)" と呼ばれることもあります。

`拡張モジュール (extension module)'
     Python を実装している 低水準言語: Python の場合は C/C++ 、 Jython
     の場合は Java 、 で書かれたモジュールです。
     通常は、動的にロードできるコンパイル済みの単一のファイルに入っています。
     例えば、UNIX向け Python 拡張のための共有オブジェクト (`.so') 、
     Windows 向け Python 拡張のための DLL (`.pyd' という拡張子が与えら
     れています)、 Jython 拡張のための Java クラスといった具合です。
     (現状では、 Distutils は Python 向けの C/C++ 拡張モジュールしか
     扱わないので注意してください。)

`パッケージ (package)'
     他のモジュールが入っているモジュールです;
     通常、ファイルシステム内のあるディレクトリに収められ、
     `__init__.py' が入っていることで通常のディレクトリと区別 できます。

`ルートパッケージ (root package)'
     階層的なパッケージの根 (root)
     の部分にあたるパッケージです。(この部分には `__init__.py'
     ファイルがないので、本当のパッケージではありませんが、便宜上
     そう呼びます。) 標準ライブラリの大部分はルートパッケージに入って
     います、また、多くの小規模な単体のサードパーティモジュールで、他の
     大規模なモジュールコレクションに属していないものもここに入ります。
     正規のパッケージと違い、ルートパッケージ上のモジュールの実体は様々な
     ディレクトリにあります: 実際は、`sys.path' に列挙されている
     ディレクトリ全てが、ルートパッケージに配置されるモジュールの内容に
     影響します。


File: python-dist-jp.info,  Node: Distutils 固有の用語,  Prev: Python 一般の用語,  Up: Distutilsの紹介

1.4 Distutils 固有の用語
========================

以下は Distutils を使って Python モジュールを配布する際に使われる
特有の用語です:
`モジュール配布物 (module distribution)'
     一個のファイルとして
     ダウンロード可能なリソースの形をとり、_一括して_
     インストールされることになっている形態で配られる Python
     モジュールの
     コレクションです。よく知られたモジュール配布物には、Numeric
     Python、 PyXML、 PIL (the Python Imaging Library)、 mxBase
     などがあります。 (_パッケージ (package)_
     と呼ばれることもありますが、 Python
     用語としてのパッケージとは意味が違います: 一つのモジュール配布物
     の中には、場合によりゼロ個、一つ、それ以上の Python パッケージが
     入っています。)

`pure モジュール配布物 (pure module distribution)'
     pure Python モジュールやパッケージだけが入ったモジュール配布物
     です。"pure 配布物 (pure distribution)" とも呼ばれます。

`非 pure モジュール配布物 (non-pure module distribution)'
     少なくとも一つの拡張モジュールが入ったモジュール配布物です。 "非
     pure 配布物"とも呼びます。

`配布物ルートディレクトリ (distribution root)'
     ソースコードツリー (またはソース配布物) ディレクトリの最上階層で、
     `setup.py' の ある場所です。一般的には、 `setup.py'
     はこのディレクトリ上で 実行します。


File: python-dist-jp.info,  Node: setup スクリプトを書く,  Next: setup 設定ファイル setup configuration file を書く,  Prev: Distutilsの紹介,  Up: Top

2 setup スクリプトを書く
************************

setup スクリプトは、Distutils を使ってモジュールをビルドし、配布し、
インストールする際の全ての動作の中心になります。 setup
スクリプトの主な目的は、モジュール配布物について Distutils に
伝え、モジュール配布を操作するための様々なコマンドを正しく動作させる
ことにあります。 上の ~*Note 簡単な例:: の節で見てきたように、 setup
スクリプトは主に `setup()' の呼び出しからなり、 開発者が distuils
に対して与えるほとんどの情報は `setup()'
のキーワード引数として指定されます。

ここではもう少しだけ複雑な例: Distutils 自体の setup スクリプト、を
示します。これについては、以降の二つの節でフォローします。 (Distutils
が入っているのは Python 1.6 以降であり、 Python 1.5.2
ユーザが他のモジュール配布物をインストールできるようにするための
独立したパッケージがあることを思い出してください。
ここで示した、Distutils 自身の setup スクリプトは、Python 1.5.2 に
Distutils パッケージをインストールする際に使います。)

     #!/usr/bin/env python

     from distutils.core import setup

     setup(name='Distutils',
           version='1.0',
           description='Python Distribution Utilities',
           author='Greg Ward',
           author_email='gward@python.net',
           url='http://www.python.org/sigs/distutils-sig/',
           packages=['distutils', 'distutils.command'],
          )

上の例と、 ~*Note 簡単な例:: で示したファイル一つからなる小さな
配布物とは、違うところは二つしかありません: メタデータの追加と、
モジュールではなくパッケージとして pure Python モジュール群を
指定しているという点です。この点は重要です。というのも、 Distutils は 2
ダースものモジュールが (今のところ) 二つのパッケージに分かれて入って
いるからです; 各モジュールについていちいち明示的に記述したリストは、
作成するのが面倒だし、維持するのも難しくなるでしょう。
その他のメタデータについては、 ~*Note 追加のメタデータ::
を参照してください。

setup スクリプトに与えるパス名 (ファイルまたはディレクトリ) は、 UNIX
におけるファイル名規約、つまりスラッシュ ('/') 区切りで
書かねばなりません。Distutils はこのプラットフォーム中立の表記を、
実際にパス名として使う前に、現在のプラットフォームに適した表記に
注意深く変換します。この機能のおかげで、setup スクリプトを異なる
オペレーティングシステム間にわたって可搬性があるものにできます。
言うまでもなく、これは Distutils の大きな目標の一つです。
この精神に従って、このドキュメントでは全てのパス名をスラッシュ区切り
にしています。 (Mac OS 9プログラマは、先頭にスラッシュが _ない_
場合は、 相対パスを表すということを心に留めておかねば
なりません。この規約は、コロンを使った Mac OS での規約と逆だからです。)

もちろん、この取り決めは Distutils に渡すパス名だけに適用されます。
もし、例えば `glob.glob()' や `os.listdir()' の ような、標準の Python
関数を使ってファイル群を指定するのなら、 パス区切り文字 (path
separator) をハードコーディングせず、
以下のように可搬性のあるコードを書くよう注意すべきです:

         glob.glob(os.path.join('mydir', 'subdir', '*.html'))
         os.listdir(os.path.join('mydir', 'subdir'))

* Menu:

* パッケージを全て列挙する::
* 個々のモジュールを列挙する::
* 拡張モジュールについて記述する::
* パッケージと配布物の関係 Relationships between Distributions and Packages::
* スクリプトをインストールする::
* パッケージデータをインストールする::
* 追加のファイルをインストールする::
* 追加のメタデータ::
* setup スクリプトをデバッグする::


File: python-dist-jp.info,  Node: パッケージを全て列挙する,  Next: 個々のモジュールを列挙する,  Prev: setup スクリプトを書く,  Up: setup スクリプトを書く

2.1 パッケージを全て列挙する
============================

`packages' オプションは、 `packages' リスト中で
指定されている各々のパッケージについて、パッケージ内に見つかった 全ての
pure Python モジュールを処理 (ビルド、配布、インストール、等) するよう
Distutils に指示します。このオプションを指定するためには、
当然のことながら各パッケージ名はファイルシステム上のディレクトリ名と
何らかの対応付けができなければなりません。デフォルトで使われる
対応関係はきわめてはっきりしたものです。すなわち、パッケージ
`distutils' が配布物ルートディレクトリからの相対パス `distutils'
で表されるディレクトリ中にあるというものです。 つまり、setup
スクリプト中で `packages = ['foo']' と指定したら、
スクリプトの置かれたディレクトリからの相対パスで `foo/__init__.py'
を探し出せると Distutils に確約した ことになります。この約束を裏切ると
Distutils は警告を出しますが、
そのまま壊れたパッケージの処理を継続します。

ソースコードディレクトリの配置について違った規約を使っていても、
まったく問題はありません: 単に `package_dir' オプションを 指定して、
Distutils に自分の規約を教えればよいのです。 例えば、全ての Python
ソースコードを `lib' 下に置いて、 "ルートパッケージ" 内のモジュール
(つまり、どのパッケージ にも入っていないモジュール) を `lib' 内に入れ、
`foo' パッケージを `lib/foo' に入れる、といった 具合にしたいのなら、

     package_dir = {'': 'lib'}

を setup スクリプト内に入れます。辞書内のキーはパッケージ名で、
空のパッケージ名はルートパッケージを表します。キーに対応する値は
ルートパッケージからの相対ディレクトリ名です、この場合、 `packages =
['foo']' を指定すれば、 `lib/foo/__init__.py' が存在すると Distutils に
確約したことになります。

もう一つの規約のあり方は `foo' パッケージを `lib' に
置き換え、`foo.bar' パッケージが `lib/bar' にある、
などとするものです。このような規約は、 setup スクリプトでは

     package_dir = {'foo': 'lib'}

のように書きます。 `package_dir' 辞書に `PACKAGE: DIR'
のようなエントリがあると、 PACKAGE
の下にある全てのパッケージに対してこの規則が
暗黙のうちに適用され、その結果 `foo.bar' の場合が自動的に 処理されます。
この例では、 `packages = ['foo', 'foo.bar']' は、 Distutils に
`lib/__init__.py' と `lib/bar/__init__.py' を探すように指示します。
(`package_dir' は再帰的に適用されますが、この場合 `packages'
の下にある全てのパッケージを明示的に指定
しなければならないことを心に留めておいてください: Distutils は
`__init__.py' を持つディレクトリを ソースツリーから再帰的にさがしたりは
_しません_ 。)


File: python-dist-jp.info,  Node: 個々のモジュールを列挙する,  Next: 拡張モジュールについて記述する,  Prev: パッケージを全て列挙する,  Up: setup スクリプトを書く

2.2 個々のモジュールを列挙する
==============================

小さなモジュール配布物の場合、パッケージを列挙するよりも、
全てのモジュールを列挙するほうがよいと思うかもしれません --
特に、単一のモジュールが "ルートパッケージ" にインストール される
(すなわち、パッケージは全くない) ような場合がそうです。
この最も単純なケースは ~*Note 簡単な例:: で示しました;
ここではもうちょっと入り組んだ例を示します:

     py_modules = ['mod1', 'pkg.mod2']

ここでは二つのモジュールについて述べていて、一方は "ルート"
パッケージに入り、他方は `pkg' パッケージに入ります。
ここでも、デフォルトのパッケージ/ディレクトリのレイアウトは、
二つのモジュールが `mod1.py' と `pkg/mod2.py' にあり、`pkg/__init__.py'
が存在することを暗示して
います。また、パッケージ/ディレクトリの対応関係は `package_dir'
オプションでも上書きできます。


File: python-dist-jp.info,  Node: 拡張モジュールについて記述する,  Next: パッケージと配布物の関係 Relationships between Distributions and Packages,  Prev: 個々のモジュールを列挙する,  Up: setup スクリプトを書く

2.3 拡張モジュールについて記述する
==================================

pure Python モジュールを書くより Python 拡張モジュールを書く方が
ちょっとだけ複雑なように、 Distutils での拡張モジュールに関する
記述もちょっと複雑です。pure モジュールと違い、単にモジュールや
パッケージを列挙して、Distutils が正しいファイルを見つけてくれる
と期待するだけでは十分ではありません; 拡張モジュールの名前、
ソースコードファイル (群) 、そして何らかのコンパイル/リンクに
関する必要事項 (include ディレクトリ、リンクすべきライブラリ、等)
を指定しなければなりません。

こうした指定は全て、 `setup()' の別のキーワード 引数、 `ext_modules'
オプションを介して行えます。 `ext_modules' は、 `Extension'
インスタンスから
なるただのリストで、各インスタンスに一個の拡張モジュールを
記述するようになっています。仮に、`foo.c' で実装された 拡張モジュール
`foo' が、配布物に一つだけ入ってるとします。
コンパイラ/リンカに他の情報を与える必要がない場合、この拡張
モジュールのための記述はきわめて単純です:

     Extension('foo', ['foo.c'])

`Extension' クラスは、 `setup()' によって、 `distutils.core' から
import されます。
従って、拡張モジュールが一つだけ入っていて、他には何も入っていない
モジュール配布物を作成するための setup スクリプトは、以下のように
なるでしょう:

     from distutils.core import setup, Extension
     setup(name='foo',
           version='1.0',
           ext_modules=[Extension('foo', ['foo.c'])],
           )

`Explained' クラス (実質的には、`Explained' クラスの 根底にある
`build_ext' コマンドで実装されている、拡張 モジュールをビルドする機構)
は、Python 拡張モジュールをきわめて
柔軟に記述できるようなサポートを提供しています。
これについては後の節で説明します。

* Menu:

* 拡張モジュールの名前とパッケージ::
* 拡張モジュールのソースファイル::
* プリプロセッサオプション::
* ライブラリオプション::
* その他の操作::


File: python-dist-jp.info,  Node: 拡張モジュールの名前とパッケージ,  Next: 拡張モジュールのソースファイル,  Prev: 拡張モジュールについて記述する,  Up: 拡張モジュールについて記述する

2.3.1 拡張モジュールの名前とパッケージ
--------------------------------------

`Extension' クラスのコンストラクタに与える最初の引数は、
常に拡張モジュールの名前にします。これにはパッケージ名も含めます。
例えば、

     Extension('foo', ['src/foo1.c', 'src/foo2.c']p)

とすると、拡張モジュールをルートパッケージに置くことになります。一方、

     Extension('pkg.foo', ['src/foo1.c', 'src/foo2.c'])

は、同じ拡張モジュールを `pkg' パッケージの下に置くよう
記述しています。ソースコードファイルと、作成されるオブジェクトコードは
どちらの場合でも同じです; 作成された拡張モジュールがファイルシステム
上のどこに置かれるか (すなわち Python の名前空間上のどこに置かれるか)
が違うにすぎません。

同じパッケージ内に (または、同じ基底パッケージ下に) いくつもの拡張
モジュールがある場合、`ext_package' キーワード引数を `setup()'
に指定します。例えば、

     setup(...
           ext_package='pkg',
           ext_modules=[Extension('foo', ['foo.c']),
                        Extension('subpkg.bar', ['bar.c'])],
          )

とすると、 `foo.c' をコンパイルして `pkg.foo' にし、 `bar.c'
をコンパイルして `pkg.subpkg.bar' にします。


File: python-dist-jp.info,  Node: 拡張モジュールのソースファイル,  Next: プリプロセッサオプション,  Prev: 拡張モジュールの名前とパッケージ,  Up: 拡張モジュールについて記述する

2.3.2 拡張モジュールのソースファイル
------------------------------------

`Extension' コンストラクタの二番目の引数は、ソースファイルの
リストです。 Distutils は現在のところ、C、C++、そして Objective-C
の拡張しかサポートしていないので、引数は通常 C/C++/Objective-C
ソースコードファイルになります。 (C++ソースコードファイルを区別
できるよう、正しいファイル拡張子を使ってください:  `.cc' や `.cpp'
にすれば、 UNIX と Windows 用の双方のコンパイラで 認識されるようです。)

ただし、 SWIG インタフェース (`.i') ファイルはリストに含め られます;
`build_ext' コマンドは、 SWIG で書かれた
拡張パッケージをどう扱えばよいか心得ています: `build_ext'
は、インタフェースファイルを SWIG にかけ、得られた C/C++
ファイルをコンパイルして拡張モジュールを生成します。

*SWIG サポートはまだ荒削りで、ほとんどテストされていません; C++
拡張に対する SWIG サポートは特にそうです! インタフェース仕様が
固まったときに、もっと詳細な説明をここに。*

プラットフォームによっては、コンパイラで処理され、拡張モジュールに
取り込まれるような非ソースコードファイルを含められます。
非ソースコードファイルとは、現状では Visual C++向けの Windows
メッセージテキスト (`.mc') ファイルや、リソース定義 (`.rc')
ファイルを指します。これらのファイルはバイナリリソース (`.res')
ファイルにコンパイルされ、実行ファイルにリンクされます。


File: python-dist-jp.info,  Node: プリプロセッサオプション,  Next: ライブラリオプション,  Prev: 拡張モジュールのソースファイル,  Up: 拡張モジュールについて記述する

2.3.3 プリプロセッサオプション
------------------------------

`Extension' には三種類のオプション引数: `include_dirs',
`define_macros', そして `undef_macros' があり、検索対象に
するインクルードディレクトリを指定したり、プリプロセッサマクロを 定義
(define)/定義解除 (undefine) したりする必要があるとき役立ちます。

例えば、拡張モジュールが配布物ルート下の `include'
ディレクトリにあるヘッダファイルを必要とするときには、 `include_dirs'
オプションを使います:

     Extension('foo', ['foo.c'], include_dirs=['include'])

ここには絶対パスも指定できます; 例えば、自分の拡張モジュールが、 `/usr'
の下にX11R6 をインストールした UNIX システムだけで
ビルドされると知っていれば、

     Extension('foo', ['foo.c'], include_dirs=['/usr/include/X11'])

のように書けます。

自分のコードを配布する際には、このような可搬性のない使い方は
避けるべきです: おそらく、 C のコードを
     #include <X11/Xlib.h>

のように書いた方がましでしょう。

他の Python 拡張モジュール由来のヘッダを include する必要があるなら、
Distutils の `install_header' コマンドが一貫した方法で
ヘッダファイルをインストールするという事実を活用できます。 例えば、
Numerical Python のヘッダファイルは、 (標準的な UNIX が
インストールされた環境では) `/usr/local/include/python1.5/Numerical'
にインストールされます。 (実際の場所は、プラットフォームやどの Python
をインストールしたかで 異なります。) Python の include ディレクトリ --
今の例では `/usr/local/include/python1.5' -- は、 Python
拡張モジュールを
ビルドする際に常にヘッダファイル検索パスに取り込まれるので、 C
コードを書く上でもっともよいアプローチは、
     #include <Numerical/arrayobject.h>

となります。

`Numerical' インクルードディレクトリ自体をヘッダ検索パス
に置きたいのなら、このディレクトリを Distutils の `distutils.sysconfig'
モジュールを使って見つけさせられます:

     from distutils.sysconfig import get_python_inc
     incdir = os.path.join(get_python_inc(plat_specific=1), 'Numerical')
     setup(...,
           Extension(..., include_dirs=[incdir]),
           )

この書き方も可搬性はあります -- プラットフォームに関わらず、 どんな
Python がインストールされていても動作します -- が、
単に実践的な書き方で C コードを書く方が簡単でしょう。

`define_macros' および `undef_macros' オプションを使って、
プリプロセッサマクロを定義 (define) したり、定義解除 (undefine)
したりもできます。 `define_macros' はタプル `(name, value)'
からなるリストを 引数にとります。`name' は定義したいマクロの名前
(文字列) で、 `value' はその値です: `value' は文字列か `None' に
なります。(マクロ `FOO' を `None' にすると、C ソースコード内 で
`#define FOO' と書いたのと同じになります: こう書くと、
ほとんどのコンパイラは `FOO' を文字列 `1' に設定します。)
`undef_macros' には、定義解除したいマクロ名からなるリストを 指定します。

例えば、以下の指定:

     Extension(...,
               define_macros=[('NDEBUG', '1'),
                              ('HAVE_STRFTIME', None)],
               undef_macros=['HAVE_FOO', 'HAVE_BAR'])

は、全ての C ソースコードファイルの先頭に、以下のマクロ:

     #define NDEBUG 1
     #define HAVE_STRFTIME
     #undef HAVE_FOO
     #undef HAVE_BAR

があるのと同じになります。


File: python-dist-jp.info,  Node: ライブラリオプション,  Next: その他の操作,  Prev: プリプロセッサオプション,  Up: 拡張モジュールについて記述する

2.3.4 ライブラリオプション
--------------------------

拡張モジュールをビルドする際にリンクするライブラリや、ライブラリを
検索するディレクトリも指定できます。 `libraries'
はリンクするライブラリのリストで、 `library_dirs'
はリンク時にライブラリを検索するディレクトリの
リストです。また、`runtime_library_dirs' は、実行時に 共有ライブラリ
(動的にロードされるライブラリ) を検索するディレクトリの リストです。

例えば、ビルド対象システムの標準ライブラリ検索パスにあることが分かって
いるライブラリをリンクする時には、以下のようにします。

     Extension(...,
               libraries=['gdbm', 'readline'])

非標準のパス上にあるライブラリをリンクしたいなら、その場所を
`library_dirs' に入れておかなければなりません:

     Extension(...,
               library_dirs=['/usr/X11R6/lib'],
               libraries=['X11', 'Xt'])

(繰り返しになりますが、この手の可搬性のない書き方は、コードを配布する
のが目的なら避けるべきです。)

*ここか、どこか別のところで clib ライブラリについて触れておかねば!*


File: python-dist-jp.info,  Node: その他の操作,  Prev: ライブラリオプション,  Up: 拡張モジュールについて記述する

2.3.5 その他の操作
------------------

他にもいくつかオプションがあり、特殊な状況を扱うために使います。

`extra_objects' オプションには、リンカに渡すオブジェクトファイル
のリストを指定します。ファイル名には拡張子をつけてはならず、コンパイラ
で使われているデフォルトの拡張子が使われます。

`extra_compile_args' および `extra_link_args' には、
それぞれコンパイラとリンカに渡す追加のコマンドライン引数を指定します。

`export_symbols' は Windows でのみ意味があります。
このオプションには、公開 (export) する (関数や変数の) シンボルのリスト
を入れられます。コンパイルして拡張モジュールをビルドする際には、
このオプションは不要です: Distutils は公開するシンボルを自動的に
`initmodule' に渡すからです。


File: python-dist-jp.info,  Node: パッケージと配布物の関係 Relationships between Distributions and Packages,  Next: スクリプトをインストールする,  Prev: 拡張モジュールについて記述する,  Up: setup スクリプトを書く

2.4 パッケージと配布物の関係 (Relationships between Distributions and Packages)
===============================================================================

配布物はパッケージと3種類の方法で関係します:

  1. パッケージかモジュールを要求する。

  2. パッケージかモジュールを提供する。

  3. パッケージかモジュールを廃止する。

これらの関係は、`distutils.core.setup()'関数のキーワード引数を
利用して指定することができます。

他のPythonモジュールやパッケージに対する依存は、`setup()'の
REQUIRESキーワード引数で指定できます。
引数の値は文字列のリストでなければなりません。
各文字列は、必要とするパッケージと、オプションとしてパッケージのバージョンを
指定します。

あるモジュールかパッケージの任意のバージョンが必要な場合、
指定する文字列はモジュール名かパッケージ名になります。例えば、
`'mymodule'' や `'xml.parsers.expat'' を含みます。

特定のバージョンが必要な場合、修飾子(qualifier)の列を加えることができます。
各修飾子は、比較演算子とバージョン番号からなります。利用できる比較演算子は:

     <    >    ==
     <=   >=   !=

これらの修飾子はカンマ(空白文字を入れても良いです)で区切って複数並べることができます。
その場合、全ての修飾子が適合する必要があります;
評価する時に論理ANDでつなげられます。

いくつかの例を見てみましょう:

require式                            説明
------                               -----
==1.0                                version `1.0' のみが適合します
>1.0, !=1.5.1, <2.0                  `1.5.1' を除いて、 `1.0' より後ろで
                                     `2.0'
                                     より前の全てのバージョンに適合します。

これで、依存を指定することができました。同じように、この配布物が他の配布物に
必要とされる何を提供するのかを指定する必要があります。
これは、`setup()' の PROVIDE キーワード引数によって指定できます。
この引数の値は文字列のリストで、各要素はPythonモジュールかパッケージの名前です。
バージョンを指定することもできます。
もしバージョンが指定されなかった場合、配布物のバージョン番号が利用されます。

いくつかの例です:

provide 式                           説明
------                               -----
mypkg                                `mypkg'
                                     を提供します。バージョンは配布物のものを使います。
mypkg (1.1                           `mypkg' version 1.1
                                     を提供します。配布物のバージョン番号は
                                     気にしません

パッケージは OBSOLETES
キーワードを利用することで、他のパッケージを廃止することを
宣言することもできます。 この値はREQUIRESキーワードと似ています:
モジュールやパッケージを指定する文字列の
リストです。各文字列は、モジュールかパッケージの名前と、オプションとして一つ以上のバージョン
指定から構成されています。バージョン指定は、モジュールやパッケージの名前のうしろに、
丸括(parentheses)でかこわれています。

指定されたバージョンは、その配布物によって廃止されるバージョンを示しています。
バージョン指定が存在しない場合は、指定された名前のモジュールまたはパッケージの
全てが廃止されたと解釈されます。


File: python-dist-jp.info,  Node: スクリプトをインストールする,  Next: パッケージデータをインストールする,  Prev: パッケージと配布物の関係 Relationships between Distributions and Packages,  Up: setup スクリプトを書く

2.5 スクリプトをインストールする
================================

ここまでは、スクリプトから import され、それ自体では実行されない ような
pure Python モジュールおよび非 pure Python モジュール
について扱ってきました。

スクリプトとは、Python ソースコードを含むファイルで、コマンドライン
から実行できるよう作られているものです。スクリプトは Distutils に
複雑なことを一切させません。唯一の気の利いた機能は、スクリプトの
最初の行が `#!' で始まっていて、 "python" という単語が
入っていた場合、Distutils は最初の行を現在使っているインタプリタを
参照するよう置き換えます。 デフォルトでは現在使っているインタプリタと
置換しますが、オプション `--executable' (または `-e')
を指定することで、明示的にインタプリタのパスを指定し
て上書きすることができます。

`scripts' オプションには、単に上で述べた方法で取り扱うべき
ファイルのリストを指定するだけです。PyXML の setup スクリプトを
例に示します:

     setup(...
           scripts=['scripts/xmlproc_parse', 'scripts/xmlproc_val']
           )


File: python-dist-jp.info,  Node: パッケージデータをインストールする,  Next: 追加のファイルをインストールする,  Prev: スクリプトをインストールする,  Up: setup スクリプトを書く

2.6 パッケージデータをインストールする
======================================

しばしばパッケージに追加のファイルをインストールする必要があります。
このファイルは、パッケージの実装に強く関連したデータや、そのパッケー
ジを使うプログラマーが必要とするドキュメントなどです。
これらのファイルを"パッケージデータ"と呼びます。

パッケージデータは 関数`setup()'にキーワード引数 `package_data'
を与えることで追加できます。
この値はパッケージ名から、パッケージへコピーされる相対パス名リストへの
マップである必要があります。それぞれのパスは対応するパッケージが含まれ
るディレクトリ(もし適切なら`package_dir'のマッピングが利用されま
す)からの相対パスとして扱われます。つまり、ファイルはソースディレクト
リ中にパッケージの一部として存在すると仮定されています。
この値にはグロブパターンを含むことができます。

パス名にはディレクトリ部分を含むことができます。必要なディレクトリは
インストール時に作成されます。

たとえば、パッケージがいくつかのデータファイルを含むサブディレクトリを
含んでいる場合、ソースツリーでは以下のように配置できます:

     setup.py
     src/
         mypkg/
             __init__.py
             module.py
             data/
                 tables.dat
                 spoons.dat
                 forks.dat

対応する `setup()'呼び出しは以下のようになります:

     setup(...,
           packages=['mypkg'],
           package_dir={'mypkg': 'src/mypkg'},
           package_data={'mypkg': ['data/*.dat']},
           )

_Added in Python version 2.4_


File: python-dist-jp.info,  Node: 追加のファイルをインストールする,  Next: 追加のメタデータ,  Prev: パッケージデータをインストールする,  Up: setup スクリプトを書く

2.7 追加のファイルをインストールする
====================================

`data_files' オプションを使うと、モジュール配布物で必要な
追加のファイル: 設定ファイル、メッセージカタログ、データファイル、
その他これまで述べてきたカテゴリに収まらない全てのファイルを指定
できます。

`data_files' には、(DIRECTORY, FILES) の ペアを以下のように指定します:

     setup(...
           data_files=[('bitmaps', ['bm/b1.gif', 'bm/b2.gif']),
                       ('config', ['cfg/data.cfg']),
                       ('/etc/init.d', ['init-script'])]
          )

データファイルのインストール先ディレクトリ名は指定できますが、
データファイル自体の名前の変更はできないので注意してください。

各々の (DIRECTORY, FILES) ペアには、インストール先の
ディレクトリ名と、そのディレクトリにインストールしたいファイルを
指定します。DIRECTORY が相対パスの場合、インストール プレフィクス
(installation prefix、 pure Python パッケージなら `sys.prefix'
、拡張モジュールの入ったパッケージなら `sys.exec_prefix')
からの相対パスと解釈されます。 FILES
内の各ファイル名は、パッケージソースコード配布物 の最上階層の、
`setup.py' のあるディレクトリからの相対パスと 解釈されます。FILES
に書かれたディレクトリ情報は、
ファイルを最終的にどこにインストールするかを決めるときには使われ
ません; ファイルの名前だけが使われます。

`data_files' オプションは、ターゲットディレクトリを指定せずに、
単にファイルの列を指定できます。しかし、このやり方は推奨されておらず、
指定すると `install' コマンドが警告を出力します。
ターゲットディレクトリにデータファイルを直接インストールしたいなら、
ディレクトリ名として空文字列を指定してください。


File: python-dist-jp.info,  Node: 追加のメタデータ,  Next: setup スクリプトをデバッグする,  Prev: 追加のファイルをインストールする,  Up: setup スクリプトを書く

2.8 追加のメタデータ
====================

setup スクリプトには、名前やバージョンにとどまらず、その他の
メタデータを含められます。以下のような情報を含められます:

メタデータ         説明               値                 注記
------             ------             ------             ------
name               パッケージの名前   短い文字列         (1)
version            リリースのバージョン短い文字列         (1)(2)
author             パッケージ作者の名前短い文字列         (3)
author_email       パッケージ作者の電子メールアドレス電子メールアドレス (3)
maintainer         パッケージメンテナンス担当者の名前短い文字列         (3)
maintainer_email   パッケージメンテナンス担当者の電子メールアドレス (3)
                   電子メールアドレス                    
url                パッケージのホームページURL                (1)
description        パッケージについての簡潔な概要説明短い文字列         
long_description   パッケージについての詳細な説明長い文字列         
download_url       パッケージをダウンロードできる場所URL                (4)
classifiers        分類語のリスト     文字列からなるリスト(4)

注記:
`(1)'
     必須のフィールドです。

`(2)'
     バージョン番号は _major.minor[.patch[.sub]]_
     の形式をとるよう奨めます。

`(3)'
     作者かメンテナのどちらかは必ず区別してください。

`(4)'
     これらのフィールドは、2.2.3 および 2.3 より以前の バージョンの
     Python でも互換性を持たせたい場合には指定しては なりません。
     リストは PyPI ウェブサイト にあります。

`「短い文字列」'
     200 文字以内の一行のテキスト。

`「長い文字列」'
     複数行からなり、ReStructuredText 形式で書かれた プレーンテキスト
     (`http://docutils.sf.net/' を参照してください)。

`「文字列のリスト」'
     下記を参照してください。

これらの文字列はいずれも Unicode であってはなりません。

バージョン情報のコード化は、それ自体が一つのアートです。 Python
のパッケージは一般的に、 _major.minor[.patch][sub]_ という
バージョン表記に従います。 メジャー (major) 番号は最初は 0
で、これはソフトウェアが実験的リリース
にあることを示します。メジャー番号は、パッケージが主要な開発目標を
達成したとき、それを示すために加算されてゆきます。マイナー (minor)
番号は、パッケージに重要な新機能が追加されたときに加算されてゆきます。
パッチ (patch) 番号は、バグフィクス版のリリースが作成されたときに
加算されます。末尾にバージョン情報が追加され、サブリリースを示す
こともあります。これは "a1,a2,...,aN" (アルファリリースの場合で、
機能や API が変更されているとき)、  "b1,b2,...,bN" (ベータリリース
の場合で、バグフィクスのみのとき) 、そして "pr1,pr2,...,prN"
(プレリリースの最終段階で、リリーステストのとき) になります。
以下に例を示します:

`0.1.0'
     パッケージの最初の実験的なリリース

`1.0.1a2'
     1.0 の最初のパッチバージョンに対する、2 回目のアルファ リリース

`classifiers' は、 Python のリスト型で指定します:

     setup(...
           classifiers=[
               'Development Status :: 4 - Beta',
               'Environment :: Console',
               'Environment :: Web Environment',
               'Intended Audience :: End Users/Desktop',
               'Intended Audience :: Developers',
               'Intended Audience :: System Administrators',
               'License :: OSI Approved :: Python Software Foundation License',
               'Operating System :: MacOS :: MacOS X',
               'Operating System :: Microsoft :: Windows',
               'Operating System :: POSIX',
               'Programming Language :: Python',
               'Topic :: Communications :: Email',
               'Topic :: Office/Business',
               'Topic :: Software Development :: Bug Tracking',
               ],
           )

`setup.py' に `classifiers' を入れておき、なおかつ 2.2.3
よりも以前のバージョンの Python と後方互換性を保ちたいなら、 `setup.py'
中で `setup()' を呼び出す前に、以下のコードを 入れます。

     # patch distutils if it can't cope with the "classifiers" or
     # "download_url" keywords
     from sys import version
     if version < '2.2.3':
         from distutils.dist import DistributionMetadata
         DistributionMetadata.classifiers = None
         DistributionMetadata.download_url = None


File: python-dist-jp.info,  Node: setup スクリプトをデバッグする,  Prev: 追加のメタデータ,  Up: setup スクリプトを書く

2.9 setup スクリプトをデバッグする
==================================

setup スクリプトのどこかがまずいと、開発者の思い通りに動作
してくれません。

Distutils は setup 実行時の全ての例外を捉えて、簡単なエラーメッセージ
を出力してからスクリプトを終了します。このような仕様にしているのは、
Python にあまり詳しくない管理者がパッケージをインストールする際に
混乱しなくてすむようにするためです。 もし Distutils
のはらわた深くからトレースバックした長大な
メッセージを見たら、管理者はきっと Python のインストール自体が
おかしくなっているのだと勘違いして、トレースバックを最後まで読み進んで
実はファイルパーミッションの問題だったと気づいたりはしないでしょう。

しかし逆に、この仕様は開発者にとってはうまくいかない理由を見つける
役には立ちません。そこで、 DISTUTILS_DEBUG 環境変数を空文字以外の
何らかの値に設定しておけば、 Distutils が何を実行しているか詳しい
情報を出力し、例外が発生した場合には完全なトレースバックを出力
するようにできます。


File: python-dist-jp.info,  Node: setup 設定ファイル setup configuration file を書く,  Next: ソースコード配布物を作成する,  Prev: setup スクリプトを書く,  Up: Top

3 setup 設定ファイル (setup configuration file) を書く
******************************************************

時に、配布物をビルドする際に必要な全ての設定を_あらかじめ_ 書き
きれない状況が起きます: 例えば、ビルドを進めるために、ユーザに関する
情報や、ユーザのシステムに関する情報を必要とするかもしれません。
こうした情報が単純 -- C ヘッダファイルやライブラリを検索する
ディレクトリのリストのように -- であるかぎり、ユーザに 設定ファイル
(configuration file) `setup.cfg' を提供して
編集してもらうのが、安上がりで簡単な特定方法になります。
設定ファイルはまた、あらゆるコマンドにおけるオプションにデフォルト値
を与えておき、インストール作業者がコマンドライン上や設定ファイルの
編集でデフォルト設定を上書きできるようにします。

setup 設定ファイルは setup スクリプト --理想的にはインストール作業者
から見えないもの (1) --と、作者の手を離れて、全てインストール
作業者次第となる setup スクリプトのコマンドライン引数との間を
橋渡しする中間層として有効です。 実際、`setup.cfg'
(と、ターゲットシステム上にある、その他の Distutils 設定ファイル) は、
setup スクリプトの内容より後で、
かつコマンドラインで上書きする前に処理されます。
この仕様の結果、いくつかの利点が生まれます:
   * インストール作業者は、作者が `setup.py' に設定した項目の
     いくつかを `setup.cfg' を変更して上書きできます。

   * `setu.py' では簡単に設定できないような、標準でない
     オプションのデフォルト値を設定できます。

   * インストール作業者は、`setup.cfg' に書かれたどんな設定も
     `setup.py' のコマンドラインオプションで上書きできます。

設定ファイルの基本的な構文は簡単なものです:

     [command]
     option=value
     ...

ここで、 COMMAND は Distutils コマンドのうちの一つ (例えば `build_py',
`install') で、OPTION
はそのコマンドでサポートされているオプションのうちの一つです。
各コマンドには任意の数のオプションを設定でき、一つの設定ファイル
中には任意の数のコマンドセクションを収められます。
空白行は無視されます、 `#' 文字で開始して行末まで続く
コメントも同様に無視されます。
長いオプション設定値は、継続行をインデントするだけで複数行に
わたって記述できます。

あるコマンドがサポートしているオプションのリストは、 `--help'
オプションで調べられます。例えば以下のように。

     > python setup.py --help build_ext
     [...]
     Options for 'build_ext' command:
       --build-lib (-b)     directory for compiled extension modules
       --build-temp (-t)    directory for temporary files (build by-products)
       --inplace (-i)       ignore build-lib and put compiled extensions into the
                            source directory alongside your pure Python modules
       --include-dirs (-I)  list of directories to search for header files
       --define (-D)        C preprocessor macros to define
       --undef (-U)         C preprocessor macros to undefine
     [...]

コマンドライン上で `--foo-bar' と綴るオプションは、 設定ファイル上では
`foo_bar' と綴るので注意してください。

例えば、拡張モジュールを "インプレース (in-place)" でビルドしたい
とします -- すなわち、`pkg.ext' という拡張モジュールを
持っていて、コンパイル済みの拡張モジュールファイル (例えば UNIX では
`ext.so') を pure Python モジュール `pkg.mod1' および `pkg.mod2'
と同じソースディレクトリに置きたいとします。
こんなときには、`--inplace' を使えば、確実にビルドを 行えます。

     python setup.py build_ext --inplace

しかし、この操作では、常に `build_ext' を明示的に指定
しなければならず、 `--inplace' オプションを忘れずに
与えなければなりません。 こうした設定を "設定しっ放しにする"
簡単な方法は、 `setup.cfg'
に書いておくやり方で、設定ファイルは以下のように なります:

     [build_ext]
     inplace=1

この設定は、明示的に `build_ext' を指定するかどうかに
関わらず、モジュール配布物の全てのビルドに影響します。 ソース配布物に
`setup.cfg' を含めると、エンドユーザの手で 行われるビルドにも影響します
-- このオプションの例に関しては `setup.cfg'
を含めるのはおそらくよくないアイデアでしょう。
というのは、拡張モジュールをインプレースでビルドすると常に
インストールしたモジュール配布物を壊してしまうからです。
とはいえ、ある特定の状況では、モジュールをインストールディレクトリ
の下に正しく構築できるので、機能としては有用だと考えられます。
(ただ、インストールディレクトリ上でのビルドを想定するような
拡張モジュールの配布は、ほとんどの場合よくない考え方です。)

もう一つ、例があります: コマンドによっては、実行時にほとんど
変更されないたくさんのオプションがあります; 例えば、 `bdist_rpm'
には、RPM 配布物を作成する際に、"spec"
ファイルを作成するために必要な情報を全て与えなければなりません。
この情報には setup スクリプトから与えるものもあり、
(インストールされるファイルのリストのように) Distutils が自動的に
生成するものもあります。しかし、こうした情報の中には `bdist_rpm'
のオプションとして与えるものがあり、
毎回実行するごとにコマンドライン上で指定するのが面倒です。
そこで、以下のような内容が Distutils 自体の `setup.cfg'
には入っています:

     [bdist_rpm]
     release = 1
     packager = Greg Ward <gward@python.net>
     doc_files = CHANGES.txt
                 README.txt
                 USAGE.txt
                 doc/
                 examples/

`doc_files' オプションは、単に空白で区切られた文字列で、
ここでは可読性のために複数行をまたぐようにしています。

See also:
     `Installing Python
     Modules'{設定ファイルに関する詳細情報は、システム管理者
     向けのこのマニュアルにあります。}

---------- Footnotes ----------

(1) Distutils が自動設定機能 (auto-configuration)
をサポートするまで、おそらくこの理想状態を 達成することはないでしょう


File: python-dist-jp.info,  Node: ソースコード配布物を作成する,  Next: ビルド済み配布物を作成する,  Prev: setup 設定ファイル setup configuration file を書く,  Up: Top

4 ソースコード配布物を作成する
******************************

~*Note 簡単な例:: 節で示したように、ソースコード配布物を作成 するには
`sdist' コマンドを使います。最も単純な例では、

     python setup.py sdist

のようにします (ここでは、`sdist' に関するオプションを setup
スクリプトや設定ファイル中で行っていないものと仮定します)。 `sdist'
は、現在のプラットフォームでのデフォルトのアーカイブ形式
でアーカイブを生成します。デフォルトの形式は UNIXでは gzip で圧縮された
tar ファイル形式 (`.tar.gz') で、Windows では ZIP 形式です。

`--formats' オプションを使えば、好きなだけ圧縮形式を
指定できます。例えば:

     python setup.py sdist --formats=gztar,zip

は、gzip された tarball と zip ファイルを作成します。
利用可能な形式は以下の通りです:
形式                     説明                     注記
------                   -----                    -----
zip                      zip ファイル (`.zip')    (1),(3)
gztar                    gzip 圧縮された tar      (2),(4)
                         ファイル (`.tar.gz')     
bztar                    bzip2 圧縮された tar     (4)
                         ファイル (`.tar.bz2')    
ztar                     compress 圧縮された tar  (4)
                         ファイル (`.tar.Z')      
tar                      tar ファイル (`.tar')    (4)

注記:
`(1)'
     Windows でのデフォルトです

`(2)'
     UNIXでのデフォルトです

`(3)'
     外部ユーティリティの `zip' か、`zipfile' モジュールが必要です
     (Python~1.6 からは 標準ライブラリになっています)

`(4)'
     外部ユーティリティ: `tar' 、場合によっては `gzip'、
     `bzip2'、または `compress' も 必要です

* Menu:

* 配布するファイルを指定する::
* マニフェスト manifest 関連のオプション::


File: python-dist-jp.info,  Node: 配布するファイルを指定する,  Next: マニフェスト manifest 関連のオプション,  Prev: ソースコード配布物を作成する,  Up: ソースコード配布物を作成する

4.1 配布するファイルを指定する
==============================

明確なファイルのリスト (またはファイルリストを生成する方法) を明示的に
与えなかった場合、`sdist' コマンドはソース配布物に以下のような
最小のデフォルトのセットを含めます:
   * `py_modules' と `packages' オプションに指定された Python
     ソースファイル全て

   * `ext_modules' や `libraries' オプションに記載 された C
     ソースファイル *(C ライブラリソースの取得機構は現状では
     うまく動きません - `build_clib.py' には、 `get_source_files()'
     メソッド がありません!)*

   * `scripts'オプションで指定されたスクリプト

   * テストスクリプトと思しきファイル全て: `test/test*.py'
     (現状では、Distutils はテストスクリプトをただソース配布物に含める
     だけですが、将来は Python
     モジュール配布物に対するテスト標準ができる かもしれません)

   * `README.txt' (または `README')、 `setup.py' (または setup
     スクリプトにしているもの) 、および `setup.cfg'

上記のセットで十分なこともありますが、大抵他のファイルを配布物に
含めたいと思うでしょう。普通は、 `MANIFEST.in' と呼ばれる
_マニフェストテンプレート (manifest template)_ を使って
これを行います。マニフェストテンプレートは、ソース配布物に
含めるファイルの正確なリストであるマニフェストファイル `MANIFEST'
をどうやって作成するか指示しているリストです。 `sdist'
コマンドはこのテンプレートを処理し、書かれた
指示とファイルシステム上に見つかったファイルに基づいて
マニフェストファイルを作成します。

自分用のマニフェストファイルを書きたいなら、その形式は簡単です:
一行あたり一つの通常ファイル (または通常ファイルに対する
シンボリックリンク) だけを書きます。自分で `MANIFEST'
を提供する場合、全てを自分で指定しなければなりません:
ただし、上で説明したデフォルトのファイルセットは、この中には
含まれません。

マニフェストテンプレートには一行あたり一つのコマンドがあります。
各コマンドはソース配布物に入れたり配布物から除外したりする
ファイルのセットを指定します。 例えば、Distutils
自体のマニフェストテンプレートの話に戻ると:

     include *.txt
     recursive-include examples *.txt *.py
     prune examples/sample?/build

各行はかなり明確に意味を取れるはずです: 上の指定では、 `*.txt'
にマッチする配布物ルート下の全てのファイル、 `examples'
ディレクトリ下にある `*.txt' か `*.py'
にマッチする全てのファイルを含め、`examples/sample?/build'
にマッチする全てのファイルを除外します。
これらの処理はすべて、標準的に含められるファイルセットの評価よりも
_後に_ 行われるので、マニフェストテンプレートに明示的に
指示をしておけば、標準セット中のファイルも除外できます。
(`--no-defaults' オプションを設定して、標準セット
自体を無効にもできます。)
他にも、このマニフェストテンプレート記述のためのミニ言語には
いくつかのコマンドがあります: ~*Note ソースコード配布物を作成する sdist
command:: 節を参照して ください。

マニフェストテンプレート中のコマンドの順番には意味があります;
初期状態では、上で述べたようなデフォルトのファイルがあり、
テンプレート中の各コマンドによって、逐次ファイルを追加したり
除去したりしていいます。マニフェストテンプレートを完全に
処理し終えたら、ソース配布物中に含めるべきでない以下のファイル
をリストから除去します:
   * Distutls の "build" (デフォルトの名前は `build')
     ツリー下にある全てのファイル

   * `RCS'、`CVS'、`.svn' といった名前のディレクトリ下にある
     全てのファイル

こうして完全なファイルのリストができ、後で参照するために
マニフェストに書き込まれます。この内容は、ソース配布物の
アーカイブを作成する際に使われます。

含めるファイルのデフォルトセットは `--no-defaults'
で無効化でき、標準で除外するセットは `--no-prune' で無効化できます。

Distutils 自体のマニフェストテンプレートから、`sdist'
コマンドがどのようにして Distutils ソース配布物に含めるファイルの
リストを作成するか見てみましょう:
  1. `distutils' ディレクトリ、および `distutils/command'
     サブディレクトリの下にある全ての Python ソースファイルを含めます
     (これらの二つのディレクトリが、setup スクリプト下の `packages'
     オプションに記載されているからです -- ~*Note setup
     スクリプトを書く:: を 参照してください)

  2. `README.txt', `setup.py', および `setup.cfg'
     (標準のファイルセット) を含めます

  3. `test/test*.py' (標準のファイルセット) を含めます

  4. 配布物ルート下の `*.txt' を含めます (この処理で、 `README.txt'
     がもう一度見つかりますが、こうした冗長性は後で 刈り取られます)

  5. `examples' 下にあるサブツリー内で `*.txt' または `*.py'
     にマッチする全てのファイルを含めます

  6. ディレクトリ名が `examples/sample?/build' にマッチする
     ディレクトリ以下のサブツリー内にあるファイル全てを除外します--
     この操作によって、上の二つのステップでリストに含められたファイルが
     除外されることがあるので、マニフェストテンプレート内では
     `recursive-include' コマンドの後に `prune' コマンドを
     持ってくることが重要です

  7. `build' ツリー全体、および `RCS'、 `CVS'と、 `.svn'
     ディレクトリ全てを除外します
     setup
スクリプトと同様、マニフェストテンプレート中のディレクトリ名は
常にスラッシュ区切りで表記します; Distutils は、こうしたディレクトリ
名を注意深くプラットフォームでの標準的な表現に変換します。
このため、マニフェストテンプレートは複数のオペレーティングシステム
にわたって可搬性を持ちます。


File: python-dist-jp.info,  Node: マニフェスト manifest 関連のオプション,  Prev: 配布するファイルを指定する,  Up: ソースコード配布物を作成する

4.2 マニフェスト (manifest) 関連のオプション
============================================

`sdist' コマンドが通常行う処理の流れは、以下のようになって います:
   * マニフェストファイル `MANIFEST' が存在しなければ、 `MANIFEST.in'
     を読み込んでマニフェストファイルを作成します

   * `MANIFEST' も `MANIFEST.in' もなければ、
     デフォルトのファイルセットだけでできたマニフェストファイルを
     作成します

   * `MANIFEST.in' または (`setup.py') が `MANIFEST'
     より新しければ、`MANIFEST.in' を読み込んで `MANIFEST' を生成します

   * (生成されたか、読み出された) `MANIFEST' 内にあるファイル
     のリストを使ってソース配布物アーカイブを作成します

上の動作は二種類のオプションを使って修正できます。まず、 標準の
"include" および "exclude" セットを無効化するには `--no-defaults'
および `--no-prune' を使います

第二に、マニフェストファイルの再生成を強制できます -- 例えば、
現在マニフェストテンプレート内に指定しているパターンにマッチする
ファイルやディレクトリを追加したり削除したりすると、マニフェストを
再生成しなくてはなりません:

     python setup.py sdist --force-manifest

また、単にマニフェストを (再) 生成したいだけで、ソース配布物は
作成したくない場合があるかもしれません:

     python setup.py sdist --manifest-only

`--manifest-only' を行うと、 `--force-manifest' を呼び出します。 `-o'
は `--manifest-only' のショートカット、 `-f' は `--force-manifest'
のショートカットです。


File: python-dist-jp.info,  Node: ビルド済み配布物を作成する,  Next: パッケージインデクスに登録する,  Prev: ソースコード配布物を作成する,  Up: Top

5 ビルド済み配布物を作成する
****************************

"ビルド済み配布物" とは、おそらく皆さんが通常 "バイナリパッケージ" とか
"インストーラ" (背景にしている知識によって違います) と考えて
いるものです。とはいえ、配布物が必然的にバイナリ形式になるわけでは
ありません。配布物には、 Python ソースコード、かつ/またはバイトコード
が入るからです; また、我々はパッケージという呼び方もしません。 すでに
Python の用語として使っているからです (また、 "インストーラ"
という言葉は主流のデスクトップシステム特有の用語です)

ビルド済み配布物は、モジュール配布物をインストール作業者にとって
できるだけ簡単な状況にする方法です: ビルド済み配布物は、RPM ベースの
Linux システムユーザにとってはバイナリ RPM 、Windows ユーザに
とっては実行可能なインストーラ、 Debian ベースの Linux システム では
Debian パッケージ、などといった具合です。
当然のことながら、一人の人間が世の中にある全てのプラットフォーム用
にビルド済み配布物を作成できるわけではありません。そこで、 Distutils
の設計は。開発者が自分の専門分野 -- コードを書き、ソース配布物
を作成する -- に集中できる一方で、_パッケージ作成者 (packager)_
と呼ばれる、開発者とエンドユーザとの中間に位置する人々が
ソースコード配布物を多くのプラットフォームにおけるビルド済み配布物
に変換できるようになっています。

もちろん、モジュール開発者自身がパッケージ作成者かもしれません; また、
パッケージを作成するのはオリジナルの作成者が利用できないプラットフォームに
アクセスできるような "外部の" ボランティアかもしれませんし、
ソース配布物を定期的に取り込んで、アクセスできるかぎりの
プラットフォーム向けにビルド済み配布物を生成するソフトウェアかも
しれません。作業を行うのが誰であれ、パッケージ作成者は setup
スクリプトを利用し、 `bdist' コマンドファミリを使って
ビルド済み配布物を作成します。

単純な例として、Distutils ソースツリーから以下のコマンドを
実行したとします:

     python setup.py bdist

すると、Distutils はモジュール配布物 (ここでは Distutils 自体) を
ビルドし、"偽の (fake)" インストールを (`build' ディレクトリで)
行います。そして現在のプラットフォームにおける標準の形式でビルド済み
配布物を生成します。デフォルトのビルド済み形式とは、UNIXでは "ダム
(dumb)" の tar ファイルで、 Windows ではシンプルな実行形式の
インストーラになります。(tar ファイルは、特定の場所に手作業で解凍
しないと動作しないので、 "ダム: 賢くない" 形式とみなします。)

従って、 UNIX システムで上記のコマンドを実行すると、
`Distutils-1.0.`PLAT'.tar.gz' を作成します; この tarball
を正しい場所で解凍すると、ちょうどソース配布物を ダウンロードして
`python setup.py install' を実行したのと 同じように、正しい場所に
Distutils がインストールされます。 ("正しい場所 (right place)"
とは、ファイルシステムのルート下か、 Python の `PREFIX'
ディレクトリ下で、これは `bdist_dumb' に指定するコマンドで変わります;
デフォルトの設定では、`PREFIX' からの相対パスにインストール
されるダム配布物が得られます。)

言うまでもなく、 pure Python 配布物の場合なら、 `python setup.py
install' するのに比べて大して簡単になったとは 言えません--しかし、非
pure 配布物で、コンパイルの必要な拡張
モジュールを含む場合、拡張モジュールを利用できるか否かという大きな
違いになりえます。 また、 RPM パッケージや Windows
用の実行形式インストーラのような "スマートな"
ビルド済み配布物を作成しておけば、たとえ拡張モジュール
が一切入っていなくてもユーザにとっては便利になります。

`bdist' コマンドには、 `--formats' オプション があります。これは
`sdist' コマンドの場合に似ていて、
生成したいビルド済み配布物の形式を選択できます: 例えば、

     python setup.py bdist --format=zip

とすると、UNIX システムでは、 `Distutils-1.0.`PLAT'.zip' を作成します--
先にも述べたように、Distutils をインストールするには、
このアーカイブ形式をルートディレクトリ下で展開します。

ビルド済み配布物として利用できる形式を以下に示します:
形式                     説明                     注記
------                   -----                    -----
gztar                    gzip 圧縮された tar      (1),(3)
                         ファイル (`.tar.gz')     
ztar                     compress 圧縮された tar  (3)
                         ファイル (`.tar.Z')      
tar                      tar ファイル (`.tar')    (3)
zip                      zip ファイル (`.zip')    (4)
rpm                      RPM 形式                 (5)
pkgtool                  Solaris `pkgtool' 形式   
sdux                     HP-UX `swinstall' 形式   
wininst                  Windows                  (2),(4)
                         用の自己展開形式 ZIP     
                         ファイル                 

注記:
`(1)'
     UNIXでのデフォルト形式です

`(2)'
     Windows でのデフォルト形式です *to-do!*

`(3)'
     外部ユーティリティが必要です: `tar' と、 `gzip' または `bzip2'
     または `compress' のいずれか

`(4)'
     外部ユーティリティの `zip' か、`zipfile' モジュール (Python~1.6
     からは標準 Python ライブラリの一部になって います) が必要です

`(5)'
     外部ユーティリティの `rpm'、バージョン 3.0.4 以上が必要です
     (バージョンを調べるには、 `rpm --version' とします)

`bdist' コマンドを使うとき、必ず `--formats'
オプションを使わなければならないわけではありません;
自分の使いたい形式をダイレクトに実装しているコマンドも使えます。
こうした `bdist' "サブコマンド (sub-command)" は、
実際には類似のいくつかの形式を生成できます; 例えば、 `bdist_dumb'
コマンドは、全ての "ダム" アーカイブ形式 (`tar', `ztar', `gztar',
および `zip') を 作成できますし、`bdist_rpm' はバイナリ RPM とソース
RPM の 両方を生成できます。`bdist' サブコマンドと、それぞれが
生成する形式を以下に示します:
コマンド                             形式
------                               -----
bdist_dumb                           tar, ztar, gztar, zip
bdist_rpm                            rpm, srpm
bdist_wininst                        wininst

`bdist_*' コマンドについては、以下の節で詳しく述べます。

* Menu:

* ダム形式のビルド済み配布物を作成する::
* RPM パッケージを作成する::
* Windows インストーラを作成する::


File: python-dist-jp.info,  Node: ダム形式のビルド済み配布物を作成する,  Next: RPM パッケージを作成する,  Prev: ビルド済み配布物を作成する,  Up: ビルド済み配布物を作成する

5.1 ダム形式のビルド済み配布物を作成する
========================================

*絶対パスと相対パスのパッケージについて述べる必要があるんだけど、
その前に実装しなくちゃね！*


File: python-dist-jp.info,  Node: RPM パッケージを作成する,  Next: Windows インストーラを作成する,  Prev: ダム形式のビルド済み配布物を作成する,  Up: ビルド済み配布物を作成する

5.2 RPM パッケージを作成する
============================

RPM 形式は、Red Hat, SuSE, Mandrake といった、多くの一般的な Linux
ディストリビューションで使われています。普段使っているのがこれらの
環境のいずれか (またはその他の RPM ベースの Linux
ディストリビューション) なら、同じディストリビューションを使っている
他のユーザ用に RPM パッケージを作成するのはとるに足らないことでしょう。
一方、モジュール配布物の複雑さや、 Linux ディストリビューション間の
違いにもよりますが、他の RPM ベースのディストリビューションでも動作
するような RPM を作成できるかもしれません。

通常、モジュール配布物の RPM を作成するには、`bdist_rpm'
コマンドを使います:

     python setup.py bdist_rpm

あるいは、`bdist' コマンドを `--format' オプション付きで使います:

     python setup.py bdist --formats=rpm

前者の場合、 RPM 特有のオプションを指定できます; 後者の場合、
一度の実行で複数の形式を指定できます。両方同時にやりたければ、
それぞれの形式について各コマンドごとにオプション付きで `bdist_*'
コマンドを並べます:

     python setup.py bdist_rpm --packager="John Doe <jdoe@example.org>" \
                     bdist_wininst --target_version="2.0"

Distutils が setup スクリプトで制御されているのとほとんど同じく、 RPM
パッケージの作成は、 `.spec' で制御されています。 RPM
の作成を簡便に解決するため、`bdist_rpm' コマンドでは 通常、 setup
スクリプトに与えた情報とコマンドライン、そして Distutils
設定ファイルに基づいて `.spec' ファイルを作成します。 `.spec'
ファイルの様々なオプションやセクション情報は、 以下のようにして setup
スクリプトから取り出されます:
RPM `.spec'                          Distutils setup
ファイルのオプションまたはセクション スクリプト内のオプション
------                               -----
Name                                 `name'
Summary (preamble 内)                `description'
Version                              `version'
Vendor                               `author' と `author_email', または
                                     \& `maintainer' と
                                     `maintainer_email'
Copyright                            `licence'
Url                                  `url'
%description (セクション)            `long_description'

また、`.spec' ファイル内の多くのオプションは、 setup スクリプト
中に対応するオプションがありません。これらのほとんどは、以下に示す
`bdist_rpm' コマンドのオプションで扱えます:
RPM `.spec'              `bdist_rpm' オプション   デフォルト値
ファイルのオプションまたはセクション                         
------                   -----                    -----
Release                  `release'                "1"
Group                    `group'                  "Development/Libraries"
Vendor                   `vendor'                 (上記参照)
Packager                 `packager'               (none)
Provides                 `provides'               (none)
Requires                 `requires'               (none)
Conflicts                `conflicts'              (none)
Obsoletes                `obsoletes'              (none)
Distribution             `distribution_name'      (none)
BuildRequires            `build_requires'         (none)
Icon                     `icon'                   (none)

言うまでもなく、こうしたオプションをコマンドラインで指定するのは
面倒だし、エラーの元になりますから、普通は `setup.cfg' に
書いておくのがベストです -- ~*Note setup 設定ファイル setup
configuration file を書く:: 節を参照してください。 沢山の Python
モジュール配布物を配布したりパッケージ化したりしている
のなら、配布物全部に当てはまるオプションを個人用の Distutils 設定
ファイル (`~/.pydistutils.cfg') に入れられます。

バイナリ形式の RPM パッケージを作成する際には三つの段階があり、
Distutils はこれら全ての段階を自動的に処理します:
  1. RPM パッケージの内容を記述する `.spec' ファイルを作成します
     (`.spec' ファイルは setup スクリプトに似たファイルです; 実際、
     setup スクリプトのほとんどの情報が `.spec' ファイルから
     引き揚げられます)

  2. ソース RPM を作成します

  3. "バイナリ (binary)" RPM を生成します (モジュール配布物に Python
     拡張モジュールが入っているか否かで、バイナリコードが
     含まれることも含まれないこともあります)

通常、RPM は最後の二つのステップをまとめて行います; Distutils
を使うと、普通は三つのステップ全てをまとめて行います。

望むなら、これらの三つのステップを分割できます。`bdist_rpm' コマンドに
`--spec-only' を指定すれば、単に `.spec' を作成して終了します;
この場合、`.spec' ファイルは "配布物ディレクトリ (distribution
directory)"-- 通常は `dist/' に作成されますが、 `--dist-dir'
オプションで変更することもできます。(通常、 `.spec' ファイルは
"ビルドツリー (build tree)"、すなわち `build_rpm'
が作成する一時ディレクトリの中から引き揚げられます。)


File: python-dist-jp.info,  Node: Windows インストーラを作成する,  Prev: RPM パッケージを作成する,  Up: ビルド済み配布物を作成する

5.3 Windows インストーラを作成する
==================================

実行可能なインストーラは、Windows 環境ではごく自然なバイナリ配布形式
です。インストーラは結構なグラフィカルユーザインタフェースを表示して、
モジュール配布物に関するいくつかの情報を setup スクリプト内のメタデータ
から取り出して示し、ユーザがいくつかのオプションを選んだり、インストール
を決行するか取りやめるか選んだりできるようにします。

メタデータは setup スクリプトから取り出されるので、Windows インストーラ
の作成は至って簡単で、以下を実行するだけです:

     python setup.py bdist_wininst

あるいは、`bdist' コマンドを `--formats' オプション付きで実行します:

     python setup.py bdist --formats=wininst

(pure Python モジュールとパッケージだけの入った) pure モジュール
配布物の場合、作成されるインストーラは実行バージョンに依存しない
形式になり、 `foo-1.0.win32.exe' のような名前になります。 pure
モジュールの Windows インストーラは UNIX や Mac OS
といったプラットフォームでも作成できます。

非 pure 配布物の場合、拡張モジュールは Windows プラットフォーム上
だけで作成でき、Python のバージョンに依存したインストーラになります。
インストーラのファイル名もバージョン依存性を反映して、
`foo-1.0.win32-py2.0.exe' のような形式になります。
従って、サポートしたい全てのバージョンの Python に対して、
別々のインストーラを作成しなければなりません。

インストーラは、ターゲットとなるシステムにインストールを実行 した後、
pure モジュールを通常 (normal) モードと最適化 (optimizing)
モードでコンパイルしようと試みます。何らかの理由があってコンパイル
させたくなければ、`bdist_wininst' コマンドを `--no-target-compile'
かつ/または `--no-target-optimize' オプション付きで実行します。

デフォルトでは、インストーラは実行時にクールな "Python Powered"
ロゴを表示しますが、自作のビットマップ画像も指定できます。 画像は
Windows の `.bmp' ファイル形式でなくてはならず、 `--bitmap'
オプションで指定します。

インストーラを起動すると、デスクトップの背景ウィンドウ上にでっかい
タイトルも表示します。タイトルは配布物の名前とバージョン番号から
作成します。`--title' オプションを使えば、
タイトルを別のテキストに変更できます。

インストーラファイルは "配布物ディレクトリ (distribution directory)" --
通常は `dist/' に作成されますが、`--dist-dir'
オプションで指定することもできます。

* Menu:

* インストール後実行スクリプト postinstallation script::


File: python-dist-jp.info,  Node: インストール後実行スクリプト postinstallation script,  Prev: Windows インストーラを作成する,  Up: Windows インストーラを作成する

5.3.1 インストール後実行スクリプト (postinstallation script)
------------------------------------------------------------

Python 2.3 からは、インストール実行後スクリプトを `--install-script'
オプションで指定できるように
なりました。スクリプトはディレクトリを含まないベースネーム (basename)
で指定しなければならず、スクリプトファイル名は setup 関数の scripts
引数中に挙げられていなければなりません。

指定したスクリプトは、インストール時、ターゲットとなるシステム上で
全てのファイルがコピーされた後に実行されます。このとき `argv[1]' を
`-install' に設定します。また、アンインストール時には、
ファイルを削除する前に `argv[1]' を `-remove' に設定して 実行します。

Windows インストーラでは、インストールスクリプトは埋め込みで実行
され、全ての出力 (`sys.stdout'、 `sys.stderr') はバッファにリダイレクト
され、スクリプトの終了後に GUI 上に表示されます。

インストールスクリプトでは、インストール/アンインストール
のコンテキストで特に有用ないくつかの機能を、追加の組み込み関数として利
用することができます。

`directory_created(path)'

`file_created path'
     これらの関数は、インストール後実行スクリプトがディレクトリやファイル
     を作成した際に呼び出さなければなりません。この関数はアンインストーラ
     に作成されたPATHを登録し、配布物をアンインストールする際にファイルが
     消されるようにします。安全を期すために、ディレクトリは空の時にのみ
     削除されます。

`get_special_folder_path(csidl_string)'
     この関数は、「スタートメニュー」や「デスクトップ」といった、
     Windows における特殊なフォルダ位置を取得する際に使えます。
     この関数はフォルダのフルパスを返します。 CSIDL_STRING は
     以下の文字列のいずれかでなければなりません:

          "CSIDL_APPDATA"

          "CSIDL_COMMON_STARTMENU"
          "CSIDL_STARTMENU"

          "CSIDL_COMMON_DESKTOPDIRECTORY"
          "CSIDL_DESKTOPDIRECTORY"

          "CSIDL_COMMON_STARTUP"
          "CSIDL_STARTUP"

          "CSIDL_COMMON_PROGRAMS"
          "CSIDL_PROGRAMS"

          "CSIDL_FONTS"

     該当するフォルダを取得できなかった場合、 `OSError' が送出されます。

     どの種類のフォルダを取得できるかは、特定の Windows のバージョン
     ごとに異なります。また、おそらく設定によっても異なるでしょう。
     詳細については、 `SHGetSpecialFolderPath()' 関数に関する Microsoft
     の ドキュメントを参照してください。

`create_shortcut(target, description, filename[, arguments[, workdir[, iconpath[, iconindex]]]])'
     この関数はショートカットを作成します。 TARGET
     はショートカットによって起動されるプログラムへのパスです。
     DESCRIPTION はショートカットに対する説明です。 FILENAME
     はユーザから見えるショートカットの名前です。
     コマンドライン引数があれば、ARGUMENTS に指定します。 WORKDIR
     はプログラムの作業ディレクトリです。 ICONPATH
     はショートカットのためのアイコンが入ったファイルで、 ICONINDEX
     はファイル ICONPATH 中のアイコンへのインデクス
     です。これについても、詳しくは`IShellLink' インタフェースに 関する
     Microsoft の ドキュメントを参照してください。


File: python-dist-jp.info,  Node: パッケージインデクスに登録する,  Next: Uploading Packages to the Package Index,  Prev: ビルド済み配布物を作成する,  Up: Top

6 パッケージインデクスに登録する
********************************

Python パッケージインデクス (Python Package Index, PyPI) は、 distutils
でパッケージ化された配布物に関するメタデータを保持
しています。配布物のメタデータをインデクスに提出するには、 Distutils
のコマンド `register' を使います。 `register' は以下のように起動します:

     python setup.py register

Distutils は以下のようなプロンプトを出します:

     running register
     We need to know who you are, so please choose either:
      1. use your existing login,
      2. register as a new user,
      3. have the server generate a new password for you (and email it to you), or
      4. quit
     Your selection [default 1]:

注意: ユーザ名とパスワードをローカルの計算機に保存しておくと、
このメニューは表示されません。

まだ PyPI に登録したことがなければ、まず登録する必要があります。
この場合選択肢 2 番を選び、リクエストされた詳細情報を入力して
ゆきます。詳細情報を提出し終えると、登録情報の承認を行うための
メールを受け取るはずです。

すでに登録を行ったことがあれば、選択肢 1 を選べます。この選択肢を
選ぶと、PyPI ユーザ名とパスワードを入力するよう促され、 `register'
がメタデータをインデクスに自動的に提出します。

配布物の様々なバージョンについて、好きなだけインデクスへの提出
を行ってかまいません。特定のバージョンに関するメタデータを
入れ替えたければ、再度提出を行えば、インデクス上のデータが
更新されます。

PyPI は提出された配布物の (名前、バージョン) の各組み合わせについて
記録を保持しています。ある配布物名について最初に情報を提出したユーザが、
その配布物名のオーナ (owner) になります。オーナは `register'
コマンドか、web インタフェースを介して変更を提出できます。
オーナは他のユーザをオーナやメンテナとして指名できます。
メンテナはパッケージ情報を編集できますが、他の人をオーナやメンテナに
指名することはできません。

デフォルトでは、 PyPI はあるパッケージについて全てのバージョンを
表示します。特定のバージョンを非表示にしたければ、パッケージの Hidden
プロパティを yes に設定します。この値は web インタフェース
で編集しなければなりません。

* Menu:

* pypircファイル pypirc file::


File: python-dist-jp.info,  Node: pypircファイル pypirc file,  Prev: パッケージインデクスに登録する,  Up: パッケージインデクスに登録する

6.1 .pypircファイル (The .pypirc file)
======================================

`.pypirc'ファイルのフォーマットを示します。

     [server-login]
     repository: <repository-url>
     username: <username>
     password: <password>

REPOSITORY は省略可能で、デフォルトでは `http://www.python.org/pypi'
になります。


File: python-dist-jp.info,  Node: Uploading Packages to the Package Index,  Next: 例,  Prev: パッケージインデクスに登録する,  Up: Top

7 Uploading Packages to the Package Index
*****************************************

_Added in Python version 2.5_

Python Package Index (PyPI)
は、パッケージ情報に加えて、作者が望むのであれば
パッケージデータを置くこともできます。 distutils の `upload'
コマンドは配布物をPyPIにアップロードします。

このコマンドは一つ以上の配布物ファイルをビルドした直後に呼び出されます。
例えば、次のコマンド

     python setup.py sdist bdist_wininst upload

は、ソース配布物とWindowsのインストーラをPyPIにアップロードします。
以前に `setup.py' を実行してビルドした配布物もアップロード対象に
なるけれども、アップロードされるのは `upload' コマンドと同時に
指定された配布物だけだということに注意してください。

`upload' コマンドは、`$HOME/.pypirc' ファイル (詳しくは*Note
pypircファイル pypirc file:: セクションを ご覧下さい)
の、ユーザー名、パスワードとリポジトリURLを利用します。

`--sign' オプションで、 アップロードする各ファイルにGPG (GNU Privacy
Guard) を使うことができます。 `gpg' プログラムが 環境変数`PATH'
から実行可能である必要があります。
署名にどの鍵を使うかを、`--identity=NAME' で指定することもできます。

他の `upload' のオプションには、 `--repository=URL' (`$HOME/.pypirc'
で設定されたリポジトリを 上書きします)、 `--show-response'
(アップロードの問題をデバッグするために、PyPI サーバー
からの全てのレスポンスを表示します)　があります。


File: python-dist-jp.info,  Node: 例,  Next: Distutilsの拡張,  Prev: Uploading Packages to the Package Index,  Up: Top

8 例
****

* Menu:

* pure Python 配布物 モジュール形式::
* pure Python 配布物 パッケージ形式::
* 単体の拡張モジュール::


File: python-dist-jp.info,  Node: pure Python 配布物 モジュール形式,  Next: pure Python 配布物 パッケージ形式,  Prev: 例,  Up: 例

8.1 pure Python 配布物 (モジュール形式)
=======================================

単に二つのモジュール、特定のパッケージに属しないモジュールを
配布するだけなら、setup スクリプト中で `py_modules'
オプションを使って個別に指定できます。

もっとも単純なケースでは、二つのファイル: setup スクリプト自体と、
配布したい単一のモジュール、この例では `foo.py' について
考えなければなりません:

     <root>/
             setup.py
             foo.py

(この節の全ての図において、 `<root>' は配布物ルートディレクトリ
を参照します。) この状況を扱うための最小の setup スクリプトは
以下のようになります:

     from distutils.core import setup
     setup(name='foo',
           version='1.0',
           py_modules=['foo'],
           )

配布物の名前は `name' オプションで個々に指定し、配布される
モジュールの一つと配布物を同じ名前にする必要はないことに注意して
ください (とはいえ、この命名方法はよいならわしでしょう)。
ただし、配布物名はファイル名を作成するときに使われるので、
文字、数字、アンダースコア、ハイフンだけで構成しなければなりません。

`py_modules' はリストなので、もちろん複数のモジュールを
指定できます。例えば、モジュール `foo' と `bar' を
配布しようとしているのなら、 setup スクリプトは以下のようになります:

     <root>/
             setup.py
             foo.py
             bar.py

また、セットアップスクリプトは以下のようになります．

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           py_modules=['foo', 'bar'],
           )

モジュールのソースファイルは他のディレクトリに置けますが、
そうしなければならないようなモジュールを沢山持っているのなら、
モジュールを個別に列挙するよりもパッケージを指定した方が 簡単でしょう。


File: python-dist-jp.info,  Node: pure Python 配布物 パッケージ形式,  Next: 単体の拡張モジュール,  Prev: pure Python 配布物 モジュール形式,  Up: 例

8.2 pure Python 配布物 (パッケージ形式)
=======================================

二つ以上のモジュールを配布する場合、とりわけ二つのパッケージに
分かれている場合、おそらく個々のモジュールよりもパッケージ全体を
指定する方が簡単です。たとえモジュールがパッケージ内に入っていなくても
状況は同じで、その場合はルートパッケージにモジュールが入っていると
Distutils に教えることができ、他のパッケージと同様にうまく処理されます
(ただし、`__init__.py' があってはなりません)。

最後の例で挙げた setup スクリプトは、
     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           packages=[''],
           )

のようにも書けます (空文字はルートパッケージを意味します)

これら二つのファイルをサブディレクトリ下に移動しておいて、
インストール先はルートパッケージのままにしておきたい、例えば:

     <root>/
             setup.py
             src/      foo.py
                       bar.py

のような場合には、パッケージ名にはルートパッケージをそのまま
指定しておきますが、ルートパッケージに置くソースファイルが
どこにあるかを Distutils に教えなければなりません:

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           package_dir={'': 'src'},
           packages=[''],
           )

もっと典型的なケースでは、複数のモジュールを同じパッケージ
(またはサブパッケージ) に入れて配布しようと思うでしょう。 例えば、`foo'
と `bar' モジュールがパッケージ `foobar'
に属する場合、ソースツリーをレイアウトする
一案として、以下が考えられます。

     <root>/
             setup.py
             foobar/
                      __init__.py
                      foo.py
                      bar.py

実際、 Distutils ではこれをデフォルトのレイアウトとして想定して
いて、setup スクリプトを書く際にも最小限の作業しか必要ありません:
     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           packages=['foobar'],
           )

モジュールを入れるディレクトリをパッケージの名前にしたくない
場合、ここでも `package_dir' オプションを使う必要があります。
例えば、パッケージ `foobar' のモジュールが `src' に 入っているとします:

     <root>/
             setup.py
             src/
                      __init__.py
                      foo.py
                      bar.py

適切な setup スクリプトは、

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           package_dir={'foobar': 'src'},
           packages=['foobar'],
           )

のようになるでしょう。

また、メインパッケージ内のモジュールを配布物ルート下に
置くことがあるかもしれません:

     <root>/
             setup.py
             __init__.py
             foo.py
             bar.py

この場合、 setup スクリプトは

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           package_dir={'foobar': ''},
           packages=['foobar'],
           )

のようになるでしょう。 (空文字列も現在のディレクトリを表します。)

サブパッケージがある場合、`packages' で
明示的に列挙しなければなりませんが、`package_dir'
はサブパッケージへのパスを自動的に展開します。 (別の言い方をすれば、
Distutils はソースツリーを_走査せず_、 どのディレクトリが Python
パッケージに相当するのかを `__init__.py' files.
を探して調べようとします。)
このようにして、デフォルトのレイアウトはサブパッケージ形式に
展開されます:

     <root>/
             setup.py
             foobar/
                      __init__.py
                      foo.py
                      bar.py
                      subfoo/
                                __init__.py
                                blah.py

対応する setup スクリプトは以下のようになります。

     from distutils.core import setup
     setup(name='foobar',
           version='1.0',
           packages=['foobar', 'foobar.subfoo'],
           )

(ここでも、`package_dir' を空文字列にすると現在のディレクトリ
を表します。)


File: python-dist-jp.info,  Node: 単体の拡張モジュール,  Prev: pure Python 配布物 パッケージ形式,  Up: 例

8.3 単体の拡張モジュール
========================

拡張モジュールは、`ext_modules' オプションを使って指定します。
`package_dir' は、拡張モジュールのソースファイルをどこで
探すかには影響しません; pure Python モジュールのソースのみに影響します。
もっとも単純なケースでは、単一の C ソースファイルで書かれた単一の拡張
モジュールは:

     <root>/
             setup.py
             foo.c

になります。

`foo' 拡張をルートパッケージ下に所属させたい場合、 setup スクリプトは

     from distutils.core import setup
     from distutils.extension import Extension
     setup(name='foobar',
           version='1.0',
           ext_modules=[Extension('foo', ['foo.c'])],
           )

になります。

同じソースツリーレイアウトで、この拡張モジュールを `foopkg'
の下に置き、拡張モジュールの名前を変えるには:

     from distutils.core import setup
     from distutils.extension import Extension
     setup(name='foobar',
           version = '1.0',
           ext_modules=[Extension('foopkg.foo', ['foo.c'])],
           )

のようにします。


File: python-dist-jp.info,  Node: Distutilsの拡張,  Next: リファレンスマニュアル,  Prev: 例,  Up: Top

9 Distutilsの拡張
*****************

Distutilsは様々な方法で拡張できます。 ほとんどの拡張は存在するコマンド
を新しいコマンドで置換する形でおこなわれます。新しいコマンドはたとえば
存在するコマンドを置換して、そのコマンドでパッケージをどう処理するかの
細部を変更することでプラットフォーム特有のパッケージ形式をサポートする
ために書かれているかもしれません

ほとんどのdistutilsの拡張は存在するコマンドを変更したい`setup.py'
スクリプト中で行われます。ほとんどはパッケージにコピーされるファイル拡
張子を`.py'の他に、いくつか追加するものです。

ほとんどのdistutilsのコマンド実装は`distutils.cmd'の
`Command'クラスのサブクラスとして実装されています。
新しいコマンドは`Command'を直接継承し、置換するコマンドでは
置換対象のコマンドのサブクラスにすることで`Command'を間接的に
継承します。コマンドは`Command'から派生したものである必要があり ます。

* Menu:

* 新しいコマンドの統合::
* 配布物の種類を追加する::


File: python-dist-jp.info,  Node: 新しいコマンドの統合,  Next: 配布物の種類を追加する,  Prev: Distutilsの拡張,  Up: Distutilsの拡張

9.1 新しいコマンドの統合
========================

新しいコマンド実装を統合するにはいくつかの方法があります。一番難しいも
のは新機能をdistutils本体に取り込み、それのサポートを提供するPythonの
バージョンが出ることを待つ(そして使う)ことです。これは様々な理由で本当
に難しいことです。

もっとも一般的な、そしておそらくほとんどの場合にもっとも妥当な方法は、
新しい実装をあなたの `setup.py'スクリプトに取り込み、
`distutils.core.setup()' 関数でそれらを使うようにすることです。

     from distutils.command.build_py import build_py as _build_py
     from distutils.core import setup

     class build_py(_build_py):
         """Specialized Python source builder."""

         # implement whatever needs to be different...

     setup(cmdclass={'build_py': build_py},
           ...)

このアプローチは新実装をある特定のパッケージで利用したい時、
そのパッケージに興味をもつ人全員がコマンドの新実装を必要とする時
にもっとも価値があります。

Python 2.4から、 インストールされたPythonを変更せずに、既存の
`setup.py'スクリプト
をサポートするための3つめの選択肢が利用できるようになりました。
これは追加のパッケージングシステムのサポートを追加するサードパーティ拡
張を提供することを想定していますが、
これらのコマンドはdistutilsが利用されている何にでも利用可能です。
新しい設定オプション `command_packages' (コマンドラインオプショ ン
`--command-packages') は、コマンド実装モジュールを検索す
る追加のパッケージを指定するために利用できます。
distutilsの全てのオプショ
ンと同様に、このオプションもコマンドラインまたは設定ファイルで指定できます。
このオプションは設定ファイル中では`[global]'セクションか、コマン
ドラインのコマンドより前でだけ設定できます。
設定ファイル中で指定する場合、コマンドラインで上書きすることができます。
空文字列を指定するとデフォルト値が使われます。これはパッケージと一緒に
提供する設定ファイルでは指定しないでください。

この新オプションによってコマンド実装を探すためのパッケージをいくつでも
追加することができます。複数のパッケージ名はコンマで区切って指定します。
指定がなければ、検索は`distutils.command'パッケージのみで行われ
ます。ただし `setup.py'がオプション `--command-packages'
`distcmds,buildcmds'で実行されている場合には、パッケージは
`distutils.command'、 `distcmds'、そして `buildcmds'
を、この順番で検索します。
新コマンドはコマンドと同じ名前のモジュールに、コマンドと同じ名前のクラ
スで実装されていると想定しています。
上のコマドラインオプションの例では、コマンド `bdist_openpkg'
は、`distcmds.bdist_openpkg.bdist_openpkg'か、
`buildcmds.bdist_openpkg.bdist_openpkg'で実装されるかもしれません。


File: python-dist-jp.info,  Node: 配布物の種類を追加する,  Prev: 新しいコマンドの統合,  Up: Distutilsの拡張

9.2 配布物の種類を追加する
==========================

配布物 (`dist/' ディレクトリの中のファイル) を作成するコマンドは、
`upload' がその配布物をPyPIにアップロードできるように、 `(COMMAND,
FILENAME)' のペアを `self.distributions.dist_files' に
追加する必要があります。 ペア中の FILENAME
はパスに関する情報を持たず、単にファイル名だけを持ちます。 dry-run
モードでも、何が作成されたかを示すために、同じペアが必要になります。


File: python-dist-jp.info,  Node: リファレンスマニュアル,  Next: API リファレンス,  Prev: Distutilsの拡張,  Up: Top

10 リファレンスマニュアル
*************************

* Menu:

* モジュールをインストールする  install コマンド群::
* ソースコード配布物を作成する  sdist command::


File: python-dist-jp.info,  Node: モジュールをインストールする install コマンド群,  Next: ソースコード配布物を作成する sdist command,  Prev: リファレンスマニュアル,  Up: リファレンスマニュアル

10.1 モジュールをインストールする:  `install' コマンド群
========================================================

`install' コマンドは最初にビルドコマンドを実行済みに
しておいてから、サブコマンド `install_lib' を実行します。
`install_data' and `install_scripts'.

* Menu:

* install_data::
* install_scripts::


File: python-dist-jp.info,  Node: install_data,  Next: install_scripts,  Prev: モジュールをインストールする install コマンド群,  Up: モジュールをインストールする install コマンド群

10.1.1 `install_data'
---------------------

このコマンドは配布物中に提供されている全てのデータファイルを
インストールします。


File: python-dist-jp.info,  Node: install_scripts,  Prev: install_data,  Up: モジュールをインストールする install コマンド群

10.1.2 `install_scripts'
------------------------

このコマンドは配布物中の全ての (Python) スクリプトをインストール
します。


File: python-dist-jp.info,  Node: ソースコード配布物を作成する sdist command,  Prev: モジュールをインストールする install コマンド群,  Up: リファレンスマニュアル

10.2 ソースコード配布物を作成する:  `sdist' command
===================================================

*これは上から断片的に移動した文章です: 脈絡を与える必要あり！*

マニフェストテンプレート関連のコマンドを以下に示します:
コマンド                             説明
------                               -----
include PAT1 PAT2 ...                列挙されたパターンのいずれかにマッチする全てのファイルを
                                     対象に含めます
exclude PAT1 PAT2 ...                列挙されたパターンのいずれかにマッチする全てのファイルを
                                     対象から除外します
recursive-include DIR PAT1 PAT2 ...  DIR
                                     下にある、列挙されたパターンのいずれかにマッチ
                                     する全てのファイルを対象に含めます
recursive-exclude DIR PAT1 PAT2 ...  DIR
                                     下にある、列挙されたパターンのいずれかにマッチ
                                     する全てのファイルを対象から除外します
global-include PAT1 PAT2 ...         ソースツリー下にある、列挙されたパターンのいずれかにマッチ
                                     する全てのファイルを対象に含めます
global-exclude PAT1 PAT2 ...         ソースツリー下にある、列挙されたパターンのいずれかにマッチ
                                     する全てのファイルを対象から除外します
prune DIR                            DIR 下の全てのファイルを除外します
graft DIR                            DIR 下の全てのファイルを含めます

ここでいうパターンとは、UNIX式の "glob" パターンです: `*'
は全ての正規なファイル名文字列に一致し、`?' は
正規なファイル名文字一字に一致します。また、 `[RANGE]' は、RANGE の範囲
(例えば、 `a=z'、`a-zA-Z'、 `a-f0-9_.')
内にある、任意の文字にマッチします。 "正規なファイル名文字"
の定義は、プラットフォームごとに特有の ものです: UNIX
ではスラッシュ以外の全ての文字です; Windows
では、バックラッシュとコロン以外です; Mac OS 9 ではコロン以外です。

*Windows はまだサポートされていません*


File: python-dist-jp.info,  Node: API リファレンス,  Next: 日本語訳について,  Prev: リファレンスマニュアル,  Up: Top

11 API リファレンス
*******************

* Menu:

* distutilscore::
* distutilsccompiler::
* distutilsunixccompiler::
* distutilsmsvccompiler::
* distutilsbcppcompiler::
* distutilscygwincompiler::
* distutilsemxccompiler::
* distutilsmwerkscompiler::
* distutilsarchive_util::
* distutilsdep_util::
* distutilsdir_util::
* distutilsfile_util::
* distutilsutil::
* distutilsdist::
* distutilsextension::
* distutilsdebug::
* distutilserrors::
* distutilsfancy_getopt::
* distutilsfilelist::
* distutilslog::
* distutilsspawn::
* distutilssysconfig::
* distutilstext_file::
* distutilsversion::
* distutilscmd::
* distutilscommand::
* distutilscommandbdist::
* distutilscommandbdist_packager::
* distutilscommandbdist_dumb::
* distutilscommandbdist_rpm::
* distutilscommandbdist_wininst::
* distutilscommandsdist::
* distutilscommandbuild::
* distutilscommandbuild_clib::
* distutilscommandbuild_ext::
* distutilscommandbuild_py::
* distutilscommandbuild_scripts::
* distutilscommandclean::
* distutilscommandconfig::
* distutilscommandinstall::
* distutilscommandinstall_data::
* distutilscommandinstall_headers::
* distutilscommandinstall_lib::
* distutilscommandinstall_scripts::
* distutilscommandregister::
* 新しいDistutilsコマンドの作成::


File: python-dist-jp.info,  Node: distutilscore,  Next: distutilsccompiler,  Prev: API リファレンス,  Up: API リファレンス

11.1 Distutils のコア機能
=========================

Distutils のコア機能

Distutilsを使うためにインストールする必要がある唯一のモジュールが
`distutils.core'モジュールです。`setup()'関数
(セットアップスクリプトから呼び出されます)を提供します。間接的に
`distutils.dist.Distribution'クラスと `distutils.cmd.Command'
クラスを提供します。

`setup(arguments)'
     全てを実行する基本的な関数で、Distutilsでできるほとんどのことを実行し
     ます。 XXXXを参照してください。

     setup関数はたくさんの引数をとります。以下のテーブルにまとめます。

     argument name          value                  type
     ------                 -----                  -----
     name                   パッケージの名前       文字列
     version                パッケージのバージョン番号`distutils.version'を参照してください
     description            1行で書いたパッケージ解説文字列
     long_description       パッケージの長い解説   文字列
     author                 パッケージ作者の名前   文字列
     author_email           パッケージ作者のemailアドレス文字列
     maintainer             現在のメンテナの名前(パッケージ作者と異なる場合)文字列
     maintainer_email       現在のメンテナのemailアドレス(パッケージ作者と異なる場合)
     url                    パッケージのURL(ホームページ)URL
     download_url           パッケージダウンロード用URLURL
     packages               distutilsが操作するPythonパッケージのリスト文字列のリスト
     py_modules             distutilsが操作するPythonモジュールのリスト文字列のリスト
     scripts                ビルドおよびインストールする単体スクリプトファイルのリスト文字列のリスト
     ext_modules            ビルドする拡張モジュール`distutils.core.Extension'インスタンスのリスト
     classifiers            パッケージのカテゴリのリスト利用可能なカテゴリ一覧は
                                                   `http://cheeseshop.python.org/pypi?:action=list_classifiers'
                                                   にあります。
     distclass              使用する               `distutils.core.Distribution'のサブクラス
                            `Distribution'クラス   
     script_name            setup.pyスクリプトの名前文字列
                            -                      
                            デフォルトでは`sys.argv[0]'
     script_args            セットアップスクリプトの引数文字列のリスト
     options                セットアップスクリプトのデフォルト引数文字列
     license                パッケージのライセンス 
     keywords               説明用メタデータ。     
                            PEP 314                
                            を参照してください     
     platforms                                     
     cmdclass               コマンド名から         辞書
                            `Command'              
                            サブクラスへのマッピング


`run_setup(script_name[, script_args=`None', stop_after=`'run''])'
     制御された環境でセットアップスクリプトを実行し、いろいろなものを操作する
     `distutils.dist.Distribution'クラスのインスタンスを返します。
     これはディストリビューションのメタデータ(キーワード引数SCRIPTと
     して 関数`setup()'に渡される)を参照したり、設定ファイルやコマ
     ンドラインの内容を調べる時に便利です。

     SCRIPT_NAME は `execfile()'で実行されるファイルです。
     `sys.argv[0]' は、 呼び出しのためにSCRIPT_NAMEと置換されます。
     SCRIPT_ARGS は文字列のリストです。もし提供されていた場合、
     `sys.argv[1:]' は、呼び出しのためにSCRIPT_ARGS で置換されます。

     STOP_AFTER は いつ動作を停止するか関数`setup()' に伝えます。
     とりうる値は:

     値                                 説明
     ------                             -----
     init                               `Distribution'インスタンスを作成し、キーワード引数を
                                        `setup()'に渡したあとに停止する。
     config                             設定ファイルをパーズしたあと停止する(そしてそのデータは
                                        `Distribution'インスタンスに保存される)。
     commandline                        コマンドライン (`sys.argv[1:]'
                                        または SCRIPT_ARGS)
                                        がパーズされたあとに停止する
                                        (そしてそのデータは
                                        `Distribution'インスタンスに保存される)。
     run                                全てのコマンドを実行したあとに停止する(関数
                                        `setup()'
                                        を通常の方法で呼び出した場合と同じ)。
                                        デフォルト値。


これに加えて、`distutils.core'モジュールは他のモジュールにある
いくつかのクラスを公開しています。

   * `Extension' は `distutils.extension' から。

   * `Command' は `distutils.cmd' から。

   * `Distribution' は `distutils.dist' から。

それぞれの簡単な説明を以下に記します。完全な説明についてはそれぞれの
モジュールをごらんください。

`Extension'
     Extension クラスは、セットアップスクリプト中で C または
     C++拡張モジュー
     ルを表します。コンストラクタで以下のキーワード引数をとります。

     argument name          value                  type
     ------                 -----                  -----
     name                   拡張のフルネーム(パッケージを含む)string
                            -- ファイル名やパス    
                            名では_なく_、Pythonのピリオド区切りの名前
     sources                ソースファイル名のリスト。配布物ルートディレクトリstring
                            (setupスクリプトのある場所)
                            からの相対パス、プラットフォーム独立のた
                            め UNIX                
                            形式(スラッシュで区切る)で記述します。ソースファイルは
                            C, C++, SWIG           
                            (.i)、特定プラットフォーム用のリソースファイル、その他
                            `build_ext'コマンドがソースファイルだと認識するどの形式でもありえます。
     include_dirs           C/C++ヘッダファイルを検索するディレクトリのリstring
                            スト(プラットフォーム独立のため
                            UNIX 形式で記述する)   
     define_macros          定義するマクロのリスト;(string,string)
                            それぞれのマクロは     または (name,`None')
                            2要素のタプルで定義されます。'値'には定義しようとしている文字列、のタプル
                            または内容なしで定義する場合は`None'(ソースコード中で
                            `#define               
                            FOO'と書く、または     
                            UNIX                   
                            Cコンパイラのコマンドラインで
                            `-DFOO'                
                            を指定するのと等価です)を指定します。
     undef_macros           定義を消すマクロのリストstring
     library_dirs           リンク時にC/C++ライブラリを検索するディレクトリのリストstring
     libraries              リンクするライブラリ名のリストstring
                            (ファイル名やパスではない)
     runtime_library_dirs   実行時(shared          string
                            extensionでは、拡張が読み
                            込まれる時)に          
                            C/C++ライブラリを探索するディレクトリのリスト
     extra_objects          追加でリンクするファイル('sources'に対応するコーstring
                            ドが含まれていないファイル、バイナリ形式のリソースファイルなど)のリスト
     extra_compile_args     'sources'のソースをコンパイルする時にstring
                            追加するプラットフォーム特有またはコンパイラ特有の情報
                            コマンドラインを利用できるプラットホームとコンパイラでは、これは通常
                            コマンドライン引数のリストですが、他のプラットホームでも、それは何か
                            に使えます。           
     extra_link_args        オブジェクトファイルをリンクして拡張(または新しいPythonインタプstring
                            リタ)を作る時に        
                            追加するプラットフォーム特有またはコンパイラ特有の情報
                            'extra_compile_args'に似た実装です。
     export_symbols         shared                 string
                            extensionからエクスポートされるシンボルのリスト。
                            全てのプラットフォームでは使われず、
                            Python拡張(典型的には  
                            `init' +               
                            extension_name         
                            という1つのシンボル    
                            だけエクスポートする)に一般的に必要なものでもない。
     depends                拡張が依存するファイルのリストstring
     language               拡張の言語 (例:        string
                            `'c'', `'c++'',        
                            `'objc'')。指定しなければソースの拡張子で検出される。


`Distribution'
     `Distribution'はPythonソフトウェアパッケージをどのようにビルド、
     インストール、パッケージするかを定義する。

     `Distribution'のコンストラクタが取りうる
     キーワード引数のリストに関しては、`setup()'関数を見てください。
     `setup()'は`Distribution'のインスタンスを作ります。

`Command'
     `Command'クラス(そのサブクラスのインスタンス)はdistutilsのあるコマン
     ドを実装します。


File: python-dist-jp.info,  Node: distutilsccompiler,  Next: distutilsunixccompiler,  Prev: distutilscore,  Up: API リファレンス

11.2 CCompiler ベースクラス
===========================

抽象 CCompiler class

このモジュールは `CCompiler'クラスの抽象ベースクラスを提供します。
`CCompiler'のインスタンスはプロジェクトにおける全てのコンパイルお
よびリンクに使われます。
コンパイラのオプションを設定するためのメソッドが提供されます -- マク
ロ定義、includeディレクトリ、リンクパス、ライブラリなど。

このモジュールは以下の関数を提供します。

`gen_lib_options(compiler, library_dirs, runtime_library_dirs, libraries)'
     ライブラリを探索するディレクトリ、特定のライブラリとのリンクをするための
     リンカオプションを生成します。 LIBRARIES と LIBRARY_DIRS
     はそれぞれライブラリ名(ファイル
     名ではありません!)のリストと、探索ディレクトリのリストです。
     compilerで利用できるコマンドラインオプションのリスト(指定されたフォーマット文字列に依存します)を返します。

`gen_preprocess_options(macros, include_dirs)'
     Cプリプロセッサオプション(`-D', `-U',
     `-I')を生成します。これらは少なくとも2つのコンパイラで利用可能です。
     典型的な UNIX のコンパイラと、VisualC++です。
     MACROSは1または2要素のタプルで`(NAME,)'はNAMEマクロの削除
     (-U)を意味し、 (NAME,VALUE)はNAMEマクロをVALUEとして
     定義(`-D')します。INCLUDE_DIRSはディレクトリ名のリストで、ヘッダファ
     イルのサーチパスに追加されます(`-I')。 UNIX のコンパイラと、Visual
     C++で利用できるコマンドラインオプショ ンのリストを返します。

`get_default_compiler(osname, platform)'
     指定されたプラットフォームのデフォルトコンパイラを返します。

     問い合わせのOSNAMEはPython標準のOS名(`os.name'で返されるもの)のひとつであるべき
     で、PLATFORMは`sys.platform'で返される共通の値です。

     パラメータが指定されていない場合のデフォルト値は`os.name'と
     `sys.platform'です。

`new_compiler(plat=`None', compiler=`None', verbose=`0', dry_run=`0', force=`0')'
     指定されたプラットフォーム/コンパイラの組み合わせ向けに、
     CCompilerサブクラスのインスタンスを生成するファクトリ関数です。
     PLAT のデフォルト値は `os.name' (例: `'posix'', `'nt''),
     COMPILER)、
     COMPILERのデフォルト値はプラトフォームのデフォルトコンパイラです。
     現在は
     `'posix''と`'nt''だけがサポートされています、デフォルトのコンパイラは
     "traditional UNIX interface"(`UnixCCompiler'クラス) と、 Visual
     C++(`MSVCCompiler' クラス) です。
     WindowsでUNIXコンパイラオブジェクトを要求することも、UNIXでMicrosoft
     コンパイラオブジェクトを要求することも可能です。COMPILER引数を与えると
     PLATは無視されます。

`show_compilers()'
     利用可能なコンパイラのリストを表示します(`build', `build_ext',
     `build_clib'の、`--help-compiler'オプションで使われます。)

`CCompiler([verbose=`0', dry_run=`0', force=`0'])'
     抽象ベースクラス
     `CCompiler'は実際のコンパイラクラスで実装される必要のある
     インタフェースを定義しています。このクラスはコンパイラクラスで利用されるユーティリティメソッドも定義しています。

     コンパイラ抽象クラスの基本的な前提は、各インスタンスはあるプロジェクトを
     ビルドするときの全コンパイル/リンクで利用できるということです。
     そこで、コンパイルとリンクステップで共通する属性 --
     インクルードディレクトリ、マクロ定義、リンクするライブラリ など --
     はコンパイラインスタンスの 属性になります。
     どのように各ファイルが扱われるかを変更できるように、ほとんどの
     属性はコンパイルごと、またはリンクごとに与えることができます。

     各サブクラスのコンストラクタは Compiler
     クラスのインスタンスを作ります。 フラグは
     VERBOSE(冗長な出力を表示します)、
     DRY_RUN(実際にはそのステップを実行しません)、
     そしてFORCE(依存関係を無視して全て再ビルドします)です。
     これらのフラグは全てデフォルト値が`0'(無効)になっています。
     `CCompiler'またはサブクラスを直接インスタンス化したくない場合には、
     かわりに`distutils.CCompiler.new_compiler()'ファクトリ関数を利用してください。

     以下のメソッドで、Compilerクラスのインスタンスが使うコンパイラオプションを手動で変更できます。

    `add_include_dir(dir)'
          DIRをヘッダファイル探索ディレクトリのリストに追加します。
          コンパイラは`add_include_dir()'を呼び出した順にディレクトリを
          探索するよう指定されます。

    `set_include_dirs(dirs)'
          探索されるディレクトリのリストを DIRS
          (文字列のリスト)に設定します。 先に実行された
          `add_include_dir()'は上書きされます。
          後で実行する`add_include_dir()'は`set_include_dirs()'の
          リストにディレクトリを追加します。これはコンパイラがデフォルトで探索する
          標準インクルードディレクトリには影響しません。

    `add_library(libname)'
          LIBNAMEをコンパイラオブジェクトによるリンク時に使われる
          ライブラリのリストに追加します。LIBNAMEはライブラリを含むファイル名ではなく、
          ライブラリそのものの名前です:
          実際のファイル名はリンカ、コンパイラ、または
          コンパイラクラス(プラットフォームに依存します)から推測されます。

          リンカは`add_library()'と`set_library()'
          で渡された順にライブラリをリンクしようとします。ライブラリ名が重なることは
          問題ありません。リンカは指定された回数だけライブラリとリンクしようとします。

    `set_libraries(libnames)'
          コンパイラオブジェクトによるリンク時に使われるライブラリのリストを
          LIBNAMES(文字列のリスト)に設定します。
          これはリンカがデフォルトでリンクする標準のシステムライブラリには影響しません。

    `add_library_dir(dir)'
          `add_library()' と `set_libraries()'で指定された
          ライブラリを探索するディレクトリのリストにDIRを追加します。
          リンカは`add_library_dir()'と `set_library_dirs()'で
          指定された順にディレクトリを探索されます。

    `set_library_dirs(dirs)'
          ライブラリを探索するディレクトリを
          DIRS(文字列のリスト)に設定します。
          これはリンカがデフォルトで探索する標準ライブラリ探索パスには影響しません。

    `add_runtime_library_dir(dir)'
          実行時に共有ライブラリを探索するディレクトリのリストにDIRを追加します。

    `set_runtime_library_dirs(dirs)'
          実行時に共有ライブラリを探索するディレクトリのリストをDIRに設定します。
          これはランタイムリンカがデフォルトで利用する標準探索パスには影響しません。

    `define_macro(name[, value=`None'])'
          このコンパイラオブジェクトで実行される全てのコンパイルで利用される
          プリプロセッサのマクロを定義します。省略可能なパラメータVALUEは
          文字列であるべきです。省略された場合は、マクロは特定の値をとらずに定義され、
          具体的な結果は利用されるコンパイラに依存します。 (XXX 本当に?
          これについてANSIで言及されている?)

    `undefine_macro(name)'
          このコンパイラオブジェクトで実行される全てのコンパイルで利用される
          プリプロセッサのマクロ定義を消します。同じマクロを`define_macro()'で
          定義し、`undefine_macro()'で定義を削除した場合、後で呼び出されたものが
          優先される(複数の再定義と削除を含みます)。
          もしコンパイルごと(すなわち`compile()'の呼び出しごと)にマクロが再定義/削除
          される場合も後で呼び出されたものが優先されます。

    `add_link_object(object)'
          このコンパイラオブジェクトによる全てのリンクで利用される
          オブジェクトファイル(または類似のライブラリファイルや
          "リソースコンパイラ"の出力)のリストにOBJECTを追加します。

    `set_link_objects(objects)'
          このコンパイラオブジェクトによる全てのリンクで利用される
          オブジェクトファイル(または類似のもの)のリストをOBJECTSに設定します。
          これはリンカがデフォルト利用する標準オブジェクトファイル(システムライブラリ
          など)には影響しません。

     以下のメソッドはコンパイラオプションの自動検出を実装しており、 GNU
     `autoconf'に似たいくつかの機能を提供します。

    `detect_language(sources)'
          与えられたファイルまたはファイルのリストの言語を検出します。
          インスタンス属性`language_map'(辞書)と、 `language_order'
          (リスト)を仕事に使います。

    `find_library_file(dirs, lib[, debug=`0'])'
          指定されたディレクトリのリストから、スタティックまたは共有ライブラリファイル
          LIBを探し、そのファイルのフルパスを返します。
          もしDEBUGが真なら、(現在のプラットフォームで意味があれば)デバッグ版を探します。
          指定されたどのディレクトリでも LIB が見つからなければ
          `None'を返します。

    `has_function(funcname [, includes=`None', include_dirs=`None', libraries=`None', library_dirs=`None'])'
          FUNCNAMEが現在のプラットフォームでサポートされているかどうかをブール値で返します。
          省略可能引数は追加のインクルードファイルやパス、
          ライブラリやパスを与えることでコンパイル環境を指定します。

    `library_dir_option(dir)'
          DIRをライブラリ探索ディレクトリに追加する
          コンパイラオプションを返します。

    `library_option(lib)'
          共有ライブラリまたは実行ファイルにリンクされるライブラリ一覧にLIBを追加する
          コンパイラオプションを返します。

    `runtime_library_dir_option(dir)'
          ランタイムライブラリを検索するディレクトリのリストに
          DIRを追加するコンパイラオプションを返します。

    `set_executables(**args)'
          コンパイルのいろいろなステージで実行される実行ファイル(とその引数)を定
          義します。コンパイラクラス(の 'executables'
          属性)によって実行ファイル
          のセットは変わる可能性がありますが、ほとんどは以下のものを持っています:

          attribute                       description
          ------                          -----
          compiler                        C/C++ コンパイラ
          linker_so                       シェアードオブジェクト、ライブラリを作るために使う
                                          リンカ
          linker_exe                      バイナリ実行可能ファイルを作るために使うリンカ
          archiver                        静的ライブラリを作るアーカイバ

          コマンドラインをもつプラットフォーム(UNIX,
          DOS/Windows)では、それぞれ
          の文字列は実行ファイル名と(省略可能な)引数リストに分割されます。(文字
          列の分割は UNIX のシェルが行うものに似ています:
          単語はスペースで区
          切られますが、クォートとバックスラッシュでオーバーライドできます。
          `distutils.util.split_quoted()'をごらんください。)

     以下のメソッドはビルドプロセスのステージを呼び出します。

    `compile(sources[, output_dir=`None', macros=`None', include_dirs=`None', debug=`0', extra_preargs=`None', extra_postargs=`None', depends=`None'])'
          1つ以上のソースファイルをコンパイルします。オブジェクトファイルを生成
          (たとえば `.c' ファイルを `.o'ファイルに変換)します。

          SOURCES はファイル名のリストである必要があります。おそらく
          C/C++
          ファイルですが、実際にはコンパイラとコンパイラクラスで扱えるもの(例:
          `MSVCCompiler'はリソースファイルを SOURCESにとることができ
          ます)なら何でも指定できます。
          SOURCESのソースファイルひとつずつ
          に対応するオブジェクトファイル名のリストを返します。実装に依存しますが、
          全てのソースファイルがコンパイルされる必要はありません。しかし全ての対
          応するオブジェクトファイル名が返ります。

          もし
          OUTPUT_DIRが指定されていれば、オブジェクトファイルはその下
          に、オリジナルのパスを維持した状態で置かれます。 つまり、
          `foo/bar.c'は通常コンパイルされて`foo/bar.o'になります
          (UNIX実装の場合)が、もしOUTPUT_DIRが BUILDであれば、
          `build/foo/bar.o'になります。

          MACROSは(もし指定されていれば)マクロ定義のリストである必要があり
          ます。 マクロ定義は`(NAME,
          VALUE)'という形式の2要素のタプル、または
          `(NAME,)'という形式の1要素のタプルのどちらかです。前者はマクロを定
          義します。もしvalueが`None'であれば、マクロは特定の値をもたないで
          定義されます。1要素のタプルはマクロ定義を削除します。後で実行された定
          義/再定義/削除が優先されます。

          INCLUDE_DIRSは(もし指定されていれば)文字列のリストである必要があ
          ります。このコンパイルだけで有効な、デフォルトのインクルードファイル
          の検索ディレクトリに追加するディレクトリ群を指定します。

          DEBUGはブーリアン値です。もし真なら、コンパイラはデバッグシンボ
          ルをオブジェクトファイルに(または別ファイルに)出力します。

          EXTRA_POSTARGSとEXTRA_POSTARGSは実装依存です。
          コマンドラインをもっているプラットフォーム(例 UNIX,
          DOS/Windows)では、 おそらく文字列のリスト:
          コンパイラのコマンドライン引数の前/後に追加す
          るコマンドライン引数です。他のプラットフォームでは、実装クラスのドキュ
          メントを参照してください。どの場合でも、これらの引数は抽象コンパイラフ
          レームワークが期待に沿わない時の脱出口として意図されています。

          DEPENDSは(もし指定されていれば)ターゲットが依存しているファイル
          名のリストです。ソースファイルが依存しているファイルのどれかより古けれ
          ば、ソースファイルは再コンパイルされます。これは依存関係のトラッキング
          をサポートしていますが、荒い粒度でしか行われません。

          失敗すると`CompileError'を起こします。

    `create_static_lib(objects, output_libname[, output_dir=`None', debug=`0', target_lang=`None'])'
          静的ライブラリファイルを作るために元ファイル群をリンクします。
          「元ファイル群」はOBJECTSで指定されたオブジェクトファイルのリス
          トを基礎にしています。追加のオブジェクトファイルを
          `add_link_object()' および/または `set_link_objects()'
          で指定し、追加のライブラリを`add_library()' および/または
          `set_libraries()'で指定します。そしてLIBRARIESで指定され
          たライブラリです。

          OUTPUT_LIBNAMEはライブラリ名で、ファイル名ではありません;
          ファイ
          ル名はライブラリ名から作られます。OUTPUT_DIRはライブラリファイル
          が起かれるディレクトリです。
          DEBUGはブール値です。真なら、デバッグ情報がライブラリに含まれま
          す(ほとんどのプラットフォームではコンパイルステップで意味をもちます:
          DEBUGフラグは一貫性のためにここにもあります。)。

          TARGET_LANG
          はオブジェクトがコンパイルされる対象になる言語です。
          これはその言語特有のリンク時の処理を可能にします。

          失敗すると `LibError' を起こします。

    `link(target_desc, objects, output_filename[, output_dir=`None', libraries=`None', library_dirs=`None', runtime_library_dirs=`None', export_symbols=`None', debug=`0', extra_preargs=`None', extra_postargs=`None', build_temp=`None', target_lang=`None'])'
          実行ファイルまたは共有ライブラリファイルを作るために元ファイル群をリンクします。

          「元ファイル群」はOBJECTSで指定されたオブジェクトファイルのリス
          トを基礎にしています。OUTPUT_FILENAME はファイル名です。もし
          OUTPUT_DIRが指定されていれば、それに対する相対パスとして
          OUTPUT_FILENAMEは扱われます(必要ならばOUTPUT_FILENAME はディ
          レクトリ名を含むことができます。)。

          LIBRARIESはリンクするライブラリのリストです。
          これはファイル名ではなくライブラリ名で指定します。プラットフォーム依存
          の方式でファイル名に変換されます(例: FOO はUNIX では
          `libfoo.a' に、DOS/Windowsでは `foo.lib' になります。
          )。ただしこれらはディレクト
          リ名を含むことができ、その場合はリンカは通常の場所全体を探すのではなく
          特定のディレクトリを参照します。

          LIBRARY_DIRSはもし指定されるならば、修飾されていない(ディレクト
          リ名を含んでいない)ライブラリ名で指定されたライブラリを探索する
          ディレクトリのリストです。これはシステムのデフォルトより優先され、
          `add_library_dir()' と/または `set_library_dirs()'に渡さ
          れます。RUNTIME_LIBRARY_DIRSは共有ライブラリに埋め込まれるディレ
          クトリのリストで、実行時にそれが依存する共有ライブラリのパスを指定しま
          す(これはUNIXでだけ意味があるかもしれません。)。

          EXPORT_SYMBOLSは共有ライブラリがエクスポートするシンボルのリストです。
          (これはWindowsだけで意味があるようです。)

          DEBUGは `compile()' や `create_static_lib()'と同じですが、
          少しだけ違いがあり、(`create_static_lib()'ではDEBUGフラグ
          は形式をあわせるために存在していたのに対して)ほとんどのプラットフォー
          ムで意識されます。

          EXTRA_PREARGS と EXTRA_POSTARGS は `compile()'
          と同じですが、コンパイラではなくリンカへの引数として扱われます。

          TARGET_LANGは指定されたオブジェクトがコンパイルされた対象言語で
          す。リンク時に言語特有の処理を行えるようにします。

          失敗すると `LinkError' が起きます。

    `link_executable(objects, output_progname[, output_dir=`None', libraries=`None', library_dirs=`None', runtime_library_dirs=`None', debug=`0', extra_preargs=`None', extra_postargs=`None', target_lang=`None'])'
          実行ファイルをリンクします。
          OUTPUT_PROGNAMEは実行ファイルの名前です。OBJECTSはリンクさ
          れるオブジェクトのファイル名のリストです。他の引数は`link'メソッドと同
          じです。

    `link_shared_lib(objects, output_libname[, output_dir=`None', libraries=`None', library_dirs=`None', runtime_library_dirs=`None', export_symbols=`None', debug=`0', extra_preargs=`None', extra_postargs=`None', build_temp=`None', target_lang=`None'])'
          共有ライブラリをリンクします。OUTPUT_LIBNAMEは出力先のライブラリ
          名です。OBJECTSはリンクされるオブジェクトのファイル名のリストで
          す。他の引数は`link'メソッドと同じです。

    `link_shared_object(objects, output_filename[, output_dir=`None', libraries=`None', library_dirs=`None', runtime_library_dirs=`None', export_symbols=`None', debug=`0', extra_preargs=`None', extra_postargs=`None', build_temp=`None', target_lang=`None'])'
          共有オブジェクトをリンクします。OUTPUT_FILENAMEは出力先の共有オ
          ブジェクト名です。OBJECTSはリンクされるオブジェクトのファイル名のリストで
          す。他の引数は`link'メソッドと同じです。

    `preprocess(source[, output_file=`None', macros=`None', include_dirs=`None', extra_preargs=`None', extra_postargs=`None'])'
          SOURCEで指定されたひとつの
          C/C++ソースファイルをプリプロセスします。 出力先のファイルは
          OUTPUT_FILEか、もし OUTPUT_FILEが指定さ れていなければ STDOUT
          になります。 MACROは`compile()'と同様にマクロ定義のリストで、
          `define_macro()' や `undefine_macro()'によって引数になります。
          INCLUDE_DIRSはデフォルトのリストに追加されるディレクトリ名のリス
          トで、`add_include_dir()'と同じ方法で扱われます。

          失敗すると `PreprocessError' が起きます。

     以下のユーティリティメソッドは具体的なサブクラスで使うために、
     `CCompiler'クラスで定義されています。

    `executable_filename(basename[, strip_dir=`0', output_dir=`'''])'
          BASENAMEで指定された実行ファイルのファイル名を返します。
          Windows以外の典型的なプラットフォームではbasenameそのままが、Windowsで
          は `.exe'が追加されたものが返ります。

    `library_filename(libname[, lib_type=`'static'', strip_dir=`0', output_dir=`'''])'
          現在のプラットフォームでのライブラリファイル名を返します。
          UNIXでLIB_TYPEが`'static''の場合、`liblibname.a'の
          形式を返し、LIB_TYPE が `'dynamic'' の場合は
          `liblibname.so'の形式を返します。

    `object_filenames(source_filenames[, strip_dir=`0', output_dir=`'''])'
          指定されたソースファイルに対応するオブジェクトファイル名を返します。
          SOURCE_FILENAMES はファイル名のリストです。

    `shared_object_filename(basename[, strip_dir=`0', output_dir=`'''])'
          BASENAMEに対応する共有オブジェクトファイルのファイル名を返します。

    `execute(func, args[, msg=`None', level=`1'])'
          `distutils.util.execute()'を呼びだします。このメソッドは
          ログを取り、DRY_RUNフラグを考慮にいれて、
          Python関数FUNCに引数ARGSを与えて呼びだします。

    `spawn(cmd)'
          `distutils.util.spawn()'を呼び出します。これは指定したコマン
          ドを実行する外部プロセスを呼び出します。

    `mkpath(name[, mode=`511'])'
          `distutils.dir_util.mkpath()'を呼び出します。これは
          親ディレクトリ込みでディレクトリを作成します。

    `move_file(src, dst)'
          `distutils.file_util.move_file()'を呼び出します。 SRC
          をDSTにリネームします。

    `announce(msg[, level=`1'])'
          `distutils.log.debug()'関数を使ってメッセージを書き出します。

    `warn(msg)'
          警告メッセージMSGを標準エラー出力に書き出します。

    `debug_print(msg)'
          もしこの `CCompiler'インスタンスで DEBUGフラグが指定されて
          いればMSGを標準出力に出力し、そうでなければ何も出力しません。



File: python-dist-jp.info,  Node: distutilsunixccompiler,  Next: distutilsmsvccompiler,  Prev: distutilsccompiler,  Up: API リファレンス

11.3 Unix C コンパイラ
======================

UNIX C Compiler

このモジュールは`UnixCCompiler'クラスを提供します。
`CCompiler'クラスのサブクラスで、典型的なUNIXスタイルのコマン
ドラインCコンパイラを扱います:

   * マクロは `-DNAME[=value]' で定義されます。

   * マクロは `-UNAME' で削除されます。

   * インクルードファイルの探索ディレクトリは `-IDIR'で指定されます。

   * ライブラリは `-lLIB' で指定されます。

   * ライブラリの探索ディレクトリは `-LDIR' で指定されます。

   * コンパイルは `cc' (またはそれに似た) 実行ファイルに、 `-c'
     オプションをつけて実行します:  `.c' を `.o'にコンパイルします。

   * 静的ライブラリは `ar'コマンドで処理されます
     (`ranlib'を使うかもしれません)

   * 共有ライブラリのリンクは `cc' `-shared' で処 理されます。


File: python-dist-jp.info,  Node: distutilsmsvccompiler,  Next: distutilsbcppcompiler,  Prev: distutilsunixccompiler,  Up: API リファレンス

11.4 Microsoft コンパイラ
=========================

Microsoft Compiler このモジュールは `MSVCCompiler'クラスを提供します。
抽象クラス`CCompiler'の具象クラスでMicrosoft Visual Studio向けの
ものです。
一般的に、拡張モジュールはPythonをコンパイルしたのと同じコンパイラでコンパイルする
必要があります。Python 2.3 やそれ以前では、コンパイラはVisual Studio
6でした。 Python 2.4 と Python 2.5 では、コンパイラは Visual Studio
.NET 2003 です。 AMD64 と Itanium バイナリは Platform SDK
を利用して作成されました。

`MSVCCompiler' は大体正しいコンパイラ、リンカその他を選びます。
この選択を上書きするためには、環境変数 DISTUTILS_USE_SDK と MSSDK の
両方を設定する必要があります。 MSSDK は現在の環境をセットアップした
`SetEnv.Cmd' スクリプト、もしくは
環境変数がSDKをインストールした時に登録されたものであることを示します。
DISTUTILS_USE_SDK はdistutilsのユーザーが明示的に `MSVCCompiler'
が選んだ コンパイラを上書きすることを示します。


File: python-dist-jp.info,  Node: distutilsbcppcompiler,  Next: distutilscygwincompiler,  Prev: distutilsmsvccompiler,  Up: API リファレンス

11.5 Borland コンパイラ
=======================

このモジュールは`BorlandCCompiler'クラスを提供します。
抽象クラス`CCompiler'の具象クラスでBorland C++ コンパイラ向けです。


File: python-dist-jp.info,  Node: distutilscygwincompiler,  Next: distutilsemxccompiler,  Prev: distutilsbcppcompiler,  Up: API リファレンス

11.6 Cygwin コンパイラ
======================

このモジュールは`CygwinCCompiler'クラスを提供します。
`UnixCCompiler'のサブクラスで Cygwinに移植されたWindows用の GNU C
コンパイラ向けです。 さらに `Mingw32CCompiler'
クラスを含んでおり、これは mingw32 向けに移植された GCC (cygwinの
no-cygwin モードと同じ)向けです。


File: python-dist-jp.info,  Node: distutilsemxccompiler,  Next: distutilsmwerkscompiler,  Prev: distutilscygwincompiler,  Up: API リファレンス

11.7 OS/2 EMX コンパイラ
========================

OS/2 EMX Compiler support
このモジュールは`EMXCCompiler'クラスを提供します。
`UnixCCompiler'のサブクラスで GNU C コンパイラの  OS/2 向け EMX
ポートを扱います。


File: python-dist-jp.info,  Node: distutilsmwerkscompiler,  Next: distutilsarchive_util,  Prev: distutilsemxccompiler,  Up: API リファレンス

11.8 Metrowerks CodeWarrior サポート
====================================

Metrowerks CodeWarrior support
`MWerksCompiler'クラスを提供します。抽象クラス`CCompiler'
の具象クラスで Mac OS X 以前の Macintosh の MetroWerks
CodeWarrior向けです。 WindowsやMac OS
XのCWをサポートするには作業が必要です。


File: python-dist-jp.info,  Node: distutilsarchive_util,  Next: distutilsdep_util,  Prev: distutilsmwerkscompiler,  Up: API リファレンス

11.9 アーカイブユーティリティ
=============================

Utility functions for creating archive files (tarballs, zip files, ...)

このモジュールはアーカイブファイル(tarやzip)を作成する関数を提供します。

`make_archive(base_name, format[, root_dir=`None', base_dir=`None', verbose=`0', dry_run=`0'])'
     アーカイブファイル(例: `zip'や`tar')を作成します。
     BASE_NAMEは作成するファイル名からフォーマットの拡張子を除いたものです。
     FORMATはアーカイブのフォーマットで`zip'、`tar'、`ztar'、`gztar'の
     いずれかです。
     ROOT_DIRはアーカイブのルートディレクトリになるディレクトリです:
     つまり アーカイブを作成する前にROOT_DIRにCHDIRします。
     BASE_DIRはアーカイブの起点となるディレクトリです: つまりBASE_DIRは
     アーカイブ中の全ファイルおよびディレクトリの前につくディレクトリ名です。
     ROOT_DIR と
     BASE_DIRはともにカレントディレクトリがデフォルト値です。
     アーカイブファイル名を返します。

     _この関数はbz2ファイルを扱えるように変更されるべきです_

`make_tarball(base_name, base_dir[, compress=`'gzip'', verbose=`0', dry_run=`0'])'
     BASE_DIR以下の全ファイルから、tarファイルを作成(オプションで圧縮)します。
     COMPRESSは`'gzip''、`'compress''、`'bzip2''、 または
     `None'である必要があります。`tar'とCOMPRESSで指定された
     圧縮ユーティリティにはパスが通っている必要があるので、これはおそらくUNIX
     だけで有効です。 出力tarファイルは `BASE_DIR.tar'という名前になり、
     圧縮によって拡張子がつきます(`.gz'、 `.bz2' または
     `.Z')。出力ファイル名が返ります。

     _これは`tarfile'モジュールの呼び出しに置換されるべきです。_

`make_zipfile(base_name, base_dir[, verbose=`0', dry_run=`0'])'
     BASE_DIR以下の全ファイルから、zipファイルを作成します。
     出力されるzipファイルはBASE_DIR + `.zip'という名前になります。
     `zipfile'Pythonモジュール(利用可能なら)またはInfoZIP `zip'
     ユーティリティ(インストールされていてパスが通っているなら)を使います。
     もしどちらも利用できなければ、`DistutilsExecError'が起きます。
     出力zipファイル名が返ります。


File: python-dist-jp.info,  Node: distutilsdep_util,  Next: distutilsdir_util,  Prev: distutilsarchive_util,  Up: API リファレンス

11.10 依存関係のチェック
========================

Utility functions for simple dependency checking
このモジュールはシンプルなタイムスタンプを元にしたファイルやファイル群の依存関係を処理する関数を提供します。さらに、それらの依存関係解析を元にした関数を提供します。

`newer(source, target)'
     SOURCEが存在して、TARGETより最近変更されている、または
     SOURCEが存在して、TARGETが存在していない場合は真を返します。
     両方が存在していて、TARGETのほうがSOURCEより新しいか同じ場合には
     偽を返します。 SOURCEが存在しない場合には
     `DistutilsFileError'を起こします。

`newer_pairwise(sources, targets)'
     ふたつのファイル名リストを並列に探索して、それぞれのソースが対応するターゲットより
     新しいかをテストします。`newer()'の意味でターゲットよりソースが新しい
     ペアのリスト(SOURCES,TARGETS)を返します。

`newer_group(sources, target[, missing=`'error''])'
     TARGETがSOURCEにリストアップされたどれかのファイル
     より古ければ真を返します。言い換えれば、TARGETが存在して
     SOURCESの全てより新しいなら偽を返し、そうでなければ真を返します。
     MISSINGはソースファイルが存在しなかった時の振る舞いを決定します。
     デフォルト(`'error'')は `os.stat()' で `OSError'
     例外を起こします。もし`'ignore''なら、単に存在しないソースファイルを無視します。
     もし`'newer''なら、存在しないソースファイルについてはTARGETが古いと
     みなします(これは"dry-tun"モードで便利です:
     入力がないのでコマンドは実行できませんが
     実際に実行しようとしていないので問題になりません)。


File: python-dist-jp.info,  Node: distutilsdir_util,  Next: distutilsfile_util,  Prev: distutilsdep_util,  Up: API リファレンス

11.11 ディレクトリツリーの操作
==============================

Utility functions for operating on directories and directory trees

このモジュールはディレクトリとディレクトリツリーを操作する関数を提供します。

`mkpath(name[, mode=`0777', verbose=`0', dry_run=`0'])'
     ディレクトリと、必要な親ディレクトリを作成します。もしディレクトリが既
     に存在している(NAMEが空文字列の場合、カレントディレクトリ
     を示すのでもちろん存在しています)場合、何もしません。
     ディレクトリを作成できなかった場合(例:
     ディレクトリと同じ名前のファイルが
     既に存在していた)、`DistutilsFileError'を起こします。 もし
     VERBOSEが真なら、それぞれのmkdirについて1行、標準出力に出力
     します。 実際に作成されたディレクトリのリストを返します。

`create_tree(base_dir, files[, mode=`0777', verbose=`0', dry_run=`0'])'
     FILESを置くために必要な空ディレクトリをBASE_DIR以下に作成 します。
     BASE_DIRディレクトリは存在している必要はありません。
     FILESはファイル名のリストでBASE_DIRからの相対パスとして扱
     われます。BASE_DIR + FILESのディレクトリ部分 が(既に存在し
     ていなければ)作成されます。MODE, VERBOSEとDRY_RUNフ
     ラグは`mkpath()'と同じです。

`copy_tree(src, dst[preserve_mode=`1', preserve_times=`1', preserve_symlinks=`0', update=`0', verbose=`0', dry_run=`0'])'
     SRCディレクトリツリー全体をDSTにコピーします。 SRCと
     DSTはどちらもディレクトリ名である必要があります。
     もしSRCがディレクトリでなければ、`DistutilsFileError'
     を起こします。もしDSTが存在しなければ、`mkpath()'で作成され
     ます。実行結果は、SRC以下の全てのファイルがDSTにコピーされ、
     SRC以下の全てのディレクトリがDSTに再帰的にコピーされます。
     コピーされた(またはされるはず)のファイルのリストを返します。返り値は
     UPDATEまたはDRY_RUNに影響されません: SRC
     以下の全ファイルを単にDST以下に改名したリストが返されます。

     PRESERVE_MODE と PRESERVE_TIMES は
     `distutils.file_util'の`copy_file' と同じです:
     通常のファイルには適用されますが、ディレクトリには適用されません。
     もしPRESERVE_SYMLINKS が真なら、シンボリックリンクは(サポートさ
     れているシステムでは)シンボリックリンクとしてコピーされます。そうでな
     ければ(デフォルト)シンボリックリンクは参照されている実体ファイルがコピーされます。
     UPDATE とVERBOSE は`copy_file()'と同じです。

`remove_tree(directory[verbose=`0', dry_run=`0'])'
     再帰的に DIRECTORYとその下の全ファイルを削除します。エラーは無視
     されます(VERBOSEが真の時は`sys.stdout'に出力されます)

*Some of this could be replaced with the shutil module?*


File: python-dist-jp.info,  Node: distutilsfile_util,  Next: distutilsutil,  Prev: distutilsdir_util,  Up: API リファレンス

11.12 1ファイルの操作
=====================

1ファイルを操作するユーティリティ関数

このモジュールはそれぞれのファイルを操作するユーティリティ関数を提供します。

`copy_file(src, dst[preserve_mode=`1', preserve_times=`1', update=`0', link=`None', verbose=`0', dry_run=`0'])'
     ファイルSRCをDSTにコピーします。もしDSTがディレクト
     リなら、SRCはそこへ同じ名前でコピーされます; そうでなければ、
     ファイル名として扱われます。
     (もしファイルが存在するなら、上書きされま す。)
     mosilPRESERVE_MODEが真(デフォルト)なら、ファイルのモード
     (タイプやパーミッション、その他プラットフォームがサポートするもの)もコ
     ピーされます。もし PRESERVE_TIMESが真(デフォルト)なら、最終更新、
     最終アクセス時刻もコピーされます。もしUPDATEが真なら、SRC
     はDSTが存在しない場合か、DSTがSRCより古い時にだけコ ピーします。

     LINKは値を`'hard''または`'sym''に設定することでコピーのかわりに
     ハードリンク(`os.link'を使います)ま
     たはシンボリックリンク(`os.symlink'を使います)を許可します。
     `None'(デフォルト)の時には、ファイルはコピーされます。LINK
     をサポートしていないシステムで有効にしないでください。
     `copy_file()'はハードリンク、シンボリックリンクが可能かチェッ
     クしていません。ファイルの内容をコピーするために
     `_copy_file_contents()'を利用しています。

     `(dest_name, copied)'のタプルを返します: DEST_NAMEは出力ファ
     イルの実際の名前、COPIEDはファイルがコピーされた(DRY_RUNが
     真の時にはコピーされることになった)場合には真です。

`move_file(src, dst[verbose, dry_run])'
     ファイルSRCをDSTに移動します。もしDSTがディレクトリ
     なら、ファイルはそのディレクトリに同じ名前で移動されます。そうでなけれ
     ば、SRCはDSTに単にリネームされます。新しいファイルの名前を
     返します。 _UNIX では
     デバイスをまたがる移動は`copy_file()'を利用して扱っています。
     他のシステムではどうなっている ??? _

`write_file(filename, contents)'
     FILENAME を作成し、CONTENTS(行末文字がない文
     字列のシーケンス)を書き込みます。


File: python-dist-jp.info,  Node: distutilsutil,  Next: distutilsdist,  Prev: distutilsfile_util,  Up: API リファレンス

11.13 その他のユーティリティ関数
================================

その他のユーティリティ関数

このモジュールは他のユーティリティモジュールにあわないものを提供しています。

`get_platform()'
     現在のプラットフォームを示す文字列を返します。
     これはプラットフォーム依存のビルドディレクトリやプラットフォーム依存の
     配布物を区別するために使われます。
     典型的には、('os.uname()'のように)OSの名前とバージョン、アーキテクチャ
     を含みますが、厳密にはOSに依存します。たとえば
     IRIXではアーキテクチャ
     はそれほど重要ではありません(IRIXはSGIのハードウェアだけで動作する)が、
     Linuxではカーネルのバージョンはそれほど重要ではありません。

     返り値の例:
        * `linux-i586'

        * `linux-alpha'

        * `solaris-2.6-sun4u'

        * `irix-5.3'

        * `irix64-6.2'

     POSIX でないプラットフォームでは、今のところ単に`sys.platform'
     が返されます。

`convert_path(pathname)'
     'pathname' をファイルシステムで利用できる名前にして返します。
     すなわち、'/'で分割し、現在のディレクトリセパレータで接続しなおします。
     セットアップスクリプト中のファイル名はUNIXスタイルで提供され、実
     際に利用する前に変換する必要があるため、この関数が必要になります。
     もし PATHNAME の最初または最後が スラッシュの場合、UNIX的でな
     いシステムでは`ValueError'が起きます。

`change_root(new_root, pathname)'
     PATHNAMEの前にNEW_ROOTを追加したものを返します。
     もしPATHNAMEが相対パスなら、
     `os.path.join(new_root,pathname)'と等価です。そうでなければ、
     PATHNAMEを相対パスに変換したあと接続します。これはDOS/Windows
     ではトリッキーな作業になります。

`check_environ()'
     'os.environ'に、ユーザがconfigファイル、コマンドラインオプションなどで
     利用できることを保証している環境変数があることを確認します。
     現在は以下のものが含まれています:
        * `HOME' - ユーザのホームディレクトリ (UNIX のみ)

        * `PLAT' - ハードウェアとOSを含む現在のプラットフォームの説
          明。 ( `get_platform()'を参照)


`subst_vars(s, local_vars)'
     shell/Perlスタイルの変数置換をSについて行います。
     全ての`$'に名前が続いたものは変数とみなされ、辞書LOCAL_VARSで
     みつかった値に置換されます。LOCAL_VARSで見つからなかった場合には
     `os.environ'で置換されます。
     OS.ENVIRONは最初にある値を含んでいることをチェックされます:
     `check_environ()'を参照。 LOCAL_VARS or
     `os.environ'のどちらにも値が見つからなかった
     場合、`ValueError'を起こします。

     これは完全な文字列挿入関数ではないことに注意してください。
     `$variable'の名前には大小英字、数字、アンダーバーだけを含むこと
     ができます。 { } や ( ) を使った引用形式は利用できません。

`grok_environment_error(exc[, prefix=`'error: ''])'
     例外オブジェクト `EnvironmentError' (`IOError' ま たは `OSError')
     から、エラーメッセージを生成します。 Python 1.5.1
     またはそれ以降の形式を扱い、ファイル名を含んでいない例外
     オブジェクトも扱います。このような状況はエラーが2つのファイルに関係す
     る操作、たとえば`rename()'や`link()'で発生します。
     PREFIXをプレフィクスに持つエラーメッセージを返します。

`split_quoted(s)'
     文字列をUNIXのシェルのようなルール(引用符やバックスラッシュの扱い)で分
     割します。つまり、バックスラッシュでエスケープされるか、引用符で囲まれ
     ていなければ各語はスペースで区切られます。一重引用符と二重引用符は同じ
     意味です。引用符もバックスラッシュでエスケープできます。
     2文字でのエスケープシーケンスに使われているバックスラッシュは削除され、
     エスケープされていた文字だけが残ります。引用符は文字列から削除されます。
     語のリストが返ります。

`execute(func, args[, msg=`None', verbose=`0', dry_run=`0'])'
     外部に影響するいくつかのアクション(たとえば、ファイルシステムへの書き
     込み)を実行します。そのようなアクションはDRY_RUNフラグで無効にす
     る必要があるので特別です。この関数はその繁雑な処理を行います。
     関数と引数のタプル、(実行する「アクション」をはっきりさせるための)表示
     に使われる任意のメッセージを渡してください。

`strtobool(val)'
     真偽値をあらわす文字列を真(1)または偽(0)に変換します。

     真の値は `y', `yes', `t', `true', `on' そして `1'です。偽の値は
     `n', `no', `f', `false', `off' そして `0'です。
     VALが上のどれでもない時は `ValueError'を起こします。

`byte_compile(py_files[, optimize=`0', force=`0', prefix=`None', base_dir=`None', verbose=`1', dry_run=`0', direct=`None'])'
     Pythonソースファイル群をバイトコンパイルして`.pyc'または
     `.pyo'ファイルを同じディレクトリに作成します。PY_FILESはコ
     ンパイルされるファイルのリストです。`.py'でおわっていないファイル
     はスキップされます。OPTIMIZEは以下のどれかです:
        * `0' - 最適化しない (`.pyc'ファイルを作成します)

        * `1' - 通常の最適化 (`python -O'のように)

        * `2' - さらに最適化 (`python -OO'のように)

     もしFORCEが真なら、全てのファイルがタイムスタンプに関係なく再コ
     ンパイルされます。

     バイトコードファイルにエンコードされるソースファイル名は、デフォルトでは
     PY_FILESが使われます。これをPREFIXとBASE_DIRで変更す
     ることができます。
     PREFIXはそれぞれのソースファイル名から削除される文字列で、
     BASE_DIRは(PREFIXを削除したあと)先頭に追加されるディレクト
     リ名です。
     任意にPREFIXとBASE_DIRのどちらか、両方を与える(与えない)こ
     とができます。

     もしDRY_RUNが真なら、ファイルシステムに影響することは何もされません。

     バイトコンパイルは現在のインタプリタプロセスによって標準の
     `py_compile'モジュールを使って直接行われるか、テンポラリスクリ
     プトを書いて間接的に行われます。
     通常は`byte_compile()'に直接かそうでないかをまかせます
     (詳細についてはソースをごらんください)。
     DIRECTフラグは関節モードで作成されたスクリプトで使用されます。
     何をやっているか理解していない時は`None'のままにしておいてください。

`rfc822_escape(header)'
     RFC 822 ヘッダに含められるよう加工したHEADERを返します。
     改行のあとには8つのスペースが追加されます。この関数は文字列に他の変更
     はしません。


File: python-dist-jp.info,  Node: distutilsdist,  Next: distutilsextension,  Prev: distutilsutil,  Up: API リファレンス

11.14 Distribution クラス
=========================

構築/インストール/配布 される配布物を表す Distribution
クラスを提供します。

このモジュールは`Distribution'クラスを提供します。これは
構築/インストール/配布される配布物をあらわします。


File: python-dist-jp.info,  Node: distutilsextension,  Next: distutilsdebug,  Prev: distutilsdist,  Up: API リファレンス

11.15 Extension クラス
======================

セットアップスクリプトでC/C++ 拡張モジュール をあら わす Extension
クラスを提供します。

このモジュールは`Extension'クラスを提供します。
C/C++拡張モジュールをセットアップスクリプトで表すために使われます。


File: python-dist-jp.info,  Node: distutilsdebug,  Next: distutilserrors,  Prev: distutilsextension,  Up: API リファレンス

11.16 Distutils デバッグモード
==============================

distutilsのデバッグフラグを提供します。

このモジュールはDEBUGフラグを提供します。


File: python-dist-jp.info,  Node: distutilserrors,  Next: distutilsfancy_getopt,  Prev: distutilsdebug,  Up: API リファレンス

11.17 Distutils 例外
====================

distutils の標準的な例外を提供します。

distutilsのモジュールで使用される例外を提供します。
distutilsのモジュールは標準的な例外を起こします。特に、 SystemExit は
エンドユーザによる失敗(コマンドライン引数の間違いなど)で起きます。

このモジュールは`from ... import *'で安全に使用することができます。
このモジュールは`Distutils'ではじまり、`Error'で終わるシンボ
ルしかexportしません。


File: python-dist-jp.info,  Node: distutilsfancy_getopt,  Next: distutilsfilelist,  Prev: distutilserrors,  Up: API リファレンス

11.18 標準 getopt モジュールのラッパ
====================================

`getopt' 追加機能

このモジュールは以下の機能を標準の`getopt'モジュールに追加する
ラッパを提供します:

   * 短いオプションと長いオプションを関連づけます

   * オプションはヘルプ文字列を持ちます。可能性としては
     `fancy_getopt'に完全な利用方法サマリを作らせることができま す。

   * オプションは渡されたオブジェクトの属性を設定します。

   * 真偽値をとるオプションは "負のエイリアス" を持ちます。-- たと えば
     `--quiet' の "負のエイリアス" が
     `--verbose'の場合、コマンドラインで `--quiet'を
     指定するとVERBOSEは偽になります。

*Should be replaced with `optik' (which is also now known as `optparse'
in Python 2.3 and later).*

`fancy_getopt(options, negative_opt, object, args)'
     ラッパ関数。OPTIONSは`FancyGetopt'のコンストラ
     クタで説明されている`(long_option, short_option, help_string)'
     の3要素タプルのリストです。 NEGATIVE_OPT
     はオプション名からオプション名のマッピングになって
     いる辞書で、キー、値のどちらもOPTIONSリストに含まれている必要が
     あります。 OBJECTは値を保存するオブジェクト(`FancyGetopt'クラスの
     `getopt()'メソッドを参照してください)です。
     ARGSは引数のリストです。ARGSとして`None'を渡すと、
     `sys.argv[1:]'が使われます。

`wrap_text(text, width)'
     TEXTをWIDTH以下の幅で折り返します。

     _ `textwrap' で置き換えられるべき ( Python 2.3 以降で利 用可能)。_

`FancyGetopt([option_table=`None'])'
     option_table は 3つ組タプルのリストです。`(long_option,
     short_option, help_string)'

     もしオプションが引数を持つなら、LONG_OPTIONに`'=''を追加する
     必要があります。SHORT_OPTIONは一文字のみで、`':''はどの場合
     にも不要です。LONG_OPTION に対応するSHORT_OPTIONがない場合、
     SHORT_OPTIONは`None'にしてください。
     全てのオプションタプルは長い形式のオプションを持つ必要があります。

`FancyGetopt'クラスは以下のメソッドを提供します:

`getopt([args=`None', object=`None'])'
     argsのコマンドラインオプションを解析します。OBJECTに属性として保
     存します。

     もしARGSが`None'もしくは与えられない場合には、
     `sys.argv[1:]'を使います。
     もしOBJECTが`None'もしくは与えられない場合には、 新しく
     `OptionDummy'インスタンスを作成し、オプションの値を保存したのち
     `(args, object)'のタプルを返します。
     もしOBJECTが提供されていれば、その場で変更され、
     `getopt()'はARGSのみを返します。どちらのケースでも、
     返されたARGSは渡されたARGSリスト(これは変更されません)の変
     更されたコピーです。

`get_option_order()'
     直前に実行された`getopt()'が処理した`(option, value)'タプ
     ルのリストを返します。`getopt()'がまだ呼ばれていない場合には
     `RuntimeError'を起こします。

`generate_help([header=`None'])'
     この `FancyGetopt'オブジェクトのオプションテーブルから
     ヘルプテキスト(出力の一行に対応する文字列のリスト)を生成します。

     もし与えられていれば、HEADERをヘルプの先頭に出力します。


File: python-dist-jp.info,  Node: distutilsfilelist,  Next: distutilslog,  Prev: distutilsfancy_getopt,  Up: API リファレンス

11.19 FileList クラス
=====================

ファイルシステムを見て、ファイルのリストを構築するために使われる
`FileList' クラス

このモジュールはファイルシステムを見て、ファイルのリストを構築するために使われる
`FileList' クラスを提供します。


File: python-dist-jp.info,  Node: distutilslog,  Next: distutilsspawn,  Prev: distutilsfilelist,  Up: API リファレンス

11.20 シンプルな PEP 282 スタイルのロギ ング
============================================

シンプルなPEP 282 スタイルのロギングメカニズム

_標準の`logging' モジュールに置き換えられるべき_


File: python-dist-jp.info,  Node: distutilsspawn,  Next: distutilssysconfig,  Prev: distutilslog,  Up: API リファレンス

11.21 サブプロセスの生成
========================

spawn() 関数を提供

このモジュールは`spawn()'関数を提供します。これは様々なプラッ
トフォーム依存の他プログラムをサブプロセスとして実行する関数に対するフ
ロントエンドになっています。
与えられた実行ファイルの名前からパスを探索する
`find_executable()'関数も提供しています。


File: python-dist-jp.info,  Node: distutilssysconfig,  Next: distutilstext_file,  Prev: distutilsspawn,  Up: API リファレンス

11.22 システム設定情報
======================

Python インタプリタの設定情報に対する低水準の アクセス手段。

`distutils.sysconfig' モジュールでは、 Python の低水準の
設定情報へのアクセス手段を提供しています。
どの設定情報変数にアクセスできるかは、プラットフォームと設定自体に
大きく左右されます。また、特定の変数は、使っている Python の
バージョンに対するビルドプロセスに左右されます; こうした変数は、 UNIX
システムでは、`Makefile' や Python と一緒にインストール
される設定ヘッダから探し出されます。 設定ファイルのヘッダは、2.2
以降のバージョンでは `pyconfig.h' 、それ以前のバージョンでは `config.h'
です。

他にも、`distutils' パッケージの別の部分を操作
する上で便利な関数がいくつか提供されています。

`PREFIX'
     `os.path.normpath(sys.prefix)' の結果です。

`EXEC_PREFIX'
     `os.path.normpath(sys.exec_prefix)' の結果です。

`get_config_var(name)'
     ある一つの設定変数に対する値を返します。
     `get_config_vars().get(NAME)' と同じです。

`get_config_vars(...)'
     定義されている変数のセットを返します。引数を指定しなければ、
     設定変数名を変数の値に対応付けるマップ型を返します。
     引数を指定する場合、引数の各値は文字列でなければならず、戻り値は
     引数に関連付けられた各設定変数の値からなるシーケンスになります。
     引数に指定した名前の設定変数に値がない場合、その変数値には `None'
     が入ります。

`get_config_h_filename()'
     設定ヘッダのフルパス名を返します。 UNIXの場合、このヘッダファイルは
     `configure' スクリプトによって生成されるヘッダファイル名です;
     他のプラットフォームでは、ヘッダは Python ソース配布物中で直接
     与えられています。ファイルはプラットフォーム固有のテキストファイル
     です。

`get_makefile_filename()'
     Python をビルドする際に用いる `Makefile' のフルパスを返します。
     UNIXの場合、このファイルは `configure' スクリプトによって
     生成されます; 他のプラットフォームでは、この関数の返す値の
     意味は様々です。有意なファイル名を返す場合、ファイルは
     プラットフォーム固有のテキストファイル形式です。 この関数は POSIX
     プラットフォームでのみ有用です。

`get_python_inc([plat_specific[, prefix]])'
     C
     インクルードファイルディレクトリについて、一般的なディレクトリ名か、
     プラットフォーム依存のディレクトリ名のいずれかを返します。
     PLAT_SPECIFIC が真であれば、プラットフォーム依存の
     インクルードディレクトリ名を返します; PLAT_SPECIFIC が偽か、
     省略された場合には、プラットフォームに依存しないディレクトリを
     返します。 PREFIX が指定されていれば、`PREFIX'
     の代わりに用いられます。また、 PLAT_SPECIFIC が真の場合、
     `EXEC_PREFIX' の代わりに用いられます。

`get_python_lib([plat_specific[, standard_lib[, prefix]]])'
     ライブラリディレクトリについて、一般的なディレクトリ名か、
     プラットフォーム依存のディレクトリ名のいずれかを返します。
     PLAT_SPECIFIC が真であれば、プラットフォーム依存の
     ライブラリディレクトリ名を返します; PLAT_SPECIFIC が偽か、
     省略された場合には、プラットフォームに依存しないディレクトリを
     返します。PREFIX が指定されていれば、`PREFIX'
     の代わりに用いられます。また、 PLAT_SPECIFIC が真の場合、
     `EXEC_PREFIX' の代わりに用いられます。 STANDARD_LIB
     が真であれば、サードパーティ製の拡張モジュール
     をインストールするディレクトリの代わりに、標準ライブラリのディレクトリ
     を返します。

以下の関数は、`distutils' パッケージ内の使用だけを 前提にしています。

`customize_compiler(compiler)'
     `distutils.ccompiler.CCompiler' インスタンスに対して、
     プラットフォーム固有のカスタマイズを行います。

     この関数は現在のところ、UNIX だけで必要ですが、将来の互換性を
     考慮して一貫して常に呼び出されます。この関数は様々な UNIX の
     変種ごとに異なる情報や、Python の`Makefile' に書かれた情報
     をインスタンスに挿入します。この情報には、選択されたコンパイラや
     コンパイラ/リンカのオプション、そして共有オブジェクトを扱うために
     リンカに指定する拡張子が含まれます。

この関数はもっと特殊用途向けで、Python 自体のビルドプロセスで
しか使われません。

`set_python_build()'
     `distutils.sysconfig' モジュールに、モジュールが Python の
     ビルドプロセスの一部として使われることを知らせます。これによって、
     ファイルコピー先を示す相対位置が大幅に変更され、インストール済みの
     Python ではなく、ビルド作業領域にファイルが置かれるようになります。


File: python-dist-jp.info,  Node: distutilstext_file,  Next: distutilsversion,  Prev: distutilssysconfig,  Up: API リファレンス

11.23 TextFile クラス
=====================

テキストファイルへのシンプルなインタフェース TextFile
クラスを提供します。

このモジュールは `TextFile'クラスを提供します。これはテキストファイル
へのインタフェースを提供し、コメントの削除、空行の無視、バックスラッシュ
での行の連結を任意に行えます。

`TextFile([filename=`None', file=`None', **options])'
     このクラスはファイルのようなオブジェクトを提供します。
     これは行指向のテキストファイルを処理する時に共通して必要となる処理を行
     います: (`#'がコメント文字なら)コメントの削除、空行のスキップ、
     (行末のバックスラッシュでの)改行のエスケープによる行の連結、
     先頭/末尾の空白文字の削除。
     これらは全て独立して任意に設定できます。

     クラスは`warn()'メソッドを提供しており、物理行つきの警告メッセー
     ジを生成することができます。この物理行は論理行が複数の物理行にまたがっ
     ていても大丈夫です。
     また`unreadline()'メソッドが一行先読みを実装するために提供されています。

     `TextFile'のインスタンスはFILENAME、FILE、またはその
     両方をとって作成されます。 両方が `None' の場合 `RuntimeError'
     が起きます。 FILENAMEは文字列、FILEはファイルオブジェク
     ト(または`readline()'と`close()'のメソッドを提供する何か)
     である必要があります。
     `TextFile'が生成する警告メッセージに含めることができるので、
     FILENAMEを与えることが推奨されます、 もしFILEが提供されなければ、
     `TextFile' は組み込みの `open()' を利用して自分で作成します。

     オプションは全て真偽値で、`readline()'で返される値に影響します。

     オプション名           説明                   デフォルト値
     ------                 -----                  -----
     strip_comments         バックスラッシュでエスケープされていない限り、`#'から行末true
                            までと、`#'の先にある空白文字の並びを削除します。
     lstrip_ws              行を返す前に先頭の空白文字の並びを削除します。false
     rstrip_ws              行を返す前に行末の空白文字(改行文字を含みます!)の並びを削除します。true
     skip_blanks            コメントと空白を除いた*あとで*内容がない行をスキップします。true
                            (もし lstrip_ws と     
                            rstrip_ws              
                            がともに偽なら、空白文字だけの行があるか
                            もしれません。これはSKIP_BLANKSが真でない限りスキップされません。)
     join_lines             もしコメントと空白文字を削除したあとで、バックスラッシュが最後の改行文false
                            字でない文字なら、次の行を接続して一つの論理行とします:
                            N行の連続した行がバックスラッシュで終わる場合、N+1
                            行の物理行が1行の論    
                            理行として扱われます。 
     collapse_join          前の行と接続するとき、行頭の空白文字を削除します。`(join_linesfalse
                            and not lstrip_ws)'    
                            の時だけ意味をもちます。

     RSTRIP_WSは行末の改行を削除するので、`readline()'のセマン
     ティクスが組み込みファイルオブジェクトの`readline()'メソッドと
     は変わってしまいます!  特に、 RSTRIP_WS が真で SKIP_BLANKS
     が偽のとき、 `readline()' はファイルの終端で`None'を返し、空文字
     列を返したときは空行(または全て空白文字の行)です。

    `open(filename)'
          新しいファイルFILENAMEを開きます。これはコンストラクタ引数の
          FILEとFILENAMEを上書きします。

    `close()'
          現在のファイルを閉じ、(ファイル名や現在の行番号を含め)現在のファイルに
          ついての情報を全て消します。

    `warn(msg[,line=`None'])'
          標準エラー出力に現在のファイルの論理行に結びついた警告メッセージを出力
          します。
          もし現在の論理行が複数の物理行に対応するなら、警告メッセージは以下のように全体
          を参照します: `"lines 3-5"'。 もし LINE が与えられていれば、
          現在の行番号を上書きします;
          物理行のレンジをあらわすリストまたはタプル、
          もしくはある物理行をあらわす整数のどれでも与えられます。

    `readline()'
          現在のファイル(または`unreadline()'で"unread"を直前に行ってい
          ればバッファ)から論理行を1行読み込んで返します。もしJOIN_LINESオ
          プションが真なら、このメソッドは複数の物理行を読み込んで接続した文字列
          を返します。
          現在の行番号を更新します。そのため`readline()'のあとに
          `warn()'を呼ぶと丁度読んだ行についての警告を出します。
          RSTRIP_WSが真で、STRIP_BLANKSが偽のとき空文字列が返るので、
          ファイルの終端では`None'を返します。

    `readlines()'
          現在のファイルで残っている全ての論理行のリストを読み込んで返します。
          行番号を、ファイルの最後の行に更新します。

    `unreadline(line)'
          LINE(文字列)を次の`readline()'用に、内部バッファにpushし
          ます。行の先読みを必要とするパーサを実装する時に便利です。
          `unreadline'で"unread"された行は`readline'で読み込む際
          に再度処理(空白の除去など)されません。
          もし`unreadlinee'を、`readline'を呼ぶ前に複数回実行する
          と、最後にunreadした行から返されます。



File: python-dist-jp.info,  Node: distutilsversion,  Next: distutilscmd,  Prev: distutilstext_file,  Up: API リファレンス

11.24 バージョン番号クラス
==========================

モジュールのバージョン番号を表すクラスの実装


File: python-dist-jp.info,  Node: distutilscmd,  Next: distutilscommand,  Prev: distutilsversion,  Up: API リファレンス

11.25 Distutils コマンドの抽象クラス
====================================

このモジュールは Command 抽象ベースクラスを提供します。このクラスは
`distutils.command'サブパッケージ中のモジュールでサブクラス
を作るために利用されます。

このモジュールは抽象ベースクラス `Command' を提供します。

`Command(dist)'
     コマンドクラスを定義するための抽象ベースクラス --
     distutilsの「働きバチ」 -- です。 コマンドクラスは OPTIONS
     とよばれるローカル変数を持ったサブルー
     チンと考えることができます。オプションは`initialize_options()'で宣
     言され、`finalize_options()' で定義さ(最終的な値を与えら)れます。
     どちらも全てのコマンドクラスで実装する必要があります。この2つの区別は
     必要です。なぜならオプションの値は外部(コマンドライン、設定ファイルな
     ど)から来るかもしれず、他のオプションに依存しているオプションは
     外部の影響を処理した後で計算される必要があるからです。そのため
     `finalize_options()'が存在します。
     サブルーチンの本体は全ての処理をオプションの値にもとづいて行う
     `run()'メソッドで、これも全てのコマンドクラスで実装される必要があります。

     クラスのコンストラクタは`Distribution'のインスタンスである単一の
     引数DISTをとります。


File: python-dist-jp.info,  Node: distutilscommand,  Next: distutilscommandbdist,  Prev: distutilscmd,  Up: API リファレンス

11.26 Distutils 各コマンド
==========================

このサブパッケージは標準のdistutilsコマンドを提供します。


File: python-dist-jp.info,  Node: distutilscommandbdist,  Next: distutilscommandbdist_packager,  Prev: distutilscommand,  Up: API リファレンス

11.27 バイナリインストーラの構築
================================

パッケージのバイナリインストラーを構築します


File: python-dist-jp.info,  Node: distutilscommandbdist_packager,  Next: distutilscommandbdist_dumb,  Prev: distutilscommandbdist,  Up: API リファレンス

11.28 パッケージの抽象ベースクラス
==================================

パッケージの抽象ベースクラス


File: python-dist-jp.info,  Node: distutilscommandbdist_dumb,  Next: distutilscommandbdist_rpm,  Prev: distutilscommandbdist_packager,  Up: API リファレンス

11.29 "ダム"インストー ラを構築
===============================

"ダム"インストーラ(単純なファイルのアーカイブ)を構築します


File: python-dist-jp.info,  Node: distutilscommandbdist_rpm,  Next: distutilscommandbdist_wininst,  Prev: distutilscommandbdist_dumb,  Up: API リファレンス

11.30 Redhat RPMとSRPM形式 のバイナリディストリビューションを構築
=================================================================

Redhat RPMとSRPM形式のバイナリディストリビューションを構築


File: python-dist-jp.info,  Node: distutilscommandbdist_wininst,  Next: distutilscommandsdist,  Prev: distutilscommandbdist_rpm,  Up: API リファレンス

11.31 Windowsインストー ラの構築
================================

Windows インストーラの構築


File: python-dist-jp.info,  Node: distutilscommandsdist,  Next: distutilscommandbuild,  Prev: distutilscommandbdist_wininst,  Up: API リファレンス

11.32 ソース配布物の構築
========================

ソース配布物の構築


File: python-dist-jp.info,  Node: distutilscommandbuild,  Next: distutilscommandbuild_clib,  Prev: distutilscommandsdist,  Up: API リファレンス

11.33 パッケージ中の全ファイルを 構築
=====================================

パッケージ中の全ファイルのビルド


File: python-dist-jp.info,  Node: distutilscommandbuild_clib,  Next: distutilscommandbuild_ext,  Prev: distutilscommandbuild,  Up: API リファレンス

11.34 パッケージ中のCライブラリを構築
=====================================

パッケージ中のCライブラリを構築


File: python-dist-jp.info,  Node: distutilscommandbuild_ext,  Next: distutilscommandbuild_py,  Prev: distutilscommandbuild_clib,  Up: API リファレンス

11.35 パッケージ中の拡張を構築
==============================

パッケージ中の拡張を構築


File: python-dist-jp.info,  Node: distutilscommandbuild_py,  Next: distutilscommandbuild_scripts,  Prev: distutilscommandbuild_ext,  Up: API リファレンス

11.36 パッケージ中の.py/.pyc ファイルを構築
===========================================

パッケージ中の.py/.pyc ファイルを構築


File: python-dist-jp.info,  Node: distutilscommandbuild_scripts,  Next: distutilscommandclean,  Prev: distutilscommandbuild_py,  Up: API リファレンス

11.37 パッケージ中のスクリプトを構築
====================================

パッケージ中のスクリプトを構築


File: python-dist-jp.info,  Node: distutilscommandclean,  Next: distutilscommandconfig,  Prev: distutilscommandbuild_scripts,  Up: API リファレンス

11.38 パッケージのビルドエリアを消去
====================================

パッケージのビルドエリアを消去


File: python-dist-jp.info,  Node: distutilscommandconfig,  Next: distutilscommandinstall,  Prev: distutilscommandclean,  Up: API リファレンス

11.39 パッケージの設定
======================

パッケージの設定


File: python-dist-jp.info,  Node: distutilscommandinstall,  Next: distutilscommandinstall_data,  Prev: distutilscommandconfig,  Up: API リファレンス

11.40 パッケージのインストー ル
===============================

パッケージのインストール


File: python-dist-jp.info,  Node: distutilscommandinstall_data,  Next: distutilscommandinstall_headers,  Prev: distutilscommandinstall,  Up: API リファレンス

11.41 パッケージ中のデータファイルをインストール
================================================

パッケージ中のデータファイルをインストール


File: python-dist-jp.info,  Node: distutilscommandinstall_headers,  Next: distutilscommandinstall_lib,  Prev: distutilscommandinstall_data,  Up: API リファレンス

11.42 パッケージから C/C++ ヘッダファイルをインストール
=======================================================

パッケージから C/C++ ヘッダファイルをインストール


File: python-dist-jp.info,  Node: distutilscommandinstall_lib,  Next: distutilscommandinstall_scripts,  Prev: distutilscommandinstall_headers,  Up: API リファレンス

11.43 パッケージから ライブラリファイルをインストール
=====================================================

パッケージから ライブラリファイルをインストール


File: python-dist-jp.info,  Node: distutilscommandinstall_scripts,  Next: distutilscommandregister,  Prev: distutilscommandinstall_lib,  Up: API リファレンス

11.44 パッケージから スクリプトファイルをインストール
=====================================================

パッケージから スクリプトファイルをインストール


File: python-dist-jp.info,  Node: distutilscommandregister,  Next: 新しいDistutilsコマンドの作成,  Prev: distutilscommandinstall_scripts,  Up: API リファレンス

11.45 モジュールをPython Package Indexに登録する
================================================

モジュールをPython Package Indexに登録する

`register'コマンドはパッケージをPython Package Index に登録します。
この詳細は PEP 301 に記述されています。


File: python-dist-jp.info,  Node: 新しいDistutilsコマンドの作成,  Prev: distutilscommandregister,  Up: API リファレンス

11.46 新しいDistutilsコマンドの作成
===================================

このセクションではDistutilsの新しいコマンドを作成する手順の概要をしめします。

新しいコマンドは `distutils.command' パッケージ中のモジュールに
作られます。`command_template' というディレクトリにサンプルのテン
プレートがあります。このファイルを実装しようとしているコマンドと同名の
新しいモジュールにコピーしてください。
このモジュールはモジュール(とコマンド)と同じ名前のクラスを実装する必要があります。
そのため、`peel_banana'コマンド(ユーザは `setup.py
peel_banana'と実行できます)を実装する際には、 `command_template'を
`distutils/command/peel_banana.py'にコ
ピーし、`distutils.cmd.Command'のサブクラス `peel_banana'
クラスを実装するように編集してください。

`Command'のサブクラスは以下のメソッドを実装する必要があります。

`initialize_options()'
     このコマンドがサポートする全てのオプションのデフォルト値を設定します。
     これらのデフォルトは他のコマンドやセットアップスクリプト、設定ファイル
     、コマンドラインによって上書きされるかもしれません。
     そのためオプション間の依存関係を記述するには適切な場所ではありません。
     一般的に`initialize_options()'は単に`self.foo = None' のよ
     うな定義だけを行います。

`finalize_options()'
     このコマンドがサポートする全てのオプションの最終的な値を設定します。
     これは可能な限り遅く呼び出されます。つまりコマンドラインや他のコマンド
     によるオプションの代入のあとに呼び出されます。
     そのため、オプション間の依存関係を記述するのに適した場所です。
     もし FOO が BAR に依存しており、かつ まだFOOが
     `initialize_options()'で定義された値のままなら、 FOO
     をBARから代入しても安全です。

`run()'
     コマンドの本体です。実行するべきアクションを実装しています。
     `initialize_options()' で初期化され、他のコマンド
     され、セットアップスクリプト、コマンドライン、設定ファイルでカスタマイ
     ズされ、`finalize_options()'で設定されたオプションがアクションを制御します。
     端末への出力とファイルシステムとのやりとりは全て`run()'が行います。

SUB_COMMANDSは コマンドの"ファミリー"を定式化したものです。 たとえば
`install' は サブコマンド `install_lib'、`install_headers'などの親です。
コマンドファミリーの親は SUB_COMMANDSをクラス属性として持ちます。
2要素のタプル`(command_name, predicate)'のリストで、
COMMAND_NAMEには文字列、PREDICATEには親コマンドのメソッドで、
現在の状況がコマンド実行にふさわしいかどうか判断するものを指定します。
(例えば `install_headers' はインストールするべき Cヘッダファイル
がある時だけ有効です。) もし PREDICATE が None なら、そのコマン
ドは常に有効になります。

SUB_COMMANDS は 通常クラスの最後で定義されます。 これはpredicate は
boundされていないメソッドになるので、全て先に定義されてい
る必要があるためです。

標準的な例は`install' コマンドです。


File: python-dist-jp.info,  Node: 日本語訳について,  Next: Class-Exception-Object Index,  Prev: API リファレンス,  Up: Top

12 日本語訳について
*******************

* Menu:

* このドキュメントについて::
* 翻訳者一覧 敬称略::
* 24 差分翻訳者一覧 敬称略::
* 25 差分翻訳者一覧 敬称略::


File: python-dist-jp.info,  Node: このドキュメントについて,  Next: 翻訳者一覧 敬称略,  Prev: 日本語訳について,  Up: 日本語訳について

12.1 このドキュメントについて
=============================

この文書は、Pythonドキュメント翻訳プロジェクトによる Distributing
Python Modules の日本語訳版です。日本語訳に対する質問や提案などが
ありましたら、Pythonドキュメント翻訳プロジェクトのメーリングリスト

`http://www.python.jp/mailman/listinfo/python-doc-jp'

または、プロジェクトのバグ管理ページ

`http://sourceforge.jp/tracker/?atid=116&group_id=11&func=browse'

までご報告ください。


File: python-dist-jp.info,  Node: 翻訳者一覧 敬称略,  Next: 24 差分翻訳者一覧 敬称略,  Prev: このドキュメントについて,  Up: 日本語訳について

12.2 翻訳者一覧 (敬称略)
========================

Yasushi Masuda <y.masuda at acm.org> (March 12, 2004)


File: python-dist-jp.info,  Node: 24 差分翻訳者一覧 敬称略,  Next: 25 差分翻訳者一覧 敬称略,  Prev: 翻訳者一覧 敬称略,  Up: 日本語訳について

12.3 2.4 差分翻訳者一覧 (敬称略)
================================

Kazuo Moriwaka (May 8, 2006)


File: python-dist-jp.info,  Node: 25 差分翻訳者一覧 敬称略,  Prev: 24 差分翻訳者一覧 敬称略,  Up: 日本語訳について

12.4 2.5 差分翻訳者一覧 (敬称略)
================================

Naoki INADA


File: python-dist-jp.info,  Node: Class-Exception-Object Index,  Next: Function-Method-Variable Index,  Prev: 日本語訳について,  Up: Top

Class, Exception, and Object Index
**********************************

 [index ]
* Menu:

* CCompiler:                             distutilsccompiler.  (line  61)
* Command <1>:                           distutilscmd.        (line  13)
* Command:                               distutilscore.       (line 173)
* Distribution:                          distutilscore.       (line 165)
* Extension:                             distutilscore.       (line 101)
* FancyGetopt:                           distutilsfancy_getopt.
                                                              (line  43)
* TextFile:                              distutilstext_file.  (line  14)


File: python-dist-jp.info,  Node: Function-Method-Variable Index,  Next: Miscellaneous Index,  Prev: Class-Exception-Object Index,  Up: Top

Function, Method, and Variable Index
************************************

 [index ]
* Menu:

* add_include_dir:                       distutilsccompiler.  (line  85)
* add_library:                           distutilsccompiler.  (line  98)
* add_library_dir:                       distutilsccompiler.  (line 114)
* add_link_object:                       distutilsccompiler.  (line 147)
* add_runtime_library_dir:               distutilsccompiler.  (line 125)
* announce:                              distutilsccompiler.  (line 394)
* byte_compile:                          distutilsutil.       (line 105)
* change_root:                           distutilsutil.       (line  43)
* check_environ:                         distutilsutil.       (line  50)
* close:                                 distutilstext_file.  (line  68)
* compile:                               distutilsccompiler.  (line 214)
* convert_path:                          distutilsutil.       (line  35)
* copy_file:                             distutilsfile_util.  (line  11)
* copy_tree:                             distutilsdir_util.   (line  29)
* create_shortcut:                       インストール後実行スクリプト postinstallation script.
                                                              (line  64)
* create_static_lib:                     distutilsccompiler.  (line 265)
* create_tree:                           distutilsdir_util.   (line  21)
* customize_compiler:                    distutilssysconfig.  (line  81)
* debug_print:                           distutilsccompiler.  (line 400)
* define_macro:                          distutilsccompiler.  (line 132)
* detect_language:                       distutilsccompiler.  (line 161)
* directory_created:                     インストール後実行スクリプト postinstallation script.
                                                              (line  26)
* EXEC_PREFIX:                           distutilssysconfig.  (line  25)
* executable_filename:                   distutilsccompiler.  (line 359)
* execute <1>:                           distutilsutil.       (line  91)
* execute:                               distutilsccompiler.  (line 377)
* fancy_getopt:                          distutilsfancy_getopt.
                                                              (line  27)
* file_created:                          インストール後実行スクリプト postinstallation script.
                                                              (line  28)
* finalize_options:                      新しいDistutilsコマンドの作成.
                                                              (line  30)
* find_library_file:                     distutilsccompiler.  (line 166)
* gen_lib_options:                       distutilsccompiler.  (line  17)
* gen_preprocess_options:                distutilsccompiler.  (line  24)
* generate_help:                         distutilsfancy_getopt.
                                                              (line  74)
* get_config_h_filename:                 distutilssysconfig.  (line  40)
* get_config_var:                        distutilssysconfig.  (line  28)
* get_config_vars:                       distutilssysconfig.  (line  32)
* get_default_compiler:                  distutilsccompiler.  (line  34)
* get_makefile_filename:                 distutilssysconfig.  (line  47)
* get_option_order:                      distutilsfancy_getopt.
                                                              (line  69)
* get_platform:                          distutilsutil.       (line  11)
* get_python_inc:                        distutilssysconfig.  (line  55)
* get_python_lib:                        distutilssysconfig.  (line  66)
* get_special_folder_path:               インストール後実行スクリプト postinstallation script.
                                                              (line  35)
* getopt:                                distutilsfancy_getopt.
                                                              (line  55)
* grok_environment_error:                distutilsutil.       (line  74)
* has_function:                          distutilsccompiler.  (line 173)
* initialize_options:                    新しいDistutilsコマンドの作成.
                                                              (line  22)
* library_dir_option:                    distutilsccompiler.  (line 178)
* library_filename:                      distutilsccompiler.  (line 364)
* library_option:                        distutilsccompiler.  (line 182)
* link:                                  distutilsccompiler.  (line 288)
* link_executable:                       distutilsccompiler.  (line 329)
* link_shared_lib:                       distutilsccompiler.  (line 335)
* link_shared_object:                    distutilsccompiler.  (line 340)
* make_archive:                          distutilsarchive_util.
                                                              (line  11)
* make_tarball:                          distutilsarchive_util.
                                                              (line  26)
* make_zipfile:                          distutilsarchive_util.
                                                              (line  37)
* mkpath <1>:                            distutilsdir_util.   (line  11)
* mkpath:                                distutilsccompiler.  (line 386)
* move_file <1>:                         distutilsfile_util.  (line  35)
* move_file:                             distutilsccompiler.  (line 390)
* new_compiler:                          distutilsccompiler.  (line  43)
* newer:                                 distutilsdep_util.   (line  10)
* newer_group:                           distutilsdep_util.   (line  22)
* newer_pairwise:                        distutilsdep_util.   (line  17)
* object_filenames:                      distutilsccompiler.  (line 370)
* open:                                  distutilstext_file.  (line  64)
* PREFIX:                                distutilssysconfig.  (line  22)
* preprocess:                            distutilsccompiler.  (line 345)
* readline:                              distutilstext_file.  (line  81)
* readlines:                             distutilstext_file.  (line  91)
* remove_tree:                           distutilsdir_util.   (line  48)
* rfc822_escape:                         distutilsutil.       (line 138)
* run:                                   新しいDistutilsコマンドの作成.
                                                              (line  39)
* run_setup:                             distutilscore.       (line  57)
* runtime_library_dir_option:            distutilsccompiler.  (line 186)
* set_executables:                       distutilsccompiler.  (line 190)
* set_include_dirs:                      distutilsccompiler.  (line  90)
* set_libraries:                         distutilsccompiler.  (line 109)
* set_library_dirs:                      distutilsccompiler.  (line 120)
* set_link_objects:                      distutilsccompiler.  (line 152)
* set_python_build:                      distutilssysconfig.  (line  95)
* set_runtime_library_dirs:              distutilsccompiler.  (line 128)
* setup:                                 distutilscore.       (line  15)
* shared_object_filename:                distutilsccompiler.  (line 374)
* show_compilers:                        distutilsccompiler.  (line  57)
* spawn:                                 distutilsccompiler.  (line 382)
* split_quoted:                          distutilsutil.       (line  82)
* strtobool:                             distutilsutil.       (line  98)
* subst_vars:                            distutilsutil.       (line  60)
* undefine_macro:                        distutilsccompiler.  (line 139)
* unreadline:                            distutilstext_file.  (line  95)
* warn <1>:                              distutilstext_file.  (line  72)
* warn:                                  distutilsccompiler.  (line 397)
* wrap_text:                             distutilsfancy_getopt.
                                                              (line  38)
* write_file:                            distutilsfile_util.  (line  43)


File: python-dist-jp.info,  Node: Miscellaneous Index,  Prev: Function-Method-Variable Index,  Up: Top

Miscellaneous Index
*******************

 [index ]
* Menu:

* distutils.archive_util:                distutilsarchive_util.
                                                              (line   6)
* distutils.bcppcompiler:                distutilsbcppcompiler.
                                                              (line   6)
* distutils.ccompiler:                   distutilsccompiler.  (line   6)
* distutils.cmd:                         distutilscmd.        (line   6)
* distutils.command:                     distutilscommand.    (line   6)
* distutils.command.bdist:               distutilscommandbdist.
                                                              (line   6)
* distutils.command.bdist_dumb:          distutilscommandbdist_dumb.
                                                              (line   6)
* distutils.command.bdist_packager:      distutilscommandbdist_packager.
                                                              (line   6)
* distutils.command.bdist_rpm:           distutilscommandbdist_rpm.
                                                              (line   6)
* distutils.command.bdist_wininst:       distutilscommandbdist_wininst.
                                                              (line   6)
* distutils.command.build:               distutilscommandbuild.
                                                              (line   6)
* distutils.command.build_clib:          distutilscommandbuild_clib.
                                                              (line   6)
* distutils.command.build_ext:           distutilscommandbuild_ext.
                                                              (line   6)
* distutils.command.build_py:            distutilscommandbuild_py.
                                                              (line   6)
* distutils.command.build_scripts:       distutilscommandbuild_scripts.
                                                              (line   6)
* distutils.command.clean:               distutilscommandclean.
                                                              (line   6)
* distutils.command.config:              distutilscommandconfig.
                                                              (line   6)
* distutils.command.install:             distutilscommandinstall.
                                                              (line   6)
* distutils.command.install_data:        distutilscommandinstall_data.
                                                              (line   6)
* distutils.command.install_headers:     distutilscommandinstall_headers.
                                                              (line   6)
* distutils.command.install_lib:         distutilscommandinstall_lib.
                                                              (line   6)
* distutils.command.install_scripts:     distutilscommandinstall_scripts.
                                                              (line   6)
* distutils.command.register:            distutilscommandregister.
                                                              (line   6)
* distutils.command.sdist:               distutilscommandsdist.
                                                              (line   6)
* distutils.core:                        distutilscore.       (line   6)
* distutils.cygwinccompiler:             distutilscygwincompiler.
                                                              (line   6)
* distutils.debug:                       distutilsdebug.      (line   6)
* distutils.dep_util:                    distutilsdep_util.   (line   6)
* distutils.dir_util:                    distutilsdir_util.   (line   6)
* distutils.dist:                        distutilsdist.       (line   6)
* distutils.emxccompiler:                distutilsemxccompiler.
                                                              (line   6)
* distutils.errors:                      distutilserrors.     (line   6)
* distutils.extension:                   distutilsextension.  (line   6)
* distutils.fancy_getopt:                distutilsfancy_getopt.
                                                              (line   6)
* distutils.file_util:                   distutilsfile_util.  (line   6)
* distutils.filelist:                    distutilsfilelist.   (line   6)
* distutils.log:                         distutilslog.        (line   6)
* distutils.msvccompiler:                distutilsmsvccompiler.
                                                              (line   6)
* distutils.mwerkscompiler:              distutilsmwerkscompiler.
                                                              (line   6)
* distutils.spawn:                       distutilsspawn.      (line   6)
* distutils.sysconfig:                   distutilssysconfig.  (line   6)
* distutils.text_file:                   distutilstext_file.  (line   6)
* distutils.unixccompiler:               distutilsunixccompiler.
                                                              (line   6)
* distutils.util:                        distutilsutil.       (line   6)
* distutils.version:                     distutilsversion.    (line   6)
* PEP 282:                               distutilslog.        (line   6)
* PEP 301:                               distutilscommandregister.
                                                              (line   9)
* PEP 314:                               distutilscore.       (line  47)
* RFC 822:                               distutilsutil.       (line 138)



Tag Table:
Node: Top125
Node: Distutilsの紹介1405
Node: 概念と用語1862
Node: 簡単な例3348
Node: Python 一般の用語7123
Node: Distutils 固有の用語9461
Node: setup スクリプトを書く10839
Node: パッケージを全て列挙する14324
Node: 個々のモジュールを列挙する16907
Node: 拡張モジュールについて記述する17885
Node: 拡張モジュールの名前とパッケージ19911
Node: 拡張モジュールのソースファイル21213
Node: プリプロセッサオプション22680
Node: ライブラリオプション25953
Node: その他の操作27092
Node: パッケージと配布物の関係 Relationships between Distributions and Packages27905
Node: スクリプトをインストールする31112
Node: パッケージデータをインストールする32314
Node: 追加のファイルをインストールする33953
Node: 追加のメタデータ35712
Node: setup スクリプトをデバッグする39998
Node: setup 設定ファイル setup configuration file を書く41056
Ref: setup 設定ファイル setup configuration file を書く-Footnote-146517
Node: ソースコード配布物を作成する46638
Node: 配布するファイルを指定する48490
Node: マニフェスト manifest 関連のオプション53752
Node: ビルド済み配布物を作成する55291
Node: ダム形式のビルド済み配布物を作成する61273
Node: RPM パッケージを作成する61626
Node: Windows インストーラを作成する66473
Node: インストール後実行スクリプト postinstallation script68907
Node: パッケージインデクスに登録する72047
Node: pypircファイル pypirc file74268
Node: Uploading Packages to the Package Index74722
Node: 例76197
Node: pure Python 配布物 モジュール形式76441
Node: pure Python 配布物 パッケージ形式78249
Node: 単体の拡張モジュール82266
Node: Distutilsの拡張83402
Node: 新しいコマンドの統合84407
Node: 配布物の種類を追加する87062
Node: リファレンスマニュアル87597
Node: モジュールをインストールする install コマンド群87880
Node: install_data88388
Node: install_scripts88700
Node: ソースコード配布物を作成する sdist command88954
Node: API リファレンス91090
Node: distutilscore92456
Node: distutilsccompiler101993
Node: distutilsunixccompiler122584
Node: distutilsmsvccompiler123485
Node: distutilsbcppcompiler124555
Node: distutilscygwincompiler124872
Node: distutilsemxccompiler125331
Node: distutilsmwerkscompiler125689
Node: distutilsarchive_util126131
Node: distutilsdep_util128289
Node: distutilsdir_util129921
Node: distutilsfile_util132574
Node: distutilsutil134683
Node: distutilsdist140715
Node: distutilsextension141077
Node: distutilsdebug141454
Node: distutilserrors141727
Node: distutilsfancy_getopt142282
Node: distutilsfilelist145316
Node: distutilslog145688
Node: distutilsspawn145999
Node: distutilssysconfig146445
Node: distutilstext_file150825
Node: distutilsversion155964
Node: distutilscmd156190
Node: distutilscommand157497
Node: distutilscommandbdist157739
Node: distutilscommandbdist_packager157998
Node: distutilscommandbdist_dumb158255
Node: distutilscommandbdist_rpm158540
Node: distutilscommandbdist_wininst158892
Node: distutilscommandsdist159141
Node: distutilscommandbuild159362
Node: distutilscommandbuild_clib159620
Node: distutilscommandbuild_ext159881
Node: distutilscommandbuild_py160124
Node: distutilscommandbuild_scripts160409
Node: distutilscommandclean160669
Node: distutilscommandconfig160927
Node: distutilscommandinstall161137
Node: distutilscommandinstall_data161380
Node: distutilscommandinstall_headers161684
Node: distutilscommandinstall_lib162013
Node: distutilscommandinstall_scripts162339
Node: distutilscommandregister162658
Node: 新しいDistutilsコマンドの作成163073
Node: 日本語訳について165932
Node: このドキュメントについて166218
Node: 翻訳者一覧 敬称略166797
Node: 24 差分翻訳者一覧 敬称略167047
Node: 25 差分翻訳者一覧 敬称略167288
Node: Class-Exception-Object Index167486
Node: Function-Method-Variable Index168294
Node: Miscellaneous Index176650

End Tag Table
