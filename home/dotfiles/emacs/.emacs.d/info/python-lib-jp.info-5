これは python-lib-jp.info、python-lib-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-lib-jp.info,  Node: SQLite と Python の型,  Next: トランザクション制御,  Prev: カーソルオブジェクト,  Up: sqlite3

13.13.4 SQLite と Python の型
-----------------------------

* Menu:

* 入門編::
* 追加された Python の型を SQLite データベースに格納するために適合関数を使う::
* SQLite の値を好きな Python 型に変換する::
* デフォルトの適合関数と変換関数::


File: python-lib-jp.info,  Node: 入門編,  Next: 追加された Python の型を SQLite データベースに格納するために適合関数を使う,  Prev: SQLite と Python の型,  Up: SQLite と Python の型

13.13.4.1 入門編
................

SQLite が最初からサポートしているのは次の型です: NULL, INTEGER, REAL,
TEXT, BLOB。

したがって、次の Python の型は問題なく SQLite に送り込めます:

Python の型                          SQLite の型
------                               -----
None                                 NULL
int                                  INTEGER
long                                 INTEGER
float                                REAL
str (UTF8 エンコード)                TEXT
unicode                              TEXT
buffer                               BLOB

SQLite の型から Python の型へのデフォルトでの変換は以下の通りです:

SQLite の型                          Python の型
------                               -----
NULL                                 None
INTEGER                              int または long (サイズによる)
REAL                                 float
TEXT                                 text_factory
                                     に依存して決まるがデフォルトでは
                                     unicode
BLOB                                 buffer

`sqlite3' モジュールの型システムは二つの方法で拡張できます。一つ
はオブジェクト適合(adaptation)を通じて追加された Python の型を SQLite
に格納することです。もう一つは変換関数(converter)を通じ て `sqlite3'
モジュールに SQLite の型を違った Python の型に変換 させることです。


File: python-lib-jp.info,  Node: 追加された Python の型を SQLite データベースに格納するために適合関数を使う,  Next: SQLite の値を好きな Python 型に変換する,  Prev: 入門編,  Up: SQLite と Python の型

13.13.4.2 追加された Python の型を SQLite データベースに格納するために適合関数を使う
....................................................................................

既に述べたように、SQLite
が最初からサポートする型は限られたものだけです。 それ以外の Python
の型を SQLite で使うには、その型を `sqlite3'
モジュールがサポートしている型の一つに *適合* させなくてはなりま
せん。サポートしている型というのは、NoneType, int, long, float, str,
unicode, buffer です。

`sqlite3' モジュールは PEP 246 に述べられているような Python
オブジェクト適合を用います。使われるプロトコル は `PrepareProtocol'
です。

`sqlite3' モジュールで望みの Python の型をサポートされている型
の一つに適合させる方法は二つあります。

オブジェクト自身で適合するようにする
....................................

自分でクラスを書いているならばこの方法が良いでしょう。次のようなクラス
があるとします:

     class Point(object):
         def __init__(self, x, y):
             self.x, self.y = x, y

さてこの点を SQLite の一つのカラムに収めたいと考えたとしましょう。最初
にしなければならないのはサポートされている型の中から点を表現するのに使
えるものを選ぶことです。ここでは単純に文字列を使うことにして、座標を区
切るのにはセミコロンを使いましょう。次に必要なのはクラスに変換された値
を返す `__conform__(self, protocol)' メソッドを追加することです。 引数
PROTOCOL は `PrepareProtocol' になります。

`sqlite3/adapter_point_1.py'

適合関数を登録する
..................

もう一つの可能性は型を文字列表現に変換する関数を作り `register_adapter'
でその関数を登録することです。

_Notice:_
適合させる型/クラスは新形式クラスでなければなりません。すなわち、`object'
を基底クラスの一つとしていなければなりません。

`sqlite3/adapter_point_2.py'

`sqlite3' モジュールには二つの Python 標準型 `datetime.date' と
`datetime.datetime' に対するデフォルト適合関数があります。いま
`datetime.datetime' オブジェクトを ISO 表現でなく UNIX タイムスタンプ
として格納したいとしましょう。

`sqlite3/adapter_datetime.py'


File: python-lib-jp.info,  Node: SQLite の値を好きな Python 型に変換する,  Next: デフォルトの適合関数と変換関数,  Prev: 追加された Python の型を SQLite データベースに格納するために適合関数を使う,  Up: SQLite と Python の型

13.13.4.3 SQLite の値を好きな Python 型に変換する
.................................................

適合関数を書くことで好きな Python 型を SQLite
に送り込めるようになりました。 しかし、本当に使い物になるようにするには
Python から SQLite さらに Python へという
往還(roundtrip)の変換ができる必要があります。

そこで変換関数(converter)です。

`Point' クラスの例に戻りましょう。x, y
座標をセミコロンで区切った文字列として SQLite に格納したのでした。

まず、文字列を引数として取り `Point'
オブジェクトをそれから構築する変換関数 を定義します。

_Notice:_ 変換関数は SQLite
に送り込んだデータ型に関係なく*常に*文字列を渡されます。

_Notice:_ 変換関数の名前を探す際、大文字と小文字は区別されます。

         def convert_point(s):
             x, y = map(float, s.split(";"))
             return Point(x, y)

次に `sqlite3' モジュールにデータベースから取得したものが本当に点
であることを教えなければなりません。二つの方法があります:

   * 宣言された型を通じて暗黙的に

   * カラム名を通じて明示的に

どちらの方法も*Note
モジュールの関数と定数::節"モジュールの関数と定数"の中で
説明されています。それぞれ `PARSE_DECLTYPES' 定数と `PARSE_COLNAMES'
定数の項目です。

以下の例で両方のアプローチを紹介します。

`sqlite3/converter_point.py'


File: python-lib-jp.info,  Node: デフォルトの適合関数と変換関数,  Prev: SQLite の値を好きな Python 型に変換する,  Up: SQLite と Python の型

13.13.4.4 デフォルトの適合関数と変換関数
........................................

datetime モジュールの date 型および datetime
型のためのデフォルト適合関数 があります。これらの型は ISO 日付 / ISO
タイムスタンプとして SQLite に送られます。

デフォルトの変換関数は `datetime.date' 用が "date" という名前で、
`datetime.datetime' 用が "timestamp" という名前で登録されています。

これにより、多くの場合特別な細工無しに Python の日付 /
タイムスタンプを使えます。 適合関数の書式は実験的な SQLite の date/time
関数とも互換性があります。

以下の例でこのことを確かめます。

`sqlite3/pysqlite_datetime.py'


File: python-lib-jp.info,  Node: トランザクション制御,  Next: pysqlite の効率的な使い方,  Prev: SQLite と Python の型,  Up: sqlite3

13.13.5 トランザクション制御
----------------------------

デフォルトでは、`sqlite3' モジュールはデータ変更言語(DML)文(すなわち
INSERT/UPDATE/DELETE/REPLACE)の前に暗黙のうちにトランザクションを開始し、
非DML、非クエリ文(すなわち SELECT/INSERT/UPDATE/DELETE/REPLACE
のいずれでも ないもの)の前にトランザクションをコミットします。

ですから、もしトランザクション中に `CREATE TABLE ...', `VACUUM',
`PRAGMA' といったコマンドを発行すると、`sqlite3' モジュールはその
コマンドの実行前に暗黙のうちにコミットします。このようにする理由は二つあります。
第一にこうしたコマンドのうちの幾つかはトランザクション中ではうまく動きません。
第二に pysqlite
はトランザクションの状態(トランザクションが掛かっているかどうか)を
追跡する必要があるからです。

pysqlite
が暗黙のうちに実行する"BEGIN"文の種類(またはそういうものを使わないこと)を
`connect' 呼び出しの ISOLATION_LEVEL パラメータを通じて、または 接続の
`isolation_level' プロパティを通じて、制御することができます。

もし*自動コミットモード*が使いたければ、`isolation_level' は None
にしてください。

そうでなければデフォルトのまま"BEGIN"文を使い続けるか、SQLite
がサポートする分離レベル DEFERRED, IMMEDIATE または EXCLUSIVE
を設定してください。

`sqlite' モジュールがトランザクション状態を把握する必要があるの で、SQL
の中で `OR ROLLBACK' や `ON CONFLICT ROLLBACK' を使っ
てはなりません。その代わりに、`IntegrityError' を捕捉して接続
の`rollback' メソッドを自分で呼び出すようにしてください。


File: python-lib-jp.info,  Node: pysqlite の効率的な使い方,  Prev: トランザクション制御,  Up: sqlite3

13.13.6 pysqlite の効率的な使い方
---------------------------------

* Menu:

* ショートカットメソッドを使う::
* 位置ではなく名前でカラムにアクセスする::


File: python-lib-jp.info,  Node: ショートカットメソッドを使う,  Next: 位置ではなく名前でカラムにアクセスする,  Prev: pysqlite の効率的な使い方,  Up: pysqlite の効率的な使い方

13.13.6.1 ショートカットメソッドを使う
......................................

`Connection' オブジェクトの非標準的なメソッド `execute', `executemany',
`executescript' を使うことで、 (しばしば余計な) `Cursor'
オブジェクトをわざわざ作り出さずに済むので、
コードをより簡潔に書くことができます。`Cursor' オブジェクトは暗黙裡に
生成されショートカットメソッドの戻り値として受け取ることができます。この方法を
使えば、 SELECT 文を実行してその結果について反復することが、
`Connection' オブジェクトに対する呼び出し一つで行なえます。

`sqlite3/shortcut_methods.py'


File: python-lib-jp.info,  Node: 位置ではなく名前でカラムにアクセスする,  Prev: ショートカットメソッドを使う,  Up: pysqlite の効率的な使い方

13.13.6.2 位置ではなく名前でカラムにアクセスする
................................................

`sqlite3' モジュールの有用な機能の一つに、行生成関数として使われるための
`sqlite3.Row' クラスがあります。

このクラスでラップされた行は、位置インデクス(タプルのような)でも
大文字小文字を区別しない名前でもアクセスできます:

`sqlite3/rowclass.py'


File: python-lib-jp.info,  Node: 汎用オペレーティングシステムサービス,  Next: オプションのオペレーティングシステムサービス,  Prev: データの永続化,  Up: Top

14 汎用オペレーティングシステムサービス
***************************************

本章に記述されたモジュールは、ファイルの取り扱いや時間計測のような(ほ
ぼ)すべてのオペレーティングシステムで利用可能な機能にインターフェー
スを提供します。これらのインターフェースは、UNIXもしくはCのインター
フェースを基に作られますが、ほとんどの他のシステムで同様に利用可能です。
概要を以下に記述します。

* Menu:

* os::
* time::
* optparse::
* getopt::
* logging::
* getpass::
* curses::
* cursestextpad::
* curseswrapper::
* cursesascii::
* cursespanel::
* platform::
* errno::
* ctypes::


File: python-lib-jp.info,  Node: os,  Next: time,  Prev: 汎用オペレーティングシステムサービス,  Up: 汎用オペレーティングシステムサービス

14.1 雑多なオペレーティングシステムインタフェース
=================================================

雑多なオペレーティングシステムインタフェース。

このモジュールでは、オペレーティングシステム依存の機能を利用する方法
として、`posix' や `nt' といったオペレーティング
システム依存の組み込みモジュールを import するよりも可搬性の高い
手段を提供しています。

このモジュールは、`mac' や `posix' のような、
オペレーティングシステム依存の組み込みモジュールから関数やデータを
検索して、見つかったものを取り出し (export) ます。Python における
組み込みのオペレーティングシステム依存モジュールは、同じ機能を
利用することができる限り、同じインタフェースを使います; たとえば、
`os.stat(PATH)' は PATH についての stat 情報を (たまたま POSIX
インタフェースに起源する) 同じ書式で返します。

特定のオペレーティングシステム固有の拡張も `os' を介して
利用することができますが、これらの利用はもちろん、可搬性を脅かします！

最初の `os' の import 以後、`os' を介した関数の
利用は、オペレーティングシステム依存組み込みモジュールにおける関数の
直接利用に比べてパフォーマンス上のペナルティは _全くありません_。
従って、`os'を利用しない理由は _存在しません_ !

`os' モジュールには多くの関数とデータ値が入っています。
以下の項目と、その後に続くサブセクションは `os' モジュールから
直接利用できます。

`error'
     関数がシステム関連のエラー(引数の型違いや他のありがちなエラーではない)
     を返した場合この例外が発生します。これは `OSError' とし
     て知られる組み込み例外でもあります。付属する値は `errno' から
     とった数値のエラーコードと、エラーコードに対応する、C 関数
     `perror()' により出力されるのと同じ文字列からなるペアです。
     背後のオペレーティングシステムで定義されているエラーコード名が収め
     られている `errno'  を参照してください。

     例外がクラスの場合、この例外は二つの属性、`errno' と `strerror'
     を持ちます。前者の属性は C の `errno' 変数 の値、後者は
     `strerror()' による対応するエラーメッセージ
     の値を持ちます。(`chdir()' や `unlink()' のような)
     ファイルシステム上のパスを含む例外に対しては、この例外インスタンス
     は 3 つめの属性、`filename' を持ち、関数に渡されたファイル名
     となります。

`name'
     import
     されているオペレーティング・システム依存モジュールの名前です。
     現在次の名前が登録されています: `'posix'', `'nt'' 、 `'dos'' 、
     `'mac'' 、 `'os2'' 、 `'ce'' 、 `'java'' 、 `'riscos'' 。


`path'
     `posixpath' や `macpath' のように、システムごとに対応
     付けられているパス名操作のためのシステム依存の標準モジュールです。
     すなわち、正しく import が行われるかぎり、 `os.path.split(FILE)'
     は `posixpath.split(FILE)'
     と等価でありながらより汎用性があります。このモジュール自体が
     import 可能なモジュールでもあるので注意してください。: `os.path'
     として直接 import してもかまいません。


* Menu:

* プロセスのパラメタ::
* ファイルオブジェクトの生成::
* ファイル記述子の操作::
* ファイルとディレクトリ::
* プロセス管理::
* 雑多なシステム情報::
* 雑多な関数::


File: python-lib-jp.info,  Node: プロセスのパラメタ,  Next: ファイルオブジェクトの生成,  Prev: os,  Up: os

14.1.1 プロセスのパラメタ
-------------------------

これらの関数とデータ要素は、現在のプロセスおよびユーザに対する情報
提供および操作のための機能を提供しています。

`environ'
     環境変数の値を表すマップ型オブジェクトです。例えば、
     `environ['HOME']' は( いくつかのプラットフォーム上での) あなたの
     ホームディレクトリへのパスです。これは C の `getenv("HOME")' と
     等価です。

     このマップ型の内容は、`os' モジュールの最初の import の時点、
     通常は Python の起動時に `site.py' が処理される中で取り込まれます。
     それ以後に変更された環境変数は `os.environ' を直接変更しない限り
     反映されません。

     プラットフォーム上で `putenv()' がサポートされている場合、この
     マップ型オブジェクトは環境変数に対するクエリと同様に変更するために使うこ
     ともできます。`putenv()' はマップ型オブジェクトが修正される時に、
     自動的に呼ばれることになります。

     _Note:_ `putenv()' を直接呼び出しても`os.environ' の
     内容は変わらないので、`os.environ'を直接変更する方がベターです。
     _Note:_ FreeBSD と Mac OS X を含むいつくかのプラットフォームでは、
     `environ' の値を変更するとメモリリークの原因になる場合があります。
     システムの `putenv()' に関するドキュメントを参照してください。

     `putenv()' が提供されていない場合、このマッピングオブジェクト
     に変更を加えたコピーを適切なプロセス生成機能に渡して、子プロセスが修正された環境変数
     を利用するようにできます。

     プラットフォームが `unsetenv()' 関数をサポートしているならば、
     このマッピングからアイテムを取り除いて環境変数を取り消すことができます。
     `unsetenv()' は `os.environ' からアイテムが取り除かれた時に
     自動的に呼ばれます。

`chdir(path)'

`getcwd'
     これらの関数は、"ファイルとディレクトリ" (*Note
     ファイルとディレクトリ:: 節) で 説明されています。

`ctermid()'
     プロセスの制御端末に対応するファイル名を返します。 利用できる環境:
     UNIX。

`getegid()'
     現在のプロセスの実行グループ id を返します。この id は
     現在のプロセスで実行されているファイルの `set id' ビットに
     対応します。 利用できる環境: UNIX。

`geteuid()'
     現在のプロセスの実行ユーザ id を返します。 利用できる環境: UNIX。

`getgid()'
     現在のプロセスの実際のグループ id を返します。 利用できる環境:
     UNIX。

`getgroups()'
     現在のプロセスに関連づけられた従属グループ id のリストを返します。
     利用できる環境: UNIX。

`getlogin()'
     現在のプロセスの制御端末にログインしているユーザ名を返します。ほとんどの
     場合、ユーザが誰かを知りたいときには環境変数 `LOGNAME' を、現在有
     効になっているユーザ名を知りたいときには
     `pwd.getpwuid(os.getuid())[0]' を使うほうが便利です。
     利用できる環境: UNIX。

`getpgrp()'
     現在のプロセス・グループの id を返します。 利用できる環境: UNIX。

`getpid()'
     現在のプロセス id を返します。 利用できる環境: UNIX、 Windows。

`getppid()'
     親プロセスの id を返します。 利用できる環境: UNIX。

`getuid()'
     現在のプロセスのユーザ id を返します。 利用できる環境: UNIX。

`getenv(varname[, value])'
     環境変数 VARNAME が存在する場合にはその値を返し、存在しない
     場合には VALUE を返します。VALUE のデフォルト値は `None' です。
     利用できる環境: UNIX互換環境、Windows。

`putenv(varname, value)'
     VARNAME と名づけられた環境変数の値を文字列 VALUE に
     設定します。このような環境変数への変更は、`os.system()' 、
     `popen()'  、 `fork()' および `execv()'
     により起動された子プロセスに影響します。 利用できる環境: 主な
     UNIX互換環境、Windows。

     _Note:_ FreeBSD と Mac OS X を含むいつくかのプラットフォームでは、
     `environ' の値を変更するとメモリリークの原因になる場合があります。
     システムの putenv に関するドキュメントを参照してください。

     `putenv()' がサポートされている場合、 `os.environ'
     の要素に対する代入を行うと自動的に `putenv()' を呼び出します;
     しかし、`putenv()' の呼び出しは `os.environ' を更新しない
     ので、実際には `os.environ' の要素に代入する方が望ましい操作です。

`setegid(egid)'
     現在のプロセスに有効なグループIDをセットします。 利用できる環境:
     UNIX。

`seteuid(euid)'
     現在のプロセスに有効なユーザIDをセットします。 利用できる環境:
     UNIX。

`setgid(gid)'
     現在のプロセスにグループ id をセットします。 利用できる環境: UNIX。

`setgroups(groups)'
     現在のグループに関連付けられた従属グループ id のリストを GROUPS
     に設定します。GROUPS はシーケンス型でなくてはならず、
     各要素はグループを特定する整数でなくてはなりません。この操作は
     通常、スーパユーザしか利用できません。 利用できる環境: UNIX。
     _Added in Python version 2.2_

`setpgrp()'
     システムコール `setpgrp()' または `setpgrp(0, 0)'
     のどちらかのバージョンのうち、 (実装されていれば)
     実装されている方を呼び出します。 機能については UNIX
     マニュアルを参照してください。 利用できる環境: UNIX

`setpgid(pid, pgrp)'
     システムコール `setpgid()' を呼び出して、 PID の id
     をもつプロセスのプロセスグループ id を PGRP に設定します。
     利用できる環境: UNIX

`setreuid(ruid, euid)'
     現在のプロセスに対して実際のユーザ id および実行ユーザ id を
     設定します。 利用できる環境: UNIX

`setregid(rgid, egid)'
     現在のプロセスに対して実際のグループ id および実行ユーザ id を
     設定します。 利用できる環境: UNIX

`getsid(pid)'
     システムコール `getsid()' を呼び出します。機能については UNIX
     マニュアルを参照してください。 利用できる環境: UNIX。 _Added in
     Python version 2.4_

`setsid()'
     システムコール `setsid()' を呼び出します。機能については UNIX
     マニュアルを参照してください。 利用できる環境: UNIX

`setuid(uid)'
     現在のプロセスのユーザ id を設定します。 利用できる環境: UNIX

`strerror(code)'
     エラーコード CODE に対応するエラーメッセージを返します。
     利用できる環境: UNIX、Windows

`umask(mask)'
     現在の数値 umask を設定し、以前の umask 値を返します。
     利用できる環境: UNIX、Windows

`uname()'
     現在のオペレーティングシステムを特定する情報の入った 5 要素のタプル
     を返します。このタプルには 5 つの文字列: `(SYSNAME, NODENAME,
     RELEASE, VERSION, MACHINE)' が入っています。
     システムによっては、ノード名を 8 文字、または先頭の要素だけに
     切り詰めます; ホスト名を取得する方法としては、
     `socket.gethostname()' を使う方がよいでしょう、あるいは `socket.gethostbyaddr(socket.gethostname())'
     でもかまいません。 利用できる環境: UNIX互換環境

`unsetenv(varname)'
     VARNAME という名前の環境変数を取り消します。
     このような環境の変化は `os.system()'、 `popen()' または `fork()'
     と `execv()' で開始されるサブプロセスに影響を与えます。
     利用できる環境:  ほとんどの UNIX互換環境、Windows

     `unsetenv()' がサポートされている時には `os.environ' のアイテムの
     削除が対応する `unsetenv()'
     の呼び出しに自動的に翻訳されます。しかし、 `unsetenv()'
     の呼び出しは `os.environ' を更新しませんので、 むしろ `os.environ'
     のアイテムを削除する方が好ましい方法です。


File: python-lib-jp.info,  Node: ファイルオブジェクトの生成,  Next: ファイル記述子の操作,  Prev: プロセスのパラメタ,  Up: os

14.1.2 ファイルオブジェクトの生成
---------------------------------

以下の関数は新しいファイルオブジェクトを作成します。

`fdopen(fd[, mode[, bufsize]])'
     ファイル記述子 FD に接続している、開かれた
     ファイルオブジェクトを返します。 引数 MODE および BUFSIZE
     は、組み込み関数 `open()'
     における対応する引数と同じ意味を持ちます。 利用できる環境:
     Macintosh、 UNIX、Windows _Changed in Python version 2.3_ _Changed
     in Python version 2.5_

`popen(command[, mode[, bufsize]])'
     COMMAND への、または COMMAND からのパイプ入出力を開きます。
     戻り値はパイプに接続されている開かれたファイルオブジェクトで、
     MODE が `'r'' (標準の設定です) または `'w'' かに
     よって読み出しまたは書き込みを行うことができます。 引数 BUFSIZE
     は、組み込み関数 `open()'
     における対応する引数と同じ意味を持ちます。 COMMAND
     の終了ステータス (`wait()' で指定された書式でコード化
     されています) は、`close()' メソッドの戻り値として取得することが
     できます。例外は終了ステータスがゼロ (すなわちエラーなしで終了) の
     場合で、このときには `None' を返します。 利用できる環境:
     Macintosh、UNIX、Windows

     _Changed in Python version 2.0_

`tmpfile()'
     更新モード(`w+b')で開かれた新しいファイルオブジェクトを返します。
     このファイルはディレクトリエントリ登録に関連付けられておらず、
     このファイルに対するファイル記述子がなくなると自動的に削除されます。
     利用できる環境: Macintosh、UNIX、Windows

以下の `popen()' の変種はどれも、BUFSIZE が指定されている場合には I/O
パイプのバッファサイズを表します。 MODE を指定する場合には、文字列
`'b'' または `'t'' でなければなりません; これは、Windows
でファイルをバイナリモードで開くか
テキストモードで開くかを決めるために必要です。 MODE の標準の
設定値は`'t'' です。

またUNIXではこれらの変種はいずれも CMD
をシーケンスにできます。その場合、 引数はシェルの介在なしに直接
(`os.spawnv()' のように) 渡されます。 CMD が文字列の場合、引数は(
`os.system()' のように) シェルに渡されます。

以下のメソッドは子プロセスから終了ステータスを取得できるようには
していません。入出力ストリームを制御し、かつ終了コードの取得も
行える唯一の方法は、 `popen2' モジュールの  `Popen3' と  `Popen4'
クラスを利用する事です。これらは UNIX上でのみ利用可能です。

これらの関数の利用に関係して起きうるデッドロック状態についての議論は、
"フロー制御問題" (section~*Note asyncore::) を参照してください。

`popen2(cmd[, mode[, bufsize]])'
     CMD を子プロセスとして実行します。ファイル・オブジェクト
     `(CHILD_STDIN, CHILD_STDOUT)' を返します。 利用できる環境:
     Macintosh、UNIX、Windows _Added in Python version 2.0_

`popen3(cmd[, mode[, bufsize]])'
     CMD を子プロセスとして実行します。ファイルオブジェクト
     `(CHILD_STDIN, CHILD_STDOUT, CHILD_STDERR)' を 返します。
     利用できる環境: Macintosh、UNIX、Windows _Added in Python version
     2.0_

`popen4(cmd[, mode[, bufsize]])'
     CMD を子プロセスとして実行します。ファイルオブジェクト
     `(CHILD_STDIN, CHILD_STDOUT_AND_STDERR)' を返します。
     利用できる環境: Macintosh、UNIX、Windows _Added in Python version
     2.0_

(`CHILD_STDIN, CHILD_STDOUT, および CHILD_STDERR'
は子プロセスの視点で名付けられているので注意してください。
すなわち、CHILD_STDIN とは子プロセスの標準入力を意味します。)

この機能は `popen2' モジュール内の同じ名前の関数
を使っても実現できますが、これらの関数の戻り値は異なる順序を持ってい
ます。


File: python-lib-jp.info,  Node: ファイル記述子の操作,  Next: ファイルとディレクトリ,  Prev: ファイルオブジェクトの生成,  Up: os

14.1.3 ファイル記述子の操作
---------------------------

これらの関数は、ファイル記述子を使って参照されている
I/Oストリームを操作します。

ファイル記述子とは現在のプロセスから開かれたファイルに対応する小さな整数です。
例えば、標準入力のファイル記述子はいつでも 0 で、標準出力は
1、標準エラーは 2 です。 その他にさらにプロセスから開かれたファイルには
3、4、5、などが割り振られます。
「ファイル記述子」という名前は少し誤解を与えるものかもしれませんが、
UNIXプラットフォームにおいて、ソケットやパイプもファイル記述子によって参照されます。

`close(fd)'
     ファイルディスクリプタ FD を閉じます。 利用できる環境: Macintosh、
     UNIX、 Windows

     _Notice:_ 注:この関数は低レベルの I/O のためのもので、`open()' や
     `pipe()' が返すファイル記述子に対して適用しなければ
     なりません。組み込み関数 `open()' や `popen()' 、 `fdopen()'
     の返す "ファイルオブジェクト" を閉じるには、 オブジェクトの
     `close()' メソッドを使ってください。


`dup(fd)'
     ファイル記述子 FD の複製を返します。 利用できる環境: Macintosh、
     UNIX、 Windows.

`dup2(fd, fd2)'
     ファイル記述子を FD から FD2 に複製し、必要なら後者の
     記述子を前もって閉じておきます。 利用できる環境:
     Macintosh、UNIX、Windows

`fdatasync(fd)'
     ファイル記述子 FD を持つファイルのディスクへの書き込みを
     強制します。メタデータの更新は強制しません。 利用できる環境: UNIX

`fpathconf(fd, name)'
     開いているファイルに関連したシステム設定情報 (system configuration
     information) を返します。 NAME には取得したい設定名を指定します;
     これは定義済みのシステム固有値名の文字列で、多くの標準 (POSIX.1、
     UNIX 95、 UNIX 98 その他) で定義されています。
     プラットフォームによっては別の名前も定義しています。
     ホストオペレーティングシステムの関知する名前は `pathconf_names'
     辞書で与えられています。このマップオブジェクトに入っていない設定
     変数については、 NAME に整数を渡してもかまいません。
     利用できる環境: Macintosh、UNIX

     もし NAME が文字列でかつ不明である場合、 `ValueError'
     を送出します。NAME の指定値がホストシステムでサポートされておらず、
     `pathconf_names' にも入っていない場合、`errno.EINVAL'
     をエラー番号として `OSError' を送出します。

`fstat(fd)'
     `stat()' のようにファイル記述子 FD の状態を返します。
     利用できる環境: Macintosh、UNIX、Windows

`fstatvfs(fd)'
     `statvfs()' のように、ファイル記述子 FD に関連
     づけられたファイルが入っているファイルシステムに関する情報を返します。
     利用できる環境: UNIX

`fsync(fd)'
     ファイル記述子 FD
     を持つファイルのディスクへの書き込みを強制します。
     UNIXでは、ネイティブの `fsync()' 関数を、Windows では MS
     `_commit()' 関数を呼び出します。

     Python のファイルオブジェクト F を使う場合、F の内部バッファ
     を確実にディスクに書き込むために、まず `F.flush()' を実行し、
     それから `os.fsync(F.fileno())' してください。 利用できる環境:
     Macintosh、UNIX、2.2.3 以降では Windows も

`ftruncate(fd, length)'
     ファイル記述子 FD に対応するファイルを、サイズが最大で LENGTH
     バイトになるように切り詰めます。 利用できる環境: Macintosh、UNIX

`isatty(fd)'
     ファイル記述子 FD が開いていて、tty(のような)装置に接
     続されている場合、`1' を返します。そうでない場合は `0' を返
     します。 利用できる環境: Macintosh、UNIX

`lseek(fd, pos, how)'
     ファイル記述子 FD の現在の位置を POS に設定します。 POS の意味は
     HOW で修飾されます: ファイルの先頭からの相対には `0' を設定します;
     現在の位置からの相対には`1' を設定します;
     ファイルの末尾からの相対には `2' を設定します。
     利用できる環境:Macintosh、 UNIX、Windows。

`open(file, flags[, mode])'
     ファイル FILE を開き、FLAG に従って様々なフラグを 設定し、可能なら
     MODE に従ってファイルモードを設定します。 MODE の標準の設定値は
     `0777' (8進表現) で、先に 現在の umask
     を使ってマスクを掛けます。新たに開かれたファイルの
     のファイル記述子を返します。利用できる環境:Macintosh、UNIX、Windows。
     フラグとファイルモードの値についての詳細は C
     ランタイムのドキュメントを 参照してください; (`O_RDONLY' や
     `O_WRONLY' のような)
     フラグ定数はこのモジュールでも定義されています
     (以下を参照してください)。

     _Notice:_ この関数は低レベルの I/O
     のためのものです。通常の利用では、 `read()' や `write()'
     (やその他多くの) メソッドを持つ 「ファイルオブジェクト」
     を返す、組み込み関数 `open()' を 使ってください。
     ファイル記述子を「ファイルオブジェクト」でラップするには `fdopen()'
     を使ってください。


`openpty()'
     新しい擬似端末のペアを開きます。ファイル記述子のペア `(MASTER,
     SLAVE)' を返し、それぞれ pty および tty を表します。(少しだけ)
     より可搬性のあるアプローチとしては、 `pty'  モジュールを使ってください。
     利用できる環境: Macintosh、いくつかの UNIX系システム

`pipe()'
     パイプを作成します。ファイル記述子のペア `(R, W)'
     を返し、それぞれ読み出し、書き込み用に使うことができます。
     利用できる環境: Macintosh、UNIX、Windows

`read(fd, n)'
     ファイル記述子 FD から最大で N バイト読み出します。
     読み出されたバイト列の入った文字列を返します。FD が参照して
     いるファイルの終端に達した場合、空の文字列が返されます。
     利用できる環境: Macintosh、UNIX、Windows。

     _Notice:_ この関数は低レベルの I/O のためのもので、`open()' や
     `pipe()' が返すファイル記述子に対して適用しなければ
     なりません。組み込み関数 `open()' や `popen()' 、 `fdopen()'
     の返す "ファイルオブジェクト" 、あるいは `sys.stdin'
     から読み出すには、オブジェクトの `read()'
     メソッドを使ってください。


`tcgetpgrp(fd)'
     FD (`open()' が返す開かれたファイル記述子)
     で与えられる端末に関連付けられたプロセスグループを返します。
     利用できる環境: Macintosh、UNIX

`tcsetpgrp(fd, pg)'
     FD (`open()' が返す開かれたファイル記述子)
     で与えられる端末に関連付けられたプロセスグループを PG
     に設定します。 利用できる環境: Macintosh、UNIX

`ttyname(fd)'
     ファイル記述子 FD に関連付けられている端末デバイスを特定する
     文字列を返します。FD が端末に関連付けられていない場合、
     例外が送出されます。 利用できる環境: Macintosh、UNIX

`write(fd, str)'
     ファイル記述子 FD に文字列 STR を書き込みます。
     実際に書き込まれたバイト数を返します。 利用できる環境:Macintosh、
     UNIX、Windows。

     _Notice:_ この関数は低レベルの I/O のためのもので、`open()' や
     `pipe()' が返すファイル記述子に対して適用しなければ
     なりません。組み込み関数 `open()' や `popen()' 、 `fdopen()'
     の返す "ファイルオブジェクト" 、あるいは
     `sys.stdout'、`sys.stderr' に書き込むには、オブジェクトの `write()'
     メソッドを使ってください。


以下のデータ要素は `open()' 関数の FLAGS 引数を
構築するために利用することができます。いくつかのアイテムは
全てのプラットフォームで使えるわけではありません。
何が使えるか、また何に使うのかといった説明は `open(2)'
を参照してください。

`O_RDONLY'

`O_WRONLY'

`O_RDWR'

`O_APPEND'

`O_CREAT'

`O_EXCL'

`O_TRUNC'
     `open()' 関数の FLAG 引数のためのオプションフラグです。
     これらの値はビット単位 OR を取れます。 利用できる環境: Macintosh、
     UNIX、Windows。

`O_DSYNC'

`O_RSYNC'

`O_SYNC'

`O_NDELAY'

`O_NONBLOCK'

`O_NOCTTY'

`O_SHLOCK'

`O_EXLOCK'
     上のフラグと同様、`open()' 関数の FLAG 引数のための
     オプションフラグです。これらの値はビット単位 OR を取れます。
     利用できる環境: Macintosh、 UNIX。

`O_BINARY'
     `open()' 関数の FLAG 引数のためのオプションフラグです。
     この値は上に列挙したフラグとビット単位 OR を取ることができます。
     利用できる環境: Windows。


`O_NOINHERIT'

`O_SHORT_LIVED'

`O_TEMPORARY'

`O_RANDOM'

`O_SEQUENTIAL'

`O_TEXT'
     `open()' 関数の FLAG 引数のためのオプションフラグです。
     これらの値はビット単位 OR を取ることができます。 利用できる環境:
     Windows

`SEEK_SET'

`SEEK_CUR'

`SEEK_END'
     `lseek()' 関数のパラメータです。 値はそれぞれ 0、 1、 2 です。
     利用できる環境: Windows、 Macintosh、 UNIX _Added in Python
     version 2.5_


File: python-lib-jp.info,  Node: ファイルとディレクトリ,  Next: プロセス管理,  Prev: ファイル記述子の操作,  Up: os

14.1.4 ファイルとディレクトリ
-----------------------------

`access(path, mode)'
     実 uid/gid を使って PATH に対するアクセスが可能か調べます。
     ほとんどのオペレーティングシステムは実行 uid/gid を使うため、
     このルーチンは suid/sgid 環境において、プログラムを起動した
     ユーザが PATH に対するアクセス権をもっているかを調べる
     ために使われます。PATH が存在するかどうかを調べるには MODE を
     `F_OK' にします。ファイル操作許可 (permission) を調べるために
     `R_OK'、 `W_OK'、`X_OK' から一つまたはそれ以上のフラグと OR
     をとることもできます。 アクセスが許可されている場合 `True'
     を、そうでない場合 `False' を返します。詳細は `access(2)'
     のマニュアルページを参照して ください。 利用できる環境:
     Macintosh、 UNIX、 Windows

     _Note:_ `access()'
     を使ってユーザーが例えばファイルを開く権限を持っているか `open()'
     を使って実際にそうする前に調べることはセキュリティ・ホールを
     作り出してしまいます。というのは、調べる時点と開く時点の時間差を利用して
     そのユーザーがファイルを操作してしまうかもしれないからです。

     _Note:_ I/O 操作は `access()'
     が成功を思わせるときにも失敗することがありえます。
     特にネットワーク・ファイルシステムにおける操作が 通常の POSIX
     許可ビット・モデルをはみ出す意味論を備える場合には
     そのようなことが起こりえます。

`F_OK'
     `access()' の MODE に渡すための値で、 PATH
     が存在するかどうかを調べます。

`R_OK'
     `access()' の MODE に渡すための値で、 PATH
     が読み出し可能かどうかを調べます。

`W_OK'
     `access()' の MODE に渡すための値で、 PATH
     が書き込み可能かどうかを調べます。

`X_OK'
     `access()' の MODE に渡すための値で、 PATH
     が実行可能かどうかを調べます。

`chdir(path)'
     現在の作業ディレクトリ (current working directory) を PATH に
     設定します。利用できる環境: Macintosh、 UNIX、Windows。

`getcwd()'
     現在の作業ディレクトリを表現する文字列を返します。 利用できる環境:
     Macintosh、 UNIX、Windows。

`getcwdu()'
     現在の作業ディレクトリを表現するユニコードオブジェクトを返します。
     利用できる環境: Macintosh、 UNIX、 Windows _Added in Python
     version 2.3_

`chroot(path)'
     現在のプロセスに対してルートディレクトリを PATH に変更します。
     利用できる環境: Macintosh、UNIX。 _Added in Python version 2.2_

`chmod(path, mode)'
     PATH のモードを数値 MODE に変更します。 MODE は、(`stat'
     モジュールで定義されている) 以下の値のいずれかまたはビット単位の
     OR で組み合わせた値を取り得ます:
        * `S_ISUID'

        * `S_ISGID'

        * `S_ENFMT'

        * `S_ISVTX'

        * `S_IREAD'

        * `S_IWRITE'

        * `S_IEXEC'

        * `S_IRWXU'

        * `S_IRUSR'

        * `S_IWUSR'

        * `S_IXUSR'

        * `S_IRWXG'

        * `S_IRGRP'

        * `S_IWGRP'

        * `S_IXGRP'

        * `S_IRWXO'

        * `S_IROTH'

        * `S_IWOTH'

        * `S_IXOTH'

     利用できる環境: Macintosh、 UNIX、 Windows。

     _Note:_ Windows でも `chmod()' はサポートされていますが、
     ファイルの読み込み専用フラグを (定数 `S_IWRITE' と
     `S_IREAD'、または対応する整数値を通して) 設定できるだけです。
     他のビットは全て無視されます。

`chown(path, uid, gid)'
     PATH の所有者 (owner) id とグループ id を、数値 UID および GID
     に変更します。いずれかの id を変更せずにおくには、 その値として -1
     をセットします。 利用できる環境: Macintosh、 UNIX。

`lchown(path, uid, gid)'
     Change the owner and group id of PATH to the numeric UID and gid.
     This function will not follow symbolic links.  PATH の所有者
     (owner) id とグループ id を、数値 UID および GID
     に変更します。この関数はシンボリックリンクをたどりません。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

`link(src, dst)'
     SRC を指しているハードリンク DST を作成します。 利用できる環境:
     Macintosh、 UNIX。

`listdir(path)'
     ディレクトリ内のエントリ名が入ったリストを返します。
     リスト内の順番は不定です。特殊エントリ `'.'' および `'..''
     は、それらがディレクトリに入っていてもリストには含められません。
     利用できる環境: Macintosh、 UNIX、 Windows。

     _Changed in Python version 2.3_

`lstat(path)'
     `stat()' に似ていますが、シンボリックリンクをたどりません。
     利用できる環境: Macintosh、 UNIX。

`mkfifo(path[, mode])'
     数値で指定されたモード MODE を持つ FIFO (名前付きパイプ) を PATH
     に作成します。MODE の標準の値は `0666' (8進) です。現在の umask
     値が前もって MODE からマスクされます。 利用できる環境: Macintosh、
     UNIX。

     FIFO は通常のファイルのようにアクセスできるパイプです。FIFO は
     (例えば `os.unlink()' を使って) 削除されるまで
     存在しつづけます。一般的に、FIFO は "クライアント" と "サーバ"
     形式のプロセス間でランデブーを行うために使われます: このとき、
     サーバは FIFO を読み出し用に開き、クライアントは書き込み用に
     開きます。`mkfifo()' は FIFO を開かない -- 単にランデブー
     ポイントを作成するだけ -- なので注意してください。

`mknod(filename[, mode=0600, device])'
     FILENAME という名前で、ファイルシステム・ノード
     (ファイル、デバイス特殊 ファイル、または、名前つきパイプ)
     を作ります 。MODE は、作ろうとす
     るノードの使用権限とタイプを、S_IFREG、S_IFCHR、S_IFBLK、S_IFIFO
     (これら の定数は `stat' で使用可能) のいずれかと（ビット OR
     で）組み合わ せて指定します。S_IFCHR と S_IFBLK
     を指定すると、DEVICE は新しく作 られたデバイス特殊ファイルを
     (おそらく `os.makedev()' を使って)
     定義し、指定しなかった場合には無視します。 _Added in Python
     version 2.3_

`major(device)'
     生のデバイス番号から、デバイスのメジャー番号を取り出します。(たいてい
     `stat' の `st_dev' フィールドか `st_rdev'　 フィールドです) _Added
     in Python version 2.3_

`minor(device)'
     生のデバイス番号から、デバイスのマイナー番号を取り出します。(たいてい
     `stat' の `st_dev' フィールドか `st_rdev'　 フィールドです) _Added
     in Python version 2.3_

`makedev(major, minor)'
     major と minor から、新しく生のデバイス番号を作ります。 _Added in
     Python version 2.3_

`mkdir(path[, mode])'
     数値で指定されたモード MODE をもつディレクトリ PATH
     を作成します。MODE の標準の値は `0777' (8進)です。
     システムによっては、 MODE は無視されます。利用の際には、 現在の
     umask 値が前もってマスクされます。 利用できる環境: Macintosh、
     UNIX、Windows。

`makedirs(path[, mode])'
     再帰的なディレクトリ作成関数です。 

     `mkdir()' に似て いますが、末端 (leaf)
     となるディレクトリを作成するために必要な
     中間の全てのディレクトリを作成します。末端ディレクトリが
     すでに存在する場合や、作成ができなかった場合には `error'
     例外を送出します。MODE の標準の値は `0777' (8進)です。
     システムによっては、 MODE は無視されます。利用の際には、 現在の
     umask 値が前もってマスクされます。 _Note:_ `makedirs()'
     は作り出すパス要素が OS.PARDIR を 含むと混乱することになります。
     _Added in Python version 1.5.2_ _Changed in Python version 2.3_

`pathconf(path, name)'
     指定されたファイルに関係するシステム設定情報を返します。 var{name}
     には取得したい設定名を指定します;
     これは定義済みのシステム固有値名の文字列で、多くの標準 (POSIX.1、
     UNIX 95、 UNIX 98 その他) で定義されています。
     プラットフォームによっては別の名前も定義しています。
     ホストオペレーティングシステムの関知する名前は `pathconf_names'
     辞書で与えられています。このマップ型オブジェクトに入っていない設定
     変数については、 NAME に整数を渡してもかまいません。
     利用できる環境: Macintosh、UNIX

     もし NAME が文字列でかつ不明である場合、 `ValueError'
     を送出します。NAME の指定値がホストシステムでサポートされておらず、
     `pathconf_names' にも入っていない場合、`errno.EINVAL'
     をエラー番号として `OSError' を送出します。

`pathconf_names'
     `pathconf()' および `fpathconf()' が受理する
     システム設定名を、ホストオペレーティングシステムで定義されている
     整数値に対応付けている辞書です。この辞書はシステムでどの
     設定名が定義されているかを決定するために利用できます。
     利用できる環境: Macintosh、 UNIX。

`readlink(path)'
     シンボリックリンクが指しているパスを表す文字列を返します。
     返される値は絶対パスにも、相対パスにもなり得ます; 相対 パスの場合、
     `os.path.join(os.path.dirname(PATH), RESULT)'
     を使って絶対パスに変換することができます。 利用できる環境:
     Macintosh、 UNIX。

`remove(path)'
     ファイル PATH を削除します。PATH がディレクトリの 場合、`OSError'
     が送出されます; ディレクトリの削除については `rmdir()'
     を参照してください。この関数は下で述べられている `unlink()'
     関数と同一です。Windows では、使用中のファイル
     を削除しようと試みると例外を送出します; UNIXでは、ディレクトリ
     エントリは削除されますが、記憶装置上にアロケーションされたファイル領域は
     元のファイルが使われなくなるまで残されます。 利用できる環境:
     Macintosh、 UNIX、Windows。

`removedirs(path)'
     再帰的なディレクトリ削除関数です。`rmdir()' と同じように
     動作しますが、末端ディレクトリがうまく削除できるかぎり、
     `removedirs()' は PATH に現れる親ディレクトリをエラー
     が送出されるまで (このエラーは通常、
     指定したディレクトリの親ディレクトリが空でないことを意味するだけ
     なので無視されます) 順に削除することを試みます。
     例えば、`os.removedirs('foo/bar/baz')' では最初にディレクトリ
     `'foo/bar/baz'' を削除し、次に `'foo/bar''、さらに `'foo''
     をそれらが空ならば削除します。
     末端のディレクトリが削除できなかった場合には `OSError'
     が送出されます。 _Added in Python version 1.5.2_

`rename(src, dst)'
     ファイルまたはディレクトリ SRC を DST に名前変更します。 DST
     がディレクトリの場合、`OSError' が送出 されます。 UNIXでは、 DST
     が存在し、かつファイルの場合、
     ユーザの権限があるかぎり暗黙のうちに元のファイルが削除されます。
     この操作はいくつかの UNIX 系において、SRC と DST
     が異なるファイルシステム上にあると失敗することがあります。
     ファイル名の変更が成功する場合、この操作は原子的 (atomic) 操作
     となります (これは POSIX 要求仕様です) Windows では、 DST
     が既に存在する場合には、たとえファイルの場合でも `OSError'
     が送出されます; これは DST が既に
     存在するファイル名の場合、名前変更の原子的操作を実装する手段が
     ないからです。 利用できる環境: Macintosh、 UNIX、Windows。

`renames(old, new)'
     再帰的にディレクトリやファイル名を変更する関数です。 `rename()'
     のように動作しますが、新たなパス名を持つ
     ファイルを配置するために必要な途中のディレクトリ構造をまず作成
     しようと試みます。 名前変更の後、元のファイル名のパス要素は
     `removedirs()' を使って右側から順に枝刈りされてゆきます。 _Added
     in Python version 1.5.2_

     _Notice:_
     この関数はコピー元の末端のディレクトリまたはファイルを削除する
     権限がない場合には失敗します。


`rmdir(path)'
     ディレクトリ PATH を削除します。 利用できる環境: Macintosh、
     UNIX、Windows。

`stat(path)'
     与えられた PATH に対して `stat()' システムコールを
     実行します。戻り値はオブジェクトで、その属性が `stat' 構造体の
     以下に挙げる各メンバ: `st_mode' (保護モードビット)、 `st_ino' (i
     ノード番号)、 `st_dev' (デバイス)、 `st_nlink' (ハードリンク数)、
     `st_uid' (所有者のユーザ ID)、 `st_gid'
     (所有者のグループ	ID)、 `st_size' (ファイルのバイトサイズ)、
     `st_atime' (最終アクセス時刻)、 `st_mtime' (最終更新時刻)、
     `st_ctime' (プラットフォーム依存：UNIXでは最終メタデータ変更時刻、
     Windowsでは作成時刻) となっています。

          >>> import os
          >>> statinfo = os.stat('somefile.txt')
          >>> statinfo
          (33188, 422511L, 769L, 1, 1032, 100, 926L, 1105022698,1105022732, 1105022732)
          >>> statinfo.st_size
          926L
          >>>

     _Changed in Python version stat_float_times_
     が真を返す場合、時間値は浮動小数点で秒を計ります。ファイルシステムがサポートしていれば、秒の小数点以下の桁も含めて返されます。
     Mac OS では、時間は常に浮動小数点です。詳細な説明は
     `stat_float_times' を参照してください]{2.3}

     (Linux のような) UNIX システムでは、以下の属性: `st_blocks'
     (ファイル用にアロケーションされているブロック数)、 `st_blksize'
     (ファイルシステムのブロックサイズ)、 `st_rdev' (i
     ノードデバイスの場合、デバイスの形式)、 `st_flags'
     (ファイルに対するユーザー定義のフラグ) も利用可能なときがあります。

     他の (FreeBSD のような) UNIX システムでは、以下の属性: `st_gen'
     (ファイル生成番号)、 `st_birthtime' (ファイル生成時刻)
     も利用可能なときがあります (ただし root
     がそれらを使うことにした場合以外は値が入っていないでしょう)。

     Mac OS システムでは、以下の属性: `st_rsize'、 `st_creator'、
     `st_type'、 も利用可能なときがあります。

     RISCOS システムでは、以下の属性: `st_ftype' (file type)、
     `st_attrs' (attributes)、 `st_obtype' (object type)、
     も利用可能なときがあります。

     後方互換性のために、`stat()' の戻り値は少なくとも 10 個の
     整数からなるタプルとしてアクセスすることができます。このタプルは
     もっとも重要な (かつ可搬性のある) `stat' 構造体のメンバを
     与えており、以下の順番、 `st_mode'、 `st_ino'、 `st_dev'、
     `st_nlink'、 `st_uid'、 `st_gid'、 `st_size'、 `st_atime'、
     `st_mtime'、 `st_ctime'、 に並んでいます。

     実装によっては、この後ろにさらに値が付け加えられていることもあります。
     Mac OS では、時刻の値は Mac OS
     の他の時刻表現値と同じように浮動小数点数 なので注意してください。
     標準モジュール `stat'  では、 `stat'
     構造体から情報を引き出す上で便利な関数や定数を定義して
     います。(Windows では、いくつかのデータ要素はダミーの値が埋められて
     います。)

     _Note:_ `st_atime', `st_mtime', および `st_ctime'
     メンバの厳密な意味や精度はオペレーティングシステムやファイルシステムによって
     変わります。例えば、FAT や FAT32
     ファイルシステムを使っているWindows システム では、`st_atime'
     の精度は 1 日に過ぎません。詳しくはお使いのオペレーティング
     システムのドキュメントを参照してください。

     利用できる環境: Macintosh、 UNIX、Windows。

     _Changed in Python version 2.2_ _Changed in Python version 2.5_

`stat_float_times([newvalue])'
     `stat_result' がタイムスタンプに浮動小数点オブジェクトを使うかどう
     かを決定します。NEWVALUE が `True' の場合、 以後の `stat()'
     呼び出しは浮動小数点を返し、 `False'
     の場合には以後整数を返します。NEWVALUE が省略された場合、現在の設
     定どおりの戻り値になります。

     古いバージョンの Python と互換性を保つため、`stat_result' にタプル
     としてアクセスすると、常に整数が返されます。

     _Changed in Python version 2.5_

     タイムスタンプの精度 (すなわち最小の小数部分) はシステム依存です。
     システムによっては秒単位の精度しかサポートしません。
     そういったシステムでは小数部分は常に 0 です。

     この設定の変更は、プログラムの起動時に、 __MAIN__
     モジュールの中でのみ行うことを推奨します。
     ライブラリは決して、この設定を変更するべきではありません。
     浮動小数点型のタイムスタンプを処理すると、不正確な動作をするようなライブ
     ラリを使う場合、ライブラリが修正されるまで、浮動小数点型を返す機能を停止
     させておくべきです。

`statvfs(path)'
     与えられた PATH に対して `statvfs()' システムコールを
     実行します。戻り値はオブジェクトで、その属性は与えられたパスが収め
     られているファイルシステムについて記述したものです。かく属性は
     `statvfs' 構造体のメンバ: `f_bsize'、 `f_frsize'、 `f_blocks'、
     `f_bfree'、 `f_bavail'、 `f_files'、 `f_ffree'、 `f_favail'、
     `f_flag'、 `f_namemax'、 に対応します。 利用できる環境: UNIX。

     後方互換性のために、戻り値は上の順にそれぞれ対応する属性値が並んだ
     タプルとしてアクセスすることもできます。 標準モジュール `statvfs'  では、
     シーケンスとしてアクセスする場合に、`statvfs' 構造体から情報を
     引き出す上便利な関数や定数を定義しています; これは
     属性として各フィールドにアクセスできないバージョンの Python で
     動作する必要のあるコードを書く際に便利です。 _Changed in Python
     version 2.2_

`symlink(src, dst)'
     SRC を指しているシンボリックリンクを DST に作成します。
     利用できる環境: UNIX。

`tempnam([dir[, prefix]])'
     一時ファイル (temporary file)
     を生成する上でファイル名として相応しい
     一意なパス名を返します。この値は一時的なディレクトリエントリ
     を表す絶対パスで、DIR ディレクトリの下か、DIR が省略 されたり
     `None' の場合には一時ファイルを置くための共通の
     ディレクトリの下になります。PREFIX が与えられており、かつ `None'
     でない場合、ファイル名の先頭につけられる短い
     接頭辞になります。アプリケーションは `tempnam()'
     が返したパス名を使って正しくファイルを生成し、生成したファイルを
     管理する責任があります; 一時ファイルの自動消去機能は提供されて
     いません。 _`tempnam()' を使うと、symlink 攻撃に対して脆弱
     になります; 代りに`tmpfile()' (第*Note
     ファイルオブジェクトの生成::節) を使うよう検討してください。_
     利用できる環境: Macintosh、 UNIX、 Windows。

`tmpnam()'
     一時ファイル (temporary file)
     を生成する上でファイル名として相応しい
     一意なパス名を返します。この値は一時ファイルを置くための共通の
     ディレクトリ下の一時的なディレクトリエントリを表す絶対パスです。
     アプリケーションは `tmpnam()'
     が返したパス名を使って正しくファイルを生成し、生成したファイルを
     管理する責任があります; 一時ファイルの自動消去機能は提供されて
     いません。

     _`tmpnam()' を使うと、symlink 攻撃に対して脆弱 になります;
     代りに`tmpfile()'  (第*Note ファイルオブジェクトの生成::節)
     を使うよう検討してください。_ 利用できる環境: UNIX、Windows。
     この関数はおそらく Windows では使うべきではないでしょう;
     Micorosoft の `tmpnam()' 実装では、常に現在のドライブの
     ルートディレクトリ下のファイル名を生成しますが、これは一般的には
     テンポラリファイルを置く場所としてはひどい場所です
     (アクセス権限によっては、この名前をつかってファイルを開くことすら
     できないかもしれません)。

`TMP_MAX'
     `tmpnam()' がテンポラリ名を再利用し始めるまでに生成できる
     一意な名前の最大数です。

`unlink(path)'
     ファイル PATH を削除します。`remove()' と同じです; `unlink()'
     の名前は伝統的な UNIX の関数名です。 利用できる環境: Macintosh、
     UNIX、Windows。

`utime(path, times)'
     PATH で指定されたファイルに最終アクセス時刻および最終修正時刻
     を設定します。TIMES が `None' の場合、ファイルの最終
     アクセス時刻および最終更新時刻は現在の時刻になります。そうでない
     場合、 TIMES は 2 要素のタプルで、`(ATIME, MTIME)'
     の形式をとらなくてはなりません。これらはそれぞれアクセス時刻および修正時刻
     を設定するために使われます。 PATH
     にディレクトリを指定できるかどうかは、オペレーティングシステム
     がディレクトリをファイルの一種として実装しているかどうかに依存します
     (例えば、 Windows
     はそうではありません)。ここで設定した時刻の値は、オペレーティング
     システムがアクセス時刻や更新時刻を記録する際の精度によっては、後で`stat()'
     呼び出したときの値と同じにならないかも知れないので注意してください。
     `stat()' も参照してください。 _Changed in Python version 2.0_
     利用できる環境: Macintosh、 UNIX、Windows。

`walk(top[, topdown`=True' [, onerror`=None']])'
     `walk()' は、ディレクトリツリー以下のファイル名を、ツリーを
     トップダウンとボトムアップの両方向に歩行することで生成します。
     ディレクトリ TOP を根に持つディレクトリツリーに含まれる、
     各ディレクトリ(TOP 自身を含む) から、タプル `(DIRPATH,  DIRNAMES,
     FILENAMES)' を生成します。

     DIRPATH は文字列で、ディレクトリへのパスです。DIRNAMES は DIRPATH
     内のサブディレクトリ名のリスト (`'.'' と `'..''
     は除く）です。FILENAMES は DIRPATH 内の非ディレクトリ・ファ
     イル名のリストです。このリスト内の名前には、ファイル名までのパスが含まれ
     ないことに、注意してください。DIRPATH 内のファイルやディレクトリへ
     の (TOP からたどった) フルパスを得るには、 `os.path.join(DIRPATH,
     NAME)' してください。

     オプション引数 TOPDOWN が真であるか、指定されなかった場合、各ディ
     レクトリからタプルを生成した後で、サブディレクトリからタプルを生成します。
     (ディレクトリはトップダウンで生成)。TOPDOWN が偽の場合、ディレクト
     リに対応するタプルは、そのディレクトリ以下の全てのサブディレクトリに対応
     するタプルの後で (ボトムアップで) 生成されます

     TOPDOWN が真のとき、呼び出し側は DIRNAMES リストを、インプレ
     ースで (たとえば、`del' やスライスを使った代入で) 変更でき、
     `walk()' はDIRNAMES に残っているサブディレクトリ内のみを
     再帰します。これにより、検索を省略したり、特定の訪問順序を強制したり、呼
     び出し側が `walk()' を再開する前に、呼び出し側が作った、または
     名前を変更したディレクトリを、`walk()' に知らせたりすることがで
     きます。TOPDOWN が偽のときに DIRNAMES を変更しても効果はあり
     ません。ボトムアップモードでは  DIRPATH 自身が生成される前に
     DIRNAMES 内のディレクトリの情報が生成されるからです。

     デフォルトでは、`os.listdir()' 呼び出しから送出されたエラーは
     無視されます。オプションの引数 ONERROR を指定するなら、
     この値は関数でなければなりません; この関数は単一の引数として、
     `OSError' インスタンスを伴って呼び出されます。この関数では
     エラーを報告して歩行を続けたり、例外を送出して歩行を中断したり
     できます。ファイル名は例外オブジェクトの `filename' 属性として
     取得できることに注意してください。

     _Notice:_ 相対パスを渡した場合、`walk()'
     の回復の間でカレント作業ディレク
     トリを変更しないでください。`walk()' はカレントディレクトリを変
     更しませんし、呼び出し側もカレントディレクトリを変更しないと仮定していま
     す。

     _Notice:_
     シンボリックリンクをサポートするシステムでは、サブディレクトリへのリンク
     が DIRNAMES リストに含まれますが、`walk()' はそのリンクを
     たどりません
     (シンボリックリンクをたどると、無限ループに陥りやすくなりま
     す)。リンクされたディレクトリをたどるには、 `os.path.islink(PATH)'
     でリンク先ディレクトリを確認し、各ディ レクトリに対して
     `walk(PATH)' を実行するとよいでしょう。

     以下の例では、最初のディレクトリ以下にある各ディレクトリに含まれる、非ディレクトリファイルのバイト数を表示します。ただし、CVS
     サブディレクトリより下を見に行きません。

          import os
          from os.path import join, getsize
          for root, dirs, files in os.walk('python/Lib/email'):
              print root, "consumes",
              print sum(getsize(join(root, name)) for name in files),
              print "bytes in", len(files), "non-directory files"
              if 'CVS' in dirs:
                  dirs.remove('CVS')  # don't visit CVS directories

     次の例では、ツリーをボトムアップで歩行することが不可欠になります;
     `rmdir()' はディレクトリが空になる前に削除させないからです:

          # Delete everything reachable from the directory named in 'top',
          # assuming there are no symbolic links.
          # CAUTION:  This is dangerous!  For example, if top == '/', it
          # could delete all your disk files.
          import os
          for root, dirs, files in os.walk(top, topdown=False):
              for name in files:
                  os.remove(os.path.join(root, name))
              for name in dirs:
                  os.rmdir(os.path.join(root, name))

     _Added in Python version 2.3_


File: python-lib-jp.info,  Node: プロセス管理,  Next: 雑多なシステム情報,  Prev: ファイルとディレクトリ,  Up: os

14.1.5 プロセス管理
-------------------

プロセスを生成したり管理するために、以下の関数を利用することができます。

様々な `exec*()' 関数が、プロセス内にロードされた新たな
プログラムに与えるための引数からなるリストをとります。どの場合でも、
新たなプログラムに渡されるリストの最初の引数は、ユーザがコマンドライン
で入力する引数ではなく、プログラム自身の名前になります。 C
プログラマにとっては、これはプログラムの `main()' に 渡される `argv[0]'
になります。例えば、 `os.execv('/bin/echo', ['foo', 'bar'])'
は、標準出力に `bar' を出力します; `foo' は無視されたかのように見える
ことでしょう。

`abort()'
     `SIGABRT' シグナルを現在のプロセスに対して生成します。
     UNIXでは、標準設定の動作はコアダンプの生成です; Windows では、
     プロセスは即座に終了コード `3' を返します。 `signal.signal()'
     を使って `SIGABRT' に対する
     シグナルハンドラを設定しているプログラムは異なる挙動を示すので
     注意してください。 利用できる環境: Macintosh、 UNIX、 Windows。

`execl(path, arg0, arg1, ...)'

`execle path, arg0, arg1, ..., env'

`execlp file, arg0, arg1, ...'

`execlpe file, arg0, arg1, ..., env'

`execv path, args'

`execve path, args, env'

`execvp file, args'

`execvpe file, args, env'
     これらの関数はすべて、現在のプロセスを置き換える形で新たな
     プログラムを実行します; 現在のプロセスは戻り値を返しません。
     UNIXでは、新たに実行される実行コードは現在のプロセス内に
     ロードされ、呼び出し側と同じプロセス ID を持つことになります。
     エラーは `OSError' 例外として報告されます。

     `l' および `v' のついた `exec*()'
     関数は、コマンドライン引数をどのように渡すかが異なります。 `l'
     型は、コードを書くときにパラメタ数が決まっている場合
     に、おそらくもっとも簡単に利用できます。個々のパラメタは単に
     `execl*()' 関数の追加パラメタとなります。`v' 型は、
     パラメタの数が可変の時に便利で、リストかタプルの引数が ARGS
     パラメタとして渡されます。どちらの場合も、子プロセスに渡す引数は
     動作させようとしているコマンドの名前から始めるべきですが、これは
     強制ではありません。

     末尾近くに `p' をもつ型 (`execlp()'、 `execlpe()'、 `execvp()'、
     および `execvpe()') は、プログラム FILE を探すために 環境変数
     `PATH' を利用します。環境変数が (次の段で述べる `exec*e()'
     型関数で) 置き換えられる場合、環境変数は `PATH'
     を決定する上の情報源として使われます。 その他の型、`execl()'、
     `execle()'、 `execv()'、 および `execve()' では、実行
     コードを探すために `PATH' を使いません。 PATH
     には適切に設定された絶対パスまたは相対パスが
     入っていなくてはなりません。

     `execle()'、 `execlpe()'、 `execve()'、 および `execvpe()'
     (全て末尾に`e' がついていること に注意してください) では、ENV
     パラメタは新たなプロセスで利用
     される環境変数を定義するためのマップ型でなくてはなりません;
     `execl()'、`execlp()'、 `execv()'、 および `execvp()'
     では、全て新たなプロセスは現在のプロセス の環境を引き継ぎます。
     利用できる環境: Macintosh、 UNIX、 Windows。

`_exit(n)'
     終了ステータス N でシステムを終了します。このとき
     クリーンアップハンドラの呼び出しや、標準入出力バッファの
     フラッシュなどは行いません。 利用できる環境: Macintosh、 UNIX、
     Windows。

     _Notice:_ システムを終了する標準的な方法は `sys.exit(N)'
     です。`_exit()' は通常、 `fork()' された後の子プロセス
     でのみ使われます。


以下の終了コードは必須ではありませんが `_exit()' と共に使うこと
ができます。一般に、 メールサーバの外部コマンド配送プログラムのような、
Python で書かれたシステムプログラムに使います。 _Note:_
いくらかの違いがあって、これらの全てが全ての UNIX プラットフォームで
使えるわけではありません。以下の定数は基礎にあるプラットフォームで
定義されていれば定義されます。

`EX_OK'
     エラーが起きなかったことを表す終了コード。 利用できる環境:
     Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_USAGE'
     誤った個数の引数が渡されたときなど、コマンドが間違って使われたことを表す
     終了コード。 利用できる環境: Macintosh、 UNIX。 _Added in Python
     version 2.3_

`EX_DATAERR'
     入力データが間違っていたことを表す終了コード。 利用できる環境:
     Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_NOINPUT'
     入力ファイルが存在しなかった、または、読み込み不可だったことを表す終了コード。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_NOUSER'
     指定されたユーザが存在しなかったことを表す終了コード。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_NOHOST'
     指定されたホストが存在しなかったことを表す終了コード。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_UNAVAILABLE'
     要求されたサービスが利用できないことを表す終了コード。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_SOFTWARE'
     内部ソフトウェアエラーが検出されたことを表す終了コード。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_OSERR'
     fork できない、pipe
     の作成ができないなど、オペレーティング・システム・エ
     ラーが検出されたことを表す終了コード。 利用できる環境: Macintosh、
     UNIX。 _Added in Python version 2.3_

`EX_OSFILE'
     システムファイルが存在しなかった、開けなかった、あるいはその他のエラーが
     起きたことを表す終了コード。 利用できる環境: Macintosh、 UNIX。
     _Added in Python version 2.3_

`EX_CANTCREAT'
     ユーザには作成できない出力ファイルを指定したことを表す終了コード。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_IOERR'
     ファイルの I/O を行っている途中にエラーが発生したときの終了コード。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_TEMPFAIL'
     一時的な失敗が発生したことを表す終了コード。これは、再試行可能な操作の途
     中に、ネットワークに接続できないというような、実際にはエラーではないかも
     知れないことを意味します。 利用できる環境: Macintosh、 UNIX。
     _Added in Python version 2.3_

`EX_PROTOCOL'
     プロトコル交換が不正、不適切、または理解不能なことを表す終了コード。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_NOPERM'
     操作を行うために十分な許可がなかった（ファイルシステムの問題を除く）こと
     を表す終了コード。 利用できる環境: Macintosh、 UNIX。 _Added in
     Python version 2.3_

`EX_CONFIG'
     設定エラーが起こったことを表す終了コード。 利用できる環境:
     Macintosh、 UNIX。 _Added in Python version 2.3_

`EX_NOTFOUND'
     "an entry was not found" のようなことを表す終了コード。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

`fork()'
     子プロセスを fork します。子プロセスでは `0' が返り、
     親プロセスでは子プロセスの id が返ります。 利用できる環境:
     Macintosh、 UNIX。

`forkpty()'
     子プロセスを fork します。このとき新しい擬似端末 (psheudo-terminal)
     を子プロセスの制御端末として使います。 親プロセスでは `(PID, FD)'
     からなるペアが返り、FD は擬似端末の マスタ側 (master end)
     のファイル記述子となります。可搬性のある
     アプローチを取るためには、`pty' モジュールを利用してください。
     利用できる環境: Macintosh、 いくつかの UNIX系。

`kill(pid, sig)'
     プロセス PID にシグナル SIG を送ります。
     ホストプラットフォームで利用可能なシグナルを特定する定数は
     `signal' モジュールで定義されています。 利用できる環境:
     Macintosh、 UNIX。

`killpg(pgid, sig)'
     プロセスグループ PGID にシグナル SIG を送ります。 利用できる環境:
     Macintosh、 UNIX。 _Added in Python version 2.3_

`nice(increment)'
     プロセスの "nice 値" に INCREMENT を加えます。新たな nice
     値を返します。 利用できる環境: Macintosh、 UNIX。

`plock(op)'
     プログラムのセグメント (program segment) をメモリ内でロックします。
     OP (`<sys/lock.h>' で定義されています) にはどのセグメントを
     ロックするかを指定します。 利用できる環境: Macintosh、 UNIX。

`popen(...)'

`popen2 ...'

`popen3 ...'

`popen4 ...'
     子プロセスを起動し、子プロセスとの通信のために開かれたパイプを返します。
     これらの関数は *Note ファイルオブジェクトの生成::
     節で記述されています。

`spawnl(mode, path, ...)'

`spawnle mode, path, ..., env'

`spawnlp mode, file, ...'

`spawnlpe mode, file, ..., env'

`spawnv mode, path, args'

`spawnve mode, path, args, env'

`spawnvp mode, file, args'

`spawnvpe mode, file, args, env'
     新たなプロセス内でプログラム PATH を実行します。 MODE が
     `P_NOWAIT' の場合、この関数は 新たなプロセスのプロセス ID
     となります。; MODE が `P_WAIT'
     の場合、子プロセスが正常に終了するとその終了コードが返ります。そうでない
     場合にはプロセスを kill したシグナル SIGNAL に対して `-SIGNAL'
     が返ります。Windows では、プロセス ID は
     実際にはプロセスハンドル値になります。

     `l' および `v' のついた `spawn*()'
     関数は、コマンドライン引数をどのように渡すかが異なります。 `l'
     型は、コードを書くときにパラメタ数が決まっている場合
     に、おそらくもっとも簡単に利用できます。個々のパラメタは単に
     `spawnl*()' 関数の追加パラメタとなります。`v' 型は、
     パラメタの数が可変の時に便利で、リストかタプルの引数が ARGS
     パラメタとして渡されます。どちらの場合も、子プロセスに渡す引数は
     動作させようとしているコマンドの名前から始まらなくてはなりません。

     末尾近くに `p' をもつ型 (`spawnlp()'、 `spawnlpe()'、 `spawnvp()'、
     および `spawnvpe()') は、プログラム FILE を探すために 環境変数
     `PATH' を利用します。環境変数が (次の段で述べる `spawn*e()'
     型関数で) 置き換えられる場合、環境変数は `PATH'
     を決定する上の情報源として使われます。 その他の型、`spawnl()'、
     `spawnle()'、 `spawnv()'、 および `spawnve()' では、実行
     コードを探すために `PATH' を使いません。 PATH
     には適切に設定された絶対パスまたは相対パスが
     入っていなくてはなりません。

     `spawnle()'、 `spawnlpe()'、 `spawnve()'、 および `spawnvpe()'
     (全て末尾に`e' がついていること に注意してください) では、ENV
     パラメタは新たなプロセスで利用
     される環境変数を定義するためのマップ型でなくてはなりません;
     `spawnl()'、`spawnlp()'、 `spawnv()'、 および `spawnvp()'
     では、全て新たなプロセスは現在のプロセス の環境を引き継ぎます。

     例えば、以下の `spawnlp()' および `spawnvpe()' 呼び出し:

          import os
          os.spawnlp(os.P_WAIT, 'cp', 'cp', 'index.html', '/dev/null')

          L = ['cp', 'index.html', '/dev/null']
          os.spawnvpe(os.P_WAIT, 'cp', L, os.environ)

     は等価です。利用できる環境: UNIX、Windows。

     `spawnlp()'、`spawnlpe()'、 `spawnvp()' および `spawnvpe()' は
     Windows では利用できません。 _Added in Python version 1.6_


`P_NOWAIT'

`P_NOWAITO'
     `spawn*()' 関数ファミリに対する MODE パラメタ
     として取れる値です。この値のいずれかを MODE として与えた場合、
     `spawn*()' 関数は新たなプロセスが生成されるとすぐに、 プロセスの
     ID を戻り値として返ります。 利用できる環境: Macintosh、
     UNIX、Windows。 _Added in Python version 1.6_

`P_WAIT'
     `spawn*()' 関数ファミリに対する MODE パラメタ
     として取れる値です。この値を MODE として与えた場合、 `spawn*()'
     関数は新たなプロセスを起動して完了するまで返らず、
     プロセスがうまく終了した場合には終了コードを、シグナルによってプロセス
     が kill された場合には `-SIGNAL' を返します。 利用できる環境:
     Macintosh、 UNIX、Windows。 _Added in Python version 1.6_

`P_DETACH'

`P_OVERLAY'
     `spawn*()' 関数ファミリに対する MODE パラメタ
     として取れる値です。これらの値は上の値よりもやや可搬性において劣って
     います。`P_DETACH' は `P_NOWAIT' に似ていますが、
     新たなプロセスは呼び出しプロセスのコンソールから切り離され (detach)
     ます。`P_OVERLAY' が使われた場合、現在のプロセスは
     置き換えられます; 従って`spawn*()' は返りません。 利用できる環境:
     Windows。 _Added in Python version 1.6_

`startfile(path[, operation])'
     ファイルを関連付けられたアプリケーションを使って「スタート」します。

     OPERATION が指定されないかまたは `'open'' であるとき、
     この動作は、 Windows の Explorer 上でのファイルをダブルクリックや、
     コマンドプロンプト (interactive command shell) 上での ファイル名を
     `start' 命令の引数としての実行と同様です:
     ファイルは拡張子が関連付けされているアプリケーション
     (が存在する場合) を使って開かれます。

     他の OPERATION
     が与えられる場合、それはファイルに対して何がなされるべきかを 表す
     "command verb" (コマンドを表す動詞) でなければなりません。
     Microsoft が文書化している動詞は、`'print'' と `'edit''
     (ファイルに対して) および `'explore'' と `'find''
     (ディレクトリに対して) です。

     `startfile()' は関連付けされたアプリケーションが起動すると
     同時に返ります。アプリケーションが閉じるまで待機させるためのオプション
     はなく、アプリケーションの終了状態を取得する方法もありません。
     PATH 引数は現在のディレクトリからの相対で表します。
     絶対パスを利用したいなら、最初の文字はスラッシュ (`/')
     ではないので注意してください; もし最初の文字がスラッシュ
     なら、システムの背後にある Win32 `ShellExecute()' 関数は
     動作しません。`os.path.normpath()' 関数を使って、Win32 用に
     正しくコード化されたパスになるようにしてください。 利用できる環境:
     Windows。 _Added in Python version 2.0_ _Added in Python version
     2.5_

`system(command)'
     サブシェル内でコマンド (文字列) を実行します。この関数は 標準 C
     関数 `system()' を使って実装されており、 `system()'
     と同じ制限があります。 `posix.environ'、 `sys.stdin'
     等に対する変更を行っても、
     実行されるコマンドの環境には反映されません。

     UNIXでは、戻り値はプロセスの終了ステータスで、`wait()'
     で定義されている書式にコード化されています。 POSIX は `system()'
     関数の戻り値の意味について定義して いないので、Python の `system'
     における戻り値はシステム依存と なることに注意してください。

     Windows では、戻り値は COMMAND を実行した後にシステムシェルから
     返される値で、Windows の環境変数 `COMSPEC' となります:
     `command.com' ベースのシステム (Windows 95, 98 および ME)
     では、この値は常に `0' です; `cmd.exe' ベースのシステム (Windows
     NT, 2000 および XP) では、この値は実行したコマンドの終了
     ステータスです;
     ネイティブでないシェルを使っているシステムについては、
     使っているシェルのドキュメントを参照してください。

     利用できる環境: Macintosh、 UNIX、 Windows。

`times()'
     (プロセスまたはその他の) 積算時間を秒で表す浮動小数点数からなる、
     5 要素のタプルを返します。タプルの要素は、ユーザ時間 (user time)、
     システム時間 (system time)、子プロセスのユーザ時間、子プロセスの
     システム時間、そして過去のある固定時点からの経過時間で、この順に
     並んでいます。UNIX マニュアルページ `times(2)' または 対応する
     Windows プラットフォーム API ドキュメントを参照してください。
     利用できる環境: Macintosh、UNIX、Windows。

`wait()'
     子プロセスの実行完了を待機し、子プロセスの pid
     と終了コードインジケータ -- 16
     ビットの数で、下位バイトがプロセスを kill
     したシグナル番号、上位バイト が終了ステータス
     (シグナル番号がゼロの場合) -- の入ったタプルを 返します;
     コアダンプファイルが生成された場合、下位バイトの最上桁ビットが
     立てられます。 利用できる環境: Macintosh、UNIX。

`waitpid(pid, options)'
     プロセス id PID で与えられた子プロセスの完了を待機し、
     子プロセスのプロセス id と(`wait()' と同様にコード化された)
     終了ステータスインジケータからなるタプルを返します。
     この関数の動作は OPTIONS によって影響されます。通常の操作では `0'
     にします。 利用できる環境: UNIX。

     PID が `0' よりも大きい場合、 `waitpid()'
     は特定のプロセスのステータス情報を要求します。PID が `0'
     の場合、現在のプロセスグループ内の任意の子プロセスの状態
     に対する要求です。PID が `-1' の場合、現在のプロセス
     の任意の子プロセスに対する要求です。PID が `-1' よりも
     小さい場合、プロセスグループ `-PID' (すなわち PID の 絶対値)
     内の任意のプロセスに対する要求です。

`wait3([options])'
     `waitpid()' に似ていますが、プロセス id を引数に取らず、
     子プロセス
     id、終了ステータスインジケータ、リソース使用情報の3要素からなるタプルを返します。
     リソース使用情報の詳しい情報は `resource'.`getrusage()'
     を参照してください。 OPTIONS は `waitpid()' および `wait4()'
     と同様です。 利用できる環境: UNIX。 _Added in Python version 2.5_

`wait4(pid, options)'
     `waitpid()' に似ていますが、 子プロセス
     id、終了ステータスインジケータ、リソース使用情報の3要素からなるタプルを返します。
     リソース使用情報の詳しい情報は `resource'.`getrusage()'
     を参照してください。 `wait4()' の引数は `waitpid()'
     に与えられるものと同じです。 利用できる環境: UNIX。 _Added in
     Python version 2.5_

`WNOHANG'
     子プロセス状態がすぐに取得できなかった場合に直ちに終了する
     ようにするための `waitpid()' のオプションです。 この場合、関数は
     `(0, 0)' を返します。 利用できる環境: Macintosh、UNIX。

`WCONTINUED'
     このオプションによって子プロセスは前回状態が報告された後にジョブ制御による停止状態から実行を継続された場合に報告されるようになります。
     利用できる環境: ある種の UNIX システム。 _Added in Python version
     2.3_

`WUNTRACED'
     このオプションによって子プロセスは停止されていながら停止されてから状態が報告されていない場合に報告されるようになります。
     利用できる環境: Macintosh、 UNIX。 _Added in Python version 2.3_

以下の関数は`system()'、 `wait()'、 あるいは`waitpid()'
が返すプロセス状態コード
を引数にとります。これらの関数はプロセスの配置を決めるために
利用することができます。

`WCOREDUMP(status)'
     プロセスに対してコアダンプが生成されていた場合には `True' を、
     それ以外の場合は `False' を返します。 利用できる環境: Macintosh、
     UNIX。 _Added in Python version 2.3_

`WIFCONTINUED(status)'
     プロセスがジョブ制御による停止状態から実行を継続された (continue)
     場合に `True' を、 それ以外の場合は `False' を返します。
     利用できる環境: UNIX。 _Added in Python version 2.3_

`WIFSTOPPED(status)'
     プロセスが停止された (stop) 場合に `True' を、 それ以外の場合は
     `False' を返します。 利用できる環境: UNIX。

`WIFSIGNALED(status)'
     プロセスがシグナルによって終了した (exit) 場合に `True' を、
     それ以外の場合は `False' を返します。 利用できる環境: Macintosh、
     UNIX。

`WIFEXITED(status)'
     プロセスが `exit(2)' システムコールで終了した場合に `True' を、
     それ以外の場合は `False' を返します。 利用できる環境:
     Macintosh、UNIX。

`WEXITSTATUS(status)'
     `WIFEXITED(STATUS)' が真の場合、`exit(2)' システム
     コールに渡された整数パラメタを返します。そうでない場合、
     返される値には意味がありません。 利用できる環境: Macintosh、UNIX。

`WSTOPSIG(status)'
     プロセスを停止させたシグナル番号を返します。 利用できる環境:
     Macintosh、UNIX。

`WTERMSIG(status)'
     プロセスを終了させたシグナル番号を返します。 利用できる環境:
     Macintosh、UNIX


File: python-lib-jp.info,  Node: 雑多なシステム情報,  Next: 雑多な関数,  Prev: プロセス管理,  Up: os

14.1.6 雑多なシステム情報
-------------------------

`confstr(name)'
     文字列形式によるシステム設定値 (system configuration
     value)を返します。 NAME には取得したい設定名を指定します; この値は
     定義済みのシステム値名を表す文字列にすることができます; 名前は
     多くの標準 (POSIX.1、 UNIX 95、 UNIX 98 その他)
     で定義されています。
     ホストオペレーティングシステムの関知する名前は `confstr_names'
     辞書のキーとして与えられています。
     このマップ型オブジェクトに入っていない設定 変数については、 NAME
     に整数を渡してもかまいません。 利用できる環境: Macintosh、UNIX。

     NAME に指定された設定値が定義されていない場合、`None' を返します。

     もし NAME が文字列でかつ不明である場合、 `ValueError'
     を送出します。NAME の指定値がホストシステムでサポートされておらず、
     `confstr_names' にも入っていない場合、`errno.EINVAL'
     をエラー番号として `OSError' を送出します。

`confstr_names'
     `confstr()' が受理する名前を、ホストオペレーティングシステムで
     定義されている整数値に対応付けている辞書です。
     この辞書はシステムでどの
     設定名が定義されているかを決定するために利用できます。
     利用できる環境: Macintosh、UNIX。

`getloadavg()'
     過去 1 分、5
     分、15分間で、システムで走っているキューの平均プロセス数を
     返します。平均負荷が得られない場合には `OSError' を送出します。

     _Added in Python version 2.3_

`sysconf(name)'
     整数値のシステム設定値を返します。 NAME
     で指定された設定値が定義されていない場合、`-1' が返されます。NAME
     に関するコメントとしては、`confstr()'
     で述べた内容が同様に当てはまります; 既知の設定名についての情報を
     与える辞書は `sysconf_names' で与えられています。 利用できる環境:
     Macintosh、UNIX。

`sysconf_names'
     `sysconf()' が受理する名前を、ホストオペレーティングシステムで
     定義されている整数値に対応付けている辞書です。
     この辞書はシステムでどの設定名が定義されているかを決定するために
     利用できます。 利用できる環境: Macintosh、UNIX。

以下のデータ値はパス名編集操作をサポートするために利用されます。
これらの値は全てのプラットフォームで定義されています。

パス名に対する高レベルの操作は `os.path' モジュールで 定義されています。

`curdir'
     現在のディレクトリ参照するためにオペレーティングシステムで使われる
     文字列定数です。 例: POSIX では `'.'' 、Mac OS 9 では`':'' 。
     `os.path' からも利用できます。

`pardir'
     親ディレクトリを参照するためにオペレーティングシステムで使われる
     文字列定数です。 例: POSIX では `'..'' 、Mac OS 9 では`'::'' 。
     `os.path' からも利用できます。

`sep'
     パス名を要素に分割するためにオペレーティングシステムで利用されている
     文字で、例えば POSIX では `/' で、Mac OS 9 では `:'
     です。しかし、このことを知っているだけではパス名を
     解析したり、パス名同士を結合したりするには不十分です --
     こうした操作には `os.path.split()' や `os.path.join()'
     を使ってください-- が、たまに便利なこともあります。 `os.path'
     からも利用できます。

`altsep'
     文字パス名を要素に分割する際にオペレーティングシステムで利用されるもう
     一つの文字で、分割文字が一つしかない場合には `None' になります。
     この値は `sep' がバックスラッシュとなっている DOS や Windows
     システムでは `/' に設定されています。 `os.path'
     からも利用できます。

`extsep'
     ベースのファイル名と拡張子を分ける文字。 たとえば、`os.py' では
     `.' です。 `os.path' からも利用できます。 _Added in Python version
     2.2_

`pathsep'
     (`PATH' のような) サーチパス内の要素を分割するために
     オペレーティングシステムが慣習的に用いる文字で、POSIX における `:'
     や DOS および Windows における `;' に相当します。 `os.path'
     からも利用できます。

`defpath'
     `exec*p*()' や `spawn*p*()' において、環境変数辞書内に `'PATH''
     キーがない場合に使われる標準設定のサーチパスです。 `os.path'
     からも利用できます。

`linesep'
     現在のプラットフォーム上で行を分割 (あるいは終端)
     するために用いられ ている文字列です。この値は例えば POSIX
     での`'\n'' や Mac OS での `'\r''
     のように、単一の文字にもなりますし、例えば DOS や Windows での
     `'\r\n'' のように複数の文字列にもなります。

`devnull'
     ヌルデバイス (null device) のファイルパスです。例えばPOSIX では
     `'/dev/null''、Mac OS 9 では`'Dev:Nul'' です。 この値は`os.path'
     からも利用できます。 _Added in Python version 2.4_


File: python-lib-jp.info,  Node: 雑多な関数,  Prev: 雑多なシステム情報,  Up: os

14.1.7 雑多な関数
-----------------

`urandom(n)'
     暗号に関する用途に適したN
     バイトからなるランダムな文字列を返します。

     この関数は OS
     固有の乱数発生源からランダムなバイト列を生成して返します。
     この関数の返すデータは暗号を用いたアプリケーションで十分利用できる程度に
     予測不能ですが、実際のクオリティは OS の実装によって異なります。
     UNIX系のシステムでは `/dev/urandom' への問い合わせを行い、 Windows
     では `CryptGenRandom' を使います。乱数発生源
     が見つからない場合、`NotImplementedError' を送出します。 _Added in
     Python version 2.4_


File: python-lib-jp.info,  Node: time,  Next: optparse,  Prev: os,  Up: 汎用オペレーティングシステムサービス

14.2 時刻データへのアクセスと変換
=================================

時刻データへのアクセスと変換

このモジュールでは、時刻に関するさまざまな関数を提供します。ほとんどの
関数が利用可能ですが、全ての関数が全てのプラットフォームで利用可能な
わけではありません。
このモジュールで定義されているほとんどの関数は、プラットフォーム上の
同名の C ライブラリ関数を呼び出します。これらの関数に対する意味付け
はプラットフォーム間で異なるため、プラットフォーム提供のドキュメント
を読んでおくと便利でしょう。

まずいくつかの用語の説明と慣習について整理します。

   * "エポック"("epoch")  は、
     時刻の計測がはじまった時点のことです。その年の 1 月 1 日の午前 0
     時に "エポックからの経過時間" が 0
     になるように設定されます。UNIXでは エポックは 1970
     年です。エポックがどうなっているかを知るには、 `gmtime(0)'
     の値を見るとよいでしょう。

   *
     このモジュールの中の関数は、エポック以前あるいは遠い未来の日付や時刻を
     扱うことができません。将来カットオフ（関数が正しく日付や時刻を扱えなく
     なる）が起きる時点は、C ライブラリによって決まります。
     UNIXではカットオフは通常 2038 です。

   * *2000年問題 (Y2K)*: Python はプラットフォームの C
     ライブラリに依存して います。C
     ライブラリは日付および時刻をエポックからの経過秒で表現する
     ので、一般的に 2000 年問題を持ちません。
     時刻を表現する`struct_time'（下記を参照してください）を入力として受け取る関数
     は一般的に 4
     桁表記の西暦年を要求します。以前のバージョンとの互換性の
     ために、モジュール変数 `accept2dyear' がゼロでない整数の場合、 2
     桁の西暦年をサポートします。この変数の初期値は環境変数 `PYTHONY2K'
     が空文字列のとき `1' に設定されます。空文字列
     でない文字列が設定されている場合、`0' に設定されます。こうして、
     `PYTHONY2K' を空文字列でない文字列に設定することで、西暦年の入力が
     すべて 4 桁の西暦年でなければならないようにすることができます。
     2桁の西暦年が入力された場合には、POSIX または X/Open
     標準に従って変換 されます: 69-99 の西暦年は 1969-1999 となり、0-68
     の西暦年は 2000-2068 に なります。100-1899
     は常に不正な値になります。この仕様は Python 1.5.2(a2)
     から新たに追加された機能であることに注意してください;
     それ以前のバージョン、すなわち Python 1.5.1 および 1.5.2a1
     では、1900 以下の年に対して 1900 を足します。

   * UTC  は協定世界時 (Coordinated Universal Time) のことです 

     (以前はグリニッジ標準時  または GMTとして知られていました)。 UTC の
     頭文字の並びは誤りではなく、英仏の妥協によるものです。

   * DST は夏時間 (Daylight Saving Time)  のことで、一年のうち部分的に
     1 時間 タイムゾーンを修正することです。DST のルールは不可思議で
     (局所的な法律 で定められています)、年ごとに変わることもあります。
     C ライブラリはローカルルールを記したテーブルを持っており
     (柔軟に対応
     するため、たいていはシステムファイルから読み込まれます)、この点に関して
     は唯一の真実の知識の源です。

   * 多くの現時刻を返す関数 (real-time functions)
     の精度は、値や引数を表現
     するのに使う単位から想像されるよりも低いかも知れません。
     例えば、ほとんどの UNIX システムで、クロックの一刹那 (ticks) の
     精度は 1 秒 の 50 から 100 分の 1 に過ぎません。また、Mac
     では時刻は 秒きっかりのとき以外正確ではありません。

   * 反対に、`time()' および `sleep()' は UNIX の
     同等の関数よりましな精度を持っています: 時刻は浮動小数点で表され、
     `time()' は可能なかぎり最も正確な時刻を (UNIX の `gettimeofday()'
     があればそれを使って) 返します。また `sleep()'
     にはゼロでない端数を与えることができます (UNIX の `select()'
     があれば、それを使って実装しています)。

   * `gmtime()'、`localtime()'、`strptime()' が返す時刻値、 および
     `asctime()'、`mktime()'、 `strftime()' に与える時刻値はどちらも 9
     つの整数からなる シーケンスです。

     Index                  Attribute              Values
     ------                 -----                  -----
     0                      `tm_year'              (例えば 1993)
     1                      `tm_mon'               [1,12] の間の数
     2                      `tm_mday'              [1,31] の間の数
     3                      `tm_hour'              [0,23] の間の数
     4                      `tm_min'               [0,59] の間の数
     5                      `tm_sec'               [0,61] の間の数
                                                   `strftime()'
                                                   の説明にある *(1)*
                                                   を読んで下さい
     6                      `tm_wday'              [0,6]
                                                   の間の数、月曜が 0
                                                   になります
     7                      `tm_yday'              [1,366] の間の数
     8                      `tm_isdst'             0, 1 または -1;
                                                   以下を参照してください

     C の構造体と違って、月の値が 0-11 でなく 1-12
     であることに注意してくだ さい。西暦年の値は上の "2000年問題 (Y2K)
     " で述べたように扱われます。 夏時間フラグを `-1' にして `mktime()'
     に渡すと、たいてい は正確な夏時間の状態を実現します。

     `struct_time' を引数とする関数に正しくない長さの`struct_time'や
     要素の型が正しくない`struct_time'を与えた場合には、`TypeError'
     が送出されます。

     _Changed in Python version 2.2_

このモジュールでは以下の関数とデータ型を定義します:

`accept2dyear'
     2
     桁の西暦年を使えるかを指定するブール型の値です。標準では真ですが、
     環境変数 `PYTHONY2K' が空文字列でない値に設定されている場合には
     偽になります。実行時に変更することもできます。

`altzone'
     ローカルの夏時間タイムゾーンにおける UTC
     からの時刻オフセットで、西に 行くほど増加する秒で表した値です
     (ほとんどの西ヨーロッパでは負になり、
     アメリカでは正、イギリスではゼロになります) 。 `daylight'
     がゼロでないときのみ使用してください。

`asctime([t])'
     `gmtime()' や `localtime()' が返す時刻を表現する タプル又は
     `struct_time'を、`'Sun Jun 20 23:21:05 1993'' といった書式の 24
     文字 の文字列に変換します。T が与えられていない場合には、
     `localtime()' が返す現在の時刻が使われます。 `asctime()'
     はロケール情報を使いません。 _Note:_ 同名の C
     の関数と違って、末尾には改行文字はありません。 _Changed in Python
     version 2.1_

`clock()'
     UNIXでは、現在のプロセッサ時間秒を浮動小数点数で返します。
     時刻の精度および "プロセッサ時間 (processor time)"  の定義そのものは同じ
     名前の C 関数に依存します。いずれにせよ、この関数は Python の
     ベンチマーク  や 計時アルゴリズムに使われています。

     Windows では、最初にこの関数が呼び出されてからの経過時間を
     wall-clock 秒で返します。この関数は Win32 関数
     `QueryPerformanceCounter()' に基づいていて、その精度 は通常 1
     マイクロ秒以下です。

`ctime([secs])'
     エポックからの経過秒数で表現された時刻を、ローカルの時刻を表現
     する文字列に変換します。SECS を指定しない、または `None'
     を指定した場合、`time()' が返す値を現在の時刻 として使います。
     `ctime(SECS)' は `asctime(localtime(SECS))' と同じです。`ctime()'
     はロケール情報を使いません。 _Changed in Python version 2.1_
     _Changed in Python version 2.4_

`daylight'
     DST タイムゾーンが定義されている場合ゼロでない値になります。

`gmtime([secs])'
     エポックからの経過時間で表現された時刻を、UTC における`struct_time'
     に変換します。このとき dst フラグは常にゼロとして扱われます。 SECS
     を指定しない、または`None' を指定した場合、 `time()'
     が返す値を現在の時刻として使います。
     秒の端数は無視されます。`struct_time'
     のレイアウトについては上を参照してください。 _Changed in Python
     version 2.1_ _Changed in Python version 2.4_

`localtime([secs])'
     `gmtime()' に似ていますが、ローカルタイムに変換します。 SECS
     を指定しない、または`None' を指定した場合、 `time()'
     が返す値を現在の時刻として使います。 現在の時刻に DST
     が適用される場合、 dst フラグは `1' に設定 されます。 _Changed in
     Python version 2.1_ _Changed in Python version 2.4_

`mktime(t)'
     `localtime()' の逆を行う関数です。引数は `struct_time'か 完全な 9
     つの要素 全てに値の入ったタプル (dst フラグも必要です;
     現在の時刻に DST が 適用されるか不明の場合には `-1'
     を使ってください) で、 UTC ではなく _ローカルの_ 時刻を指定します。
     `time()' との互換性のために浮動小数点数の値を返します。
     入力の値が正しい時刻で表現できない場合、例外`OverflowError' または
     `ValueError' が送出されます (どちらが送出されるかは Python および
     その下にある C ライブラリのどちらにとって無効な値が
     入力されたかで決まります) 。この関数で生成できる最も昔の時刻値は
     プラットフォームに依存します。

`sleep(secs)'
     与えられた秒数の間実行を停止します。より精度の高い実行停止時間を指定
     するために、引数は浮動小数点にしてもかまいません。何らかのシステム
     シグナルがキャッチされた場合、それに続いてシグナル処理ルーチンが実行
     され、 `sleep()' を停止してしまいます。従って実際の実行停止
     時間は要求した時間よりも短くなるかもしれません。また、システムが
     他の処理をスケジューリングするために、実行停止時間が要求した時間よりも
     多少長い時間になることもあります。

`strftime(format[, t])'
     `gmtime()' や `localtime()' が返す時刻値タプル
     又は`struct_time'を、 FORMAT で指定した文字列形式に変換します。 T
     が与えられていない場合、`localtime()' が返す
     現在の時刻が使われます。FORMAT は文字列でなくてはなりません。 T
     のいずれかのフィールドが許容範囲外の数値であった場合、
     `ValueError' を送出します。 _Changed in Python version 2.1_
     _Changed in Python version 2.4_ _Changed in Python version 2.5_

     FORMAT 文字列には以下の指示語 (directive) を埋め込むことが
     できます。これらはフィールド長や精度のオプションを付けずに表され、
     `strftime()' の結果の対応する文字列と入れ替えられます:

     Directive              Meaning                Notes
     ------                 -----                  -----
     %a                     ロケールにおける省略形の曜日名。
     %A                     ロケールにおける省略なしの曜日名。
     %b                     ロケールにおける省略形の月名。
     %B                     ロケールにおける省略なしの月名。
     %c                     ロケールにおける適切な日付および時刻表現。
     %d                     月の始めから何日目かを表す
                            10 進数 [01,31]。      
     %H                     (24 時間計での)        
                            時を表す 10 進数       
                            [00,23]。              
     %I                     (12 時間計での)        
                            時を表す 10 進数       
                            [01,12]。              
     %j                     年の初めから何日目かを表す
                            10 進数 [001,366]。    
     %m                     月を表す 10 進数       
                            [01,12]。              
     %M                     分を表す 10 進数       
                            [00,59]。              
     %p                     ロケールにおける AM    (1)
                            または PM              
                            に対応する文字列。     
     %S                     秒を表す 10 進数       (2)
                            [00,61]。              
     %U                     年の初めから何週目か   (3)
                            (日曜を週の始まりとします)を表す
                            10 進数                
                            [00,53]。年が明けてから最初の日曜日までの全ての
                            曜日は 0               
                            週目に属すると見なされます。
     %w                     曜日を表す 10 進数     
                            [0(日曜日),6]。        
     %W                     年の初めから何週目か   (3)
                            (日曜を週の始まりとします)を表す
                            10 進数                
                            [00,53]。年が明けてから最初の月曜日までの全ての
                            曜日は 0               
                            週目に属すると見なされます。
     %x                     ロケールにおける適切な日付の表現。
     %X                     ロケールにおける適切な時刻の表現。
     %y                     上 2                   
                            桁なしの西暦年を表す   
                            10 進数 [00,99]。      
     %Y                     上 2                   
                            桁付きの西暦年を表す   
                            10 進数。              
     %Z                     タイムゾーンの名前     
                            (タイムゾーンがない場合には空文字列)。
     %%                     文字 `%' 自体の表現。  

     注意:

    `(1)'
          `strptime()' 関数で使う場合、`%p' ディレクティブが
          出力結果の時刻フィールドに影響を及ぼすのは、時刻を解釈するために
          `%I' を使ったときのみです。

    `(2)'
          値の幅は間違いなく `0' to `61' です; これはうるう秒と、
          （ごく稀ですが）2 重のうるう秒のためのものです。

    `(3)'
          `strptime()' 関数で使う場合、`%U' および `%W'
          を計算に使うのは曜日と年を指定したときだけです。

     以下に RFC 2822 インターネット電子メール標準で定義されている日付
     表現と互換の書式の例を示します。 (1)

          >>> from time import gmtime, strftime
          >>> strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime())
          'Thu, 28 Jun 2001 14:17:15 +0000'

     いくつかのプラットフォームではさらにいくつかの指示語がサポートされて
     いますが、標準 ANSI C で意味のある値はここで列挙したものだけです。

     いくつかのプラットフォームでは、フィールドの幅や精度を指定する
     オプションが以下のように指示語の先頭の文字 `%' の直後に
     付けられるようになっていました; この機能も移植性はありません。
     フィールドの幅は通常 2 ですが、`%j' は例外で 3 です。

`strptime(string[, format])'
     時刻を表現する文字列をフォーマットに従って解釈します。返される値は
     `gmtime()' や `localtime()' が返すような`struct_time' です。FORMAT
     パラメタは `strftime()' で使うものと 同じ指示語を使います;
     このパラメタの値はデフォルトでは `"%a %b %d %H:%M:%S %Y"'
     で、`ctime()' が 返すフォーマットに一致します。 STRING が FORMAT
     に従って解釈できなかった場合、 例外 `ValueError' が送出されます。
     解析しようとする文字列が解析後に余分なデータを持っていた場合、
     `ValueError'
     が送出されます。欠落したデータについて、適切な値を推測できない
     場合はデフォルトの値で埋められ、その値は `(1900, 1, 1, 0, 0, 0, 0,
     1, -1)' です。

     `%Z' 指示語へのサポートは `tzname' に収められている値と `daylight'
     が真かどうかで決められます。このため、常に既知の
     (かつ夏時間でないと考えられている) UTC や GMT を認識する時以外は
     プラットフォーム固有の動作になります。

`struct_time'
     `gmtime()'、`localtime()' および `strptime()'
     が返す時刻値シーケンスのタイプです。 _Added in Python version 2.2_

`time()'
     時刻を浮動小数点数で返します。単位は UTC
     におけるエポックからの秒数です。
     時刻は常に浮動小数点で返されますが、全てのシステムが 1
     秒より高い精度で
     時刻を提供するとは限らないので注意してください。この関数が返す値は通常
     減少していくことはありませんが、この関数を 2
     回呼び出し、呼び出しの間に
     システムクロックの時刻を巻き戻して設定した場合には、以前の呼び出しよりも
     低い値が返ることもあります。

`timezone'
     (DST でない) ローカルタイムゾーンの UTC
     からの時刻オフセットで、西に 行くほど増加する秒で表した値です
     (ほとんどの西ヨーロッパでは負になり、
     アメリカでは正、イギリスではゼロになります) 。

`tzname'
     二つの文字列からなるタプルです。最初の要素は DST でないローカルの
     タイムゾーン名です。ふたつめの要素は DST のタイムゾーンです。 DST
     のタイムゾーンが定義されていない場合。二つ目の文字列を使うべきでは
     ありません。

`tzset()'
     ライブラリで使われている時刻変換規則をリセットします。
     どのように行われるかは、環境変数 `TZ' で指定されます。 _Added in
     Python version 2.3_

     利用できるシステム: UNIX。

     _Notice:_ 多くの場合、環境変数 `TZ' を変更すると、`tzset' を
     呼ばない限り `localtime' のような関数の出力に影響を
     及ぼすため、値が信頼できなくなってしまいます。

     `TZ' 環境変数には空白文字を含めてはなりません。

     環境変数 `TZ' の標準的な書式は以下です:
     (分かりやすいように空白を入れています)
        * std offset [dst [offset [,start[/time], end[/time]]]]

     各値は以下のようになっています:

        * std と dst
          三文字またはそれ以上の英数字で、タイムゾーンの略称を与えます。
          この値は time.tzname になります。

        * offset オフセットは形式: +- hh[:mm[:ss]] をとります。
          この表現は、UTC 時刻にするためにローカルな時間に加算する必要の
          ある時間値を示します。'-' が先頭につく場合、そのタイムゾーンは
          本子午線 (Prime Meridian) より東側にあります; それ以外の場合は
          本子午線の西側です。オフセットが dst の後ろに続かない場合、
          夏時間は標準時より一時間先行しているものと仮定します。

        * start[/time ,end[/time]] いつ DST に移動し、DST
          から戻ってくるかを示します。開始および終了
          日時の形式は以下のいずれかです:

             * JN ユリウス日 (Julian day) N (1 <= N <= 365) を表します。
               うるう日は計算に含められないため、2 月 28 日は常に 59
               で、 3 月 1 日は 60 になります。

             * N ゼロから始まるユリウス日 (0 <= N <= 365)
               です。うるう日は 計算に含められるため、2 月 29
               日を参照することができます。

             * MM.N.D M 月の第 N 週における D 番目の日 (0 <= D <= 6, 1
               <= N <= 5,  1 <= M <= 12) を表します。週 5
               は月における最終週の D 番目の日を表し、 第 4 週か第 5
               週のどちらかになります。週 1 は日 D が最初に
               現れる日を指します。日 0 は日曜日です。

          時間はオフセットと同じで、先頭に符号 ('-' や '+')
          を付けてはいけない
          ところが違います。時刻が指定されていなければ、デフォルトの値
          02:00:00 になります。

          >>> os.environ['TZ'] = 'EST+05EDT,M4.1.0,M10.5.0'
          >>> time.tzset()
          >>> time.strftime('%X %x %Z')
          '02:07:36 05/08/03 EDT'
          >>> os.environ['TZ'] = 'AEST-10AEDT-11,M10.5.0,M3.5.0'
          >>> time.tzset()
          >>> time.strftime('%X %x %Z')
          '16:08:12 05/08/03 AEST'

     多くの UNIX システム (*BSD, Linux, Solaris, および Darwin を含む)
     では、システムの zoneinfo  (`tzfile(5)') データベース
     を使ったほうが、タイムゾーンごとの規則を指定する上で便利です。
     これを行うには、必要なタイムゾーンデータファイルへのパスを
     システムの 'zoneinfo' タイムゾーンデータベースからの相対で表した値
     を環境変数 `TZ' に設定します。システムの 'zoneinfo' は
     通常`/usr/share/zoneinfo' にあります。例えば、 `'US/Eastern''、
     `'Australia/Melbourne''、 `'Egypt'' ないし `'Europe/Amsterdam''
     と指定します。

          >>> os.environ['TZ'] = 'US/Eastern'
          >>> time.tzset()
          >>> time.tzname
          ('EST', 'EDT')
          >>> os.environ['TZ'] = 'Egypt'
          >>> time.tzset()
          >>> time.tzname
          ('EET', 'EEST')


See also:
     *Note datetime:: 日付と時刻に対する、
     よりオブジェクト指向のインタフェースです。 *Note locale::
     国際化サービス。ロケールの設定は `time'
     モジュールのいくつかの関数が返す値に影響をおよぼすことがあります。
     *Note calendar:: 一般的なカレンダー関連の関数。   `timegm()'
     はこのモジュールの `gmtime()' の逆の操作を行います。

---------- Footnotes ----------

(1)  現在では `%Z' の利用は推奨されていません。しかし
ここで実現したい時間及び分オフセットへの展開を行ってくれる `%Z'
エスケープは全ての ANSI C
ライブラリでサポートされているわけではありません。 また、オリジナルの
1982 年に提出された RFC 822 標準は西暦年の表現を 2 桁
と要求しています(%Y でなく%y )。しかし実際には 2000 年になるだいぶ
以前から 4 桁の西暦年表現に移行しています。4 桁の西暦年表現は RFC 2822 に
おいて義務付けられ、伴って RFC 822 での取り決めは撤廃されました。


File: python-lib-jp.info,  Node: optparse,  Next: getopt,  Prev: time,  Up: 汎用オペレーティングシステムサービス

14.3 より強力なコマンドラインオプション解析器
=============================================

より便利で柔軟性に富んだ強力なコマンドライン解析ライブラリ _Added in
Python version 2.3_

`optparse' モジュールは、`getopt' よりも簡便で、柔軟性に富み、
かつ強力なコマンドライン解析ライブラリです。 `optparse'
では、より明快なスタイルのコマンドライン解析手法、
すなわち`OptionParser' のインスタンスを作成してオプションを
追加してゆき、そのインスタンスでコマンドラインを解析するという手法を
とっています。`optparse' を使うと、GNU/POSIX 構文でオプションを
指定できるだけでなく、使用法やヘルプメッセージの生成も行えます。

`optparse' を使った簡単なスクリプト例を以下に示します:
     from optparse import OptionParser

     [...]
     parser = OptionParser()
     parser.add_option("-f", "--file", dest="filename",
                       help="write report to FILE", metavar="FILE")
     parser.add_option("-q", "--quiet",
                       action="store_false", dest="verbose", default=True,
                       help="don't print status messages to stdout")

     (options, args) = parser.parse_args()

このようにわずかな行数のコードによって、スクリプトのユーザは
コマンドライン上で例えば以下のような 「よくある使い方」
を実行できるように なります:
     <yourscript> --file=outfile -q

コマンドライン解析の中で、`optparse' はユーザの指定した
コマンドライン引数値に応じて`parse{_}args()' の返す `options'
の属性値を設定してゆきます。 `parse{_}args()'
がコマンドライン解析から処理を戻したとき、 `options.filename'
は`"outfile"' に、`options.verbose' は `False'
になっているはずです。`optparse' は
長い形式と短い形式の両方のオプション表記をサポートしており、
短い形式は結合して指定できます。また、様々な形でオプションに
引数値を関連付けられます。従って、以下のコマンドラインは全て上の例
と同じ意味になります:

     <yourscript> -f outfile --quiet
     <yourscript> --quiet --file outfile
     <yourscript> -q -foutfile
     <yourscript> -qfoutfile

さらに、ユーザが

     <yourscript> -h
     <yourscript> --help

のいずれかを実行すると、`optparse' はスクリプトの
オプションについて簡単にまとめた内容を出力します:

     usage: <yourscript> [options]

     options:
       -h, --help            show this help message and exit
       -f FILE, --file=FILE  write report to FILE
       -q, --quiet           don't print status messages to stdout

_yourscript_ の中身は実行時に決まります (通常は `sys.argv{[}0]'
になります)。

* Menu:

* Background::
* Tutorial::
* リファレンスガイド::
* オプション処理コールバック::
* optparse の拡張::


File: python-lib-jp.info,  Node: Background,  Next: Tutorial,  Prev: optparse,  Up: optparse

14.3.1 Background
-----------------

`optparse' は、素直で慣習に則ったコマンドラインインタフェースを
備えたプログラムの作成を援助する目的で設計されました。 その結果、UNIX
で慣習的に使われているコマンドラインの構文や機能
だけをサポートするに留まっています。こうした慣習に詳しくなければ、
よく知っておくためにもこの節を読んでおきましょう。

* Menu:

* Terminology::
* オプションとは何か::
* 固定引数とは何か::


File: python-lib-jp.info,  Node: Terminology,  Next: オプションとは何か,  Prev: Background,  Up: Background

14.3.1.1 Terminology
....................

`引数 (argument)'
     コマンドラインでユーザが入力するテキストの塊で、シェルが `execl()'
     や `execv()' に引き渡すものです。Python では、引数は
     `sys.argv[1:]' の要素となります。(`sys.argv[0]'
     は実行しようとしているプログラムの名前です。引数解析に関しては、この要
     素はあまり重要ではありません。) UNIX シェルでは、 「語 (word)」 と
     いう用語も使います。

     場合によっては `sys.argv[1:]' 以外の引数リストを代入する方が望ま
     しいことがあるので、「引数」 は 「`sys.argv[1:]' または
     `sys.argv[1:]' の代替として提供される別のリストの要素」と読むべき
     でしょう。

`オプション (option)'
     追加的な情報を与えるための引数で、プログラムの実行に対する教示やカスタ
     マイズを行います。オプションには多様な文法が存在します。伝統的な
     UNIX における書法はハイフン ("-") の後ろに一文字が続くもので、例
     えば `"-x"' や `"-F"' です。また、伝統的な UNIX における
     書法では、複数のオプションを一つの引数にまとめられます。例えば
     `"-x -F"' は`"-xF"' と等価です。 GNU プロジェクトでは `"-{}-"'
     の後ろにハイフンで区切りの語を指定 する方法、例えば `"-{}-file"'
     や `"-{}-dry-run"' も提供して います。`optparse'
     は、これら二種類のオプション書法だけをサポー トしています。

     他に見られる他のオプション書法には以下のようなものがあります:
        * {} ハイフンの後ろに数個の文字が続くもので、例えば `"-pf"'
          (このオプションは複数のオプションを一つにまとめたものとは
          _違います_)

        * {} ハイフンの後ろに語が続くもので、例えば `"-file"'
          (これは技術的には上の書式と同じですが、通常同じプログラム上で一緒に
          使うことはありません)

        * {}
          プラス記号の後ろに一文字、数個の文字、または語を続けたもので、
          例えば `"+f"' 、 `"+rgb"'

        * {}
          スラッシュ記号の後ろに一文字、数個の文字、または語を続けたもので、
          例えば `"/f"' 、 `"/file"'

     上記のオプション書法は `optparse' ではサポートしておらず、
     今後もサポートする予定はありません。これは故意によるものです:
     最初の三つはどの環境の標準でもなく、最後の一つは VMS や MS-DOS,
     そして Windows を対象にしているときにしか意味をなさないからです。

`オプション引数 (option argument)'
     あるオプションの後ろに続く引数で、そのオプションに密接な関連を
     もち、オプションと同時に引数リストから取り出されます。 `optparse'
     では、オプション引数は以下のように別々の引数にできます:
          -f foo
          --file foo

     また、一つの引数中にも入れられます:
          -ffoo
          --file=foo

     通常、オプションは引数をとることもとらないこともあります。
     あるオプションは引数をとることがなく、またあるオプションは
     常に引数をとります。多くの人々が 「オプションのオプション引数」
     機能を欲しています。これは、あるオプションが引数が指定されている
     場合には引数をとり、そうでない場合には引数をもたないようにするという機能です。
     この機能は引数解析をあいまいにするため、議論の的となっています:
     例えば、もし `-a' がオプション引数を とり、`-b'
     がまったく別のオプションだとしたら、 `-ab'
     をどうやって解析すればいいのでしょうか？
     こうした曖昧さが存在するため、`optparse'
     は今のところこの機能をサポートしていません。

`固定引数 (positional argument)'
     他のオプションが解析される、すなわち他のオプションとその引数が
     解析されて引数リストから除去された後に引数リストに置かれている
     ものです。

`必須のオプション (required option)'
     コマンドラインで与えなければならないオプションです;
     「必須なオプション (required
     option)」という語は、英語では矛盾した言葉です。`optparse'
     では必須オプションの実装を妨げてはいませんが、とりたてて実装上役立つこともしていません。
     `optparse' で必須オプションを実装する方法は、`optparse'
     ソースコード配布物中の`examples/required{_}1.py' や
     `examples/required{_}2.py' を参照してください。

例えば、下記のような架空のコマンドラインを考えてみましょう:
     prog -v --report /tmp/report.txt foo bar

`"-v"' と`"-{}-report"' はどちらもオプションです。 `--report'
オプションが引数をとるとすれば、 `"/tmp/report.txt"'
はオプションの引数です。 `"foo"'と`"bar"' は固定引数になります。


File: python-lib-jp.info,  Node: オプションとは何か,  Next: 固定引数とは何か,  Prev: Terminology,  Up: Background

14.3.1.2 オプションとは何か
...........................

オプションはプログラムの実行を調整したり、カスタマイズしたりするための補助的な
情報を与えるために使います。もっとはっきりいうと、オプションはあくまでもオプション
(省略可能)であるということです。本来、プログラムはともかくもオプションなしでうまく
実行できてしかるべきです。(UNIX やGNU
ツールセットのプログラムをランダムに
ピックアップしてみてください。オプションを全く指定しなくてもちゃんと動くでしょう？
例外は`find', `tar', `dd' くらいです--これらの例外は、
オプション文法が標準的でなく、インタフェースが混乱を招くと酷評されてきた変種の
はみ出しものなのです)

多くの人が自分のプログラムに「必須のオプション」を持たせたいと考えます。しかし
よく考えてください。必須なら、それは_オプション(省略可能)
ではないのです！_
プログラムを正しく動作させるのに絶対的に必要な情報があるとすれば、そこには
固定引数を割り当てるべきなのです。

良くできたコマンドラインインタフェース設計として、ファイルのコピーに使われる
`cp' ユーティリティのことを考えてみましょう。ファイルのコピーでは、
コピー先を指定せずにファイルをコピーするのは無意味な操作ですし、少なくとも一つの
コピー元が必要です。従って、`cp' は引数無しで実行すると失敗します。
とはいえ、`cp' はオプションを全く必要としない柔軟で便利なコマンドライン
文法を備えています:
     cp SOURCE DEST
     cp SOURCE ... DEST-DIR

まだあります。ほとんどの `cp'
の実装では、ファイルモードや変更時刻を変えずに
コピーする、シンボリックリンクの追跡を行わない、すでにあるファイルを上書きする前に
ユーザに尋ねる、など、ファイルをコピーする方法をいじるための一連のオプションを実装
しています。しかし、こうしたオプションは、一つのファイルを別の場所にコピーする、
または複数のファイルを別のディレクトリにコピーするという、`cp'
の中心的な処理 を乱すことはないのです。


File: python-lib-jp.info,  Node: 固定引数とは何か,  Prev: オプションとは何か,  Up: Background

14.3.1.3 固定引数とは何か
.........................

固定引数とは、プログラムを動作させる上で絶対的に必要な情報となる引数です。

よいユーザインタフェースとは、可能な限り少ない固定引数をもつものです。
プログラムを正しく動作させるために 17 個もの別個の情報が必要だとしたら、
その_方法_ はさして問題にはなりません --ユーザはプログラムを正しく
動作させられないうちに諦め、立ち去ってしまうからです。
ユーザインタフェースがコマンドラインでも、設定ファイルでも、GUI
やその他の 何であっても同じです:
多くの要求をユーザに押し付ければ、ほとんどのユーザはただ
音をあげてしまうだけなのです。

要するに、ユーザが絶対に提供しなければならない情報だけに制限する --
そして可能な限りよく練られたデフォルト設定を使うよう試みてください。
もちろん、プログラムには適度な柔軟性を持たせたいとも望むはずですが、
それこそがオプションの果たす役割です。繰り返しますが、設定ファイルのエントリ
であろうが、 GUI
でできた「環境設定」ダイアログ上のウィジェットであろうが、
コマンドラインオプションであろうが関係ありません --
より多くのオプションを実装すればプログラムはより柔軟性を持ちますが、
実装はより難解になるのです。高すぎる柔軟性はユーザを閉口させ、コードの維持を
より難しくするのです。


File: python-lib-jp.info,  Node: Tutorial,  Next: リファレンスガイド,  Prev: Background,  Up: optparse

14.3.2 Tutorial
---------------

`optparse' はとても柔軟で強力でありながら、ほとんどの場合には簡単に利用
できます。この節では、`optparse' ベースのプログラムで広く使われて
いるコードパターンについて述べます。

まず、`OptionParser' クラスを import しておかねばなりません。
次に、プログラムの冒頭で `OptionParser' インスタンスを生成しておきます:

     from optparse import OptionParser
     [...]
     parser = OptionParser()

これでオプションを定義できるようになりました。基本的な構文は以下の通りです:
     parser.add_option(opt_str, ...,
                       attr=value, ...)

各オプションには、`"-f"' や`"-{}-file"' のような一つまたは複数の
オプション文字列と、パーザがコマンドライン上のオプションを見つけた際に、
何を準備し、何を行うべきかを`optparse' に教えるためのオプション属性
(option attribute)がいくつか入ります。

通常、各オプションには短いオプション文字列と長いオプション文字列があります。
例えば:
     parser.add_option("-f", "--file", ...)

といった具合です。

オプション文字列は、(ゼロ文字の場合も含め)いくらでも短く、またいくらでも長く
できます。ただしオプション文字列は少なくとも一つなければなりません。

`add{_}option()' に渡されたオプション文字列は、実際にはこの
関数で定義したオプションに対するラベルになります。簡単のため、以後では
コマンドライン上で_オプションを見つける_
という表現をしばしば使いますが、 これは実際には`optparse'
がコマンドライン上の_オプション文字列_
を見つけ、対応づけされているオプションを捜し出す、という処理に相当します。

オプションを全て定義したら、`optparse' にコマンドラインを解析するように
指示します:
     (options, args) = parser.parse_args()

(お望みなら、`parse{_}args()' に自作の引数リストを渡してもかまいません。
とはいえ、実際にはそうした必要はほとんどないでしょう: `optionparser'
はデフォルトで`sys.argv{[}1:]'を使うからです。)

`parse{_}args()' は二つの値を返します:
   * {} 全てのオプションに対する値の入ったオブジェクト`options' --
     例えば、 `"-{}-file"' が単一の文字列引数をとる場合、`options.file'
     は
     ユーザが指定したファイル名になります。オプションを指定しなかった場合には
     `None' になります。

   * {} オプションの解析後に残った固定引数からなるリスト`args'。


このチュートリアルの節では、最も重要な四つのオプション属性: `action',
`type', `dest' (destination), および `help'
についてしか触れません。このうち最も重要なのは`action' です。

* Menu:

* オプション・アクションを理解する::
* store アクション::
* ブール値 フラグ オプションの処理::
* その他のアクション::
* デフォルト値::
* ヘルプの生成::
* バージョン番号の出力::
* optparse のエラー処理法::
* 全てをつなぎ合わせる::


File: python-lib-jp.info,  Node: オプション・アクションを理解する,  Next: store アクション,  Prev: Tutorial,  Up: Tutorial

14.3.2.1 オプション・アクションを理解する
.........................................

アクション(action)は`optparse' が コマンドライン上にあるオプションを
見つけたときに何をすべきかを指示します。`optparse' には押し着せの
アクションのセットがハードコードされています。
新たなアクションの追加は上級者向けの話題であり、 *Note optparse
の拡張:: の「`optparse' の拡張」で触れます。
ほとんどのアクションは、値を何らかの変数に記憶するよう`optparse' に
指示します -- 例えば、文字列をコマンドラインから取り出して、`options' の
属性の中に入れる、といった具合にです。

オプション・アクションを指定しない場合、`optparse' のデフォルトの動作は
`store' になります。


File: python-lib-jp.info,  Node: store アクション,  Next: ブール値 フラグ オプションの処理,  Prev: オプション・アクションを理解する,  Up: Tutorial

14.3.2.2 store アクション
.........................

もっとも良く使われるアクションは `store' です。このアクションは
次の引数 (あるいは現在の引数の残りの部分)
を取り出し、正しい型の値か確かめ、
指定した保存先に保存するよう`optparse' に指示します。

例えば:
     parser.add_option("-f", "--file",
                       action="store", type="string", dest="filename")

のように指定しておき、偽のコマンドラインを作成して `optparse' に
解析させてみましょう:
     args = ["-f", "foo.txt"]
     (options, args) = parser.parse_args(args)

オプション文字列 `"-f"' を見つけると、`optparse' は次の 引数である
`"foo.txt"' を消費し、その値を `options.filename' に
保存します。従って、この`parse{_}args()'呼び出し後には
`options.filename' は`"foo.txt"'になっています。

オプションの型として、`optparse' は他にも`int' や`float'
をサポートしています。

整数の引数を想定したオプションの例を示します:
     parser.add_option("-n", type="int", dest="num")

このオプションには長い形式のオプション文字列がないため、設定に問題がないという
ことに注意してください。また、デフォルトのアクションは `store' なので、
ここでは action を明示的に指定していません。

架空のコマンドラインをもう一つ解析してみましょう。今度は、オプション引数を
オプションの右側にぴったりくっつけて一緒くたにします: `-n42'
(一つの引数のみ) は `-n 42' (二つの引数からなる) と等価になるので、

     (options, args) = parser.parse_args(["-n42"])
     print options.num

は `"42"' を出力します。

型を指定しない場合、 `optparse' は引数を`string' であると仮定します。
デフォルトのアクションが `store'
であることも併せて考えると、最初の例はもっと 短くなります:

     parser.add_option("-f", "--file", dest="filename")

保存先 (destination) を指定しない場合、 `optparse' はデフォルト値として
オプション文字列から気のきいた名前を設定します:
最初に指定した長い形式のオプション 文字列が`"-{}-foo-bar"'
であれば、デフォルトの保存先は `foo{_}bar'
になります。長い形式のオプション文字列がなければ、`optparse'
は最初に指定 した短い形式のオプション文字列を探します: 例えば、`"-f"'
に対する保存先は `f' になります。

`optparse' では、`long' や`complex' といった組み込み型も
取り入れています。型の追加は*Note optparse の拡張:: 節の 「`optparse'
の拡張」で触れています。


File: python-lib-jp.info,  Node: ブール値 フラグ オプションの処理,  Next: その他のアクション,  Prev: store アクション,  Up: Tutorial

14.3.2.3 ブール値 (フラグ) オプションの処理
...........................................

フラグオプション--特定のオプションに対して真または偽の値の値を設定するオプション--
はよく使われます。`optparse' では、二つのアクション、`store{_}true'
および `store{_}false' をサポートしています。例えば、 `verbose'
というフラグを`"-v"' で有効にして、`"-q"' で無効に したいとします:
     parser.add_option("-v", action="store_true", dest="verbose")
     parser.add_option("-q", action="store_false", dest="verbose")

ここでは二つのオプションに同じ保存先を指定していますが、全く問題ありません
(下記のように、デフォルト値の設定を少し注意深く行わねばならないだけです)

`"-v"' をコマンドライン上に見つけると、`optparse' は `options.verbose'
を `True' に設定します。`"-q"' を見つければ、`options.verbose' は
`False' にセットされます。


File: python-lib-jp.info,  Node: その他のアクション,  Next: デフォルト値,  Prev: ブール値 フラグ オプションの処理,  Up: Tutorial

14.3.2.4 その他のアクション
...........................

この他にも、`optparse' は以下のようなアクションをサポートしています:
``store{_}const''
     定数値を保存します。

``append''
     オプションの引数を指定のリストに追加します。

``count''
     指定のカウンタを 1 増やします。

``callback''
     指定の関数を呼び出します。

これらのアクションについては、*Note リファレンスガイド:: 節の
「リファレンスガイド」および*Note オプション処理コールバック:: 節の
「オプション・コールバック」で触れます。


File: python-lib-jp.info,  Node: デフォルト値,  Next: ヘルプの生成,  Prev: その他のアクション,  Up: Tutorial

14.3.2.5 デフォルト値
.....................

上記の例は全て、何らかのコマンドラインオプションが見つかった時に
何らかの変数 (保存先: destination) に値を設定していました。
では、該当するオプションが見つからなかった場合には何が起きるのでしょうか？
デフォルトは全く与えていないため、これらの値は全て `None' になります。
たいていはこれで十分ですが、もっときちんと制御したい場合もあります。
`optparse' では各保存先に対してデフォルト値を指定し、コマンドライン
の解析前にデフォルト値が設定されるようにできます。

まず、 verbose/quiet の例について考えてみましょう。`optparse' に
対して、`"-q"' がない限り `verbose' を `True' に設定
させたいなら、以下のようにします:

     parser.add_option("-v", action="store_true", dest="verbose", default=True)
     parser.add_option("-q", action="store_false", dest="verbose")

デフォルトの値は特定のオプションではなく _保存先_ に対して適用されます。
また、これら二つのオプションはたまたま同じ保存先を持っているにすぎないため、
上のコードは下のコードと全く等価になります:

     parser.add_option("-v", action="store_true", dest="verbose")
     parser.add_option("-q", action="store_false", dest="verbose", default=True)

下のような場合を考えてみましょう:
     parser.add_option("-v", action="store_true", dest="verbose", default=False)
     parser.add_option("-q", action="store_false", dest="verbose", default=True)

やはり`verbose' のデフォルト値は `True' になります;
特定の目的変数に対するデフォルト値として有効なのは、最後に指定した値だからです。

デフォルト値をすっきりと指定するには、`OptionParser' の
`set{_}defaults()' メソッドを使います。このメソッドは `parse{_}args()'
を呼び出す前ならいつでも使えます:
     parser.set_defaults(verbose=True)
     parser.add_option(...)
     (options, args) = parser.parse_args()

前の例と同様、あるオプションの値の保存先に対するデフォルトの値は最後に指定した
値になります。コードを読みやすくするため、デフォルト値を設定するときには両方のやり方
を混ぜるのではなく、片方だけを使うようにしましょう。


File: python-lib-jp.info,  Node: ヘルプの生成,  Next: バージョン番号の出力,  Prev: デフォルト値,  Up: Tutorial

14.3.2.6 ヘルプの生成
.....................

`optparse' にはヘルプと使い方の説明 (usage text) を生成する機能があり、
ユーザに優しいコマンドラインインタフェースを作成する上で役立ちます。
やらなければならないのは、各オプションに対する`help' の値と、
必要ならプログラム全体の使用法を説明する短いメッセージを与えることだけです。

ユーザフレンドリな (ドキュメント付きの) オプションを追加した
`OptionParser' を以下に示します:

     usage = "usage: %prog [options] arg1 arg2"
     parser = OptionParser(usage=usage)
     parser.add_option("-v", "--verbose",
                       action="store_true", dest="verbose", default=True,
                       help="make lots of noise [default]")
     parser.add_option("-q", "--quiet",
                       action="store_false", dest="verbose",
                       help="be vewwy quiet (I'm hunting wabbits)")
     parser.add_option("-f", "--filename",
                       metavar="FILE", help="write output to FILE"),
     parser.add_option("-m", "--mode",
                       default="intermediate",
                       help="interaction mode: novice, intermediate, "
                            "or expert [default: %default]")

`optparse' がコマンドライン上で`"-h"' や`"-{}-help"' を
見つけた場合やユーザが`parser.print{_}help()' を呼び出した場合、
この`OptionParser' は以下のようなメッセージを標準出力に出力します:

     usage: <yourscript> [options] arg1 arg2

     options:
       -h, --help            show this help message and exit
       -v, --verbose         make lots of noise [default]
       -q, --quiet           be vewwy quiet (I'm hunting wabbits)
       -f FILE, --filename=FILE
                             write output to FILE
       -m MODE, --mode=MODE  interaction mode: novice, intermediate, or
                             expert [default: intermediate]

(help オプションでヘルプを出力した場合、`optparse' は出力後に
プログラムを終了します。)

`optparse' ができるだけうまくメッセージを生成するよう手助けするには、
他にもまだまだやるべきことがあります:
   * {} スクリプト自体の利用法を表すメッセージを定義します:
          usage = "usage: %prog [options] arg1 arg2"

     `optparse' は `"{%}prog"' を現在のプログラム名、すなわち
     `os.path.basename(sys.argv{[}0{]})' と置き換えます。この文字列は
     詳細なオプションヘルプの前に展開され出力されます。

     usage の文字列を指定しない場合、`optparse' は型どおりとはいえ
     気の効いたデフォルト値、 `"usage: {%}prog {[}options{]}"' を
     使います。固定引数をとらないスクリプトの場合はこれで十分でしょう。

   * {}
     全てのオプションにヘルプ文字列を定義します。行の折り返しは気にしなくて
     かまいません -- `optparse' は行の折り返しに気を配り、見栄えの
     よいヘルプ出力を生成します。

   * {}
     オプションが値をとるということは自動的に生成されるヘルプメッセージの中で
     分かります。例えば、"mode" option の場合には:
          -m MODE, --mode=MODE

     のようになります。

     ここで "MODE" はメタ変数 (meta-variable) と呼ばれます: メタ変数は、
     ユーザが `-m'/`--mode' に対して指定するはずの
     引数を表します。デフォルトでは、`optparse' は保存先の変数名を
     大文字だけにしたものをメタ変数に使います。これは時として期待通りの結果に
     なりません -- 例えば、上の例の`--filename' オプションでは 明示的に
     `metavar="FILE"' を設定しており、その結果自動生成された
     オプション説明テキストは:
          -f FILE, --filename=FILE

     のようになります。

     この機能の重要さは、単に表示スペースを節約するといった理由にとどまりません:
     上の例では、手作業で書いたヘルプテキストの中でメタ変数として
     "FILE" を
     使っています。その結果、ユーザに対してやや堅苦しい表現の書法 "-f
     FILE" と、より平易に意味付けを説明した "write output to FILE"
     との間に
     対応があるというヒントを与えています。これは、エンドユーザにとってより明解で
     便利なヘルプテキストを作成する単純でありながら効果的な手法なのです。

   * {} デフォルト値を持つオプションのヘルプ文字列には`{%}default'
     を入れられ ます -- `optparse' は`{%}default' をデフォルト値の
     `str()' で置き換えます。該当するオプションにデフォルト値がない場合
     (あるいはデフォルト値が `None' である場合) `{%}default' の
     展開結果は `none' になります。



File: python-lib-jp.info,  Node: バージョン番号の出力,  Next: optparse のエラー処理法,  Prev: ヘルプの生成,  Up: Tutorial

14.3.2.7 バージョン番号の出力
.............................

`optparse' では、使用法メッセージと同様にプログラムのバージョン文字列を
出力できます。`OptionParser' の`version' 引数に文字列を渡します:
     parser = OptionParser(usage="%prog [-f] [-q]", version="%prog 1.0")

`"{%}prog"' はUSAGE と同じような展開を受けます。 その他にも`version'
には何でも好きな内容を入れられます。 `version'
を指定した場合、`optparse' は自動的に`"-{}-version"'
オプションをパーザに渡します。 コマンドライン中に`"-{}-version"'
が見つかると、`optparse' は`version' 文字列を展開して (`"{%}prog"'
を置き換えて) 標準出力に出力し、プログラムを終了します。

例えば、 `/usr/bin/foo' という名前のスクリプトなら:
     $ /usr/bin/foo --version
     foo 1.0

のようになります。


File: python-lib-jp.info,  Node: optparse のエラー処理法,  Next: 全てをつなぎ合わせる,  Prev: バージョン番号の出力,  Up: Tutorial

14.3.2.8 `optparse' のエラー処理法
..................................

`optparse' を使う場合に気を付けねばならないエラーには、
大きく分けてプログラマ側のエラーとユーザ側のエラーという二つの種類があります。
プログラマ側のエラーの多くは、例えば不正なオプション文字列や定義されていない
オプション属性の指定、あるいはオプション属性を指定し忘れるといった、
誤った`parser.add{_}option()' 呼び出しによるものです。
こうした誤りは通常通りに処理されます。すなわち、例外(`optparse.OptionError'
や `TypeError') を送出して、プログラムをクラッシュさせます。
もっと重要なのはユーザ側のエラーの処理です。というのも、ユーザの操作エラーという
ものはコードの安定性に関係なく起こるからです。 `optparse'
は、誤ったオプション引数の指定 (整数を引数にとるオプション `-n'
に対して `"-n4x"' と指定してしまうなど) や、引数を 指定し忘れた場合
(`-n' が何らかの引数をとるオプションであるのに、 `"-n"'
が引数の末尾に来ている場合) といった、ユーザによるエラーを自動的に
検出します。また、アプリケーション側で定義されたエラー条件が起きた場合、
`parser.error()' を呼び出してエラーを通知できます:

     (options, args) = parser.parse_args()
     [...]
     if options.a and options.b:
         parser.error("options -a and -b are mutually exclusive")

いずれの場合にも `optparse' はエラーを同じやり方で処理します。すなわち、
プログラムの使用法メッセージとエラーメッセージを標準エラー出力に出力して、
終了ステータス 2 でプログラムを終了させます。

上に挙げた最初の例、すなわち整数を引数にとるオプションにユーザが `"4x"'
を 指定した場合を考えてみましょう:

     $ /usr/bin/foo -n 4x
     usage: foo [options]

     foo: error: option -n: invalid integer value: '4x'

値を全く指定しない場合には、以下のようになります:
     $ /usr/bin/foo -n
     usage: foo [options]

     foo: error: -n option requires an argument

`optparse' は、常にエラーを引き起こしたオプションについて説明の入った
エラーメッセージを生成するよう気を配ります; 従って、`parser.error()' を
アプリケーションコードから呼び出す場合にも、同じようなメッセージになるように
してください。

`optparse' のデフォルトのエラー処理動作が気に入らないのなら、
`OptionParser' をサブクラス化して、`exit()' かつ/または `error()'
をオーバライドする必要があります。


File: python-lib-jp.info,  Node: 全てをつなぎ合わせる,  Prev: optparse のエラー処理法,  Up: Tutorial

14.3.2.9 全てをつなぎ合わせる
.............................

`optparse' を使ったスクリプトは、通常以下のようになります:
     from optparse import OptionParser
     [...]
     def main():
         usage = "usage: %prog [options] arg"
         parser = OptionParser(usage)
         parser.add_option("-f", "--file", dest="filename",
                           help="read data from FILENAME")
         parser.add_option("-v", "--verbose",
                           action="store_true", dest="verbose")
         parser.add_option("-q", "--quiet",
                           action="store_false", dest="verbose")
         [...]
         (options, args) = parser.parse_args()
         if len(args) != 1:
             parser.error("incorrect number of arguments")
         if options.verbose:
             print "reading %s..." % options.filename
         [...]

     if __name__ == "__main__":
         main()


File: python-lib-jp.info,  Node: リファレンスガイド,  Next: オプション処理コールバック,  Prev: Tutorial,  Up: optparse

14.3.3 リファレンスガイド
-------------------------

* Menu:

* Creating the parser::
* パーザへのオプション追加::
* オプションの定義::
* 標準的なオプション・アクション::
* オプション属性::
* 標準のオプション型::
* 引数の解析::
* オプション解析器への問い合わせと操作::
* オプション間の衝突::
* クリーンアップ::
* その他のメソッド::


File: python-lib-jp.info,  Node: Creating the parser,  Next: パーザへのオプション追加,  Prev: リファレンスガイド,  Up: リファレンスガイド

14.3.3.1 Creating the parser
............................

`optparse' を使う最初の一歩は OptionParser インスタンスを作ることです。
     parser = OptionParser(...)

OptionParser のコンストラクタの引数はどれも必須ではありませんが、いくつ
ものキーワード引数がオプションとして使えます。これらはキーワード引数と
して渡さなければなりません。すなわち、引数が宣言されている順番に頼っては
いけません。

    ``usage' (デフォルト: `"{%}prog {[}options "')]'
          プログラムが間違った方法で実行されるかまたはヘルプオプションを付けて
          実行された場合に表示される使用法です。`optparse' は使用法の文
          字列を表示する際に `{%}prog' を
          `os.path.basename(sys.argv{[}0])' (または `prog'
          キーワード引数が指定されていればその値) に展開します。
          使用法メッセージを抑制するためには特別な
          `optparse.SUPPRESS{_}USAGE' という値を指定します。

    ``option{_}list' (デフォルト: `{[} ')]'
          パーザに追加する Option
          オブジェクトのリストです。`option{_}list' の 中のオプションは
          `standard{_}option{_}list' (OptionParser の
          サブクラスでセットされる可能性のあるクラス属性)
          の後に追加されますが、バージョンや
          ヘルプのオプションよりは前になります。
          このオプションの使用は推奨されません。パーザを作成した後で、`add{_}option()'
          を使って追加してください。

    ``option{_}class' (デフォルト: optparse.Option)'
          `add{_}option()'
          でパーザにオプションを追加するときに使用されるクラス。

    ``version' (デフォルト: `None')'
          ユーザがバージョンオプションを与えたときに表示されるバージョン文字列です。
          `version' に真の値を与えると、`optparse' は自動的に
          単独のオプション文字列 `"-{}-version"'
          とともにバージョンオプションを 追加します。部分文字列
          `"{%}prog"' は `usage' と同様に 展開されます。

    ``conflict{_}handler' (デフォルト: `"error"')'
          オプション文字列が衝突するようなオプションがパーザに追加されたときにどうするかを
          指定します。*Note オプション間の衝突::
          節「オプション間の衝突」 を参照して下さい。

    ``description' (デフォルト: `None')'
          プログラムの概要を表す一段落のテキストです。`optparse' は
          ユーザがヘルプを要求したときにこの概要を現在のターミナルの幅に合わせて
          整形し直して表示します (`usage'
          の後、オプションリストの前に表示されます)。

    ``formatter' (デフォルト: 新しい IndentedHelpFormatter)'
          ヘルプテキストを表示する際に使われる optparse.HelpFormatter
          のインスタンスです。 `optparse'
          はこの目的のためにすぐ使えるクラスを二つ提供しています。
          IndentedHelpFormatter と TitledHelpFormatter がそれです。

    ``add{_}help{_}option' (デフォルト: `True')'
          もし真ならば、`optparse' はパーザにヘルプオプションを
          (オプション文字列 `"-h"' と `"-{}-help"' とともに)
          追加します。

    ``prog''
          `usage' や `version' の中の `"{%}prog"' を展開するときに
          `os.path.basename(sys.argv{[}0])'
          の代わりに使われる文字列です。



File: python-lib-jp.info,  Node: パーザへのオプション追加,  Next: オプションの定義,  Prev: Creating the parser,  Up: リファレンスガイド

14.3.3.2 パーザへのオプション追加
.................................

パーザにオプションを加えていくにはいくつか方法があります。推奨するのは
*Note Tutorial:: 節のチュートリアルで示したような
`OptionParser.add{_}option()' を使う方法です。 `add{_}option()'
は以下の二つのうちいずれかの方法で 呼び出せます:
   * {} `make{_}option()'に (すなわち`Option' のコンストラクタに)
     固定引数とキーワード引数の組み合わせを渡して、`Option'
     インスタンスを 生成させます。

   * {} (`make{_}option()' などが返す)`Option'インスタンスを渡します。

もう一つの方法は、あらかじめ作成しておいた`Option' インスタンスから
なるリストを、以下のようにして `OptionParser' のコンストラクタに渡す
というものです:

     option_list = [
         make_option("-f", "--filename",
                     action="store", type="string", dest="filename"),
         make_option("-q", "--quiet",
                     action="store_false", dest="verbose"),
         ]
     parser = OptionParser(option_list=option_list)

(`make{_}option()' は `Option' インスタンスを生成する
ファクトリ関数です; 現在のところ、個の関数は`Option' のコンストラクタの
別名にすぎません。`optparse'の将来のバージョンでは、`Option' を
複数のクラスに分割し、`make{_}option()' は適切なクラスを選んで
インスタンスを生成するようになる予定です。従って、`Option' を直接
インスタンス化しないでください。)


File: python-lib-jp.info,  Node: オプションの定義,  Next: 標準的なオプション・アクション,  Prev: パーザへのオプション追加,  Up: リファレンスガイド

14.3.3.3 オプションの定義
.........................

各々の`Option' インスタンス、は`-f' や`--file'
といった同義のコマンドラインオプションからなる集合を表現しています。
一つの`Option' には任意の数のオプションを短い形式でも長い形式でも
指定できます。ただし、少なくとも一つは指定せねばなりません。

正しい方法で`Option' インスタンスを生成するには、 `OptionParser' の
`add{_}option()' を使います:
     parser.add_option(opt_str[, ...], attr=value, ...)

短い形式のオプション文字列を一つだけ持つようなオプションを生成するには:
     parser.add_option("-f", attr=value, ...)

のようにします。

また、長い形式のオプション文字列を一つだけ持つようなオプションの定義は:
     parser.add_option("--foo", attr=value, ...)

のようになります。

キーワード引数は新しい `Option'
オブジェクトの属性を定義します。オプションの属性のうちでもっとも重要なのは
`action' です。`action' は他のどの属性と関連があるか、そして
どの属性が必要かに大きく作用します。関係のないオプション属性を指定したり、
必要な属性を指定し忘れたりすると、`optparse' は誤りを解説した
`OptionError'例外を送出します。

コマンドライン上にあるオプションが見つかったときの`optparse' の
振舞いを決定しているのは _アクション(action)_ です。 `optparse'
でハードコードされている標準的なアクションには
以下のようなものがあります:
``store''
     オプションの引数を保存します (デフォルトの動作です)

``store{_}const''
     定数を保存します

``store{_}true''
     真 (`True') を保存します

``store{_}false''
     偽 (`False') を保存します

``append''
     オプションの引数をリストに追加します

``append{_}const''
     定数をリストに追加します

``count''
     カウンタを一つ増やします

``callback''
     指定された関数を呼び出します

``help''
     全てのオプションとそのドキュメントの入った使用法メッセージを出力します。

(アクションを指定しない場合、デフォルトは `store'
になります。このアクション では、 `type' および `dest'
オプション属性を指定せねばなりません。 下記を参照してください。)

すでにお分かりのように、ほとんどのアクションはどこかに値を保存したり、値を更新
したりします。 この目的のために、`optparse'
は常に特別なオブジェクトを作り出し、 それは通常 `options' と呼ばれます
(`optparse.Values' の インスタンスになっています)。 オプションの引数
(や、その他の様々な値) は、`dest' (保存先: destination)
オプション属性に従って、OPTIONSの属性として保存されます。

例えば、
     parser.parse_args()

を呼び出した場合、`optparse' はまず `options' オブジェクト を生成します:

     options = Values()

パーザ中で以下のようなオプション
     parser.add_option("-f", "--file", action="store", type="string", dest="filename")

が定義されていて、パーズしたコマンドラインに以下のいずれかが入っていた場合:
     -ffoo
     -f foo
     --file=foo
     --file foo

`optparse' はこのオプションを見つけて、

     options.filename = "foo"

と同等の処理を行います。

`type' および `dest' オプション属性は `action' と同じくらい
重要ですが、_全ての_ オプションで意味をなすのは`action' だけなのです。


File: python-lib-jp.info,  Node: 標準的なオプション・アクション,  Next: オプション属性,  Prev: オプションの定義,  Up: リファレンスガイド

14.3.3.4 標準的なオプション・アクション
.......................................

様々なオプション・アクションにはどれも互いに少しづつ異なった条件と作用があります。
ほとんどのアクションに関連するオプション属性がいくつかあり、値を指定して
`optparse'の挙動を操作できます; いくつかのアクションには必須の属性
があり、必ず値を指定せねばなりません。
   * {} `store' {[}relevant: `type', `dest', `nargs', `choices']

     オプションの後には必ず引数が続きます。引数は`type'
     に従った値に変換されて `dest' に保存されます。NARGS {>} 1 の場合、
     複数の引数をコマンドラインから取り出します; 引数は全て `type'
     に従って 変換され、`dest' にタプルとして保存されます。 下記の
     *Note 標準のオプション型:: 節「標準のオプション型」 を
     参照してください。

     `choices' を(文字列のリストかタプルで)
     指定した場合、型のデフォルト値は "choice" になります。

     `type' を指定しない場合、デフォルトの値は `string' です。

     `dest' を指定しない場合、 `optparse' は保存先を最初の長い形式の
     オプション文字列から導出します (例えば、`"-{}-foo-bar"' は
     `foo{_}bar' になります)。長い形式のオプション文字列がない場合、
     `optparse'
     は最初の短い形式のオプションから保存先の変数名を導出します (`"-f"'
     は `f' になります)。

     例えば:
          parser.add_option("-f")
          parser.add_option("-p", type="float", nargs=3, dest="point")

     とすると、以下のようなコマンドライン:

          -f foo.txt -p 1 -3.5 4 -fbar.txt

     を解析した場合、`optparse' は
          options.f = "foo.txt"
          options.point = (1.0, -3.5, 4.0)
          options.f = "bar.txt"

     のように設定を行います。

   * {} `store{_}const' {[}required: `const'; relevant: `dest']

     値`cost' を`dest' に保存します。

     例えば:
          parser.add_option("-q", "--quiet",
                            action="store_const", const=0, dest="verbose")
          parser.add_option("-v", "--verbose",
                            action="store_const", const=1, dest="verbose")
          parser.add_option("--noisy",
                            action="store_const", const=2, dest="verbose")

     とします。

     `"-{}-noisy"' が見つかると、 `optparse' は
          options.verbose = 2

     のように設定を行います。

   * {} `store{_}true' {[}relevant: `dest']

     `store{_}const' の特殊なケースで、真 (True) を`dest' に保存します。

   * {} `store{_}false' {[}relevant: `dest']

     `store{_}true' と同じですが、偽 (False) を保存します。

     例:
          parser.add_option("--clobber", action="store_true", dest="clobber")
          parser.add_option("--no-clobber", action="store_false", dest="clobber")

   * {} `append' {[}relevant: `type', `dest', `nargs', `choices']

     このオプションの後ろには必ず引数が続きます。引数は`dest' のリストに
     追加されます。`dest' のデフォルト値を指定しなかった場合、
     `optparse'
     がこのオプションを最初にみつけた時点で空のリストを自動的に生成します。
     `nargs' {>} 1 の場合、複数の引数をコマンドラインから取り出し、
     長さ `nargs' のタプルを生成して `dest'に追加します。

     `type' および `dest' のデフォルト値は `store' アクションと
     同じです。

     例:
          parser.add_option("-t", "--tracks", action="append", type="int")

     `"-t3"' がコマンドライン上で見つかると、`optparse' は:
          options.tracks = []
          options.tracks.append(int("3"))

     と同等の処理を行います。

     その後、`"-{}-tracks=4"' が見つかると:
          options.tracks.append(int("4"))

     を実行します。

   * {} `append{_}const' {[}required: `const'; relevant: `dest']

     `store{_}const' と同様ですが、`const' の値は `dest' に
     追加(append)されます。 `append' の場合と同じように `dest'
     のデフォルトは `None' ですが
     このオプションを最初にみつけた時点で空のリストを自動的に生成します。

   * {} `count' {[}relevant: `dest']

     `dest' に保存されている整数値をインクリメントします。 `dest' は
     (デフォルトの値を指定しない限り) 最初にインクリメントを
     行う前にゼロに設定されます。

     例:
          parser.add_option("-v", action="count", dest="verbosity")

     コマンドライン上で最初に `"-v"' が見つかると、`optparse' は:
          options.verbosity = 0
          options.verbosity += 1

     と同等の処理を行います。

     以後、`"-v"' が見つかるたびに、
          options.verbosity += 1

     を実行します。

   * {} `callback' {[}required: `callback'; relevant: `type', `nargs',
     `callback{_}args', `callback{_}kwargs']

     `callback' に指定された関数を次のように呼び出します。
          func(option, opt_str, value, parser, *args, **kwargs)

     詳細は、*Note オプション処理コールバック::
     節「オプション処理コールバック」を 参照してください。

   * {} `help'

     現在のオプションパーザ内の全てのオプションに対する完全なヘルプメッセージを出力します。
     ヘルプメッセージは `OptionParser' のコンストラクタに渡した`usage'
     文字列と、各オプションに渡した `help' 文字列から生成します。

     オプションに `help' 文字列が指定されていなくても、オプションは
     ヘルプメッセージ中に列挙されます。オプションを完全に表示させないようにするには、
     特殊な値 `optparse.SUPPRESS{_}HELP' を使ってください。

     `optparse' は全ての`OptionParser' に自動的に`help'
     オプションを追加するので、通常自分で生成する必要はありません。

     例:
          from optparse import OptionParser, SUPPRESS_HELP

          parser = OptionParser()
          parser.add_option("-h", "--help", action="help"),
          parser.add_option("-v", action="store_true", dest="verbose",
                            help="Be moderately verbose")
          parser.add_option("--file", dest="filename",
                            help="Input file to read data from"),
          parser.add_option("--secret", help=SUPPRESS_HELP)

     `optparse' がコマンドライン上に `"-h"' または `"-{}-help"'
     を見つけると、以下のようなヘルプメッセージを 標準出力に出力します
     (`sys.argv{[}0]' は`"foo.py"' だとします):
          usage: foo.py [options]

          options:
            -h, --help        Show this help message and exit
            -v                Be moderately verbose
            --file=FILENAME   Input file to read data from

     ヘルプメッセージの出力後、`optparse' は `sys.exit(0)'
     でプロセスを終了します。

   * {} `version'

     `OptionParser' に指定されているバージョン番号を標準出力に
     出力して終了します。バージョン番号は、実際には `OptionParser'
     の`print_version()' メソッドで書式化されてから出力されます。
     通常、 `OptionParser' のコンストラクタに VERSION
     が指定されたときのみ関係のあるアクションです。 `help'
     オプションと同様、`optparse' はこのオプションを
     必要に応じて自動的に追加するので、`version' オプションを作成する
     ことはほとんどないでしょう。


File: python-lib-jp.info,  Node: オプション属性,  Next: 標準のオプション型,  Prev: 標準的なオプション・アクション,  Up: リファレンスガイド

14.3.3.5 オプション属性
.......................

以下のオプション属性は `parser.add{_}option()' へのキーワード引数として
渡すことができます。特定のオプションに無関係なオプション属性を渡した場合、
または必須のオプションを渡しそこなった場合、`optparse' は OptionError
を送出します。
   * {} `action' (デフォルト: `"store"')

     このオプションがコマンドラインにあった場合に `optparse'
     に何をさせるかを決めます。
     取りうるオプションについては既に説明しました。

   * {} `type' (デフォルト: `"string"')

     このオプションに与えられる引数の型 (たとえば `"string"' や
     `"int"') です。取りうるオプションの型については既に説明しました。

   * {} `dest' (デフォルト: オプション文字列から)

     このオプションのアクションがある値をどこかに書いたり書き換えたりを意味する場合、
     これは `optparse' にその書く場所を教えます。詳しく言えば `dest'
     には `optparse' がコマンドラインを解析しながら 組み立てる
     `options' オブジェクトの属性の名前を指定します。

   * {} `default' (非推奨)

     コマンドラインに指定がなかったときにこのオプションの対象に使われる値です。
     使用は推奨されません。代わりに `parser.set{_}defaults()'
     を使ってください。

   * {} `nargs' (デフォルト: 1)

     このオプションがあったときに幾つの `type'
     型の引数が消費されるべきかを 指定します。もし {>} 1
     ならば、`optparse' は `dest' に値のタプルを格納します。

   * {} `const'

     定数を格納する動作のための、その定数です。

   * {} `choices'

     `"choice"'
     型オプションに対してユーザがその中から選べる文字列のリストです。

   * {} `callback'

     アクションが `"callback"'
     であるオプションに対し、このオプションがあったときに
     呼ばれる呼び出し可能オブジェクトです。`callable'
     に渡す引数の詳細については、 *Note オプション処理コールバック::
     節「オプション処理コールバック」を参照してください。

   * {} `callback{_}args', `callback{_}kwargs'

     `callback' に渡される標準的な4つのコールバック引数の後ろに追加する
     位置による引数またはキーワード引数です。

   * {} `help'

     ユーザが `help' オプション(`"-{}-help"' のような)を指定したときに
     表示される使用可能な全オプションのリストの中のこのオプションに関する説明文です。
     説明文を提供しておかなければ、オプションは説明文なしで表示されます。
     オプションを隠すには特殊な値 `SUPPRESS{_}HELP' を使います。

   * {} `metavar' (デフォルト: オプション文字列から)

     説明文を表示する際にオプションの引数の身代わりになるものです。
     例は *Note Tutorial:: 節のチュートリアルを参照してください。



File: python-lib-jp.info,  Node: 標準のオプション型,  Next: 引数の解析,  Prev: オプション属性,  Up: リファレンスガイド

14.3.3.6 標準のオプション型
...........................

`optparse' には、"string" (文字列)、"int" (整数)、 "long" (長整数)、
"choice" (選択肢)、 "float" (浮動小数点数) および "complex" (複素数) の
6 種類のオプション型があります。
新たなオプションの型を追加したければ、*Note optparse の拡張:: 節、
「`optparse' の拡張」を参照してください。

文字列オプションの引数はチェックや変換を一切受けません:
コマンドライン上のテキストは 保存先にそのまま保存されます
(またはコールバックに渡されます)。

整数引数 (`int' 型や `long' 型) は次のように読み取られます。

        * {} 数が `0x' から始まるならば、16進数として読み取られます

        * {} 数が `0' から始まるならば、8進数として読み取られます

        * {} 数が `0b' から始まるならば、2進数として読み取られます

        * {} それ以外の場合、数は10進数として読み取られます



変換は適切な底(2, 8, 10, 16 のどれか)とともに `int()' または `long()'
を呼び出すことで行なわれます。 この変換が失敗した場合 `optparse'
の処理も失敗に終わりますが、 より役に立つエラーメッセージを出力します。

`float' および `complex' のオプション引数は直接 `float()' や
`complex()' で変換されます。 エラーは同様の扱いです。

`choice' オプションは `string' オプションのサブタイプです。 `choice'
オプションの属性 (文字列からなるシーケンス) には、利用できる
オプション引数のセットを指定します。`optparse.check{_}choice()'
はユーザの指定したオプション引数とマスタリストを比較して、無効な文字列が
指定された場合には`OptionValueError' を送出します。


File: python-lib-jp.info,  Node: 引数の解析,  Next: オプション解析器への問い合わせと操作,  Prev: 標準のオプション型,  Up: リファレンスガイド

14.3.3.7 引数の解析
...................

OptionParser を作成してオプションを追加していく上で大事なポイントは、
`parse{_}args()' メソッドの呼び出しです。
     (options, args) = parser.parse_args(args=None, options=None)

ここで入力パラメータは
``args''
     処理する引数のリスト (デフォルト: `sys.argv{[}1:]')

``options''
     オプション引数を格納するオブジェクト (デフォルト: 新しい
     optparse.Values のインスタンス)

であり、戻り値は
``options''
     `options' に渡されたものと同じオブジェクト、または `optparse'
     によって生成された optparse.Values インスタンス

``args''
     全てのオプションの処理が終わった後で残った位置引数

です。

一番普通の使い方は一切キーワード引数を使わないというものです。
`options' を指定した場合、それは繰り返される `setattr()' の呼び出し
(大雑把に言うと保存される各オプション引数につき一回ずつ)
で更新されていき、`parse{_}args()' で返されます。

`parse{_}args()' が引数リストでエラーに遭遇した場合、 OptionParser の
`error()' メソッドを適切なエンドユーザ向けの
エラーメッセージとともに呼び出します。この呼び出しにより、最終的に終了ステータス
2 (伝統的な UNIX におけるコマンドラインエラーの終了ステータス)
でプロセスを終了させることになります。


File: python-lib-jp.info,  Node: オプション解析器への問い合わせと操作,  Next: オプション間の衝突,  Prev: 引数の解析,  Up: リファレンスガイド

14.3.3.8 オプション解析器への問い合わせと操作
.............................................

自前のオプションパーザをつつきまわして、何が起こるかを調べると便利
なことがあります。`OptionParser' では便利な二つのメソッドを提供
しています:

``has{_}option(opt{_}str)''
     `OptionParser' に(`"-q"' や `"-{}-verbose"' のような) オプション
     `opt{_}str' がある場合、真を返します。

``get{_}option(opt{_}str)''
     オプション文字列`opt{_}str'に対する`Option'
     インスタンスを返します。 該当するオプションがなければ `None'
     を返します。

``remove{_}option(opt{_}str)''
     `OptionParser' に`opt{_}str' に対応するオプションがある場合、
     そのオプションを削除します。該当するオプションに他のオプション文字列が指定されて
     いた場合、それらのオプション文字列は全て無効になります。
     `opt{_}str' がこの `OptionParser' オブジェクトのどのオプション
     にも属さない場合、`ValueError' を送出します。


File: python-lib-jp.info,  Node: オプション間の衝突,  Next: クリーンアップ,  Prev: オプション解析器への問い合わせと操作,  Up: リファレンスガイド

14.3.3.9 オプション間の衝突
...........................

注意が足りないと、衝突するオプションを定義しやすくなります:

     parser.add_option("-n", "--dry-run", ...)
     [...]
     parser.add_option("-n", "--noisy", ...)

(とりわけ、`OptionParser'
から標準的なオプションを備えた自前のサブクラスを
定義してしまった場合にはよく起きます。)

ユーザがオプションを追加するたびに、`optparse'
は既存のオプションとの衝突
がないかチェックします。何らかの衝突が見付かると、現在設定されている衝突処理メカニズム
を呼び出します。衝突処理メカニズムはコンストラクタ中で呼び出せます:
     parser = OptionParser(..., conflict_handler=handler)

個別にも呼び出せます:
     parser.set_conflict_handler(handler)

衝突時の処理をおこなうハンドラ(handler)には、以下のものが利用できます:

    ``error' (デフォルトの設定)'
          オプション間の衝突をプログラム上のエラーとみなし、
          `OptionConflictError' を送出します。

    ``resolve''
          オプション間の衝突をインテリジェントに解決します (下記参照)。


一例として、衝突をインテリジェントに解決する`OptionParser'
を定義し、衝突を起こすようなオプションを追加してみましょう:
     parser = OptionParser(conflict_handler="resolve")
     parser.add_option("-n", "--dry-run", ..., help="do no harm")
     parser.add_option("-n", "--noisy", ..., help="be noisy")

この時点で、`optparse' はすでに追加済のオプションが オプション文字列
`"-n"' を使っていることを検出します。 `conflict{_}handler' が
`"resolve"' なので、 `optparse'は既に追加済のオプションリストの方から
`"-n"' を除去して問題を解決します。従って、`"-n"' の除去
されたオプションは`"-{}-dry-run"' だけでしか有効にできなく
なります。ユーザがヘルプ文字列を要求した場合、問題解決の結果を反映した
メッセージが出力されます:
     options:
       --dry-run     do no harm
       [...]
       -n, --noisy   be noisy

これまでに追加したオプション文字列を跡形もなく削り去り、ユーザがそのオプションを
コマンドラインから起動する手段をなくせます。 この場合、`optparse'
はオプションを完全に除去してしまうので、
こうしたオプションはヘルプテキストやその他のどこにも表示されなくなります。
例えば、現在の `OptionParser' の場合、以下の操作:

     parser.add_option("--dry-run", ..., help="new dry-run option")

を行った時点で、最初の `-n/-{}-dry-run'
オプションはもはやアクセスできなくなります。このため、`optparse' は
オプションを消去してしまい、ヘルプテキスト:

     options:
       [...]
       -n, --noisy   be noisy
       --dry-run     new dry-run option

だけが残ります。


File: python-lib-jp.info,  Node: クリーンアップ,  Next: その他のメソッド,  Prev: オプション間の衝突,  Up: リファレンスガイド

14.3.3.10 クリーンアップ
........................

OptionParser インスタンスはいくつかの循環参照を抱えています。
このことは Python
のガーベジコレクタにとって問題になるわけではありませんが、 使い終わった
OptionParser に対して `destroy()' を呼び出すことで
この循環参照を意図的に断ち切るという方法を選ぶこともできます。
この方法は特に長時間実行するアプリケーションで OptionParser から
大きなオブジェクトグラフが到達可能になっているような場合に有用です。


File: python-lib-jp.info,  Node: その他のメソッド,  Prev: クリーンアップ,  Up: リファレンスガイド

14.3.3.11 その他のメソッド
..........................

OptionParser にはその他にも幾つかの公開されたメソッドがあります:
   * {} `set{_}usage(usage)'

     上で説明したコンストラクタの `usage' キーワード引数での規則に従った
     使用法の文字列をセットします。`None'
     を渡すとデフォルトの使用法文字列が
     使われるようになり、`SUPPRESS{_}USAGE' によって使用法メッセージを
     抑制できます。

   * {} `enable{_}interspersed{_}args()',
     `disable{_}interspersed{_}args()'

     位置引数をオプションと混ぜこぜにする GNU getopt
     のような扱いを有効化/無効化する
     (デフォルトでは有効)。たとえば、`"-a"' と `"-b"' はどちらも引数を
     取らない単純なオプションだとすると、`optparse'
     は通常つぎのような文法を 受け入れます。
          prog -a arg1 -b arg2

     そして扱いは次のように指定した時と同じです。
          prog -a -b arg1 arg2

     この機能を無効化したい時は `disable{_}interspersed{_}args()' を
     呼び出してください。この呼び出しにより、伝統的な UNIX
     文法に回帰し、
     オプションの解析は最初のオプションでない引数で止まるようになります。

   * {} `set{_}defaults(dest=value, ...)'

     幾つかの保存先に対してデフォルト値をまとめてセットします。
     `set{_}defaults()'
     を使うのは複数のオプションにデフォルト値をセットする
     好ましいやり方です。というのも複数のオプションが同じ保存先を共有することがあり得るからです。
     たとえば幾つかの "mode"
     オプションが全て同じ保存先をセットするものだったとすると、
     どのオプションもデフォルトをセットすることができ、しかし最後に指定したものが勝ちます。
          parser.add_option("--advanced", action="store_const",
                            dest="mode", const="advanced",
                            default="novice")    # 上書きされます
          parser.add_option("--novice", action="store_const",
                            dest="mode", const="novice",
                            default="advanced")  # 上の設定を上書きします

     こうした混乱を避けるために `set{_}defaults()' を使います。
          parser.set_defaults(mode="advanced")
          parser.add_option("--advanced", action="store_const",
                            dest="mode", const="advanced")
          parser.add_option("--novice", action="store_const",
                            dest="mode", const="novice")



File: python-lib-jp.info,  Node: オプション処理コールバック,  Next: optparse の拡張,  Prev: リファレンスガイド,  Up: optparse

14.3.4 オプション処理コールバック
---------------------------------

`optparse' の組み込みのアクションや型が望みにかなったものでない
場合、二つの選択肢があります: 一つは `optparse' の拡張、もう一つは
callback オプションの定義です。 `optparse'
の拡張は汎用性に富んでいますが、単純なケースに対して
いささか大げさでもあります。大体は簡単なコールバックで事足りるでしょう。

`callback' オプションの定義は二つのステップからなります:
   * {} `callback' アクションを使ってオプション自体を定義する。

   * {} コールバックを書く。コールバックは少なくとも後で説明する 4
     つの引数を とる関数 (またはメソッド) でなければなりません。


* Menu:

* callbackオプションの定義::
* コールバック関数はどのように呼び出されるか::
* コールバック中で例外を送出する::
* コールバックの例 1 ありふれたコールバック::
* コールバックの例 2 オプションの順番をチェックする::
* コールバックの例 3 オプションの順番をチェックする 汎用的::
* コールバックの例 4 任意の条件をチェックする::
* コールバックの例5 固定引数::
* コールバックの例6 可変個の引数::


File: python-lib-jp.info,  Node: callbackオプションの定義,  Next: コールバック関数はどのように呼び出されるか,  Prev: オプション処理コールバック,  Up: オプション処理コールバック

14.3.4.1 callbackオプションの定義
.................................

callbackオプションを最も簡単に定義するには、 `parser.add{_}option()'
メソッドを使います。 `action' の他に指定しなければならない属性は
`callback'、 すなわちコールバックする関数自体です:
     parser.add_option("-c", action="callback", callback=my_callback)

`callback' は関数 (または呼び出し可能オブジェクト)なので、callback
オプションを定義する時にはあらかじめ `my{_}callback()'
を定義しておかねば なりません。この単純なケースでは、`optparse' は `-c'
が 何らかの引数をとるかどうか判別できず、通常は`-c' が引数を
伴わないことを意味します -- 知りたいことはただ単に `-c'
がコマンドライン上に
現れたどうかだけです。とはいえ、場合によっては、自分のコールバック関数に
任意の個数のコマンドライン引数を消費させたいこともあるでしょう。これがコールバック関数
をトリッキーなものにしています;
これについてはこの節の後の方で説明します。

`optparse' は常に四つの引数をコールバックに渡し、その他には
`callback{_}args' および `callback{_}kwargs' で指定した
追加引数しか渡しません。従って、最小のコールバック関数シグネチャは:
     def my_callback(option, opt, value, parser):

のようになります。

コールバックの四つの引数については後で説明します。

callback オプションを定義する場合には、他にもいくつかオプション属性を
指定できます:
``type''
     他で使われているのと同じ意味です: `store' や `append'
     アクションの時と同じく、
     この属性は`optparse'に引数を一つ消費して、`type' に指定した
     型に変換させます。`optparse' は変換後の値をどこかに保存する代わりに
     コールバック関数に渡します。

``nargs''
     これも他で使われているのと同じ意味です:
     このオプションが指定されていて、 かつ `nargs' {>} 1 である場合、
     `optparse' は`nargs' 個の引数を消費します。このとき各引数は `type'
     型に変換できねばなりません。変換後の値はタプルとしてコールバックに渡されます。

``callback{_}args''
     その他の固定引数からなるタプルで、コールバックに渡されます。

``callback{_}kwargs''
     その他のキーワード引数からなるタプルで、コールバックに渡されます。


File: python-lib-jp.info,  Node: コールバック関数はどのように呼び出されるか,  Next: コールバック中で例外を送出する,  Prev: callbackオプションの定義,  Up: オプション処理コールバック

14.3.4.2 コールバック関数はどのように呼び出されるか
...................................................

コールバックは全て以下の形式で呼び出されます:
     func(option, opt_str, value, parser, *args, **kwargs)

ここで、
``option''
     コールバックを呼び出している `Option' のインスタンスです。

``opt{_}str''
     は、コールバック呼び出しのきっかけとなったコマンドライン上のオプション文字列です。
     (長い形式のオプションに対する省略形が使われている場合、OPT
     は完全な、 正式な形のオプション文字列となります --
     例えば、ユーザが `--foobar' の短縮形として `"-{}-foo"'
     をコマンドラインに入力した時には、OPT{_}STR は `"-{}-foobar"'
     となります。)

``value''
     オプションの引数で、コマンドライン上に見つかったものです。
     `optparse' は、`type' が設定されている場合、
     単一の引数しかとりません;`value' の型はオプションの型
     として指定された型になります。このオプションに対する `type' が
     None である(引数なしの) 場合、VALUE は None になります。 `nargs'
     {>} 1 であれば、`value' は は適切な型をもつ値のタプルになります。

``parser''
     現在のオプション解析の全てを駆動している `OptionParser'
     インスタンスです。この変数が有用なのは、この値を介してインスタンス属性と
     していくつかの興味深いデータにアクセスできるからです:
    ``parser.largs''
          現在放置されている引数、すなわち、すでに消費されたものの、オプションでも
          オプション引数でもない引数からなるリストです。 `parser.largs'
          は自由に変更でき、 たとえば引数を追加したりできます
          (このリストは `args' 、すなわち `parse{_}args()'
          の二つ目の戻り値になります)

    ``parser.rargs''
          現在残っている引数、すなわち、 `opt{_}str' および `value'
          があれば除き、それ以外の引数が残っているリストです。
          `parser.rargs' は自由に変更でき、例えばさらに引数を消費したり
          できます。

    ``parser.values''
          オプションの値がデフォルトで保存されるオブジェクト
          (`optparse.OptionValues' のインスタンス)
          です。この値を使うと、コールバック関数がオプションの値を記憶するために、
          他の`optparse'
          と同じ機構を使えるようにするため、グローバル変数や閉包
          (closure) を台無しにしないので便利です。
          コマンドライン上にすでに現れているオプションの値にもアクセスできます。

``args''
     `callback{_}args' オプション属性で与えられた任意の固定引数
     からなるタプルです。

``kwargs''
     `callback{_}args' オプション属性で与えられた任意のキーワード引数
     からなるタプルです。


File: python-lib-jp.info,  Node: コールバック中で例外を送出する,  Next: コールバックの例 1 ありふれたコールバック,  Prev: コールバック関数はどのように呼び出されるか,  Up: オプション処理コールバック

14.3.4.3 コールバック中で例外を送出する
.......................................

オプション自体か、あるいはその引数に問題があるばあい、コールバック関数は
`OptionValueError' を送出せねばなりません。`optparse' は
この例外をとらえてプログラムを終了させ、ユーザが指定しておいたエラーメッセージを
標準エラー出力に出力します。エラーメッセージは明確、簡潔かつ正確で、どの
オプションに誤りがあるかを示さねばなりません。さもなければ、ユーザは自分の
操作のどこに問題があるかを解決するのに苦労することになります。


File: python-lib-jp.info,  Node: コールバックの例 1 ありふれたコールバック,  Next: コールバックの例 2 オプションの順番をチェックする,  Prev: コールバック中で例外を送出する,  Up: オプション処理コールバック

14.3.4.4 コールバックの例 1: ありふれたコールバック
...................................................

引数をとらず、発見したオプションを単に記録するだけのコールバックオプションの例を
以下に示します:
     def record_foo_seen(option, opt_str, value, parser):
         parser.saw_foo = True

     parser.add_option("--foo", action="callback", callback=record_foo_seen)

もちろん、`store{_}true' アクションを使っても実現できます。


File: python-lib-jp.info,  Node: コールバックの例 2 オプションの順番をチェックする,  Next: コールバックの例 3 オプションの順番をチェックする 汎用的,  Prev: コールバックの例 1 ありふれたコールバック,  Up: オプション処理コールバック

14.3.4.5 コールバックの例 2: オプションの順番をチェックする
...........................................................

もう少し面白みのある例を示します: この例では、`"-b"'
を発見して、その後で `"-a"'
がコマンドライン中に現れた場合にはエラーになります。
     def check_order(option, opt_str, value, parser):
         if parser.values.b:
             raise OptionValueError("can't use -a after -b")
         parser.values.a = 1
     [...]
     parser.add_option("-a", action="callback", callback=check_order)
     parser.add_option("-b", action="store_true", dest="b")


File: python-lib-jp.info,  Node: コールバックの例 3 オプションの順番をチェックする 汎用的,  Next: コールバックの例 4 任意の条件をチェックする,  Prev: コールバックの例 2 オプションの順番をチェックする,  Up: オプション処理コールバック

14.3.4.6 コールバックの例 3: オプションの順番をチェックする (汎用的)
....................................................................

このコールバック (フラグを立てるが、`"-b"'
が既に指定されていればエラーになる)
を同様の複数のオプションに対して再利用したければ、もう少し作業する必要があります:
エラーメッセージとセットされるフラグを一般化しなければなりません。
     def check_order(option, opt_str, value, parser):
         if parser.values.b:
             raise OptionValueError("can't use %s after -b" % opt_str)
         setattr(parser.values, option.dest, 1)
     [...]
     parser.add_option("-a", action="callback", callback=check_order, dest='a')
     parser.add_option("-b", action="store_true", dest="b")
     parser.add_option("-c", action="callback", callback=check_order, dest='c')


File: python-lib-jp.info,  Node: コールバックの例 4 任意の条件をチェックする,  Next: コールバックの例5 固定引数,  Prev: コールバックの例 3 オプションの順番をチェックする 汎用的,  Up: オプション処理コールバック

14.3.4.7 コールバックの例 4: 任意の条件をチェックする
.....................................................

もちろん、単に定義済みのオプションの値を調べるだけにとどまらず、コールバックには
任意の条件を入れられます。例えば、満月でなければ呼び出してはならないオプション
があるとしましょう。やらなければならないことはこれだけです:
     def check_moon(option, opt_str, value, parser):
         if is_moon_full():
             raise OptionValueError("%s option invalid when moon is full"
                                    % opt_str)
         setattr(parser.values, option.dest, 1)
     [...]
     parser.add_option("--foo",
                       action="callback", callback=check_moon, dest="foo")

(`is{_}moon{_}full()' の定義は読者への課題としましょう。


File: python-lib-jp.info,  Node: コールバックの例5 固定引数,  Next: コールバックの例6 可変個の引数,  Prev: コールバックの例 4 任意の条件をチェックする,  Up: オプション処理コールバック

14.3.4.8 コールバックの例5: 固定引数
....................................

決まった数の引数をとるようなコールパックオプションを定義するなら、問題はやや興味深く
なってきます。引数をとるようコールバックに指定するのは、`store' や
`append' オプションの定義に似ています: `type' を定義していれば、
そのオプションは引数を受け取ったときに該当する型に変換できねばなりません;
さらに `nargs' を指定すれば、オプションは `nargs' 個の引数を
受け取ります。

標準の `store' アクションをエミュレートする例を以下に示します:
     def store_value(option, opt_str, value, parser):
         setattr(parser.values, option.dest, value)
     [...]
     parser.add_option("--foo",
                       action="callback", callback=store_value,
                       type="int", nargs=3, dest="foo")

`optparse' は 3 個の引数を受け取り、それらを整数に変換するところまで
面倒をみてくれます; ユーザは単にそれを保存するだけです。
(他の処理もできます;
いうまでもなく、この例にはコールバックは必要ありません)


File: python-lib-jp.info,  Node: コールバックの例6 可変個の引数,  Prev: コールバックの例5 固定引数,  Up: オプション処理コールバック

14.3.4.9 コールバックの例6: 可変個の引数
........................................

あるオプションに可変個の引数を持たせたいと考えているなら、問題はいささか手強く
なってきます。この場合、`optparse' では該当する組み込みのオプション解析
機能を提供していないので、自分でコールバックを書かねばなりません。さらに、
`optparse' が普段処理している、伝統的な UNIX コマンドライン解析における
難題を自分で解決せねばなりません。とりわけ、コールバック関数では
引数が裸の`"-{}-"' や `"-"' の場合における慣習的な処理規則:
   * {} either `"-{}-"' or `"-"' can be option arguments

   * {} 裸の `"-{}-"' (何らかのオプションの引数でない場合):
     コマンドライン処理を 停止し、`"-{}-"'を無視します。

   * {} 裸の`"-"' (何らかのオプションの引数でない場合):
     コマンドライン処理を停止しますが、 `"-"' は残します
     (`parser.largs' に追加します)。


を実装せねばなりません。

オプションが可変個の引数をとるようにさせたいなら、いくつかの
巧妙で厄介な問題に配慮しなければなりません。どういう実装を
とるかは、アプリケーションでどのようなトレードオフを考慮するか
によります (このため、`optparse' では可変個の引数に
関する問題を直接的に取り扱わないのです)。

とはいえ、可変個の引数をもつオプションに対するスタブ (stub、仲介
インタフェース) を以下に示しておきます:

     def vararg_callback(option, opt_str, value, parser):
         assert value is None
         done = 0
         value = []
         rargs = parser.rargs
         while rargs:
             arg = rargs[0]

             # "--foo", "-a", "-fx", "--file=f" といった引数で停止。
             # "-3" や "-3.0" でも止まるので、オプションに数値が入る場合には
             # それを処理せねばならない。
             if ((arg[:2] == "--" and len(arg) > 2) or
                 (arg[:1] == "-" and len(arg) > 1 and arg[1] != "-")):
                 break
             else:
                 value.append(arg)
                 del rargs[0]

          setattr(parser.values, option.dest, value)

     [...]
     parser.add_option("-c", "--callback",
                       action="callback", callback=varargs)

この実装固有の弱点は、`"-c"' 以後に続いて負の数を表す
引数があった場合、その引数は `"-c"' の引数ではなく次の
オプションとして解釈される(そしておそらくエラーを引き起こす)
ということです。この問題の修正は読者の練習課題としておきます。


File: python-lib-jp.info,  Node: optparse の拡張,  Prev: オプション処理コールバック,  Up: optparse

14.3.5 `optparse' の拡張
------------------------

`optparse' がコマンドラインオプションをどのように解釈するかを決
める二つの重要な要素はそれぞれのオプションのアクションと型なので、拡張
の方向は新しいアクションと型を追加することになると思います。

* Menu:

* 新しい型の追加::
* 新しいアクションの追加::


File: python-lib-jp.info,  Node: 新しい型の追加,  Next: 新しいアクションの追加,  Prev: optparse の拡張,  Up: optparse の拡張

14.3.5.1 新しい型の追加
.......................

新しい型を追加するためには、`optparse' の Option クラスのサブクラスを
自身で定義する必要があります。このクラスには `optparse'
における型を定義する 一対の属性があります。それは `TYPES' と
`TYPE{_}CHECKER' です。

`TYPES' は型名のタプルです。新しく作るサブクラスでは、 タプル `TYPES'
は単純に標準的なもののを利用して定義すると良いでしょう。

`TYPE{_}CHECKER' は辞書で型名を型チェック関数に対応付けるものです。
型チェック関数は以下のような引数をとります。
     def check_mytype(option, opt, value)

ここで `option' は `Option' のインスタンスであ り、`opt'
はオプション文字列(たとえ ば `"-f"')で、`value'
は望みの型としてチェックされ変換される
べくコマンドラインで与えられる文字列です。`check{_}mytype()' は想
定されている型 `mytype' のオブジェクトを返さなければなりません。型
チェック関数から返される値は `OptionParser.parse{_}args()' で返
されるOptionValues インスタンスに収められるか、またはコールバック に
`value' パラメータとして渡されます。

型チェック関数は何か問題に遭遇したら OptionValueError
を送出しなければなりません。 OptionValueError
は文字列一つを引数に取り、それはそのまま OptionParser の `error()'
メソッドに渡され、そこでプログラム名と文字列 `"error:"'
が前置されてプロセスが終了する前に stderr に出力されます。

馬鹿馬鹿しい例ですが、Python スタイルの複素数を解析する `complex'
オプション型 を作ってみせることにします。(`optparse' 1.3
が複素数のサポートを
組み込んでしまったため以前にも増して馬鹿らしくなりましたが、気にしないでください。)

最初に必要な import 文を書きます。
     from copy import copy
     from optparse import Option, OptionValueError

まずは型チェック関数を定義しなければなりません。
これは後で(これから定義する Option のサブクラスの `TYPE{_}CHECKER'
クラス属性 の中で)参照されることになります。
     def check_complex(option, opt, value):
         try:
             return complex(value)
         except ValueError:
             raise OptionValueError(
                 "option %s: invalid complex value: %r" % (opt, value))

最後に Option のサブクラスです。
     class MyOption (Option):
         TYPES = Option.TYPES + ("complex",)
         TYPE_CHECKER = copy(Option.TYPE_CHECKER)
         TYPE_CHECKER["complex"] = check_complex

(もしここで `Option.TYPE{_}CHECKER' に `copy()' を適用しなければ、
`optparse' の Option クラスの `TYPE{_}CHECKER' 属性をいじってしまう
ことになります。Python
の常として、良いマナーと常識以外にそうすることを止めるものは
ありません。)

これだけです! もう新しいオプション型を使うスクリプトを他の `optparse'
に基づいた スクリプトとまるで同じように書くことができます。ただし、
OptionParser に Option でなく MyOption
を使うように指示しなければなければなりません。
     parser = OptionParser(option_class=MyOption)
     parser.add_option("-c", type="complex")

別のやり方として、オプションリストを構築して OptionParser
に渡すという方法もあります。 `add{_}option()'
を上でやったように使わないならば、OptionParser に
どのクラスを使うのか教える必要はありません。
     option_list = [MyOption("-c", action="store", type="complex", dest="c")]
     parser = OptionParser(option_list=option_list)


File: python-lib-jp.info,  Node: 新しいアクションの追加,  Prev: 新しい型の追加,  Up: optparse の拡張

14.3.5.2 新しいアクションの追加
...............................

新しいアクションの追加はもう少しトリッキーです。というのも `optparse'
が使っている二つのアクションの分類を理解する必要があるからです。
```store'' アクション'
     `optparse' が値を現在の OptionValues
     の属性に格納することになるアクションです。 この種類のオプションは
     Option のコンストラクタに `dest' 属性を与えることが 要求されます。

```typed'' アクション'
     コマンドラインから引数を受け取り、それがある型であることが期待されているアクションです。
     もう少しはっきり言えば、その型に変換される文字列を受け取るものです。
     この種類のオプションは Option のコンストラクタに `type'
     属性を与えることが 要求されます。

この分類には重複する部分があります。デフォルトの "store" アクションには
`store'、`store{_}const'、`append'、`count' などがありますが、
デフォルトの "typed" オプションは `store'、`append'、`callback'
の三つです。

アクションを追加する際に、以下の Option
のクラス属性(全て文字列のリストです)
の中の少なくとも一つに付け加えることでそのアクションを分類する必要があります。
``ACTIONS''
     全てのアクションは ACTIONS にリストされていなければなりません

``STORE{_}ACTIONS''
     "store" アクションはここにもリストされます

``TYPED{_}ACTIONS''
     "typed" アクションはここにもリストされます

``ALWAYS{_}TYPED{_}ACTIONS''
     型を取るアクション (つまりそのオプションが値を取る)
     はここにもリストされます。 このことの唯一の効果は `optparse'
     が、型の指定が無くアクション が `ALWAYS{_}TYPED{_}ACTIONS'
     のリストにあるオプションに、 デフォルト型 `string'
     を割り当てるということだけです。

実際に新しいアクションを実装するには、Option の `take{_}action()'
メソッドをオーバライドしてそのアクションを認識する場合分けを追加しなければなりません。

例えば、`extend'
アクションというのを追加してみましょう。このアクションは 標準的な
`append' アクションと似ていますが、コマンドラインから一つだけ値を
読み取って既存のリストに追加するのではなく、複数の値をコンマ区切りの文字列として
読み取ってそれらで既存のリストを拡張します。すなわち、もし
`"-{}-names"' が `string' 型の `extend'
オプションだとすると、次のコマンドライン
     --names=foo,bar --names blah --names ding,dong

の結果は次のリストになります。
     ["foo", "bar", "blah", "ding", "dong"]

再び Option のサブクラスを定義します。
     class MyOption (Option):

         ACTIONS = Option.ACTIONS + ("extend",)
         STORE_ACTIONS = Option.STORE_ACTIONS + ("extend",)
         TYPED_ACTIONS = Option.TYPED_ACTIONS + ("extend",)
         ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + ("extend",)

         def take_action(self, action, dest, opt, value, values, parser):
             if action == "extend":
                 lvalue = value.split(",")
                 values.ensure_value(dest, []).extend(lvalue)
             else:
                 Option.take_action(
                     self, action, dest, opt, value, values, parser)

注意すべきは次のようなところです。
   * {} `extend'
     はコマンドラインの値を予期していると同時にその値をどこかに格納します
     ので、`STORE{_}ACTIONS' と `TYPED{_}ACTIONS' の両方に入ります。

   * {} `optparse' が `extend' アクションに `string'
     型を割り当てるように `extend' アクションは
     `ALWAYS{_}TYPED{_}ACTIONS' にも入れてあります。

   * {} `MyOption.take{_}action()'
     にはこの新しいアクション一つの扱いだけを
     実装してあり、他の標準的な `optparse' のアクションについては
     `Option.take{_}action()' に制御を戻すようにしてあります。

   * {} `values' は optparse{_}parser.Values
     クラスのインスタンスであり、 非常に有用な `ensure{_}value()'
     メソッドを提供しています。 `ensure{_}value()'
     は本質的に安全弁付きの `getattr()' です。 次のように呼び出します。
          values.ensure_value(attr, value)

     `values' に `attr' 属性が無いか None だった場合に、
     `ensure{_}value()' は最初に `value' をセットし、 それから `value'
     を返します。 この振る舞いは `extend'、`append'、`count'
     のように、データを変数に 集積し、またその変数がある型
     (最初の二つはリスト、最後のは整数) であると期待されるアクション
     を作るのにとても使い易いものです。`ensure{_}value()' を使えば、
     作ったアクションを使うスクリプトはオプションに保存先にデフォルト値をセットすることに
     煩わされずに済みます。デフォルトを None にしておけば
     `ensure{_}value()' が
     それが必要になったときに適当な値を返してくれます。



File: python-lib-jp.info,  Node: getopt,  Next: logging,  Prev: optparse,  Up: 汎用オペレーティングシステムサービス

14.4 コマンドラインオプションのパーザ
=====================================

ポータブルなコマンドラインオプションのパーザ。長短の両方
の形式をサポートします。

このモジュールは`sys.argv'に入っているコマンドラインオプションの構文解
析を支援します。 ``-'' や ``-'`-'' の特別扱いも含めて、
UNIXの`getopt()'と同じ記法をサポートしています。
3番目の引数(省略可能)を設定することで、
GNUのソフトウェアでサポートされているような長形式のオプションも利用することが
できます。 このモジュールは1つの関数と例外を提供しています:

`getopt(args, options[, long_options])'
     コマンドラインオプションとパラメータのリストを構文解析します。
     ARGSは構文解析の対象になる引数リストです。これは
     先頭のプログラム名を除いたもので、通常`sys.argv[1:]'で与えられます。
     OPTIONS はスクリプトで認識させたいオプション文字と、引数が必要な場
     合にはコロン(`:')をつけます。つまりUNIXの
     `getopt()'と同じフォーマットになります。

     _Note:_ GNUの `getopt()'とは違って、オプションでない引数の後は全て
     オプションではないと判断されます。これは
     GNUでない、UNIXシステムの挙 動に近いものです。

     LONG_OPTIONSは長形式のオプションの名前を示す文字列のリストです。
     名前には、先頭の`'-'`-''は含めません。引数が必要な場合
     には名前の最後に等号(`=')を入れます。長形式のオプションだけを
     受けつけるためには、OPTIONSは空文字列である必要があります。
     長形式のオプションは、該当するオプションを一意に決定できる長さまで入力さ
     れていれば認識されます。たとえば、LONG_OPTIONSが `['foo',
     'frob']'の場合、`--fo'は`--foo' に該当しますが、`--f'
     では一意に決定できないので、 `GetoptError'が発生します。

     返り値は2つの要素から成っています: 最初は `(OPTION,
     VALUE)'のタプルのリスト、2つ目はオプションリス
     トを取り除いたあとに残ったプログラムの引数リストです(ARGSの末尾部
     分のスライスになります)。
     それぞれの引数と値のタプルの最初の要素は、短形式の時はハイフン
     1つで始まる文字列(例:`'-x'')、長形式の時はハイフン2つで始まる文字
     列(例: `'-'`-long-option'')となり、引数が2番目の要素になりま
     す。引数をとらない場合には空文字列が入ります。オプションは見つかった順
     に並んでいて、複数回同じオプションを指定することができます。長形式と短
     形式のオプションは混在させることができます。

`gnu_getopt(args, options[, long_options])'
     この関数はデフォルトでGNUスタイルのスキャンモードを使う以外は
     `getopt()'と同じように動作します。つまり、オプションと
     オプションでない引数とを混在させることができます。`getopt()'関
     数はオプションでない引数を見つけると解析をやめてしまいます。

     オプション文字列の最初の文字が '+'にするか、環境変数
     POSIXLY_CORRECTを設定することで、
     オプションでない引数を見つけると解析をやめるように振舞いを変えることがで
     きます。

     _Added in Python version 2.3_

`GetoptError'
     引数リストの中に認識できないオプションがあった場合か、引数が必要なオプショ
     ンに引数が与えられなかった場合に発生します。例外の引数は原因を示す文字
     列です。長形式のオプションについては、不要な引数が与えられた場合にもこ
     の例外が発生します。`msg'属性と`opt'属性で、エラーメッセー
     ジと関連するオプションを取得できます。特に関係するオプションが無い場合
     には`opt'は空文字列となります。

     _Changed in Python version 1.6_

`error'
     `GetoptError'へのエイリアスです。後方互換性のために残されてい
     ます。

UNIXスタイルのオプションを使った例です:
     >>> import getopt
     >>> args = '-a -b -cfoo -d bar a1 a2'.split()
     >>> args
     ['-a', '-b', '-cfoo', '-d', 'bar', 'a1', 'a2']
     >>> optlist, args = getopt.getopt(args, 'abc:d:')
     >>> optlist
     [('-a', ''), ('-b', ''), ('-c', 'foo'), ('-d', 'bar')]
     >>> args
     ['a1', 'a2']

長形式のオプションを使っても同様です:

     >>> s = '--condition=foo --testing --output-file abc.def -x a1 a2'
     >>> args = s.split()
     >>> args
     ['--condition=foo', '--testing', '--output-file', 'abc.def', '-x', 'a1', 'a2']
     >>> optlist, args = getopt.getopt(args, 'x', [
     ...     'condition=', 'output-file=', 'testing'])
     >>> optlist
     [('--condition', 'foo'), ('--testing', ''), ('--output-file', 'abc.def'), ('-x',
      '')]
     >>> args
     ['a1', 'a2']

スクリプト中での典型的な使い方は以下のようになります:

     import getopt, sys

     def main():
         try:
             opts, args = getopt.getopt(sys.argv[1:], "ho:v", ["help", "output="])
         except getopt.GetoptError:
             # ヘルプメッセージを出力して終了
             usage()
             sys.exit(2)
         output = None
         verbose = False
         for o, a in opts:
             if o == "-v":
                 verbose = True
             if o in ("-h", "--help"):
                 usage()
                 sys.exit()
             if o in ("-o", "--output"):
                 output = a
         # ...

     if __name__ == "__main__":
         main()

See also:
     *Note optparse:: よりオブジェクト指向的なコマンドラインオプショ
     ンのパーズを提供します。


File: python-lib-jp.info,  Node: logging,  Next: getpass,  Prev: getopt,  Up: 汎用オペレーティングシステムサービス

14.5 Python 用ロギング機能
==========================

PEP 282 に基づくPython 用のロギングモジュール。

_Added in Python version 2.3_
このモジュールでは、アプリケーションのための柔軟なエラーログ記録
(logging) システムを実装するための関数やクラスを定義しています。

ログ記録は `Logger' クラスのインスタンス (以降 "ロガー" :logger)
におけるメソッドを呼び出すことで行われます。各インスタンスは
名前をもち、ドット (ピリオド) を区切り文字として表記することで、
概念的には名前空間中の階層構造に配置されることになります。
例えば、"scan" と名づけられたロガーは "scan.text"、"scan.html"、 および
"scan.pdf" ロガーの親ロガーとなります。ロガー名には何をつけてもよく、
ログに記録されるメッセージの生成元となるアプリケーション中の特定の
領域を示すことになります。

ログ記録されたメッセージにはまた、重要度レベル (level of importance)
が関連付けられています。デフォルトのレベルとして提供されているものは
`DEBUG'、`INFO'、`WARNING'、 `ERROR' および `CRITICAL'
です。簡便性のために、 `Logger'
の適切なメソッド群を呼ぶことで、ログに記録されたメッセージの
重要性を指定することができます。それらのメソッドとは、デフォルトの
レベルを反映する形で、`debug()'、 `info()'、 `warning()'、 `error()'
および `critical()' となっています。
これらのレベルを指定するにあたって制限はありません: `Logger' の
より汎用的なメソッドで、明示的なレベル指定のための引数を持つ `log()'
を使って自分自身でレベルを定義したり使用したりできます。

ログレベルの数値は以下の表のように与えられています。
これらは基本的に自分でレベルを定義したい人のためのもので、
定義するレベルを既存のレベルの間に位置づけるために具体的な値が必要になります。
もし数値が他のレベルと同じだったら、既存の値は上書きされその名前は失われます。

レベル                               数値
------                               -----
CRITICAL                             50
ERROR                                40
WARNING                              30
INFO                                 20
DEBUG                                10
NOTSET                               0

レベルもロガーに関連付けることができ、デベロッパが設定することも、
保存されたログ記録設定を読み込む際に設定することもできます。
ロガーに対してログ記録メソッドが呼び出されると、ロガーは自らの
レベルとメソッド呼び出しに関連付けられたレベルを比較します。
ロガーのレベルがメソッド呼び出しのレベルよりも高い場合、実際の
ログメッセージは生成されません。これはログ出力の冗長性を制御
するための基本的なメカニズムです。

ログ記録されるメッセージは `LogRecord' クラスのインスタンスとして
コード化されます。ロガーがあるイベントを実際にログ出力すると決定した
場合、ログメッセージから `LogRecord' インスタンスが生成されます。

ログ記録されるメッセージは、ハンドラ ("handlers") を通して、 処理機構
(dispatch mechanism) にかけられます。ハンドラは `Handler'
クラスのサブクラスのインスタンスで、ログ記録された (`LogRecord' 形式の)
メッセージが、そのメッセージの伝達対象となる相手
(エンドユーザ、サポートデスクのスタッフ、システム管理者、開発者)
に行き着くようにする役割を持ちます。ハンドラには特定の行き先に方向付け
られた `LogRecord' インスタンスが渡されます。各ロガーは
ゼロ個、単一またはそれ以上のハンドラを (`Logger' の `addHandler()'
メソッド) で関連付けることができます。
ロガーに直接関連付けられたハンドラに加えて、
_ロガーの上位にあるロガー全てに関連付けられたハンドラ_
がメッセージを処理する際に呼び出されます。

ロガーと同様に、ハンドラは関連付けられたレベルを持つことができます。
ハンドラのレベルはロガーのレベルと同じ方法で、フィルタとして働きます。
ハンドラがあるイベントを実際に処理すると決定した場合、 `emit()'
メソッドが使われ、メッセージを発送先に送信します。ほとんどの
ユーザ定義の `Handler' のサブクラスで、この `emit()'
をオーバライドする必要があるでしょう。

基底クラスとなる `Handler' クラスに加えて、多くの有用なサブクラスが
提供されています:

  1. `StreamHandler' のインスタンスはストリーム (ファイル様
     オブジェクト) にエラーメッセージを送信します。

  2. `FileHandler' のインスタンスはディスク上のファイルに
     エラーメッセージを送信します。

  3. `BaseRotatingHandler' はログファイルをある時点で交替させる
     ハンドラの基底クラスです。直接インスタンス化するためのクラスではありません。
     `RotatingFileHandler' や`TimedRotatingFileHandler' を使う
     ようにしてください。

  4. `RotatingFileHandler' のインスタンスは最大ログファイルの
     サイズ指定とログファイルの交替機能をサポートしながら、ディスク上のファイルに
     エラーメッセージを送信します。

  5. `TimedRotatingFileHandler' のインスタンスは、ログファイルを
     一定時間間隔ごとに交替しながら、ディスク上のファイルに
     エラーメッセージを送信します。

  6. `SocketHandler' のインスタンスは TCP/IP
     ソケットにエラーメッセージを送信します。

  7. `DatagramHandler' のインスタンスは UDP
     ソケットにエラーメッセージを送信します。

  8. `SMTPHandler'
     のインスタンスは指定された電子メールアドレスにエラーメッセージを送信します。

  9. `SysLogHandler' のインスタンスは遠隔を含むマシン上の syslog
     デーモンにエラーメッセージを送信します。

 10. `NTEventLogHandler' のインスタンスは Windows NT/2000/XP
     イベントログにエラーメッセージを送信します。

 11. `MemoryHandler'
     のインスタンスはメモリ上のバッファにエラーメッセージを送信し、指定された条件でフラッシュされるようにします。

 12. `HTTPHandler' のインスタンスは `GET' か `POST'
     セマンティクスを使って HTTP サーバにエラーメッセージを送信します。


`StreamHandler' および `FileHandler' クラスは、中核となる
ログ化機構パッケージ内で定義されています。他のハンドラはサブモジュール、
`logging.handlers' で定義されています。 (サブモジュールには もうひとつ
`logging.config' があり、これは環境設定機能の ためのものです。)

ログ記録されたメッセージは `Formatter' クラスのインスタンスを
介し、表示用に書式化されます。これらのインスタンスは % 演算子と辞書を
使うのに適した書式化文字列で初期化されます。

複数のメッセージの初期化をバッチ処理するために、 `BufferingFormatter'
のインスタンスを使うことができます。 書式化文字列
(バッチ処理で各メッセージに適用されます) に加えて、 ヘッダ (header)
およびトレイラ (trailer) 書式化文字列が用意されて います。

ロガーレベル、ハンドラレベルの両方または片方に基づいたフィルタリング
が十分でない場合、`Logger' および `Handler' インスタンスに `Filter'
のインスタンスを (`addFilter()' メソッドを介して)
追加することができます。メッセージの処理を進める前に、ロガーとハンドラは
ともに、全てのフィルタでメッセージの処理が許可されているか調べます。
いずれかのフィルタが偽となる値を返した場合、メッセージの処理は
行われません。

基本的な `Filter' 機能では、指定されたロガー名でフィルタを
行えるようになっています。この機能が利用された場合、名前付けされた
ロガーとその下位にあるロガーに送られたメッセージがフィルタを通過
できるようになり、その他のメッセージは捨てられます。

上で述べたクラスに加えて、いくつかのモジュールレベルの関数が存在します。

`getLogger([name])'
     指定された名前のロガーを返します。名前が指定されていない場合、
     ロガー階層のルート (root) にあるロガーを返します。 NAME
     を指定する場合には、通常は "A", "A.B", あるいは "A.B.C.D"
     といったようなドット区切りの階層的な
     名前にします。名前の付け方はログ機能を使う開発者次第です。

     与えられた名前に対して、この関数はどの呼び出しでも同じロガーインスタンス
     を返します。従って、ロガーインスタンスをアプリケーションの各部
     でやりとりする必要はなくなります。

`getLoggerClass()'
     標準の`Logger' クラスか、最後に`setLoggerClass()' に渡した
     クラスを返します。この関数は、新たに定義するクラス内で呼び出し、
     カスタマイズした`Logger' クラスのインストールを行うときに
     既に他のコードで適用したカスタマイズを取り消そうとしていないか
     確かめるのに使います。例えば以下のようにします:

           class MyLogger(logging.getLoggerClass()):
               # ... override behaviour here


`debug(msg[, *args[, **kwargs]])'
     レベル `DEBUG' のメッセージをルートロガーで記録します。 MSG
     はメッセージの書式化文字列で、ARGS は MSG に
     文字列書式化演算子を使って取り込むための引数です。(これは、
     書式化文字列でキーワードを使い引数に辞書を渡すことができる、ということを意味します。)

     キーワード引数 KWARGS からは二つのキーワードが調べられます。
     一つめは EXC_INFO で、この値の評価値が偽でない場合、
     例外情報をログメッセージに追加します。(`sys.exc_info'
     の返す形式の) 例外情報を表すタプルが与えられていれば、それを
     メッセージに使います。それ以外の場合には、`sys.exc_info'
     を呼び出して例外情報を取得します。

     もう一つのキーワード引数は EXTRA で、当該ログイベント用に作られた
     LogRecoed の __dict__
     にユーザー定義属性を増やすのに使われる辞書を渡すのに
     用いられます。これらの属性は好きなように使えます。たとえば、ログメッセージの一部に
     することもできます。以下の例を見てください:

           FORMAT = "%(asctime)-15s %(clientip)s %(user)-8s %(message)s"
           logging.basicConfig(format=FORMAT)
           d = { 'clientip' : '192.168.0.1', 'user' : 'fbloggs' }
           logging.warning("Protocol problem: %s", "connection reset", extra=d)

     出力はこのようになります。
          2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset

     EXTRA
     で渡される辞書のキーはロギングシステムで使われているものとぶつからない
     ようにしなければなりません。(どのキーがロギングシステムで使われているかについての
     詳細は `Formatter' のドキュメントを参照してください。)

     これらの属性をログメッセージに使うことにしたなら、少し注意が必要です。
     上の例では、'clientip' と 'user' が LogRecord
     の属性辞書に含まれている ことを期待した書式化文字列で `Formatter'
     はセットアップされてい
     ます。これらの属性が欠けていると、書式化例外が発生してしまうためメッセー
     ジはログに残りません。したがってこの場合、常にこれらのキーがあ る
     EXTRA 辞書を渡す必要があります。

     このようなことは煩わしいかもしれませんが、この機能は限定された場面で使
     われるように意図しているものなのです。たとえば同じコードがいくつものコ
     ンテキストで実行されるマルチスレッドのサーバで、興味のある条件が現れる
     のがそのコンテキストに依存している(上の例で言えば、リモートのクライアン
     ト IP
     アドレスや認証されたユーザ名など)、というような場合です。そういっ
     た場面では、それ用の `Formatter' が特定の `Handler' と共に
     使われるというのはよくあることです。

     _Changed in Python version 2.5_

`info(msg[, *args[, **kwargs]])'
     レベル `INFO' のメッセージをルートロガーで記録します。 引数は
     `debug()' と同じように解釈されます。

`warning(msg[, *args[, **kwargs]])'
     レベル `WARNING' のメッセージをルートロガーで記録します。 引数は
     `debug()' と同じように解釈されます。

`error(msg[, *args[, **kwargs]])'
     レベル `ERROR' のメッセージをルートロガーで記録します。 引数は
     `debug()' と同じように解釈されます。

`critical(msg[, *args[, **kwargs]])'
     レベル `CRITICAL' のメッセージをルートロガーで記録します。 引数は
     `debug()' と同じように解釈されます。

`exception(msg[, *args])'
     レベル `ERROR' のメッセージをルートロガーで記録します。 引数は
     `debug()' と同じように解釈されます。
     例外情報はログメッセージに追加されます。このメソッドは
     例外ハンドラからのみ呼び出されます。

`log(level, msg[, *args[, **kwargs]])'
     レベル `level' のメッセージをルートロガーで記録します。
     その他の引数は `debug()' と同じように解釈されます。

`disable(lvl)'
     全てのロガーに対して、ロガー自体のレベルに優先するような上書きレベル
     LVL を与えます。アプリケーション全体にわたって一時的にログ出力の
     頻度を押し下げる必要が生じた場合にはこの関数が有効です。

`addLevelName(lvl, levelName)'
     内部辞書内でレベル LVL をテキスト LEVELNAME に関連付け
     ます。これは例えば `Formatter' でメッセージを書式化する
     際のように、数字のレベルをテキスト表現に対応付ける際に用いられます。
     この関数は自作のレベルを定義するために使うこともできます。
     使われるレベル対する唯一の制限は、レベルは正の整数でなくては
     ならず、メッセージの深刻さが上がるに従ってレベルの数も上がらなくては
     ならないということです。

`getLevelName(lvl)'
     ログ記録レベル LVL のテキスト表現を返します。レベルが定義
     済みのレベル `CRITICAL'、`ERROR'、 `WARNING'、 `INFO'、あるいは
     `DEBUG' のいずれかである場合、対応する文字列が返されます。
     `addLevelName()' を使ってレベルに名前を関連づけていた 場合、LVL
     に関連付けられていた名前が返されます。
     定義済みのレベルに対応する数値を指定した場合、レベルに対応した
     文字列表現を返します。そうでない場合、文字列 "Level %s" % lvl を
     返します。

`makeLogRecord(attrdict)'
     属性が ATTRDICT で定義された、新たな `LogRecord'
     インスタンスを生成して返します。この関数は pickle 化された
     `LogRecord' 属性の辞書を作成し、ソケットを介して送信し、受信端で
     `LogRecord' インスタンスとして再構成する際に便利です。

`makeLogRecord(attrdict)'
     ATTRDICT で属性を定義した、新しい `LogRecord' インスタンスを
     返します。この関数は、逆 pickle 化された `LogRecord' 属性辞書を
     socket 越しに受け取り、受信端で `LogRecord' インスタンスに再構築す
     る場合に有用です。

`basicConfig([**kwargs])'
     デフォルトの `Formatter' を持つ `StreamHandler'
     を生成してルートロガーに追加し、ログ記録システムの基本的な環境設定を
     行います。 関数 `debug()'、`info()'、`warning()'、
     `error()'、および `critical()' は、ルートロガーに
     ハンドラが定義されていない場合に自動的に `basicConfig()'
     を呼び出します。

     _Changed in Python version 2.4_

     以下のキーワード引数がサポートされます。

     Format                             説明
     ------                             -----
     filename                           StreamHandler
                                        ではなく指定された名前で
                                        FileHandler が作られます
     filemode                           filename
                                        が指定されているとき、ファイルモードを指定します
                                        (filemode
                                        が指定されない場合デフォルトは
                                        'a' です)
     format                             指定された書式化文字列をハンドラで使います
     datefmt                            指定された日付/時刻の書式を使います
     level                              ルートロガーのレベルを指定されたものにします
     stream                             指定されたストリームを
                                        StreamHandler
                                        の初期化に使います。 この引数は
                                        'filename'
                                        と同時には使えないことに注意してください。
                                        両方が指定されたときには 'stream'
                                        は無視されます


`shutdown()'
     ログ記録システムに対して、バッファのフラッシュを行い、全てのハンドラを
     閉じることで順次シャットダウンを行うように告知します。

`setLoggerClass(klass)'
     ログ記録システムに対して、ロガーをインスタンス化する際にクラス
     KLASS を使うように指示します。指定するクラスは引数として
     名前だけをとるようなメソッド `__init__()' を定義して
     いなければならず、`__init__()' では `Logger.__init__()'
     を呼び出さなければなりません。典型的な利用法として、この関数は自作の
     ロガーを必要とするようなアプリケーションにおいて、他のロガーが
     インスタンス化される前にインスタンス化されます。

See also:
    *PEP282 A Logging System*
          本機能を Python 標準ライブラリに含めるよう記述している提案書。

    `*http://www.red-dove.com/python_logging.html*'
          (この `logging' パッケージのオリジナル)
          オリジナルの`logging'パッケージ。このサイトにあるバー
          ジョンのパッケージは、標準で`logging'パッケージを含まな
          いPython 1.5.2 と 2.1.x、2.2.xでも使用できます


* Menu:

* Logger オブジェクト::
* 基本的な使い方::
* 複数の出力先にログを出力する::
* ログイベントをネットワーク越しに送受信する::
* Handler オブジェクト::
* Formatter オブジェクト::
* Filter オブジェクト::
* LogRecord オブジェクト::
* スレッド安全性::
* 環境設定::


File: python-lib-jp.info,  Node: Logger オブジェクト,  Next: 基本的な使い方,  Prev: logging,  Up: logging

14.5.1 Logger オブジェクト
--------------------------

ロガーは以下の属性とメソッドを持ちます。ロガーを直接インスタンス化
することはできず、常にモジュール関数 `logging.getLogger(name)'
を介してインスタンス化するので注意してください。

`propagate'
     この値の評価結果が偽になる場合、ログ記録しようとするメッセージは
     このロガーに渡されず、また子ロガーから上位の (親の) ロガーに
     渡されません。コンストラクタはこの属性を 1 に設定します。

`setLevel(lvl)'
     このロガーの閾値を LVL に設定します。ログ記録しようとする
     メッセージで、LVL よりも深刻でないものは無視されます。
     ロガーが生成された際、レベルは `NOTSET' (これにより
     全てのメッセージについて、ロガーがルートロガーであれば処理される、
     そうでなくてロガーが非ルートロガーの場合には親ロガーに代行させる)
     に設定されます。ルートロガーは `WARNING' レベル
     で生成されることに注意してください。

     「親ロガーに代行させる」という用語の意味は、もしロガーのレベルが
     NOTEST ならば、祖先ロガーの系列の中を NOTEST
     以外のレベルの祖先を見つけるかルー
     トに到達するまで辿っていく、ということです。

     もし NOTEST
     以外のレベルの祖先が見つかったなら、その祖先のレベルが祖先
     の探索を開始したロガーの実効レベルとして取り扱われ、ログイベントがどの
     ように処理されるかを決めるのに使われます。

     ルートに到達した場合、ルートのレベルが NOTEST
     ならば全てのメッセージは
     処理されます。そうでなければルートのレベルが実効レベルとして使われま
     す。

`isEnabledFor(lvl)'
     深刻さが LVL のメッセージが、このロガーで処理されることに
     なっているかどうかを示します。このメソッドはまず、
     `logging.disable(lvl)' で設定されるモジュールレベル
     の深刻さレベルを調べ、次にロガーの実効レベルを
     `getEffectiveLevel()' で調べます。

`getEffectiveLevel()'
     このロガーの実効レベルを示します。`NOTSET' 以外の値が `setLevel()'
     で設定されていた場合、その値が返されます。
     そうでない場合、`NOTSET' 以外の値が見つかるまでロガーの
     階層をルートロガーの方向に追跡します。見つかった場合、その値が
     返されます。

`debug(msg[, *args[, **kwargs]])'
     レベル `DEBUG' のメッセージをこのロガーで記録します。 MSG
     はメッセージの書式化文字列で、ARGS は MSG に
     文字列書式化演算子を使って取り込むための引数です。(これは、
     書式化文字列でキーワードを使い引数に辞書を渡すことができる、ということを意味します。)

     キーワード引数 KWARGS からは二つのキーワードが調べられます。
     一つめは EXC_INFO で、この値の評価値が偽でない場合、
     例外情報をログメッセージに追加します。(`sys.exc_info'
     の返す形式の) 例外情報を表すタプルが与えられていれば、それを
     メッセージに使います。それ以外の場合には、`sys.exc_info'
     を呼び出して例外情報を取得します。

     もう一つのキーワード引数は EXTRA で、当該ログイベント用に作られた
     LogRecoed の __dict__
     にユーザー定義属性を増やすのに使われる辞書を渡すのに
     用いられます。これらの属性は好きなように使えます。たとえば、ログメッセージの一部に
     することもできます。以下の例を見てください:

           FORMAT = "%(asctime)-15s %(clientip)s %(user)-8s %(message)s"
           logging.basicConfig(format=FORMAT)
           d = { 'clientip' : '192.168.0.1', 'user' : 'fbloggs' }
           logger = logging.getLogger("tcpserver")
           logger.warning("Protocol problem: %s", "connection reset", extra=d)

     出力はこのようになります。
          2006-02-08 22:20:02,165 192.168.0.1 fbloggs  Protocol problem: connection reset

     EXTRA
     で渡される辞書のキーはロギングシステムで使われているものとぶつからない
     ようにしなければなりません。(どのキーがロギングシステムで使われているかについての
     詳細は `Formatter' のドキュメントを参照してください。)

     これらの属性をログメッセージに使うことにしたなら、少し注意が必要です。
     上の例では、'clientip' と 'user' が LogRecord
     の属性辞書に含まれている ことを期待した書式化文字列で `Formatter'
     はセットアップされてい
     ます。これらの属性が欠けていると、書式化例外が発生してしまうためメッセー
     ジはログに残りません。したがってこの場合、常にこれらのキーがあ る
     EXTRA 辞書を渡す必要があります。

     このようなことは煩わしいかもしれませんが、この機能は限定された場面で使
     われるように意図しているものなのです。たとえば同じコードがいくつものコ
     ンテキストで実行されるマルチスレッドのサーバで、興味のある条件が現れる
     のがそのコンテキストに依存している(上の例で言えば、リモートのクライアン
     ト IP
     アドレスや認証されたユーザ名など)、というような場合です。そういっ
     た場面では、それ用の `Formatter' が特定の `Handler' と共に
     使われるというのはよくあることです。

     _Changed in Python version 2.5_

`info(msg[, *args[, **kwargs]])'
     レベル `INFO' のメッセージをこのロガーで記録します。 引数は
     `debug()' と同じように解釈されます。

`warning(msg[, *args[, **kwargs]])'
     レベル `WARNING' のメッセージをこのロガーで記録します。 引数は
     `debug()' と同じように解釈されます。

`error(msg[, *args[, **kwargs]])'
     レベル `ERROR' のメッセージをこのロガーで記録します。 引数は
     `debug()' と同じように解釈されます。

`critical(msg[, *args[, **kwargs]])'
     レベル `CRITICAL' のメッセージをこのロガーで記録します。 引数は
     `debug()' と同じように解釈されます。

`log(lvl, msg[, *args[, **kwargs]])'
     整数で表したレベル LVL のメッセージをこのロガーで記録します。
     その他の引数は `debug()' と同じように解釈されます。

`exception(msg[, *args])'
     レベル `ERROR' のメッセージをこのロガーで記録します。 引数は
     `debug()' と同じように解釈されます。
     例外情報はログメッセージに追加されます。このメソッドは
     例外ハンドラからのみ呼び出されます。

`addFilter(filt)'
     指定されたフィルタ FILT をこのロガーに追加します。

`removeFilter(filt)'
     指定されたフィルタ FILT をこのロガーから除去します。

`filter(record)'
     このロガーのフィルタをレコード (record) に適用し、レコードが
     フィルタを透過して処理されることになる場合には真を返します。

`addHandler(hdlr)'
     指定されたハンドラ HDLR をこのロガーに追加します。

`removeHandler(hdlr)'
     指定されたハンドラ HDLR をこのロガーから除去します。

`findCaller()'
     呼び出し元のソースファイル名と行番号を調べます。ファイル名と行番号
     を 2 要素のタプルで返します。

`handle(record)'
     レコードをこのロガーおよびその上位ロガーに (PROPAGATE の
     値が偽になるまで)
     さかのぼった関連付けられている全てのハンドラに渡して
     処理します。このメソッドはソケットから受信した逆 pickle 化された
     レコードに対してもレコードがローカルで生成された場合と同様に用いられます。
     `filter()' によって、ロガーレベルでのフィルタが適用されます。

`makeRecord(name, lvl, fn, lno, msg, args, exc_info, func, extra)'
     このメソッドは、特殊な `LogRecord' インスタンスを生成する
     ためにサブクラスでオーバライドできるファクトリメソッドです。
     _Changed in Python version 2.5_


File: python-lib-jp.info,  Node: 基本的な使い方,  Next: 複数の出力先にログを出力する,  Prev: Logger オブジェクト,  Up: logging

14.5.2 基本的な使い方
---------------------

_Changed in Python version 2.4_

`logging' パッケージには高い柔軟性があり、その設定にたじろぐ
こともあるでしょう。そこでこの節では、 `logging' パッケージを
簡単に使う方法もあることを示します。

以下の最も単純な例では、コンソールにログを表示します:

     import logging

     logging.debug('A debug message')
     logging.info('Some information')
     logging.warning('A shot across the bows')

上のスクリプトを実行すると、以下のようなメッセージを目にするでしょう:
     WARNING:root:A shot across the bows

ここではロガーを特定しなかったので、システムはルートロガーを使っています。
デバッグメッセージや情報メッセージは表示されませんが、これはデフォルトの
ルートロガーが WARNING 以上の重要度を持つメッセージしか処理しないように
設定されているからです。
メッセージの書式もデフォルトの設定に従っています。出力先は `sys.stderr'
で、これもデフォルトの設定です。
重要度レベルやメッセージの形式、ログの出力先は、以下の例のように簡単に
変更できます:

     import logging

     logging.basicConfig(level=logging.DEBUG,
                         format='%(asctime)s %(levelname)s %(message)s',
                         filename='/tmp/myapp.log',
                         filemode='w')
     logging.debug('A debug message')
     logging.info('Some information')
     logging.warning('A shot across the bows')

ここでは、`basicConfig()' メソッドを使って、以下のような出力例 になる
(そして`/tmp/myapp.log' に書き込まれる) ように、
デフォルト設定を変更しています:

     2004-07-02 13:00:08,743 DEBUG A debug message
     2004-07-02 13:00:08,743 INFO Some information
     2004-07-02 13:00:08,743 WARNING A shot across the bows

今度は、重要度が DEBUG か、それ以上のメッセージが処理されました。
メッセージの形式も変更され、出力はコンソールではなく特定のファイル
に書き出されました。

出力の書式化には、通常の Python 文字列に対する初期化を使います - *Note
文字列フォーマット操作:: 節を参照してください。書式化文字列は、
以下の指定子 (specifier) を常にとります。指定子の完全なリストに
ついては `Formatter' のドキュメントを参照してください。

書式                                 説明
------                               -----
%(name)s                             ロガーの名前 (ログチャネル)
                                     の名前です。
%(levelname)s                        メッセージのログレベル (`'DEBUG'',
                                     `'INFO'', `'WARNING'', `'ERROR'',
                                     `'CRITICAL'') です。
%(asctime)s                          `LogRecord'
                                     が生成された際の時刻を、
                                     人間が読み取れる形式にしたものです。デフォルトでは、
                                     "2003-07-08 16:49:45,896"
                                     のような形式 (コンマの後ろはミリ秒)
                                     です。
%(message)s                          ログメッセージです。

以下のように、追加のキーワードパラメタ DATEFMT を渡すと日付や時刻の
書式を変更できます:

     import logging

     logging.basicConfig(level=logging.DEBUG,
                         format='%(asctime)s %(levelname)-8s %(message)s',
                         datefmt='%a, %d %b %Y %H:%M:%S',
                         filename='/temp/myapp.log',
                         filemode='w')
     logging.debug('A debug message')
     logging.info('Some information')
     logging.warning('A shot across the bows')

出力は以下のようになります:

     Fri, 02 Jul 2004 13:06:18 DEBUG    A debug message
     Fri, 02 Jul 2004 13:06:18 INFO     Some information
     Fri, 02 Jul 2004 13:06:18 WARNING  A shot across the bows

日付を書式化する文字列は、`strftime()' の要求に従います - `time'
モジュールを参照してください。

コンソールやファイルではなく、別個に作成しておいたファイル類似オブジェクト
にログを出力したい場合には、`basicConfig()' に STREAM
キーワード引数で渡します。STREAM とFILENAME
の両方の引数を指定した場合、STREAM は無視されるので注意してください。

状況に応じて変化する情報ももちろんログ出力できます。以下のように、
単にメッセージを書式化文字列にして、その後ろに可変情報の引数を渡すだけです:

     import logging

     logging.basicConfig(level=logging.DEBUG,
                         format='%(asctime)s %(levelname)-8s %(message)s',
                         datefmt='%a, %d %b %Y %H:%M:%S',
                         filename='/temp/myapp.log',
                         filemode='w')
     logging.error('Pack my box with %d dozen %s', 5, 'liquor jugs')

出力は以下のようになります:

     Wed, 21 Jul 2004 15:35:16 ERROR    Pack my box with 5 dozen liquor jugs


File: python-lib-jp.info,  Node: 複数の出力先にログを出力する,  Next: ログイベントをネットワーク越しに送受信する,  Prev: 基本的な使い方,  Up: logging

14.5.3 複数の出力先にログを出力する
-----------------------------------

コンソールとファイルに、別々のメッセージ書式で、別々の状況に応じた
ログ出力を行わせたいとしましょう。例えば DEBUG よりも高いレベルの
メッセージはファイルに記録し、INFO 以上のレベルのメッセージは
コンソールに出力したいという場合です。また、ファイルにはタイムスタンプを
記録し、コンソールには出力しないとします。以下のようにすれば、こうした
挙動を実現できます:

     import logging

     # set up logging to file - see previous section for more details
     logging.basicConfig(level=logging.DEBUG,
                         format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
                         datefmt='%m-%d %H:%M',
                         filename='/temp/myapp.log',
                         filemode='w')
     # define a Handler which writes INFO messages or higher to the sys.stderr
     console = logging.StreamHandler()
     console.setLevel(logging.INFO)
     # set a format which is simpler for console use
     formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
     # tell the handler to use this format
     console.setFormatter(formatter)
     # add the handler to the root logger
     logging.getLogger('').addHandler(console)

     # Now, we can log to the root logger, or any other logger. First the root...
     logging.info('Jackdaws love my big sphinx of quartz.')

     # Now, define a couple of other loggers which might represent areas in your
     # application:

     logger1 = logging.getLogger('myapp.area1')
     logger2 = logging.getLogger('myapp.area2')

     logger1.debug('Quick zephyrs blow, vexing daft Jim.')
     logger1.info('How quickly daft jumping zebras vex.')
     logger2.warning('Jail zesty vixen who grabbed pay from quack.')
     logger2.error('The five boxing wizards jump quickly.')

このスクリプトを実行すると、コンソールには以下のように表示されるでしょう:

     root        : INFO     Jackdaws love my big sphinx of quartz.
     myapp.area1 : INFO     How quickly daft jumping zebras vex.
     myapp.area2 : WARNING  Jail zesty vixen who grabbed pay from quack.
     myapp.area2 : ERROR    The five boxing wizards jump quickly.

そして、ファイルは以下のようになるはずです:

     10-22 22:19 root         INFO     Jackdaws love my big sphinx of quartz.
     10-22 22:19 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.
     10-22 22:19 myapp.area1  INFO     How quickly daft jumping zebras vex.
     10-22 22:19 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from quack.
     10-22 22:19 myapp.area2  ERROR    The five boxing wizards jump quickly.

ご覧のように、 DEBUG
メッセージはファイルだけに出力され、その他のメッセージ
は両方に出力されます。

この例題では、コンソールとファイルのハンドラだけを使っていますが、
実際には任意の数のハンドラや組み合わせを使えます。


File: python-lib-jp.info,  Node: ログイベントをネットワーク越しに送受信する,  Next: Handler オブジェクト,  Prev: 複数の出力先にログを出力する,  Up: logging

14.5.4 ログイベントをネットワーク越しに送受信する
-------------------------------------------------

ログイベントをネットワーク越しに送信し、受信端でそれを処理したいとしましょう。
`SocketHandler' インスタンスを送信端のルートロガーに接続すれば、
簡単に実現できます:

     import logging, logging.handlers

     rootLogger = logging.getLogger('')
     rootLogger.setLevel(logging.DEBUG)
     socketHandler = logging.handlers.SocketHandler('localhost',
                         logging.handlers.DEFAULT_TCP_LOGGING_PORT)
     # don't bother with a formatter, since a socket handler sends the event as
     # an unformatted pickle
     rootLogger.addHandler(socketHandler)

     # Now, we can log to the root logger, or any other logger. First the root...
     logging.info('Jackdaws love my big sphinx of quartz.')

     # Now, define a couple of other loggers which might represent areas in your
     # application:

     logger1 = logging.getLogger('myapp.area1')
     logger2 = logging.getLogger('myapp.area2')

     logger1.debug('Quick zephyrs blow, vexing daft Jim.')
     logger1.info('How quickly daft jumping zebras vex.')
     logger2.warning('Jail zesty vixen who grabbed pay from quack.')
     logger2.error('The five boxing wizards jump quickly.')

受信端では、`SocketServer' モジュールを使って受信プログラムを
作成しておきます。簡単な実用プログラムを以下に示します:

     import cPickle
     import logging
     import logging.handlers
     import SocketServer
     import struct

     class LogRecordStreamHandler(SocketServer.StreamRequestHandler):
         """Handler for a streaming logging request.

         This basically logs the record using whatever logging policy is
         configured locally.
         """

         def handle(self):
             """
             Handle multiple requests - each expected to be a 4-byte length,
             followed by the LogRecord in pickle format. Logs the record
             according to whatever policy is configured locally.
             """
             while 1:
                 chunk = self.connection.recv(4)
                 if len(chunk) < 4:
                     break
                 slen = struct.unpack(">L", chunk)[0]
                 chunk = self.connection.recv(slen)
                 while len(chunk) < slen:
                     chunk = chunk + self.connection.recv(slen - len(chunk))
                 obj = self.unPickle(chunk)
                 record = logging.makeLogRecord(obj)
                 self.handleLogRecord(record)

         def unPickle(self, data):
             return cPickle.loads(data)

         def handleLogRecord(self, record):
             # if a name is specified, we use the named logger rather than the one
             # implied by the record.
             if self.server.logname is not None:
                 name = self.server.logname
             else:
                 name = record.name
             logger = logging.getLogger(name)
             # N.B. EVERY record gets logged. This is because Logger.handle
             # is normally called AFTER logger-level filtering. If you want
             # to do filtering, do it at the client end to save wasting
             # cycles and network bandwidth!
             logger.handle(record)

     class LogRecordSocketReceiver(SocketServer.ThreadingTCPServer):
         """simple TCP socket-based logging receiver suitable for testing.
         """

         allow_reuse_address = 1

         def __init__(self, host='localhost',
                      port=logging.handlers.DEFAULT_TCP_LOGGING_PORT,
                      handler=LogRecordStreamHandler):
             SocketServer.ThreadingTCPServer.__init__(self, (host, port), handler)
             self.abort = 0
             self.timeout = 1
             self.logname = None

         def serve_until_stopped(self):
             import select
             abort = 0
             while not abort:
                 rd, wr, ex = select.select([self.socket.fileno()],
                                            [], [],
                                            self.timeout)
                 if rd:
                     self.handle_request()
                 abort = self.abort

     def main():
         logging.basicConfig(
             format="%(relativeCreated)5d %(name)-15s %(levelname)-8s %(message)s")
         tcpserver = LogRecordSocketReceiver()
         print "About to start TCP server..."
         tcpserver.serve_until_stopped()

     if __name__ == "__main__":
         main()

先にサーバを起動しておき、次にクライアントを起動します。クライアント
側では、コンソールには何も出力されません;
サーバ側では以下のようなメッセージ を目にするはずです:

     About to start TCP server...
        59 root            INFO     Jackdaws love my big sphinx of quartz.
        59 myapp.area1     DEBUG    Quick zephyrs blow, vexing daft Jim.
        69 myapp.area1     INFO     How quickly daft jumping zebras vex.
        69 myapp.area2     WARNING  Jail zesty vixen who grabbed pay from quack.
        69 myapp.area2     ERROR    The five boxing wizards jump quickly.


File: python-lib-jp.info,  Node: Handler オブジェクト,  Next: Formatter オブジェクト,  Prev: ログイベントをネットワーク越しに送受信する,  Up: logging

14.5.5 Handler オブジェクト
---------------------------

ハンドラは以下の属性とメソッドを持ちます。`Handler'
は直接インスタンス化されることはありません; このクラスは
より便利なサブクラスの基底クラスとして働きます。しかしながら、
サブクラスにおける `__init__()' メソッドでは、 `Handler.__init__()'
を呼び出す必要があります。

`__init__(level=`NOTSET')'
     レベルを設定して、`Handler' インスタンスを初期化します。
     空のリストを使ってフィルタを設定し、I/O 機構へのアクセスを
     直列化するために (`createLock()' を使って) ロックを生成します。

`createLock()'
     スレッド安全でない根底の I/O 機能に対するアクセスを直列化
     するために用いられるスレッドロック (thread lock) を初期化します。

`acquire()'
     `createLock()' で生成されたスレッドロックを獲得します。

`release()'
     `acquire()' で獲得したスレッドロックを解放します。

`setLevel(lvl)'
     このハンドラに対する閾値を LVL に設定します。
     ログ記録しようとするメッセージで、LVL よりも深刻でないものは
     無視されます。ハンドラが生成された際、レベルは `NOTSET'
     (全てのメッセージが処理される) に設定されます。

`setFormatter(form)'
     このハンドラのフォーマッタを FORM に設定します。

`addFilter(filt)'
     指定されたフィルタ FILT をこのハンドラに追加します。

`removeFilter(filt)'
     指定されたフィルタ FILT をこのハンドラから除去します。

`filter(record)'
     このハンドラのフィルタをレコードに適用し、レコードが
     フィルタを透過して処理されることになる場合には真を返します。

`flush()'
     全てのログ出力がフラッシュされるようにします。このクラスの
     バージョンではなにも行わず、サブクラスで実装するためのものです。

`close()'
     ハンドラで使われている全てのリソースを始末します。このクラスの
     バージョンではなにも行わず、サブクラスで実装するためのものです。

`handle(record)'
     ハンドラに追加されたフィルタの条件に応じて、指定されたログレコードを
     発信します。このメソッドは I/O
     スレッドロックの獲得/開放を伴う実際の ログ発信をラップします。

`handleError(record)'
     このメソッドは `emit()' の呼び出し中に例外に遭遇した際に
     ハンドラから呼び出されます。デフォルトではこのメソッドは
     何も行いません。すなわち、例外は暗黙のまま無視されます。
     ほとんどのログ記録システムでは、これがほぼ望ましい機能です -
     というのは、ほとんどのユーザはログ記録システム自体のエラーは
     気にせず、むしろアプリケーションのエラーに興味があるからです。
     しかしながら、望むならこのメソッドを自作のハンドラと置き換え
     ることはできます。RECORD には、例外発生時に処理
     されていたレコードが入ります。

`format(record)'
     レコードに対する書式化を行います - フォーマッタ
     が設定されていれば、それを使います。そうでない場合、
     モジュールにデフォルト指定されたフォーマッタを使います。

`emit(record)'
     指定されたログ記録レコードを実際にログ記録する際の全ての処理
     を行います。このメソッドのこのクラスのバージョンはサブクラスで
     実装するためのものなので、`NotImplementedError' を送出します。

* Menu:

* StreamHandler::
* FileHandler::
* RotatingFileHandler::
* TimedRotatingFileHandler::
* SocketHandler::
* DatagramHandler::
* SysLogHandler::
* NTEventLogHandler::
* SMTPHandler::
* MemoryHandler::
* HTTPHandler::


File: python-lib-jp.info,  Node: StreamHandler,  Next: FileHandler,  Prev: Handler オブジェクト,  Up: Handler オブジェクト

14.5.5.1 StreamHandler
......................

`StreamHandler' クラスは、`logging' パッケージのコアにあり
ますが、ログ出力を SYS.STDOUT、SYS.STDERR あるいは何らかの
ファイル類似オブジェクト(あるいは、もっと正確にいえ ば、`write()'
および `flush()' メソッドをサポートする何ら かのオブジェクト)
といったストリームに送信します。

`StreamHandler([strm])'
     `StreamHandler' クラスの新たなインスタンスを返します。 STRM
     が指定された場合、インスタンスはログ出力先として
     指定されたストリームを使います; そうでない場合、 SYS.STDERR
     が使われます。

`emit(record)'
     フォーマッタが指定されていれば、フォーマッタを使ってレコードを書式化
     します。次に、レコードがストリームに書き込まれ、末端に
     改行がつけられます。例外情報が存在する場合、
     `traceback.print_exception()' を使って書式化され、
     ストリームの末尾につけられます。

`flush()'
     ストリームの `flush()' メソッドを呼び出してバッファを
     フラッシュします。`close()' メソッドは `Handler' から
     継承しているため何も行わないので、`flush()' 呼び出しを
     明示的に行う必要があります。


File: python-lib-jp.info,  Node: FileHandler,  Next: RotatingFileHandler,  Prev: StreamHandler,  Up: Handler オブジェクト

14.5.5.2 FileHandler
....................

`FileHandler' クラスは、`logging' パッケージのコアにありま
すが、ログ出力をディスク上のファイルに送信します。このクラスは出力機能
を `StreamHandler' から継承しています。

`FileHandler(filename[, mode])'
     `FileHandler' クラスの新たなインスタンスを返します。
     指定されたファイルが開かれ、ログ記録のためのストリームとして
     使われます。MODE が指定されなかった場合、 `'a''
     が使われます。デフォルトでは、ファイルは無制限に大きくなりつづけます。

`close()'
     ファイルを閉じます。

`emit(record)'
     RECORD をファイルに出力します。


File: python-lib-jp.info,  Node: RotatingFileHandler,  Next: TimedRotatingFileHandler,  Prev: FileHandler,  Up: Handler オブジェクト

14.5.5.3 RotatingFileHandler
............................

`RotatingFileHandler' クラスは、`logging.handlers' モジュー
ルの中にありますが、ディスク上のログファイルに対するローテーション処理
をサポートします。

`RotatingFileHandler(filename[, mode[, maxBytes[, backupCount]]])'
     `RotatingFileHandler' クラスの新たなインスタンスを返します。
     指定されたファイルが開かれ、ログ記録のためのストリームとして
     使われます。MODE が指定されなかった場合、 `"a"'
     が使われます。デフォルトでは、ファイルは無制限に大きくなりつづけます。

     あらかじめ決められたサイズでファイルをロールオーバ ("rollover")
     させられるように、MAXBYTES および BACKUPCOUNT 値を
     指定することができます。指定サイズを超えそうになると、ファイルは
     閉じられ、暗黙のうちに新たなファイルが開かれます。ロールオーバは
     現在のログファイルの長さが MAXBYTES に近くなると常に起きます。
     BACKUPCOUNT が非ゼロの場合、システムは古いログファイルを
     ファイル名に ".1", ".2" といった拡張子を追加して保存します。
     例えば、BACKUPCOUNT が 5 で、基本のファイル名が `app.log' なら、
     `app.log'、 `app.log.1'、 `app.log.2'、 ... と続き、 `app.log.5'
     までを得ることになります。ログの書き込み対象になる ファイルは常に
     `app.log' です。このファイルが満杯になると、
     ファイルは閉じられ、`app.log.1' に名称変更されます。
     `app.log.1'、`app.log.2' などが存在する場合、それらの
     ファイルはそれぞれ`app.log.2'、`app.log.3' といった具合に
     名前変更されます。

`doRollover()'
     上述のような方法でロールオーバを行います。

`emit(record)'
     上述のようなロールオーバを行いながら、
     レコードをファイルに出力します。


File: python-lib-jp.info,  Node: TimedRotatingFileHandler,  Next: SocketHandler,  Prev: RotatingFileHandler,  Up: Handler オブジェクト

14.5.5.4 TimedRotatingFileHandler
.................................

`TimedRotatingFileHandler' クラスは、`logging.handlers' モ
ジュールの中にありますが、特定の時間間隔でのログ交替をサポートしていま
す。

`TimedRotatingFileHandler(filename [,when [,interval [,backupCount]]])'
     `TimedRotatingFileHandler' クラスの新たなインスタンスを返します。
     FILENAME に指定したファイルを開き、ログ出力先のストリームとして
     使います。ログファイルの交替時には、ファイル名に拡張子 (suffix) を
     つけます。ログファイルの交替はWHEN および INTERVAL
     の積に基づいて行います。

     WHEN は INTERVAL の単位を指定するために使います。
     使える値は下表の通りで、大小文字の区別を行いません:

     値                                 INTERVAL の単位
     ------                             -----
     S                                  秒
     M                                  分
     H                                  時間
     D                                  日
     W                                  曜日 (0=Monday)
     midnight                           深夜

     BACKUPCOUNT がゼロでない場合、古いログファイルを保存する際に
     ロギングシステムは拡張子を付けます。拡張子は日付と時間に基づいて、
     strftime の `%Y-%m-%d_%H-%M-%S' 形式かその前の方の一部分を、
     ロールオーバ間隔に依存した形で使います。
     保存されるファイル数は高々 BACKUPCOUNT 個で、それ以上のファイルが
     ロールオーバされる時に作られるならば、一番古いものが削除されます。

`doRollover()'
     上記の方法でロールオーバを行います。

`emit(record)'
     `setRollover()' で解説した方法でロールオーバを行いながら、
     レコードをファイルに出力します。


File: python-lib-jp.info,  Node: SocketHandler,  Next: DatagramHandler,  Prev: TimedRotatingFileHandler,  Up: Handler オブジェクト

14.5.5.5 SocketHandler
......................

`SocketHandler' クラスは、`logging.handlers' モ
ジュールの中にありますが、ログ出力をネットワークソケットに
送信します。基底クラスでは TCP ソケットを用います。

`SocketHandler(host, port)'
     アドレスが HOST および PORT で与えられた遠隔のマシン
     と通信するようにした `SocketHandler' クラスのインスタンスを
     生成して返します。

`close()'
     ソケットを閉じます。

`handleError()'

`emit()'
     レコードの属性辞書を pickle 化し、バイナリ形式でソケットに書き込み
     ます。ソケット操作でエラーが生じた場合、暗黙のうちにパケットは
     捨てられます。前もって接続が失われていた場合、接続を再度確立
     します。受信端でレコードを逆 pickle 化して `LogRecord'
     にするには、`makeLogRecord' 関数を使ってください。

`handleError()'
     `emit()' の処理中に発生したエラーを処理します。
     よくある原因は接続の消失です。次のイベント発生時に再度
     接続確立を試みることができるようにソケットを閉じます。

`makeSocket()'
     サブクラスで必要なソケット形式を詳細に定義できるようにするための
     ファクトリメソッドです。デフォルトの実装では、TCP ソケット
     (`socket.SOCK_STREAM') を生成します。

`makePickle(record)'
     レコードの属性辞書を pickle 化して、長さを指定プレフィクス付きの
     バイナリにし、ソケットを介して送信できるようにして返します。

`send(packet)'
     pickle 化された文字列 PACKET をソケットに送信します。
     この関数はネットワークが処理待ち状態の時に発生しうる部分的送信を
     行えます。


File: python-lib-jp.info,  Node: DatagramHandler,  Next: SysLogHandler,  Prev: SocketHandler,  Up: Handler オブジェクト

14.5.5.6 DatagramHandler
........................

`DatagramHandler' クラスは、`logging.handlers' モ
ジュールの中にありますが、 `SocketHandler' を
継承しており、ログ記録メッセージを UDP ソケットを介して
送れるようサポートしています。

`DatagramHandler(host, port)'
     アドレスが HOST および PORT で与えられた遠隔のマシン
     と通信するようにした `DatagramHandler' クラスのインスタンスを
     生成して返します。

`emit()'
     レコードの属性辞書を pickle 化し、バイナリ形式でソケットに書き込み
     ます。ソケット操作でエラーが生じた場合、暗黙のうちにパケットは
     捨てられます。前もって接続が失われていた場合、接続を再度確立
     します。受信端でレコードを逆 pickle 化して `LogRecord' にするには、
     `makeLogRecord' 関数を使ってください。

`makeSocket()'
     ここで `SocketHandler' のファクトリメソッドをオーバライド して UDP
     ソケット (`socket.SOCK_DGRAM') を生成しています。

`send(s)'
     pickle 化された文字列をソケットに送信します。


File: python-lib-jp.info,  Node: SysLogHandler,  Next: NTEventLogHandler,  Prev: DatagramHandler,  Up: Handler オブジェクト

14.5.5.7 SysLogHandler
......................

`SysLogHandler' クラスは、`logging.handlers' モ
ジュールの中にありますが、ログ記録メッセージを遠隔またはローカル の
UNIX syslog に送信する機能をサポートしています。

`SysLogHandler([address[, facility]])'
     遠隔のUNIX マシンと通信するための、`SysLogHandler' クラスの
     新たなインスタンスを返します。マシンのアドレスは `(HOST, PORT)'
     のタプル形式をとる ADDRESS で与えられます。 ADDRESS
     が指定されない場合、`('localhost', 514)' が 使われます。アドレスは
     UDP ソケットを使って開かれます。 FACILITY
     が指定されない場合、`LOG_USER' が使われます。

`close()'
     遠隔ホストのソケットを閉じます。

`emit(record)'
     レコードは書式化された後、syslog サーバに送信されます。
     例外情報が存在しても、サーバには _送信されません_ 。

`encodePriority(facility, priority)'
     便宜レベル (facility) および優先度を整数に符号化します。値は文字列
     でも整数でも渡すことができます。文字列が渡された場合、内部の
     対応付け辞書が使われ、整数に変換されます。


File: python-lib-jp.info,  Node: NTEventLogHandler,  Next: SMTPHandler,  Prev: SysLogHandler,  Up: Handler オブジェクト

14.5.5.8 NTEventLogHandler
..........................

`NTEventLogHandler' クラスは、`logging.handlers' モ
ジュールの中にありますが、ログ記録メッセージをローカルな Windows
NT、Windows 2000 、または Windows XP のイベントログ (event log)
に送信する機能をサポートします。この機能を使えるようにするには、 Mark
Hammond による Python 用 Win32 拡張パッケージをインストール
する必要があります。

`NTEventLogHandler(appname[, dllname[, logtype]])'
     `NTEventLogHandler' クラスの新たなインスタンスを返します。 APPNAME
     はイベントログに表示する際のアプリケーション名を定義する
     ために使われます。この名前を使って適切なレジストリエントリが生成されます。
     DLLNAME はログに保存するメッセージ定義の入った .dll または .exe
     ファイルへの完全に限定的な (fully qualified) パス名を与えなければ
     なりません (指定されない場合、`'win32service.pyd'' が 使われます -
     このライブラリは Win32 拡張とともにインストールされ、
     いくつかのプレースホルダとなるメッセージ定義を含んでいます)。
     これらのプレースホルダを利用すると、メッセージの発信源全体がログに
     記録されるため、イベントログは巨大になるので注意してください。
     LOGTYPE は `'Application''、 `'System'' または `'Security''
     のいずれかであるか、デフォルトの `'Application''
     でなければなりません。

`close()'
     現時点では、イベントログエントリの発信源としての
     アプリケーション名をレジストリから除去することができます。
     しかしこれを行うと、イベントログビューアで意図したログをみることが
     できなくなるでしょう - これはイベントログが .dll 名を取得するために
     レジストリにアクセスできなければならないからです。現在のバージョン
     ではこの操作を行いません (実際、このメソッドは何も行いません)。

`emit(record)'
     メッセージ ID、イベントカテゴリおよびイベント型を決定し、
     メッセージを NT イベントログに記録します。

`getEventCategory(record)'
     レコードに対するイベントカテゴリを返します。自作のカテゴリを
     指定したい場合、このメソッドをオーバライドしてください。
     このクラスのバージョンのメソッドは 0 を返します。

`getEventType(record)'
     レコードのイベント型を返します。自作の型を指定したい場合、
     このメソッドをオーバライドしてください。
     このクラスのバージョンのメソッドは、ハンドラの TYPEMAP 属性を
     使って対応付けを行います。この属性は `__init__()' で初期化
     され、`DEBUG'、`INFO'、 `WARNING'、 `ERROR'、および `CRITICAL'
     が入っています。
     自作のレベルを使っているのなら、このメソッドをオーバライドするか、
     ハンドラの TYPEMAP 属性に適切な辞書を配置する必要があるでしょう。

`getMessageID(record)'
     レコードのメッセージ ID を返します。自作のメッセージを使っているの
     なら、ロガーに渡されるMSG を書式化文字列ではなく ID に
     します。その上で、辞書参照を行ってメッセージ ID を得ます。
     このクラスのバージョンでは 1 を返します。この値は
     `win32service.pyd' における基本となるメッセージ ID です。


File: python-lib-jp.info,  Node: SMTPHandler,  Next: MemoryHandler,  Prev: NTEventLogHandler,  Up: Handler オブジェクト

14.5.5.9 SMTPHandler
....................

`SMTPHandler' クラスは、`logging.handlers' モ
ジュールの中にありますが、SMTP を介したログ記録メッセージの
送信機能をサポートします。

`SMTPHandler(mailhost, fromaddr, toaddrs, subject)'
     新たな `SMTPHandler' クラスのインスタンスを返します。
     インスタンスは email の from および to アドレス行、および subject
     行と ともに初期化されます。 TOADDRS
     は文字列からなるリストでなければなりません 非標準の SMTP
     ポートを指定するには、MAILHOST 引数に (host, port)
     のタプル形式を指定します。文字列を使った場合、標準の SMTP ポートが
     使われます。

`emit(record)'
     レコードを書式化し、指定されたアドレスに送信します。

`getSubject(record)'
     レコードに応じたサブジェクト行を指定したいなら、このメソッドを
     オーバライドしてください。


File: python-lib-jp.info,  Node: MemoryHandler,  Next: HTTPHandler,  Prev: SMTPHandler,  Up: Handler オブジェクト

14.5.5.10 MemoryHandler
.......................

`MemoryHandler' は、`logging.handlers' モ
ジュールの中にありますが、ログ記録するレコードをメモリ上にバッファし、
定期的にその内容をターゲット ("target") となるハンドラに
フラッシュする機能をサポートしています。
フラッシュ処理はバッファが一杯になるか、ある深刻さかそれ以上のレベル
をもったイベントが観測された際に行われます。

`MemoryHandler' はより一般的な抽象クラス、 `BufferingHandler'
のサブクラスです。この抽象クラスでは、
ログ記録するレコードをメモリ上にバッファします。各レコードがバッファに
追加される毎に、`shouldFlush()' を呼び出してバッファをフラッシュ
すべきかどうか調べます。フラッシュする必要がある場合、`flush()'
が必要にして十分な処理を行うものと想定しています。

`BufferingHandler(capacity)'
     指定し許容量のバッファでハンドラを初期化します。

`emit(record)'
     レコードをバッファに追加します。 `shouldFlush()' が真を
     返す場合、バッファを処理するために `flush()' を呼び出します。

`flush()'
     このメソッドをオーバライドして、自作のフラッシュ動作を実装することが
     できます。このクラスのバージョンのメソッドでは、単にバッファの内容を
     削除して空にします。

`shouldFlush(record)'
     バッファが許容量に達している場合に真を返します。このメソッドは
     自作のフラッシュ処理方針を実装するためにオーバライドすることが
     できます。

`MemoryHandler(capacity[, flushLevel [, target]])'
     `MemoryHandler' クラスの新たなインスタンスを返します。
     インスタンスはサイズ CAPACITY のバッファとともに初期化されます。
     FLUSHLEVEL が指定されていない場合、`ERROR' が使われます。 TARGET
     が指定されていない場合、ハンドラが何らかの有意義な 処理を行う前に
     `setTarget()' でターゲットを指定する必要があります。

`close()'
     `flush()' を呼び出し、ターゲットを `None' に
     設定してバッファを消去します。

`flush()'
     `MemoryHandler' の場合、フラッシュ処理は単に、バッファされた
     レコードをターゲットがあれば送信することを意味します。
     違った動作を行いたい場合、オーバライドしてください。

`setTarget(target)'
     ターゲットハンドラをこのハンドラに設定します。

`shouldFlush(record)'
     バッファが満杯になっているか、 FLUSHLEVEL またはそれ以上の
     レコードでないかを調べます。


File: python-lib-jp.info,  Node: HTTPHandler,  Prev: MemoryHandler,  Up: Handler オブジェクト

14.5.5.11 HTTPHandler
.....................

`HTTPHandler' クラスは、`logging.handlers' モ
ジュールの中にありますが、ログ記録メッセージを `GET' または `POST'
セマンティクスを使って Web サーバに送信する機能をサポートしています。

`HTTPHandler(host, url[, method])'
     `HTTPHandler' クラスの新たなインスタンスを返します。
     インスタンスはホストアドレス、URL および HTTP メソッドと
     ともに初期化されます。 HOST
     は特別なポートを使うことが必要な場合には、 `host:port'
     の形式で使うこともできます。 METHOD が指定されなかった場合 `GET'
     が使われます。

`emit(record)'
     レコードを URL エンコードされた辞書形式で Web サーバに送信します。


File: python-lib-jp.info,  Node: Formatter オブジェクト,  Next: Filter オブジェクト,  Prev: Handler オブジェクト,  Up: logging

14.5.6 Formatter オブジェクト
-----------------------------

`Formatter' は以下の属性とメソッドを持っています。 `Formatter' は
`LogRecord' を (通常は) 人間か外部のシステム
で解釈できる文字列に変換する役割を担っています。基底クラスの
`Formatter' では書式化文字列を指定することができます。
何も指定されなかった場合、`'%(message)s'' の値が使われます。

Formatter は書式化文字列とともに初期化され、`LogRecord' 属性に
入っている知識を利用できるようにします - 上で触れたデフォルトの
値では、ユーザによるメッセージと引数はあらかじめ書式化されて、
`LogRecord' の MESSAGE 属性に入っていることを利用 しているようにです。
この書式化文字列は、Python 標準の %
を使った変換文字列で構成されます。文字列整形に関する詳細は *Note
文字列フォーマット操作:: "String Formatting Operations"
の章を参照してください。

現状では、 `LogRecord' の有用な属性は以下のようになっています:

Format                               Description
------                               -----
%(name)s                             ロガー (ログ記録チャネル) の名前
%(levelno)s                          メッセージのログ記録レベルを表す数字
                                     (DEBUG, INFO, WARNING, ERROR,
                                     CRITICAL)
%(levelname)s                        メッセージのログ記録レベルを表す文字列
                                     ("DEBUG",  "INFO", "WARNING",
                                     "ERROR", "CRITICAL")
%(pathname)s                         ログ記録の呼び出しが行われたソースファイルの
                                     全パス名 (取得できる場合)
%(filename)s                         パス名中のファイル名部分
%(module)s                           モジュール名 (ファイル名の名前部分)
%(funcName)s                         ログ記録の呼び出しを含む関数の名前
%(lineno)d                           ログ記録の呼び出しが行われたソース行番号
                                     (取得できる場合)
%(created)f                          `LogRecord' が生成された時刻
                                     (time.time() の返した値)
%(asctime)s                          `LogRecord'
                                     が生成された時刻を人間が読める書式で
                                     表したもの。 デフォルトでは
                                     "2003-07-08 16:49:45,896" 形式
                                     (コンマ以降の数字は時刻のミリ秒部分)
                                     です
%(msecs)d                            `LogRecord'
                                     が生成された時刻の、ミリ秒部分
%(thread)d                           スレッド ID (取得できる場合)
%(threadName)s                       スレッド名 (取得できる場合)
%(process)d                          プロセス ID (取得できる場合)
%(message)s                          レコードが発信された際に処理された
                                     `msg % args' の結果

_Changed in Python version 2.5_

`Formatter([fmt[, datefmt]])'
     `Formatter' クラスの新たなインスタンスを返します。インスタンスは
     全体としてのメッセージに対する書式化文字列と、メッセージの
     日付/時刻部分のための書式化文字列を伴って初期化されます。FMT
     が指定されない場合、 `datefmt' が指定されない場合、ISO8601
     日付書式が使われます。

`format(record)'
     レコードの属性辞書が、文字列を書式化する演算で被演算子として
     使われます。書式化された結果の文字列を返します。
     辞書を書式化する前に、二つの準備段階を経ます。 レコードの MESSAGE
     属性が MSG % ARGS を使って 処理されます。書式化された文字列が
     `'(asctime)'' を含む なら、 `formatTime()'
     が呼び出され、イベントの発生時刻を
     書式化します。例外情報が存在する場合、`formatException()'
     を使って書式化され、メッセージに追加されます。

`formatTime(record[, datefmt])'
     このメソッドは、フォーマッタが書式化された時間を利用したい際に、
     `format()' から呼び出されます。このメソッドは特定の要求を
     提供するためにフォーマッタで上書きすることができますが、基本的な
     振る舞いは以下のようになります: DATEFMT (文字列) が指定された
     場合、レコードが生成された時刻を書式化するために `time.strftime()'
     で使われます。そうでない場合、 ISO8601
     書式が使われます。結果の文字列が返されます。

`formatException(exc_info)'
     指定された例外情報 (`sys.exc_info()' が返すような
     標準例外のタプル) を文字列として書式化します。
     デフォルトの実装は単に `traceback.print_exception()'
     を使います。結果の文字列が返されます。


File: python-lib-jp.info,  Node: Filter オブジェクト,  Next: LogRecord オブジェクト,  Prev: Formatter オブジェクト,  Up: logging

14.5.7 Filter オブジェクト
--------------------------

`Filter' は `Handler' と `Logger' によって利用され、
レベルによる制御よりも洗練されたフィルタ処理を提供します。基底の
フィルタクラスでは、ロガーの階層構造のある点よりも下層にあるイベント
だけを通過させます。例えば、"A.B" で初期化されたフィルタは ロガー
"A.B"、 "A.B.C"、 "A.B.C.D"、 "A.B.D" などでログ記録された
イベントを通過させます。しかし、 "A.BB"、"B.A.B" などは通過させません。
空の文字列で初期化された場合、全てのイベントを通過させます。

`Filter([name])'
     `Filter' クラスのインスタンスを返します。 NAME が指定されて
     いれば、NAME
     はロガーの名前を表します。指定されたロガーとその子ロガー
     のイベントがフィルタを通過できるようになります。NAME が指定
     されなければ、全てのイベントを通過させます。

`filter(record)'
     指定されたレコードがログされているか？ されていなければゼロを、
     されていればゼロでない値を返します。適切と判断されれば、このメソッド
     によってレコードは in place で修正されることがあります。


File: python-lib-jp.info,  Node: LogRecord オブジェクト,  Next: スレッド安全性,  Prev: Filter オブジェクト,  Up: logging

14.5.8 LogRecord オブジェクト
-----------------------------

何かをログ記録する際には常に `LogRecord' インスタンスが生成されます。
インスタンスにはログ記録されることになっているイベントに関係する
全ての情報が入っています。インスタンスに渡される主要な情報は MSG および
ARGS で、これらは msg % args を使って
組み合わせられ、レコードのメッセージフィールドを生成します。
レコードはまた、レコードがいつ生成されたか、ログ記録がソースコード
行のどこで呼び出されたか、あるいはログ記録すべき何らかの例外情報
といった情報も含んでいます。

`LogRecord(name, lvl, pathname, lineno, msg, args, exc_info)'
     関係のある情報とともに初期化された `LogRecord' のインスタンスを
     返します。NAME はロガーの名前です; LVL は数字で表された
     レベルです; PATHNAME はログ記録呼び出しが見つかったソースファイル
     の絶対パス名です。MSG はユーザ定義のメッセージ (書式化文字列)
     です; ARGS はタプルで、MSG と合わせて、ユーザメッセージ
     を生成します; EXC_INFO は例外情報のタプルで、 `sys.exc_info() '
     を呼び出して得られたもの (または、 例外情報が取得できない場合には
     `None') です。

`getMessage()'
     ユーザが供給した引数をメッセージに交ぜた後、この `LogRecord'
     インスタンスへの メッセージを返します。


File: python-lib-jp.info,  Node: スレッド安全性,  Next: 環境設定,  Prev: LogRecord オブジェクト,  Up: logging

14.5.9 スレッド安全性
---------------------

LOGGING モジュールは、クライアントで特殊な作業を必要としない
かぎりスレッド安全 (thread-safe) なようになっています。このスレッド
安全性はスレッドロックによって達成されています;
モジュールの共有データへのアクセスを直列化するためのロックが
一つ存在し、各ハンドラでも根底にある I/O へのアクセスを直列化するために
ロックを生成します。


File: python-lib-jp.info,  Node: 環境設定,  Prev: スレッド安全性,  Up: logging

14.5.10 環境設定
----------------

* Menu:

* 環境設定のための関数::
* 環境設定ファイルの書式::


File: python-lib-jp.info,  Node: 環境設定のための関数,  Next: 環境設定ファイルの書式,  Prev: 環境設定,  Up: 環境設定

14.5.10.1 環境設定のための関数
..............................

以下の関数で `logging' モジュールの環境設定をします。
これらの関数は、`logging.config' にあります。
これらの関数の使用はオプションです -- `logging'
モジュールはこれらの関数を使うか、 (`logging' 自体で 定義されている)
主要な API を呼び出し、 `logging' か `logging.handlers'
で宣言されているハンドラを定義することで 設定することができます。

`fileConfig(fname[, defaults])'
     ログ記録の環境設定をファイル名 FNAME の ConfigParser 形式ファイル
     から読み出します。この関数はアプリケーションから何度も呼び出すことが
     でき、これによって、(設定の選択と、選択された設定を読み出す機構を
     デベロッパが提供していれば) 複数のお仕着せの設定からエンドユーザが
     選択するようにできます。ConfigParser に渡すためのデフォルト値は
     DEFAULTS 引数で指定できます。

`listen([port])'
     指定されたポートでソケットサーバを開始し、新たな設定を待ち受け
     (listen) ます。ポートが指定されなければ、モジュールのデフォルト設定
     である `DEFAULT_LOGGING_CONFIG_PORT' が使われます。
     ログ記録の環境設定は `fileConfig()' で処理できるような
     ファイルとして送信されます。 `Thread'
     インスタンスを返し、サーバを開始するために `start()'
     を呼び、適切な状況で `join()' を
     呼び出すことができます。サーバを停止するには `stopListening()'
     を呼んでください。
     設定を送るには、まず設定ファイルを読み、それを4バイトからなる長さを
     struct.`pack('>L', n)' を使ってバイナリにパックしたものを
     前に付けたバイト列としてソケットに送ります。

`stopListening()'
     `listen()' を呼び出して作成された、待ち受け中のサーバを
     停止します。通常 `listen()' の戻り値に対して `join()'
     が呼ばれる前に呼び出します。


File: python-lib-jp.info,  Node: 環境設定ファイルの書式,  Prev: 環境設定のための関数,  Up: 環境設定

14.5.10.2 環境設定ファイルの書式
................................

`fileConfig()' が解釈できる環境設定ファイルの形式は、 ConfigParser
の機能に基づいています。 ファイルには、`[loggers]'、
`[handlers]'、および `[formatters]'
といったセクションが入っていなければならず、
各セクションではファイル中で定義されている各タイプのエンティティを
名前で指定しています。こうしたエンティティの各々について、
そのエンティティをどう設定するかを示した個別のセクションがあります。
すなわち、`log01' という名前の `[loggers]' セクションにある
ロガーに対しては、対応する詳細設定がセクション `[logger_log01]'
に収められています。同様に、 `hand01' という名前の `[handlers]'
セクションにあるハンドラは `[handler_hand01]'
と呼ばれるセクションに設定をもつことになり、`[formatters]'
セクションにある `form01' は `[formatter_form01]'
というセクションで設定が指定されています。ルートロガーの 設定は
`[logger_root]' と呼ばれるセクションで指定 されていなければなりません。

ファイルにおけるこれらのセクションの例を以下に示します。

     [loggers]
     keys=root,log02,log03,log04,log05,log06,log07

     [handlers]
     keys=hand01,hand02,hand03,hand04,hand05,hand06,hand07,hand08,hand09

     [formatters]
     keys=form01,form02,form03,form04,form05,form06,form07,form08,form09

ルートロガーでは、レベルとハンドラのリストを指定しなければ
なりません。ルートロガーのセクションの例を以下に示します。

     [logger_root]
     level=NOTSET
     handlers=hand01

`level' エントリは `DEBUG, INFO, WARNING, ERROR, CRITICAL'
のうちの一つか、`NOTSET' になります。ルートロガーの場合にのみ、
`NOTSET' は全てのメッセージがログ記録されることを意味します。
レベル値は `logging' パッケージの名前空間のコンテキストに おいて
`eval()' されます。

`handlers' エントリはコンマで区切られたハンドラ名からなる
リストで、`[handlers]' セクションになくてはなりません。
また、これらの各ハンドラの名前に対応するセクションが設定ファイルに
存在しなければなりません。

ルートロガー以外のロガーでは、いくつか追加の情報が必要になります。
これは以下の例のように表されます。

     [logger_parser]
     level=DEBUG
     handlers=hand01
     propagate=1
     qualname=compiler.parser

`level' および `handlers' エントリはルートロガーのエントリ
と同様に解釈されますが、非ルートロガーのレベルが `NOTSET'
に指定された場合、ログ記録システムはロガー階層のより上位のロガー
にロガーの実効レベルを問い合わせるところが違います。 `propagate'
エントリは、メッセージをロガー階層におけるこの
ロガーの上位のハンドラに伝播させることを示す 1 に設定されるか、
メッセージを階層の上位に伝播*しない* ことを示す 0 に 設定されます。
`qualname' エントリはロガーのチャネル名を階層的に表した
もの、すなわちアプリケーションがこのロガーを取得する際に使う
名前になります。

ハンドラの環境設定を指定しているセクションは以下の例のようになります。

     [handler_hand01]
     class=StreamHandler
     level=NOTSET
     formatter=form01
     args=(sys.stdout,)

`class' エントリはハンドラのクラス (`logging' パッケージの
名前空間において `eval()' で決定されます) を示します。 `level'
はロガーの場合と同じように解釈され、`NOTSET' は "全てを記録する (log
everything)" と解釈されます。

`formatter' エントリはこのハンドラのフォーマッタに対するキー名
を表します。空文字列の場合、デフォルトのフォーマッタ
(`logging._defaultFormatter') が使われます。名前が指定
されている場合、その名前は `[formatters]' セクションになくては
ならず、対応するセクションが設定ファイル中になければなりません。

`args' エントリは、`logging' パッケージの名前空間の コンテキストで
`eval()' される際、ハンドラクラスの
コンストラクタに対する引数からなるリストになります。
典型的なエントリがどうやって作成されるかについては、対応するハンドラのコンストラクタか、以下の例を参照してください。

     [handler_hand02]
     class=FileHandler
     level=DEBUG
     formatter=form02
     args=('python.log', 'w')

     [handler_hand03]
     class=handlers.SocketHandler
     level=INFO
     formatter=form03
     args=('localhost', handlers.DEFAULT_TCP_LOGGING_PORT)

     [handler_hand04]
     class=handlers.DatagramHandler
     level=WARN
     formatter=form04
     args=('localhost', handlers.DEFAULT_UDP_LOGGING_PORT)

     [handler_hand05]
     class=handlers.SysLogHandler
     level=ERROR
     formatter=form05
     args=(('localhost', handlers.SYSLOG_UDP_PORT), handlers.SysLogHandler.LOG_USER)

     [handler_hand06]
     class=handlers.NTEventLogHandler
     level=CRITICAL
     formatter=form06
     args=('Python Application', '', 'Application')

     [handler_hand07]
     class=handlers.SMTPHandler
     level=WARN
     formatter=form07
     args=('localhost', 'from@abc', ['user1@abc', 'user2@xyz'], 'Logger Subject')

     [handler_hand08]
     class=handlers.MemoryHandler
     level=NOTSET
     formatter=form08
     target=
     args=(10, ERROR)

     [handler_hand09]
     class=handlers.HTTPHandler
     level=NOTSET
     formatter=form09
     args=('localhost:9022', '/log', 'GET')

フォーマッタの環境設定を指定しているセクションは以下のような形式です。

     [formatter_form01]
     format=F1 %(asctime)s %(levelname)s %(message)s
     datefmt=
     class=logging.Formatter

`format' エントリは全体を書式化する文字列で、`datefmt' エントリは
`strftime()' 互換の日付/時刻書式化文字列です。
空文字列の場合、パッケージによって ISO8601 形式の
日付/時刻に置き換えられ、 日付書式化文字列 "ISO8601
形式ではミリ秒も指定しており、上の書式化文字列の結果にカンマ
で区切って追加されます。ISO8601 形式の時刻の例は `2003-01-23
00:29:50,411' です。

`class' エントリはオプションです。`class' はフォーマッタのクラス名
(ドット区切りのモジュールとクラス名として)を示します。このオプションは
`Formatter' のサブクラスをインスタンス化するのに有用です。 `Formatter'
のサブクラスは例外トレースバックを展開された形式
または圧縮された形式で表現することができます。


File: python-lib-jp.info,  Node: getpass,  Next: curses,  Prev: logging,  Up: 汎用オペレーティングシステムサービス

14.6 可搬性のあるパスワード入力機構
===================================

ポータブルなパスワードとユーザーIDの検索

The `getpass' module provides two functions:
getpassモジュールは二つの機能を提供します:

`getpass([prompt[, stream]])'
     エコーなしでユーザーにパスワードを入力させるプロンプト。
     ユーザーはPROMPTの文字列をプロンプトに使えます、
     デフォルトは`'Password:''です。
     UNIXではプロンプトはファイルに似たオブジェクトSTREAMへ
     出力されます。デフォルトは`sys.stdout'です(この引数は
     Windowsでは無視されます。)。

     利用できるシステム: Macintosh, Unix, Windows _Changed in Python
     version 2.5_


`getuser()'
     ユーザーの "ログイン名"を返します。 　有効性:UNIX、Windows

     この関数は環境変数`LOGNAME' `USER' `LNAME'
     `USERNAME'の順序でチェックして、最初の空ではない文字列が設定された値を返します。
     もし、なにも設定されていない場合はpwdモジュールが提供するシステム上のパスワードデータベースから返します。それ以外は、例外が上がります。



File: python-lib-jp.info,  Node: curses,  Next: cursestextpad,  Prev: getpass,  Up: 汎用オペレーティングシステムサービス

14.7 文字セル表示のための端末操作
=================================

可搬性のある端末操作を提供する curses ライブラリへの インタフェース．

_Changed in Python version 1.6_

`curses' モジュールは、可搬性のある端末操作を行うための
デファクトスタンダードである、curses ライブラリへのインタフェースを
提供します。

UNIX 環境では curses は非常に広く用いられていますが、DOS、OS2、
そしておそらく他のシステムのバージョンも利用することができます。
この拡張モジュールは Linux および BSD 系の UNIXで動作する
オープンソースの curses ライブラリである ncurses の API に
合致するように設計されています。

See also:
     *Note cursesascii:: ロケール設定に関わらず ASCII 文字を
     扱うためのユーティリティ。 *Note cursespanel:: curses
     ウィンドウにデプス機能を追加する パネルスタック拡張。 *Note
     cursestextpad:: `Emacs' ライクなキーバインディング
     をサポートする編集可能な curses 用テキストウィジェット。 *Note
     curseswrapper:: アプリケーションの起動時および終了時に
     適切な端末のセットアップとリセットを確実に行うための関数。 `Curses
     Programming with Python'{Andrew Kuchling および Eric Raymond
     によって書かれた、curses を Python
     で使うためのチュートリアルです。 Python Web サイトで入手できます。}
     Python ソースコードの `Demo/curses/' ディレクトリには、
     このモジュールで提供されている curses
     バインディングを使ったプログラム 例がいくつか収められています。

* Menu:

* 関数 3::
* Window オブジェクト::
* 定数::


File: python-lib-jp.info,  Node: 関数 3,  Next: Window オブジェクト,  Prev: curses,  Up: curses

14.7.1 関数
-----------

`curses' モジュールでは以下の例外を定義しています:

`error'
     curses ライブラリ関数がエラーを返した際に送出される例外です。

_Note:_ 関数やメソッドにおけるオプションの引数 X および Y
がある場合、標準の値は常に現在のカーソルになります。 オプションの ATTR
がある場合、標準の値は `A_NORMAL' です。

`curses' では以下の関数を定義しています:

`baudrate()'
     端末の出力速度をビット／秒で返します。ソフトウェア端末エミュレータ
     の場合、これは固定の高い値を持つことになります。この関数は
     歴史的な理由で入れられています; かつては、この関数は時間遅延を
     生成するための出力ループを書くために用いられたり、行速度
     に応じてインタフェースを切り替えたりするために用いられたり
     していました。

`beep()'
     注意を促す短い音を鳴らします。

`can_change_color()'
     端末に表示される色をプログラマが変更できるか否かによって、
     真または偽を返します。

`cbreak()'
     cbreak モードに入ります。cbreak モード ("rare" モードと呼ばれる
     こともあります) では、通常の tty 行バッファリングはオフにされ、
     文字を一文字一文字読むことができます。ただし、raw
     モードとは異なり、 特殊文字
     (割り込み:interrupt、終了:quit、一時停止:suspend、および
     フロー制御) については、tty ドライバおよび呼び出し側のプログラムに
     対する通常の効果をもっています。まず `raw()' を呼び出し、 次いで
     `cbreak()' を呼び出すと、端末を cbreak モード にします。

`color_content(color_number)'
     色 COLOR_NUMBER の赤、緑、および青 (RGB) 要素の強度を返します。
     COLOR_NUMBER は `0' から `COLORS' の間でなければ
     なりません。与えられた色の R、G、B、の値からなる三要素のタプルが
     返されます。この値は `0' (その成分はない) から `1000'
     (その成分の最大強度) の範囲をとります。

`color_pair(color_number)'
     指定された色の表示テキストにおける属性値を返します。 属性値は
     `A_STANDOUT'、 `A_REVERSE'、 およびその他の `A_*'
     属性と組み合わせられています。 `pair_number()' はこの関数の逆です。

`curs_set(visibility)'
     カーソルの状態を設定します。VISIBILITY は 0、1、または 2 に
     設定され、それぞれ不可視、通常、または非常に可視、を意味します。
     要求された可視属性を端末がサポートしている場合、以前のカーソル
     状態が返されます;
     そうでなければ例外が送出されます。多くの端末では、 "可視 (通常)"
     モードは下線カーソルで、"非常に可視" モードは
     ブロックカーソルです。

`def_prog_mode()'
     現在の端末属性を、稼動中のプログラムが curses
     を使う際のモードである "プログラム"
     モードとして保存します。(このモードの反対は、プログラム が curses
     を使わない "シェル" モードです。) その後 `reset_prog_mode()'
     を呼ぶとこのモードを復旧します。

`def_shell_mode()'
     現在の端末属性を、稼動中のプログラムが curses
     を使っていないときのモード である "シェル"
     モードとして保存します。(このモードの反対は、 プログラムが curses
     機能を利用している "プログラム" モードです。) その後
     `reset_shell_mode()' を呼ぶとこのモードを復旧します。

`delay_output(ms)'
     出力に MS ミリ秒の一時停止を入れます。

`doupdate()'
     物理スクリーン (physical screen) を更新します。curses
     ライブラリは、
     現在の物理スクリーンの内容と、次の状態として要求されている仮想スクリーン
     をそれぞれ表す、2 つのデータ構造を保持しています。`doupdate()'
     は更新を適用し、物理スクリーンを仮想スクリーンに一致させます。

     仮想スクリーンは `addstr()' のような書き込み操作をウィンドウに
     行った後に `noutrefresh()' を呼び出して更新することができます。
     通常の `refresh()' 呼び出しは、単に `noutrefresh()' を呼んだ後に
     `doupdate()' を呼ぶだけです; 複数のウィンドウを
     更新しなければならない場合、全てのウィンドウに対して
     `noutrefresh()' を呼び出した後、一度だけ `doupdate()'
     を呼ぶことで、パフォーマンスを向上させることができ、おそらくスクリーン
     のちらつきも押さえることができます。

`echo()'
     echo モードに入ります。 echo モードでは、各文字入力はスクリーン上に
     入力された通りにエコーバックされます。

`endwin()'
     ライブラリの非初期化を行い、端末を通常の状態に戻します。

`erasechar()'
     ユーザの現在の消去文字 (erase character) 設定を返します。 UNIX
     オペレーティングシステムでは、この値は curses プログラムが
     制御している端末の属性であり、curses ライブラリ自体では設定
     されません。

`filter()'
     `filter()' ルーチンを使う場合、`initscr()' を
     呼ぶ前に呼び出さなくてはなりません。この手順のもたらす効果は以下の
     通りです: まず二つの関数の呼び出しの間は、LINES は 1
     に設定されます; clear、cup、cud、cud1、cuu1、cuu、vpa
     は無効化されます; home 文字列 は cr
     の値に設定されます。これにより、カーソルは現在の行に制限される
     ので、スクリーンの更新も同様に制限されます。
     この関数は、スクリーンの他の部分に影響を及ぼさずに文字単位の行編集を
     行う場合に利用できます。

`flash()'
     スクリーンをフラッシュ(flash) します。すなわち、画面を色反転
     (reverse-video) にして、短時間でもとにもどします。人によっては、
     `beep()' で生成される可聴な注意音よりも、このような
     "可視ベル(visible bell)" を好みます。

`flushinp()'
     全ての入力バッファをフラッシュします。この関数は、ユーザによって
     すでに入力されているが、まだプログラムによって処理されていない
     全ての先行入力文字 (typeahead) を捨て去ります。

`getmouse()'
     `getch()' が `KEY_MOUSE' を返してマウスイベントを
     通知した後、この関数を呼んで待ち行列 (queue) 上に置かれている
     マウスイベントを取得しなければなりません。イベントは `(ID, X, Y,
     Z, BSTATE)' の 5 要素のタプルで表現されています。 ID
     は複数のデバイスを区別するための ID 値で、 X、 Y、Z
     はイベントの座標値です (現在 Z は使われていません)。 BSTATE
     は整数値で、
     その各ビットはイベントのタイプを示す値に設定されています。
     この値は以下に示す定数のうち一つまたはそれ以上のビット単位 OR
     になっています。以下の定数のN は 1 から 4 のボタン番号を 示します:
     `BUTTONN_PRESSED', `BUTTONN_RELEASED', `BUTTONN_CLICKED',
     `BUTTONN_DOUBLE_CLICKED', `BUTTONN_TRIPLE_CLICKED', `BUTTON_SHIFT',
     `BUTTON_CTRL', `BUTTON_ALT'.

`getsyx()'
     仮想スクリーンにおける現在のカーソル位置を y および x
     の順で返します。 leaveok が真に設定されていれば、 -1、-1
     が返されます。

`getwin(file)'
     以前の `putwin()' 呼び出しでファイルに保存されている、
     ウィンドウ関連データを読み出します。次に、このルーチンは
     そのデータを使って新たなウィンドウを生成し初期化して、
     その新規ウィンドウオブジェクトを返します。

`has_colors()'
     端末が色表示を行える場合には真を返します。そうでない場合には偽を
     返します。

`has_ic()'
     端末が文字の挿入／削除機能を持つ場合に真を返します。
     この関数は、最近の端末エミュレータがどれもこの機能を持っているのと同じく、
     歴史的な理由だけのために含められています。

`has_il()'
     端末が行の挿入／削除機能を持つか、領域単位のスクロールによって
     機能をシミュレートできる場合に真を返します。
     この関数は、最近の端末エミュレータがどれもこの機能を持っているのと同じく、
     歴史的な理由だけのために含められています。

`has_key(ch)'
     キー値 CH をとり、現在の端末タイプがその値のキーを認識できる
     場合に真を返します。

`halfdelay(tenths)'
     半遅延モード、すなわち cbreak モードに似た、ユーザが打鍵した文字
     がすぐにプログラムで利用できるようになるモードで使われます。
     しかしながら、何も入力されなかった場合、 TENTHS 十秒後に
     例外が送出されます。TENTHS の値は 1 から 255 の間でなければ
     なりません。半遅延モードから抜けるには `nocbreak()' を使います。

`init_color(color_number, r, g, b)'
     色の定義を変更します。変更したい色番号と、その後に 3 つ組みの RGB
     値 (赤、緑、青の成分の大きさ) をとります。COLOR_NUMBER の値は `0'
     から `COLORS' の間でなければなりません。 R、G、B の値は `0' から
     `1000' の 間でなければなりません。 `init_color()' を使うと、
     スクリーン上でカラーが使用されている部分は全て新しい設定に
     即時変更されます。この関数はほとんどの端末で何も行いません;
     `can_change_color()' が `1' を返す場合にのみ 動作します。

`init_pair(pair_number, fg, bg)'
     色ペアの定義を変更します。3 つの引数: 変更したい色ペア、前景色の
     色番号、背景色の色番号、をとります。PAIR_NUMBER は `1' から
     `COLOR_PAIRS -1' の間でなければなりません (`0'
     色ペアは黒色背景に白色前景となるように設定されており、
     変更することができません) 。FG および BG 引数は `0' と `COLORS'
     の間でなければなりません。
     色ペアが以前に初期化されていれば、スクリーンを更新して、指定
     された色ペアの部分を新たな設定に変更します。

`initscr()'
     ライブラリを初期化します。スクリーン全体をあらわす `WindowObject'
     を返します。_Note:_ 端末のオープン時にエラーが発生した場合、curses
     ライブラリ によってインタープリタが終了される場合があります。

`isendwin()'
     `endwin()' がすでに呼び出されている (すなわち、curses ライブラリ
     が非初期化されてしまっている) 場合に真を返します。

`keyname(k)'
     K に番号付けされているキーの名前を返します。印字可能な ASCII
     文字を生成するキーの名前はそのキーの文字自体になります。
     コントロールキーと組み合わせたキーの名前は、キャレットの後に対応する
     ASCII 文字が続く 2 文字の文字列になります。Alt キーと組み合わせた
     キー (128-255) の名前は、先頭に `M-' が付き、その後に対応する
     ASCII 文字が続く文字列になります。

`killchar()'
     ユーザの現在の行削除文字を返します。 UNIX
     オペレーティングシステムでは、この値は curses プログラムが
     制御している端末の属性であり、curses ライブラリ自体では設定
     されません。

`longname()'
     現在の端末について記述している terminfo の長形式 name フィールドが
     入った文字列を返します。verbose 形式記述の最大長は 128 文字です。
     この値は `initscr()' 呼び出しの後でのみ定義されています。

`meta(yes)'
     YES が 1 の場合、8 ビット文字を入力として許します。YES が 0
     の場合、 7 ビット文字だけを許します。

`mouseinterval(interval)'
     ボタンが押されてから離されるまでの時間をマウスクリック一回として認識
     する最大の時間間隔を設定します。以前の内部設定値を返します。
     標準の値は 200 ミリ秒、または 5 分の 1 秒です。

`mousemask(mousemask)'
     報告すべきマウスイベントを設定し、`(AVAILMASK, OLDMASK)'
     の組からなるタプルを返します。 AVAILMASK
     はどの指定されたマウスイベントのどれが報告されるかを 示します;
     どのイベント指定も完全に失敗した場合には 0 が返ります。 OLDMASK
     は与えられたウィンドウの以前のマウスイベントマスク
     です。この関数が呼ばれない限り、マウスイベントは何も報告されません。

`napms(ms)'
     MS ミリ秒スリープします。

`newpad(nlines, ncols)'
     与えられた行とカラム数を持つパッド (pad) データ構造を生成し、その
     ポインタを返します。パッドはウィンドウオブジェクトとして返されます。

     パッドはウィンドウと同じようなものですが、スクリーンのサイズによる
     制限をうけず、スクリーンの特定の部分に関連付けられていなくても
     かまいません。大きなウィンドウが必要であり、スクリーンにはその
     ウィンドウの一部しか一度に表示しない場合に使えます。
     (スクロールや入力エコーなどによる)
     パッドに対する再描画は起こりません。 パッドに対する `refresh()'
     および `noutrefresh()' メソッド
     は、パッド中の表示する部分と表示するために利用するスクリーン上の位置を
     指定する 6 つの引数が必要です。これらの引数は pminrow、 pmincol、
     sminrow、 smincol、 smaxrow、smaxcol です; p
     で始まる引数はパッド中の表示領域の左上位置で、s で始まる引数は
     パッド領域を表示するスクリーン上のクリップ矩形を指定します。

`newwin([nlines, ncols,] begin_y, begin_x)'
     左上の角が `(BEGIN_Y, BEGIN_X)' で、高さ／幅が NLINES/NCOLS
     の新規ウィンドウを返します。

     標準では、ウィンドウは指定された位置からスクリーンの右下まで
     広がります。

`nl()'
     newlime モードに入ります。このモードはリターンキーを入力中の改行
     として変換し、出力時に改行文字を復帰 (return) と改行 (line-feed)
     に変換 します。newline モードは初期化時にはオンになっています。

`nocbreak()'
     cbreak モードから離れます。行バッファリングを行う通常の "cooked"
     モードに戻ります。

`noecho()'
     echo モードから離れます。入力のエコーバックはオフにされます。

`nonl()'
     newline モードから離れます。入力時のリターンキーから改行への変換、
     および出力時の改行から復帰／改行への低レベル変換を無効化します
     (ただし、`addch('\n')' の振る舞いは変更せず、仮想スクリーン
     上では常に復帰と改行に等しくなります)。変換をオフにすることで、
     curses は水平方向の動きを少しだけ高速化できることがあります;
     また、入力中のリターンキーの検出ができるようになります。

`noqiflush()'
     noquiflush ルーチンを使うと、通常行われている INTR、QUIT、および
     SUSP 文字による入力および出力キューのフラッシュが行われなく
     なります。シグナルハンドラが終了した際、割り込みが発生しなかった
     かのように出力を続たい場合、ハンドラ中で `noqiflush()'
     を呼び出すことができます。

`noraw()'
     raw モードから離れます。行バッファリングを行う通常の "cooked"
     モードに戻ります。

`pair_content(pair_number)'
     要求された色ペア中の色を含む `(FG, BG)' からなる
     タプルを返します。PAIR_NUMBER は `1' から ``COLOR_PAIRS' - 1'
     の間でなければなりません。

`pair_number(attr)'
     ATTR に対する色ペアセットの番号を返します。`color_pair()'
     はこの関数の逆に相当します。

`putp(string)'
     `tputs(str, 1, putchar)' と等価です; 現在の端末における、
     指定された terminfo 機能の値を出力します。putp の出力は常に標準
     出力に送られるので注意して下さい。

`qiflush( [flag] )'
     FLAG が偽なら、`noqiflush()' を呼ぶのとと同じ効果です。 FLAG
     が真か、引数が与えられていない場合、制御文字が読み出された
     最にキューはフラッシュされます。

`raw()'
     raw モードに入ります。raw モードでは、通常の行バッファリングと
     割り込み (interrupt)、終了 (quit)、一時停止 (suspend)、および
     フロー制御キーはオフになります; 文字は curses 入力関数に一文字
     づつ渡されます。

`reset_prog_mode()'
     端末を "program" モードに復旧し、予め `def_prog_mode()'
     で保存した内容に戻します。

`reset_shell_mode()'
     端末を "shell" モードに復旧し、予め `def_shell_mode()'
     で保存した内容に戻します。

`setsyx(y, x)'
     仮想スクリーンカーソルを Y、X に設定します。 Y および X が共に -1
     の場合、leaveok が設定されます。

`setupterm([termstr, fd])'
     端末を初期化します。TERMSTR は文字列で、端末の名前を与えます;
     省略された場合、TERM 環境変数の値が使われます。FD は
     初期化シーケンスが送られる先のファイル記述子です; FD
     を与えない場合、`sys.stdout' のファイル記述子が使われます。

`start_color()'
     プログラマがカラーを利用したい場合で、かつ他の何らかのカラー操作
     ルーチンを呼び出す前に呼び出さなくてはなりません。 この関数は
     `initscr()' を呼んだ直後に呼ぶようにしておくと よいでしょう。

     `start_color()' は 8 つの基本色 (黒、赤、緑、黄、青、マゼンタ、
     シアン、および白)
     と、色数の最大値と端末がサポートする色ペアの最大数
     が入っている、`curses' モジュールにおける二つのグローバル変数、
     `COLORS' および `COLOR_PAIRS' を初期化します。
     この関数はまた、色設定を端末のスイッチが入れられたときの状態に
     戻します。

`termattrs()'
     端末がサポートする全てのビデオ属性を論理和した値を返します。
     この情報は、curses プログラムがスクリーンの見え方を
     完全に制御する必要がある場合に便利です。

`termname()'
     14 文字以下になるように切り詰められた環境変数 TERM の値を返します。

`tigetflag(capname)'
     terminfo 機能名 CAPNAME に対応する機能値をブール値で返します。
     CAPNAME がブール値で表される機能値でない場合 `-1'
     が返され、機能がキャンセルされているか、端末記述上に見つからない
     場合には `0' を返します。

`tigetnum(capname)'
     terminfo 機能名 CAPNAME に対応する機能値を数値で返します。 CAPNAME
     が数値で表される機能値でない場合 `-2'
     が返され、機能がキャンセルされているか、端末記述上に見つからない
     場合には `-1' を返します。

`tigetstr(capname)'
     terminfo 機能名 CAPNAME に対応する機能値を文字列値で返します。
     CAPNAME が文字列値で表される機能値でない場合や、
     機能がキャンセルされているか、端末記述上に見つからない 場合には
     `None' を返します。

`tparm(str[,...])'
     STR を与えられたパラメタを使って文字列にインスタンス化します。 STR
     は terminfo データベースから得られたパラメタを持つ文字列
     でなければなりません。例えば、`tparm(tigetstr("cup"), 5, 3)' は
     `'\033[6;4H'' のようになります。厳密には端末の形式に
     よって異なる結果となります。

`typeahead(fd)'
     先読みチェックに使うためのファイル記述子 FD を指定します。 FD が
     `-1' の場合、先読みチェックは行われません。

     curses ライブラリはスクリーンを更新する間、先読み文字列を定期的に
     検索することで "行はみ出し最適化 (line-breakout optimization)"
     を行います。入力が得られ、かつ入力は端末からのものである場合、現在
     行おうとしている更新は refresh や doupdate を再度呼び出すまで
     先送りにします。この関数は異なるファイル記述子で先読みチェックを
     行うように指定することができます。

`unctrl(ch)'
     CH の印字可能な表現を文字列で返します。制御文字は例えば `^C'
     のようにキャレットに続く文字として表示
     されます。印字可能文字はそのままです。

`ungetch(ch)'
     CH をプッシュして、 `getch()' を次に呼び出したときに
     返されるようにします。_Note:_ `getch()' を呼び出すまでは CH
     は一つしかプッシュできません。

`ungetmouse(id, x, y, z, bstate)'
     与えられた状態データが関連付けられた `KEY_MOUSE' イベントを
     入力キューにプッシュします。

`use_env(flag)'
     この関数を使う場合、`initscr()' または newterm を呼ぶ前に
     呼び出さなくてはなりません。FLAG が偽の場合、環境変数 `LINES'
     および `COLUMNS' の値 (これらは標準の設定で 使われます)
     の値が設定されていたり、curses がウィンドウ内で 動作して (この場合
     `LINES' や `COLUMNS' が設定
     されていないとウィンドウのサイズを使います) いても、terminfo
     データベースに指定された lines および columns の値を使います。

`use_default_colors()'
     この機能をサポートしている端末上で、色の値としてデフォルト値を使う設定
     をします。
     あなたのアプリケーションで透過性とサポートするためにこの関数を使ってください。
     デフォルトの色は 色番号-1に割り当てられます。

     この関数を呼んだ後、たとえば `init_pair(x, curses.COLOR_RED, -1)'
     は色ペアXを赤い前景色とデフォルトの背景色に初期化します。


File: python-lib-jp.info,  Node: Window オブジェクト,  Next: 定数,  Prev: 関数 3,  Up: curses

14.7.2 Window オブジェクト
--------------------------

上記の `initscr()' や `newwin()' が返すウィンドウ
は、以下のメソッドを持ちます:

`addch([y, x,] ch[, attr])'
     _Note:_ ここで _文字_ は Python 文字 (長さ 1 の文字列) C における
     文字 (ASCII コード)
     を意味します。(この注釈は文字について触れている
     ドキュメントではどこでも当てはまります。) 組み込みの `ord()'
     は文字列をコードの集まりにする際に 便利です。

     `(Y, X)' にある文字 CH を属性 ATTR
     で描画します。このときその場所に以前描画された文字は上書きされます。
     標準の設定では、文字の位置および属性はウィンドウオブジェクトにおける
     現在の設定になります。

`addnstr([y, x,] str, n[, attr])'
     文字列 STR から最大で N 文字を `(Y, X)' に属性 ATTR
     で描画します。以前ディスプレイにあった内容はすべて 上書きされます。

`addstr([y, x,] str[, attr])'
     `(Y, X)' に文字列 STR を属性 ATTR で描画
     します。以前ディスプレイにあった内容はすべて上書きされます。

`attroff(attr)'
     現在のウィンドウに書き込まれた全ての内容に対し "バックグラウンド"
     に設定された属性 ATTR を除去します。

`attron(attr)'
     現在のウィンドウに書き込まれた全ての内容に対し "バックグラウンド"
     に属性 ATTR を追加します。

`attrset(attr)'
     "バックグラウンド" の属性セットを ATTR に設定します。 初期値は 0
     (属性なし) です。

`bkgd(ch[, attr])'
     ウィンドウ上の背景プロパティを、 ATTR を属性とする 文字 CH
     に設定します。変更はそのウィンドウ中の全ての文字に
     以下のようにして適用されます:
        * ウィンドウ中の全ての文字の属性が新たな背景属性に変更されます。

        * 以前の背景文字が出現すると、常に新たな背景文字に変更されます。


`bkgdset(ch[, attr])'
     ウィンドウの背景を設定します。ウィンドウの背景は、文字と何らかの
     属性の組み合わせから成り立ちます。背景情報の属性の部分は、
     ウィンドウ上に描画されている空白でない全ての文字と組み合わされ (OR
     され) ます。空白文字には文字部分と属性部分の両方が組み合わされ
     ます。背景は文字のプロパティとなり、スクロールや行／文字の挿入／削除
     操作の際には文字と一緒に移動します。

`border([ls[, rs[, ts[, bs[, tl[, tr[, bl[, br]]]]]]]])'
     ウィンドウの縁に境界線を描画します。各引数には境界の特定部分を表現
     するために使われる文字を指定します; 詳細は以下のテーブルを参照
     してください。文字は整数または 1 文字からなる文字列で指定されます。

     _Note:_ どの引数も、`0' を指定した場合標準設定の文字が
     使われるようになります。キーワード引数は使うことが _できません_。
     標準の設定はテーブル中に示されています:

     引数                   記述                   標準の設定値
     ------                 -----                  -----
     ls                     左側                   `ACS_VLINE'
     rs                     右側                   `ACS_VLINE'
     ts                     上側                   `ACS_HLINE'
     bs                     下側                   `ACS_HLINE'
     tl                     左上の角               `ACS_ULCORNER'
     tr                     右上の角               `ACS_URCORNER'
     bl                     左下の角               `ACS_LLCORNER'
     br                     右下の角               `ACS_LRCORNER'


`box([vertch, horch])'
     `border()' と同様ですが、LS および RS は 共に VERTCH で、TS および
     BS は共に HORCH
     です。この関数では、角に使われる文字は常に標準設定の値です。

`clear()'
     `erase()' に似ていますが、次に `refresh()' が呼び出された
     際に全てのウィンドウを再描画するようにします。

`clearok(yes)'
     YES が 1 ならば、次の `refresh()' はウィンドウを完全に 消去します。

`clrtobot()'
     カーソルの位置からウィンドウの端までを消去します: カーソル以降の
     全ての行が削除されるため、 `clrtoeol()' が実行されたのと
     おなじになります。

`clrtoeol()'
     カーソル位置から行末までを消去します。

`cursyncup()'
     ウィンドウの全ての親ウィンドウについて、現在のカーソル位置
     を反映するよう更新します。

`delch([y, x])'
     `(Y, X)' にある文字を削除します。 Delete any character at `(Y, X)'.

`deleteln()'
     カーソルの下にある行を削除します。後続の行はすべて 1
     行上に移動します。

`derwin([nlines, ncols,] begin_y, begin_x)'
     "derive window (ウィンドウを導出する)" の短縮形です。 `derwin()'
     は `subwin()' と同じですが、 BEGIN_Y および BEGIN+X
     はスクリーン全体の原点ではなく、
     ウィンドウの原点からの相対位置です。導出されたウィンドウオブジェクト
     が返されます。

`echochar(ch[, attr])'
     文字 CH に属性 ATTR を付与し、即座に `refresh()'
     をウィンドウに対して呼び出します。

`enclose(y, x)'
     与えられた文字セル座標をスクリーン原点から相対的なものとし、
     ウィンドウの中に含まれるかを調べて、真または偽を返します。
     スクリーン上のウィンドウの一部がマウスイベントの発生場所を
     含むかどうかを調べる上で便利です。

`erase()'
     ウィンドウをクリアします。

`getbegyx()'
     左上の角の座標をあらわすタプル `(Y, X)' を返します。

`getch([y, x])'
     文字を取得します。返される整数は ASCII の範囲の値となる
     _わけではない_ ので注意してください: ファンクションキー、
     キーパッド上のキー等は 256 よりも大きな数字を返します。無遅延
     (no-delay) モードでは、入力がない場合 -1 が返されます。

`getkey([y, x])'
     文字を取得し、 `getch()' のように整数を返す代わりに
     文字列を返します。ファンクションキー、キーバットキーなどは
     キー名の入った複数バイトからなる文字列を返します。無遅延
     モードでは、入力がない場合例外が送出されます。

`getmaxyx()'
     ウィンドウの高さおよび幅を表すタプル `(Y, X)' を返します。

`getparyx()'
     親ウィンドウ中におけるウィンドウの開始位置を x と y の二つの
     整数で返します。ウィンドウに親ウィンドウがない場合`-1,-1'
     を返します。

`getstr([y, x])'
     原始的な文字編集機能つきで、ユーザの入力文字列を読み取ります。

`getyx()'
     ウィンドウの左上角からの相対で表した現在のカーソル位置をタプル
     `(Y, X)' で返します。

`hline([y, x,] ch, n)'
     `(Y, X)' から始まり、 N の長さを持つ、 文字 CH
     で作られる水平線を表示します。

`idcok(flag)'
     FLAG が偽の場合、curses は端末のハードウェアによる文字挿入／削除
     機能を使おうとしなくなります; FLAG が真ならば、文字挿入／削除
     は有効にされます。curses が最初に初期化された際には文字挿入／削除は
     標準の設定で有効になっています。

`idlok(yes)'
     YES が 1 であれば、`curses' はハードウェアの行編集
     機能を利用しようと試みます。行挿入／削除は無効化されます。

`immedok(flag)'
     FLAG が真ならば、ウィンドウイメージ内における何らかの変更
     があるとウィンドウを更新するようになります; すなわち、`refresh()'
     を自分で呼ばなくても良くなります。とはいえ、wrefresh を繰り返し
     呼び出すことになるため、この操作はかなりパフォーマンスを低下させます。
     標準の設定では無効になっています。

`inch([y, x])'
     ウィンドウの指定の位置の文字を返します。下位 8
     ビットが常に文字となり、 それより上のビットは属性を表します。

`insch([y, x,] ch[, attr])'
     `(Y, X)' に文字 CH を属性 ATTR で描画し、 行の X からの内容を 1
     文字分右にずらします。

`insdelln(nlines)'
     NLINES 行を指定されたウィンドウの現在の行の上に挿入します。
     その下にある NLINES 行は失われます。負の NLINES を指定
     すると、カーソルのある行以降の NLINES を削除し、削除された行の
     後ろに続く内容が上に来ます。その下にある NLINES は消去されます。
     現在のカーソル位置はそのままです。

`insertln()'
     カーソルの下に空行を 1 行入れます。それ以降の行は 1 行づつ下に移動
     します。

`insnstr([y, x,] str, n [, attr])'
     文字列をカーソルの下にある文字の前に (一行に収まるだけ) 最大 N 文字
     挿入します。N がゼロまたは負の値の場合、文字列全体が挿入されます。
     カーソルの右にある全ての文字は右に移動し、行の左端にある文字は失われます。
     カーソル位置は (Y、 X が指定されていた場合はそこに移動しますが、
     その後は) 変化しません。

`insstr([y, x, ] str [, attr])'
     キャラクタ文字列を (行に収まるだけ) カーソルより前に挿入します。
     カーソルの右側にある文字は全て右にシフトし、行の右端の文字は失われます。
     カーソル位置は (Y、 X が指定されていた場合はそこに移動しますが、
     その後は) 変化しません。

`instr([y, x] [, n])'
     現在のカーソル位置、または Y, X が指定されている場合には
     その場所から始まるキャラクタ文字列をウィンドウから抽出して返します。
     属性は文字から剥ぎ取られます。N が指定された場合、`instr()' は
     (末尾の NUL 文字を除いて) 最大で N 文字までの長さからなる
     文字列を返します。

`is_linetouched(LINE)'
     指定した行が、最後に `refresh()' を呼んだ時から変更されている
     場合に真を返します; そうでない場合には偽を返します。 LINE
     が現在のウィンドウ上の有効な行でない場合、 `curses.error'
     例外を送出します。

`is_wintouched()'
     指定したウィンドウが、最後に `refresh()'
     を呼んだ時から変更されている 場合に真を返します;
     そうでない場合には偽を返します。

`keypad(yes)'
     YES が 1 の場合、ある種のキー (キーパッドやファンクションキー)
     によって生成されたエスケープシーケンスは `curses' で
     解釈されます。YES が 0 の場合、エスケープシーケンスは
     入力ストリームにそのままの状態で残されます。

`leaveok(yes)'
     YES が 1 の場合、カーソルは "カーソル位置" に移動せず
     現在の場所にとどめます。これにより、カーソルの移動を減らせる
     可能性があります。この場合、カーソルは不可視にされます。

     YES が 0 の場合、カーソルは更新の際に常に "カーソル位置"
     に移動します。

`move(new_y, new_x)'
     カーソルを `(NEW_Y, NEW_X)' に移動します。

`mvderwin(y, x)'
     ウィンドウを親ウィンドウの中で移動します。ウィンドウのスクリーン相対
     となるパラメタ群は変化しません。このルーチンは親ウィンドウの一部を
     スクリーン上の同じ物理位置に表示する際に用いられます。

`mvwin(new_y, new_x)'
     ウィンドウの左上角が `(NEW_Y, NEW_X)' になるように移動します。

`nodelay(yes)'
     YES が `1' の場合、`getch()' は非ブロックで動作します。

`notimeout(yes)'
     YES が `1' の場合、エスケープシーケンスはタイムアウト
     しなくなります。

     YES が `0' の場合、数ミリ秒間の間エスケープシーケンスは
     解釈されず、入力ストリーム中にそのままの状態で残されます。

`noutrefresh()'
     更新をマークはしますが待機します。この関数はウィンドウのデータ構造
     を表現したい内容を反映するように更新しますが、物理スクリーン上に
     反映させるための強制更新を行いません。更新を行うためには
     `doupdate()' を呼び出します。

`overlay(destwin[, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol])'
     ウィンドウを DESTWIN の上に重ね書き (overlay) します。
     ウィンドウは同じサイズである必要はなく、重なっている領域だけが
     複写されます。この複写は非破壊的 (non-destructive) です。これは
     現在の背景文字が DESTWIN の内容を上書きしないことを意味します。

     複写領域をきめ細かく制御するために、`overlay()' の第二形式を
     使うことができます。SMINROW および SMINCOL は
     元のウィンドウの左上の座標で、他の変数は DESTWIN 内の矩形を
     表します。

`overwrite(destwin[, sminrow, smincol, dminrow, dmincol, dmaxrow, dmaxcol])'
     DESTWIN の上にウィンドウの内容を上書き (overwrite) します。
     ウィンドウは同じサイズである必要はなく、重なっている領域だけが
     複写されます。この複写は破壊的 (destructive) です。これは
     現在の背景文字が DESTWIN の内容を上書きすることを意味します。

     複写領域をきめ細かく制御するために、`overlay()' の第二形式を
     使うことができます。SMINROW および SMINCOL は
     元のウィンドウの左上の座標で、他の変数は DESTWIN 内の矩形を
     表します。

`putwin(file)'
     ウィンドウに関連付けられている全てのデータを与えられたファイルオブジェクト
     に書き込みます。この情報は後に `getwin()' 関数を使って
     取得することができます。

`redrawln(beg, num)'
     BEG 行から始まる NUM スクリーン行の表示内容が壊れており、 次の
     `refresh()' 呼び出しで完全に再描画されなければならない
     ことを通知します。

`redrawwin()'
     ウィンドウ全体を更新 (touch) し、次の `refresh()' 呼び出しで
     完全に再描画されるようにします。

`refresh([pminrow, pmincol, sminrow, smincol, smaxrow, smaxcol])'
     ディスプレイを即時更新し (現実のウィンドウとこれまでの描画／削除
     メソッドの内容との同期をとり) ます。

     6 つのオプション引数はウィンドウが `newpad()' で生成された
     場合にのみ指定することができます。追加の引数はパッドやスクリーンの
     どの部分が含まれるのかを示すために必要です。 PMINROW および
     PMINCOL にはパッドが表示されている矩形の
     左上角を指定します。SMINROW,  SMINCOL, SMAXROW, および SMAXCOL
     には、スクリーン上に表示される矩形の縁を指定します。
     パッド内に表示される矩形の右下角はスクリーン座標から計算されるので、
     矩形は同じサイズでなければなりません。矩形は両方とも、それぞれの
     ウィンドウ構造内に完全に含まれていなければなりません。 PMINROW,
     PMINCOL, SMINROW, または SMINCOL
     に負の値を指定すると、ゼロを指定したものとして扱われます。

`scroll([lines` = 1'])'
     スクリーンまたはスクロール領域を上に LINES 行スクロール します。

`scrollok(flag)'
     ウィンドウのカーソルが、最下行で改行を行ったり最後の文字を入力したり
     した結果、ウィンドウやスクロール領域の縁からはみ出して移動した際の
     動作を制御します。FLAG が偽の場合、カーソルは最下行にそのまま
     にしておかれます。FLAG が真の場合、ウィンドウは 1 行上に
     スクロールします。端末の物理スクロール効果を得るためには `idlok()'
     も呼び出す必要があるので注意してください。

`setscrreg(top, bottom)'
     スクロール領域を TOP から BOTTOM に設定します。
     スクロール動作は全てこの領域で行われます。

`standend()'
     A_STANDOUT 属性をオフにします。端末によっては、この操作で
     全ての属性をオフにする副作用が発生します。

`standout()'
     A_STANDOUT 属性をオンにします。

`subpad([nlines, ncols,] begin_y, begin_x)'
     左上の角が `(BEGIN_Y, BEGIN_X)' にあり、幅／高さが それぞれ
     NCOLS/NLINES であるようなサブウィンドウを返します。

`subwin([nlines, ncols,] begin_y, begin_x)'
     左上の角が `(BEGIN_Y, BEGIN_X)' にあり、幅／高さが それぞれ
     NCOLS/NLINES であるようなサブウィンドウを返します。

     標準の設定では、サブウィンドウは指定された場所からウィンドウの右下角まで
     広がります。

`syncdown()'
     このウィンドウの上位のウィンドウのいずれかで更新(touch)された各場所を
     このウィンドウ内でも更新します。 このルーチンは `refresh()'
     から呼び出されるので、 手動で呼び出す必要はほとんどないはずです。

`syncok(flag)'
     FLAG を真にして呼び出すと、ウィンドウが変更された際は常に
     `syncup()' を自動的に呼ぶようになります。

`syncup()'
     ウィンドウ内で更新 (touch)
     した場所を、上位の全てのウィンドウ内でも更新します。

`timeout(delay)'
     ウィンドウのブロックまたは非ブロック読み込み動作を設定します。
     DELAY が負の場合、ブロック読み出しが使われ、入力を無期限で
     待ち受けます。DELAY がゼロの場合、非ブロック読み出しが 使われ、
     入力待ちの文字がない場合 `getch()' は -1 を返し ます。DELAY
     が正の値であれば、 `getch()' は DELAY
     ミリ秒間ブロックし、ブロック後の時点で入力がない場合には -1
     を返します。

`touchline(start, count)'
     START から始まる COUNT 行が変更されたかのように 振舞わせます。

`touchwin()'
     描画を最適化するために、全てのウィンドウが変更されたかのように
     振舞わせます。

`untouchwin()'
     ウィンドウ内の全ての行を、最後に `refresh()' を呼んだ際から
     変更されていないものとしてマークします。

`vline([y, x,] ch, n)'
     `(Y, X)' から始まり、 N の長さを持つ、 文字 CH
     で作られる垂直線を表示します。


File: python-lib-jp.info,  Node: 定数,  Prev: Window オブジェクト,  Up: curses

14.7.3 定数
-----------

`curses' モジュールでは以下のデータメンバを定義しています:

`ERR'
     `getch()' のような整数を返す curses ルーチンの
     いくつかは、失敗した際に `ERR' を返します。

`OK'
     `napms()' のような整数を返す curses ルーチンの
     いくつかは、成功した際に `OK' を返します。

`version'
     モジュールの現在のバージョンを表現する文字列です。 `__version__'
     でも取得できます。

以下に文字セルの属性を指定するために利用可能ないくつかの定数を示します:

属性                                 意味
------                               -----
A_ALTCHARSET                         代用文字 (alternate character)
                                     モード。
A_BLINK                              点滅モード。
A_BOLD                               太字モード。
A_DIM                                低輝度モード。
A_NORMAL                             通常の属性。
A_STANDOUT                           強調モード。
A_UNDERLINE                          下線モード。

キーは `KEY_' で始まる名前をもつ整数定数です。利用可能な
キーキャップはシステムに依存します。

キー定数                             キー
------                               -----
KEY_MIN                              最小のキー値
KEY_BREAK                            ブレーク (Break, 信頼できません)
KEY_DOWN                             下向き矢印 (Down-arrow)
KEY_UP                               上向き矢印 (Up-arrow)
KEY_LEFT                             左向き矢印 (Left-arrow)
KEY_RIGHT                            右向き矢印 (Right-arrow)
KEY_HOME                             ホームキー (Home, または上左矢印)
KEY_BACKSPACE                        バックスペース (Backspace,
                                     信頼できません)
KEY_F0                               ファンクションキー 64
                                     個までサポートされています。
KEY_FN                               ファンクションキー N の値
KEY_DL                               行削除 (Delete line)
KEY_IL                               行挿入 (Insert line)
KEY_DC                               文字削除 (Delete char)
KEY_IC                               文字挿入、または文字挿入モードへ入る
KEY_EIC                              文字挿入モードから抜ける
KEY_CLEAR                            画面消去
KEY_EOS                              画面の末端まで消去
KEY_EOL                              行末端まで消去
KEY_SF                               前に 1 行スクロール
KEY_SR                               後ろ (逆方向) に 1 行スクロール
KEY_NPAGE                            次のページ (Page Next)
KEY_PPAGE                            前のページ (Page Prev)
KEY_STAB                             タブ設定
KEY_CTAB                             タブリセット
KEY_CATAB                            全てのタブをリセット
KEY_ENTER                            入力または送信 (信頼できません)
KEY_SRESET                           ソフトウェア (部分的) リセット
                                     (信頼できません)
KEY_RESET                            リセットまたはハードリセット
                                     (信頼できません)
KEY_PRINT                            印刷 (Print)
KEY_LL                               下ホーム (Home down) または最下行
                                     (左下)
KEY_A1                               キーパッドの左上キー
KEY_A3                               キーパッドの右上キー
KEY_B2                               キーパッドの中央キー
KEY_C1                               キーパッドの左下キー
KEY_C3                               キーパッドの右下キー
KEY_BTAB                             Back tab
KEY_BEG                              開始 (Beg)
KEY_CANCEL                           キャンセル (Cancel)
KEY_CLOSE                            閉じる (Close)
KEY_COMMAND                          コマンド (Cmd)
KEY_COPY                             コピー (Copy)
KEY_CREATE                           生成 (Create)
KEY_END                              終了 (End)
KEY_EXIT                             終了 (Exit)
KEY_FIND                             検索 (Find)
KEY_HELP                             ヘルプ (Help)
KEY_MARK                             マーク (Mark)
KEY_MESSAGE                          メッセージ (Message)
KEY_MOVE                             移動 (Move)
KEY_NEXT                             次へ (Next)
KEY_OPEN                             開く (Open)
KEY_OPTIONS                          オプション (Options)
KEY_PREVIOUS                         前へ (Prev)
KEY_REDO                             やり直し (Redo)
KEY_REFERENCE                        参照 (Ref)
KEY_REFRESH                          更新 (Refresh)
KEY_REPLACE                          置換 (Replace)
KEY_RESTART                          再起動 (Restart)
KEY_RESUME                           再開 (Resume)
KEY_SAVE                             保存 (Save)
KEY_SBEG                             シフト付き開始 Beg
KEY_SCANCEL                          シフト付きキャンセル Cancel
KEY_SCOMMAND                         シフト付き Command
KEY_SCOPY                            シフト付き Copy
KEY_SCREATE                          シフト付き Create
KEY_SDC                              シフト付き Delete char
KEY_SDL                              シフト付き Delete line
KEY_SELECT                           選択 (Select)
KEY_SEND                             シフト付き End
KEY_SEOL                             シフト付き Clear line
KEY_SEXIT                            シフト付き Dxit
KEY_SFIND                            シフト付き Find
KEY_SHELP                            シフト付き Help
KEY_SHOME                            シフト付き Home
KEY_SIC                              シフト付き Input
KEY_SLEFT                            シフト付き Left arrow
KEY_SMESSAGE                         シフト付き Message
KEY_SMOVE                            シフト付き Move
KEY_SNEXT                            シフト付き Next
KEY_SOPTIONS                         シフト付き Options
KEY_SPREVIOUS                        シフト付き Prev
KEY_SPRINT                           シフト付き Print
KEY_SREDO                            シフト付き Redo
KEY_SREPLACE                         シフト付き Replace
KEY_SRIGHT                           シフト付き Right arrow
KEY_SRSUME                           シフト付き Resume
KEY_SSAVE                            シフト付き Save
KEY_SSUSPEND                         シフト付き Suspend
KEY_SUNDO                            シフト付き Undo
KEY_SUSPEND                          一時停止 (Suspend)
KEY_UNDO                             元に戻す (Undo)
KEY_MOUSE                            マウスイベント通知
KEY_RESIZE                           端末リサイズイベント
KEY_MAX                              最大キー値

VT100 や、X 端末エミュレータのようなソフトウェアエミュレーションでは、
通常少なくとも 4 つのファンクションキー (`KEY_F1'、 `KEY_F2'、
`KEY_F3'、 `KEY_F4') が利用可能 で、矢印キーは `KEY_UP'、 `KEY_DOWN'、
`KEY_LEFT' および `KEY_RIGHT' が対応付け られています。計算機に PC
キーボードが付属している場合、 矢印キーと 12 個のファンクションキー
(古い PC キーボードには 10 個しか
ファンクションキーがないかもしれません) が利用できると考えて
よいでしょう; また、以下のキーパッド対応付けは標準的なものです:

キーキャップ                         定数
------                               -----
Insert                               KEY_IC
Delete                               KEY_DC
Home                                 KEY_HOME
End                                  KEY_END
Page Up                              KEY_NPAGE
Page Down                            KEY_PPAGE

代用文字 (alternative character) セットを以下の表に列挙します。
これらは VT100 端末から継承したものであり、X 端末のような
ソフトウェアエミュレーション上で一般に利用可能なものです。
グラフィックが利用できない場合、curses は印字可能 ASCII文字による
粗雑な近似出力を行います。 _Note:_ これらは `initscr()'
が呼び出された後でしか 利用できません。

ACS コード                           意味
------                               -----
ACS_BBSS                             右上角の別名
ACS_BLOCK                            黒四角ブロック
ACS_BOARD                            白四角ブロック
ACS_BSBS                             水平線の別名
ACS_BSSB                             左上角の別名
ACS_BSSS                             上向き T 字罫線の別名
ACS_BTEE                             下向き T 字罫線
ACS_BULLET                           黒丸(bullet)
ACS_CKBOARD                          チェッカーボードパタン (点描)
ACS_DARROW                           下向き矢印
ACS_DEGREE                           度
ACS_DIAMOND                          ダイアモンド
ACS_GEQUAL                           より大きいか等しい
ACS_HLINE                            水平線
ACS_LANTERN                          ランタン(lantern) シンボル
ACS_LARROW                           left arrow
ACS_LEQUAL                           より小さいか等しい
ACS_LLCORNER                         左下角
ACS_LRCORNER                         右下角
ACS_LTEE                             left tee
ACS_NEQUAL                           等号否定
ACS_PI                               パイ記号
ACS_PLMINUS                          プラスマイナス記号
ACS_PLUS                             大プラス記号
ACS_RARROW                           右向き矢印
ACS_RTEE                             右向き T 字罫線
ACS_S1                               scan line 1
ACS_S3                               scan line 3
ACS_S7                               scan line 7
ACS_S9                               scan line 9
ACS_SBBS                             右下角の別名
ACS_SBSB                             垂直線の別名
ACS_SBSS                             右向き T 字罫線の別名
ACS_SSBB                             左下角の別名
ACS_SSBS                             下向き T 字罫線の別名
ACS_SSSB                             左向き T 字罫線の別名
ACS_SSSS                             交差罫線または大プラス記号の別名
ACS_STERLING                         ポンドスターリング記号
ACS_TTEE                             上向き T 字罫線
ACS_UARROW                           上向き矢印
ACS_ULCORNER                         左上角
ACS_URCORNER                         右上角
ACS_VLINE                            垂直線

以下のテーブルは定義済みの色を列挙したものです:

定数                                 色
------                               -----
COLOR_BLACK                          黒
COLOR_BLUE                           青
COLOR_CYAN                           シアン (薄く緑がかった青)
COLOR_GREEN                          緑
COLOR_MAGENTA                        マゼンタ (紫がかった赤)
COLOR_RED                            赤
COLOR_WHITE                          白
COLOR_YELLOW                         黄色


File: python-lib-jp.info,  Node: cursestextpad,  Next: curseswrapper,  Prev: curses,  Up: 汎用オペレーティングシステムサービス

14.8 curses プログラムのためのテキスト入力ウィジェット
======================================================

curses ウィンドウ内での Emacs ライクな入力編集機能。 _Added in Python
version 1.6_

`curses.textpad' モジュールでは、curses ウィンドウ内での基本的な
テキスト編集を処理し、Emacs に似た (すなわち Netscape Navigator, BBedit
6.x, FrameMaker, その他諸々のプログラムとも似た) キーバインドを
サポートしている `Textbox' クラスを提供します。このモジュールでは
また、テキストボックスを枠で囲むなどの目的のために有用な、矩形描画
関数を提供しています。

`curses.textpad' モジュールでは以下の関数を定義しています:

`rectangle(win, uly, ulx, lry, lrx)'
     矩形を描画します。最初の引数はウィンドウオブジェクトでなければ
     なりません; 残りの引数はそのウィンドウからの相対座標になります。 2
     番目および 3 番目の引数は描画すべき矩形の左上角の y および x
     座標です; 4 番目および 5 番目の引数は右下角の y および x 座標です。
     矩形は、 VT100/IBM PC におけるフォーム文字を利用できる 端末(xterm
     やその他のほとんどのソフトウェア端末エミュレータを含む)
     ではそれを使って描画されます。そうでなければ ASCII 文字のダッシュ、
     垂直バー、およびプラス記号で描画されます。

* Menu:

* Textbox オブジェクト::

