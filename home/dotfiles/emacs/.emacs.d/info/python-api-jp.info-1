これは python-api-jp.info、python-api-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-api-jp.info,  Node: Top,  Next: 序,  Prev: (dir),  Up: (dir)

Python/C API リファレンスマニュアル
***********************************

* Menu:

* 序::
* はじめに::
* 超高レベルレイヤ::
* 参照カウント 2::
* 例外処理::
* ユーティリティ関数::
* 抽象オブジェクトレイヤ abstract objects layer::
* 具象オブジェクト concrete object レイヤ::
* 初期化 initialization、終了処理 finalization、スレッド::
* メモリ管理::
* オブジェクト実装サポート object implementation support::
* バグ報告::
* 歴史とライセンス::
* 日本語訳について::
* Module Index::
* Class-Exception-Object Index::
* Function-Method-Variable Index::
* Miscellaneous Index::


File: python-api-jp.info,  Node: 序,  Next: はじめに,  Prev: Top,  Up: Top

序
**

Copyright (C) 2001-2006 Python Software Foundation.  All rights
reserved.

Copyright (C) 2000 BeOpen.com.  All rights reserved.

Copyright (C) 1995-2000 Corporation for National Research Initiatives.
All rights reserved.

Copyright (C) 1991-1995 Stichting Mathematisch Centrum.  All rights
reserved.

Translation Copyright (C) 2003, 2004 Python Document Japanese
Translation Project. All rights reserved.

ライセンスおよび許諾に関する完全な情報は、このドキュメントの末尾を
参照してください。

     このマニュアルでは、拡張モジュールを書いたり Python インタプリタを
     アプリケーションに埋め込んだりしたい C および C++ プログラマ
     が利用できる API について述べています。
     は拡張モジュールを書く際の一般的な決まりごとについて
     記述していますが、API の詳細までは記述していないので、
     このドキュメントが手引きになります。

     _このドキュメントの現在のバージョンはまだ不完全です。
     とはいえ、役に立つだろうと思います。引き続きドキュメントの整備を
     継続して、 Python ソースコードのリリースとは別に、その時々で
     新たなバージョンをリリースするつもりです。_



File: python-api-jp.info,  Node: はじめに,  Next: 超高レベルレイヤ,  Prev: 序,  Up: Top

1 はじめに
**********

Python のアプリケーションプログラマ用インタフェース (Application
Programmer's Interface, API) は、 Python
インタプリタに対する様々なレベルでのアクセス手段を C や C++
のプログラマに提供しています。この API は通常 C++
からも全く同じように利用できるのですが、簡潔な呼び名に するために
Python/C API と名づけられています。 根本的に異なる二つの目的から、
Python/C API が用いられます。 第一は、特定用途の _拡張モジュール
(extention module)_、 すなわち Python インタプリタを拡張する C
で書かれたモジュール
を記述する、という目的です。第二は、より大規模なアプリケーション 内で
Python を構成要素 (component) として利用するという目的です;
このテクニックは、一般的にはアプリケーションへの Python の 埋め込み
("embedding") と呼びます。
拡張モジュールの作成は比較的わかりやすいプロセスで、 "手引書
(cookbook)" 的なアプローチでうまく実現できます。
作業をある程度まで自動化してくれるツールもいくつかあります。
一方、他のアプリケーションへの Python の埋め込みは、Python
ができてから早い
時期から行われてきましたが、拡張モジュールの作成に比べるとやや難解です。

多くの API 関数は、Python の埋め込みであるか拡張であるかに関わらず
役立ちます; とはいえ、 Python を埋め込んでいるほとんどのアプリケーション
は、同時に自作の拡張モジュールも提供する必要が生じることになる
でしょうから、Python を実際にアプリケーションに埋め込んでみる前に
拡張モジュールの書き方に詳しくなっておくのはよい考えだと思います。

* Menu:

* インクルードファイル::
* オブジェクト、型および参照カウント::
* 例外::
* Python の埋め込み::
* デバッグ版ビルド Debugging Builds::


File: python-api-jp.info,  Node: インクルードファイル,  Next: オブジェクト、型および参照カウント,  Prev: はじめに,  Up: はじめに

1.1 インクルードファイル
========================

Python/C API を使うために必要な、関数、型およびマクロの全ての定義
をインクルードするには、以下の行:

     #include "Python.h"

をソースコードに記述します。 この行を記述すると、標準ヘッダ:
`<stdio.h>', `<string.h>', `<errno.h>', `<limits.h>', and `<stdlib.h>'
を (あれば) インクルードします。 システムによっては、Python
の定義しているプリプロセッサ定義が
標準ヘッダに影響をおよぼす可能性があるので、`Python.h'
は他の標準ヘッダファイルよりも前にインクルードしてください。

Python.h で定義されている、ユーザから見える名前全て (Python.h
がインクルードしている標準ヘッダの名前は除きます) には、接頭文字列 `Py'
または `_Py' が付きます。 `_Py' で始まる名前は Python
実装で内部使用するための名前で、拡張モジュールの作者は
使ってはなりません。構造体のメンバには予約済みの接頭文字列はありません。

*重要:* API のユーザは、`Py' や `_Py' で始まる名前を
定義するようなコードを絶対に書いてはなりません。
後からコードを読む人を混乱させたり、将来の Python のバージョンで同じ
名前が定義されて、ユーザの書いたコードの可搬性を危うくする可能性が
あります。

ヘッダファイル群は通常 Python と共にインストールされます。 UNIXでは
``prefix'/include/pythonVERSION/' および
``exec_prefix'/include/pythonVERSION/' に 置かれます。`prefix' と
`exec_prefix' は Python を ビルドする際の `configure'
スクリプトに与えたパラメタに 対応し、VERSION は `sys.version[:3]'
に対応します。 Windows では、ヘッダは ``prefix'/include' に置かれます。
`prefix' はインストーラに指定したインストールディレクトリです。

ヘッダをインクルードするには、 各ヘッダの入ったディレクトリ (別々の
ディレクトリの場合は両方) を、コンパイラがインクルードファイルを
検索するためのパスに入れます。 親ディレクトリをサーチパスに入れて、
`#include <python2.5/Python.h>' のようにしては _なりません_; `prefix'
内のプラットフォームに依存しない ヘッダは、`exec_prefix'
からプラットフォーム依存のヘッダを
インクルードしているので、このような操作を行うと複数のプラットフォーム
でのビルドができなくなります。

API はすべて C 言語を使って定義していますが、ヘッダファイルは
エントリポイントを `extern "C"' で適切に宣言しているので、 C++
ユーザは、なんの問題もなく C++から API を利用できる
ことに気づくはずです。


File: python-api-jp.info,  Node: オブジェクト、型および参照カウント,  Next: 例外,  Prev: インクルードファイル,  Up: はじめに

1.2 オブジェクト、型および参照カウント
======================================

Python/C API 関数は、 `PyObject*' 型の一つ以上の引数と
戻り値を持ちます。この型は、任意の Python オブジェクトを表現する 不透明
(opaque) なデータ型へのポインタです。 Python 言語は、全ての Python
オブジェクト型をほとんどの状況 (例えば代入、スコープ規則 (scope
rule)、引数渡し) で同様に 扱います。ほとんど全ての Python
オブジェクトはヒープ (heap) 上に 置かれます: このため、`PyObject'
型のオブジェクトは、 自動記憶 (automatic) としても静的記憶 (static)
としても 宣言できません。`PyObject*' 型のポインタ変数のみ
宣言できます。唯一の例外は、型オブジェクト  です;
型オブジェクトはメモリ解放 (deallocate) してはならないので、
通常は静的記憶の `PyTypeObject' オブジェクトにします。

全ての Python オブジェクトには (Python 整数型ですら) 型 ("type")
と参照カウント ("reference count") があります。
あるオブジェクトの型は、そのオブジェクトがどの種類のオブジェクト か
(例えば整数、リスト、ユーザ定義関数、など; その他多数については、
で説明して います)
を決定します。よく知られている型については、各々マクロが
存在して、あるオブジェクトがその型かどうか調べられます; 例えば、
`PyList_Check(A)' は、A で示されたオブジェクトが Python リスト型のとき
(かつそのときに限り) 真値を返します。

* Menu:

* 参照カウント::
* 型::


File: python-api-jp.info,  Node: 参照カウント,  Next: 型,  Prev: オブジェクト、型および参照カウント,  Up: オブジェクト、型および参照カウント

1.2.1 参照カウント
------------------

今日の計算機は有限の (しばしば非常に限られた) メモリサイズしか
持たないので、参照カウントは重要な概念です; 参照カウントは、
あるオブジェクトに対して参照を行っている場所が何箇所あるか
を数える値です。参照を行っている場所とは、別のオブジェクトで
あったり、グローバルな (あるいは静的な) C 変数であったり、 何らかの C
関数内にあるローカルな変数だったりします。
あるオブジェクトの参照カウントがゼロになると、そのオブジェクトは
解放されます。そのオブジェクトに他のオブジェクトへの
参照が入っていれば、他のオブジェクトの参照カウントはデクリメント
されます。デクリメントの結果、他のオブジェクトの参照カウント
がゼロになると、今度はそのオブジェクトが解放される、といった具合に
以後続きます。(言うまでもなく、互いを参照しあうオブジェクトに
ついて問題があります; 現状では、解決策は "何もしない" です。)

参照カウントは、常に明示的なやり方で操作されます。
通常の方法では、`Py_INCREF()' 

でオブジェクトの参照を 1 インクリメントし、 `Py_DECREF()'  で 1
デクリメント します。`Py_DECREF()' マクロは、incref よりもかなり
複雑です。というのは、`Py_DECREF()' マクロは参照カウント
がゼロになったかどうかを調べて、なった場合にはオブジェクトの
デアロケータ (deallocator) を呼び出さなければならないからです。
デアロケータとは、オブジェクトの型を定義している構造体内にある
関数へのポインタです。 型固有のデアロケータは、その型が複合オブジェクト
(compound object)
型である場合には、オブジェクト内の他のオブジェクトに対する参照
カウントをデクリメントするよう気を配るとともに、その他の必要な
ファイナライズ (finalize) 処理を実行します。
参照カウントがオーバフローすることはありません; というのも、
仮想メモリ空間には、(`sizeof(long) >= sizeof(char*)' と 仮定した場合)
少なくとも参照カウントの記憶に使われるビット数と
同じだけのメモリ上の位置があるからです。従って、参照カウントの
インクリメントは単純な操作になります。

オブジェクトへのポインタが入っているローカルな変数全てについて、
オブジェクトの参照カウントを必ずインクリメントしなければならない
わけではありません。理論上は、オブジェクトの参照カウントは、
オブジェクトを指し示す変数が生成されたときに 1 増やされ、
その変数がスコープから出て行った際に 1 減らされます。しかしこの
場合、二つの操作は互いに相殺するので、結果的に参照カウントは
変化しません。参照カウントを使う真の意義とは、手持ちの何らかの
変数がオブジェクトを指している間はオブジェクトがデアロケート
されないようにすることにあります。オブジェクトに対して、
一つでも別の参照が行われていて、その参照が手持ちの変数
と同じ間維持されるのなら、参照カウントを一時的に増やす必要は
ありません。参照カウント操作の必要性が浮き彫りになる重要な局面
とは、Python から呼び出された拡張モジュール内の C 関数に
オブジェクトを引数として渡すときです; 呼び出しメカニズムは、
呼び出しの間全ての引数に対する参照を保証します。

しかしながら、よく陥る過ちとして、あるオブジェクトをリストから
得たときに、参照カウントをインクリメントせずにしばらく放っておく
というのがあります。他の操作がオブジェクトをリストから除去してしまい、
参照カウントがデクリメントされてデアロケートされてしまうことが
考えられます。
本当に危険なのは、まったく無害そうにみえる操作が、上記の動作を
引き起こす何らかの Python コードを呼び出しかねないということです;
`Py_DECREF()' からユーザへ制御を戻せるような
コードパスが存在するため、ほとんど全ての操作が潜在的に危険を
はらむことになります。

安全に参照カウントを操作するアプローチは、汎用の操作 (関数名が
`PyObject_', `PyNumber_', `PySequence_', および `PyMapping_'
で始まる関数) の利用です。これらの操作は
常に戻り値となるオブジェクトの参照カウントをインクリメントします。
ユーザには戻り値が不要になったら `Py_DECREF()' を呼ぶ
責任が残されています; とはいえ、すぐにその習慣は身に付くでしょう。

* Menu:

* 参照カウントの詳細::


File: python-api-jp.info,  Node: 参照カウントの詳細,  Prev: 参照カウント,  Up: 参照カウント

1.2.1.1 参照カウントの詳細
..........................

Python/C API の各関数における参照カウントの振る舞いは、
説明するには、_参照の所有権 (ownership of references)_
という言葉でうまく説明できます。所有権は参照に対するもので、
オブジェクトに対するものではありません (オブジェクトは
誰にも所有されず、常に共有されています)。 ある参照の "所有"
は、その参照が必要なくなった時点で `Py_DECREF()'
を呼び出す役割を担うことを意味します。
所有権は委譲でき、あるコードが委譲によって所有権を得ると、
今度はそのコードが参照が必要なくなった際に最終的に `Py_DECREF()' や
`Py_XDECREF()' を呼び出して decref する役割を担います --
あるいは、その役割を (通常はコードを 呼び出した元に) 受け渡します。
ある関数が、関数の呼び出し側に対して参照の所有権を渡すと、 呼び出し側は
_新たな_ 参照 (new reference) を得る、と言います。
所有権が渡されない場合、呼び出し側は参照を_借りる_ (borrow)
といいます。借りた参照に対しては、何もする必要はありません。

逆に、ある関数呼び出しで、あるオブジェクトへの参照を呼び出される
関数に渡す際には、二つの可能性: 関数がオブジェクトへの参照を _盗み取る_
(steal) 場合と、そうでない場合があります。

_参照を盗む_ とは、関数に参照を渡したときに、参照の所有者が
その関数になったと仮定し、関数の呼び出し元には所有権がなくなるということです。

参照を盗み取る関数はほとんどありません; 例外としてよく知られているのは、
`PyList_SetItem()'  と `PyTuple_SetItem()'  で、
これらはシーケンスに入れる要素に対する参照を盗み取ります (しかし、要素の
入る先のタプルやリストの参照は盗み取りません!)。これらの関数は、
リストやタプルの中に新たに作成されたオブジェクトを入れていく際の
常套的な書き方をしやすくするために、参照を盗み取るように設計されて
います; 例えば、`(1, 2, "three")' というタプルを生成するコードは
以下のようになります (とりあえず例外処理のことは忘れておきます;
もっとよい書き方を後で示します):

     PyObject *t;

     t = PyTuple_New(3);
     PyTuple_SetItem(t, 0, PyInt_FromLong(1L));
     PyTuple_SetItem(t, 1, PyInt_FromLong(2L));
     PyTuple_SetItem(t, 2, PyString_FromString("three"));

ここで、`PyInt_FromLong()' は新しい参照を返し、すぐに
`PyTuple_SetItem()' に盗まれます。
参照が盗まれた後もそのオブジェクトを利用したい場合は、参照盗む関数を
呼び出す前に、`Py_INCREF()' を利用してもう一つの参照を取得
してください。

ちなみに、`PyTuple_SetItem()' はタプルに値をセットする ための _唯一の_
方法です; タプルは変更不能なデータ型なので、 `PySequence_SetItem()' や
`PyObject_SetItem()'
を使うと上の操作は拒否されてしまいます。自分でタプルの値を入れていく
つもりなら、`PyTuple_SetItem()' だけしか使えません。

同じく、リストに値を入れていくコードは `PyList_New()' と
`PyList_SetItem()' で書けます。

しかし実際には、タプルやリストを生成して値を入れる際には、
上記のような方法はほとんど使いません。
より汎用性のある関数、`Py_BuildValue()' があり、
ほとんどの主要なオブジェクトをフォーマット文字列 "format string"
の指定に基づいて C の値から生成できます。例えば、
上の二種類のコードブロックは、以下のように置き換えられます
(エラーチェックにも配慮しています):

     PyObject *tuple, *list;

     tuple = Py_BuildValue("(iis)", 1, 2, "three");
     list = Py_BuildValue("[iis]", 1, 2, "three");

自作の関数に渡す引数のように、単に参照を借りるだけの要素に
対しては、`PyObject_SetItem()' とその仲間を 使うのがはるかに一般的です。
その場合、参照カウントをインクリメントする必要がなく、 参照を引き渡せる
("参照を盗み取らせられる") ので、
参照カウントに関する動作はより健全になります。
例えば、以下の関数は与えられた要素をリスト中の全ての要素の値に
セットします:

     int
     set_all(PyObject *target, PyObject *item)
     {
         int i, n;

         n = PyObject_Length(target);
         if (n < 0)
             return -1;
         for (i = 0; i < n; i++) {
             PyObject *index = PyInt_FromLong(i);
             if (!index)
                 return -1;
             if (PyObject_SetItem(target, index, item) < 0)
                 return -1;
             Py_DECREF(index);
         }
         return 0;
     }

関数の戻り値の場合には、状況は少し異なります。
ほとんどの関数については、参照を渡してもその参照に対する
所有権が変わることがない一方で、あるオブジェクトに対する参照を
返すような多くの関数は、参照に対する所有権を呼び出し側に与えます。
理由は簡単です: 多くの場合、関数が返すオブジェクトはその場で (on the
fly) 生成されるため、呼び出し側が得る参照は生成された
オブジェクトに対する唯一の参照になるからです。
従って、`PyObject_GetItem()' や `PySequence_GetItem()'
のように、オブジェクトに対する
参照を返す汎用の関数は、常に新たな参照を返します (呼び出し側
が参照の所有者になります)。

重要なのは、関数が返す参照の所有権を持てるかどうかは、どの関数を
呼び出すかだけによる、と理解することです -- 関数呼び出し時の _お飾り_
(関数に引数として渡したオブジェクトの型) は
_この問題には関係ありません!_ 従って、`PyList_GetItem()'
を使ってリスト内の要素を 得た場合には、参照の所有者にはなりません --
が、同じ要素を 同じリストから `PySequence_GetItem()' (図らずもこの関数は
全く同じ引数をとります) を使って取り出すと、返されたオブジェクト
に対する参照を得ます。

以下は、整数からなるリストに対して各要素の合計を計算する関数を
どのようにして書けるかを示した例です; 一つは `PyList_GetItem()'  を使っていて、
もう一つは `PySequence_GetItem()' を使っています。

     long
     sum_list(PyObject *list)
     {
         int i, n;
         long total = 0;
         PyObject *item;

         n = PyList_Size(list);
         if (n < 0)
             return -1; /* リストではない */
         for (i = 0; i < n; i++) {
             item = PyList_GetItem(list, i); /* 失敗しないはず */
             if (!PyInt_Check(item)) continue; /* 整数でなければ読み飛ばす */
             total += PyInt_AsLong(item);
         }
         return total;
     }

     long
     sum_sequence(PyObject *sequence)
     {
         int i, n;
         long total = 0;
         PyObject *item;
         n = PySequence_Length(sequence);
         if (n < 0)
             return -1; /* 長さの概念がない */
         for (i = 0; i < n; i++) {
             item = PySequence_GetItem(sequence, i);
             if (item == NULL)
                 return -1; /* シーケンスでないか、その他の失敗 */
             if (PyInt_Check(item))
                 total += PyInt_AsLong(item);
             Py_DECREF(item); /* GetItem で得た所有権を放棄する */
         }
         return total;
     }


File: python-api-jp.info,  Node: 型,  Prev: 参照カウント,  Up: オブジェクト、型および参照カウント

1.2.2 型
--------

Python/C API において重要な役割を持つデータ型は、`PyObject'
型の他にもいくつかあります; ほとんどは `int', `long', `double', および
`char*' といった、単なる C のデータ型です。
また、モジュールで公開している関数を列挙する際に用いられる静的な
テーブルや、新しいオブジェクト型におけるデータ属性を記述したり、
複素数の値を記述したりするために構造体をいくつか使っています。
これらの型については、その型を使う関数とともに説明してゆきます。


File: python-api-jp.info,  Node: 例外,  Next: Python の埋め込み,  Prev: オブジェクト、型および参照カウント,  Up: はじめに

1.3 例外
========

Python プログラマは、特定のエラー処理が必要なときだけしか例外を扱う
必要はありません; 処理しなかった例外は、処理の呼び出し側、そのまた
呼び出し側、といった具合に、トップレベルのインタプリタ層まで自動的に
伝播します。インタプリタ層は、スタックトレースバックと合わせて
例外をユーザに報告します。

ところが、 C プログラマの場合、エラーチェックは常に明示的に行わねば
なりません。Python/C API の全ての関数は、関数のドキュメントで明確に
説明がない限り例外を発行する可能性があります。
一般的な話として、ある関数が何らかのエラーに遭遇すると、関数は
例外を送出して、関数内における参照の所有権を全て放棄し、 エラー指標
(error indicator) -- 通常は `NULL' または `-1'
を返します。いくつかの関数ではブール型で真/偽を返し、偽はエラーを
示します。きわめて少数の関数では明確なエラー指標を返さなかったり、
あいまいな戻り値を返したりするので、 `PyErr_Occurred()'  で
明示的にエラーテストを行う必要があります。

例外時の状態情報 (exception state)は、スレッド単位に用意された 記憶領域
(per-thread storage) 内で管理されます (この記憶領域は、
スレッドを使わないアプリケーションではグローバルな記憶領域と 同じです)。
一つのスレッドは二つの状態のどちらか: 例外が発生したか、まだ発生
していないか、をとります。 関数 `PyErr_Occurred()'
を使うと、この状態を調べられます:
この関数は例外が発生した際にはその例外型オブジェクトに対する 借用参照
(borrowed reference) を返し、そうでないときには `NULL'
を返します。例外状態を設定する関数は数多くあります: `PyErr_SetString()'  はもっとも
よく知られている (が、もっとも汎用性のない) 例外を設定するための
関数で、`PyErr_Clear()'  は 例外状態情報を消し去る関数です。

完全な例外状態情報は、3 つのオブジェクト: 例外の型、例外の値、
そしてトレースバック、からなります  (どのオブジェクトも
`NULL'を取り得ます)。これらの情報は、 Python オブジェクトの `sys.exc_type',
`sys.exc_value', および `sys.exc_traceback' と同じ意味を持ちます;
とはいえ、 C と Python の例外状態情報は全く同じではありません: Python
における 例外オブジェクトは、Python の `try' ...  `except'
文で最近処理したオブジェクトを表す一方、 C
レベルの例外状態情報が存続するのは、 渡された例外情報を
`sys.exc_type'その他に転送するよう取り計らう Python
のバイトコードインタプリタのメインループに到達するまで、
例外が関数の間で受け渡しされている間だけです。

Python 1.5 からは、Python で書かれたコードから例外状態情報にアクセス
する方法として、推奨されていてスレッドセーフな方法は `sys.exc_info()'
になっているので注意してください。 この関数は Python
コードの実行されているスレッドにおける 例外状態情報を返します。
また、これらの例外状態情報に対するアクセス手段は、両方とも 意味づけ
(semantics) が変更され、ある関数が例外を捕捉すると、
その関数を実行しているスレッドの例外状態情報を保存して、呼び出し側の
呼び出し側の例外状態情報を維持するようになりました。
この変更によって、無害そうに見える関数が現在扱っている例外を上書き
することで引き起こされる、例外処理コードでよくおきていたバグを
抑止しています; また、トレースバック内のスタックフレームで
参照されているオブジェクトがしばしば不必要に寿命を永らえて
いたのをなくしています。

一般的な原理として、ある関数が別の関数を呼び出して何らかの作業を
させるとき、呼び出し先の関数が例外を送出していないか調べなくては
ならず、もし送出していれば、その例外状態情報は呼び出し側に
渡されなければなりません。
呼び出し元の関数はオブジェクト参照の所有権をすべて放棄し、
エラー指標を返さなくてはなりませんが、余計に例外を設定 する必要は
_ありません_ -- そんなことをすれば、たった今
送出されたばかりの例外を上書きしてしまい、エラーの原因そのもの
に関する重要な情報を失うことになります。

例外を検出して渡す例は、上の `sum_sequence()'  で示しています。
偶然にも、この例ではエラーを検出した際に何ら参照を放棄する必要が
ありません。以下の関数の例では、エラーに対する後始末について示して
います。まず、どうして Python で書くのが好きか思い出してもらうために、
等価な Python コードを示します:

     def incr_item(dict, key):
         try:
             item = dict[key]
         except KeyError:
             item = 0
         dict[key] = item + 1

以下は対応するコードを C で完璧に書いたものです:

     int
     incr_item(PyObject *dict, PyObject *key)
     {
         /* Py_XDECREF 用に全てのオブジェクトを NULL で初期化 */
         PyObject *item = NULL, *const_one = NULL, *incremented_item = NULL;
         int rv = -1; /* 戻り値の初期値を -1 (失敗) に設定しておく */

         item = PyObject_GetItem(dict, key);
         if (item == NULL) {
             /* KeyError だけを処理: */
             if (!PyErr_ExceptionMatches(PyExc_KeyError))
                 goto error;

             /* エラーを無かったことに (clear) してゼロを使う: */
             PyErr_Clear();
             item = PyInt_FromLong(0L);
             if (item == NULL)
                 goto error;
         }
         const_one = PyInt_FromLong(1L);
         if (const_one == NULL)
             goto error;

         incremented_item = PyNumber_Add(item, const_one);
         if (incremented_item == NULL)
             goto error;

         if (PyObject_SetItem(dict, key, incremented_item) < 0)
             goto error;
         rv = 0; /* うまくいった場合 */
         /* 後始末コードに続く */

      error:
         /* 成功しても失敗しても使われる後始末コード */

         /* NULL を参照している場合は無視するために Py_XDECREF() を使う */
         Py_XDECREF(item);
         Py_XDECREF(const_one);
         Py_XDECREF(incremented_item);

         return rv; /* エラーなら -1 、 成功なら 0 */
     }

なんとこの例は C で `goto' 文を使うお勧めの方法まで示して いますね!
この例では、特定の例外を処理するために `PyErr_ExceptionMatches()' 

および `PyErr_Clear()'  をどう使うかを
示しています。また、所有権を持っている参照で、値が `NULL' に
なるかもしれないものを捨てるために `Py_XDECREF()' 

をどう使うかも示しています (関数名に `X' が付いていることに
注意してください; `Py_DECREF()' は `NULL' 参照に出くわすと
クラッシュします)。正しく動作させるためには、所有権を持つ参照を
保持するための変数を `NULL' で初期化することが重要です; 同様に、
あらかじめ戻り値を定義する際には値を `-1' (失敗) で初期化して
おいて、最後の関数呼び出しまでうまくいった場合にのみ `0' (成功)
に設定します。


File: python-api-jp.info,  Node: Python の埋め込み,  Next: デバッグ版ビルド Debugging Builds,  Prev: 例外,  Up: はじめに

1.4 Python の埋め込み
=====================

Python インタプリタの埋め込みを行う人 (いわば拡張モジュールの
書き手の対極) が気にかけなければならない重要なタスクは、 Python
インタプリタの初期化処理 (initialization)、そしておそらくは 終了処理
(finalization) です。インタプリタのほとんどの機能は、
インタプリタの起動後しか使えません。

基本的な初期化処理を行う関数は `Py_Initialize()'  です。
この関数はロード済みのモジュールからなるテーブルを作成し、
土台となるモジュール `__builtin__' , `__main__' , `sys' , および
`exceptions'  を作成します。 また、モジュール検索パス (`sys.path') 

の初期化も行います。

`Py_Initialize()' の中では、 "スクリプトへの引数リスト" (script
argument list, `sys.argv' のこと) を設定しません。
この変数が後に実行される Python コード中で必要なら、 `Py_Initialize()'
に続いて `PySys_SetArgv(ARGC, ARGV)' を呼び出して明示的に設定しなければなりません。

ほとんどのシステムでは (特に UNIX と Windows は、詳細がわずかに
異なりはしますが)、 `Py_Initialize()' は 標準の Python
インタプリタ実行形式の場所に対する推定結果に基づいて、 Python
のライブラリが Python インタプリタ実行形式からの相対パスで
見つかるという仮定の下にモジュール検索パスを計算します。
とりわけこの検索では、シェルコマンド検索パス (環境変数 `PATH')
上に見つかった `python' という名前の実行ファイルの置かれている
ディレクトリの親ディレクトリからの相対で、 `lib/python2.5'
という名前のディレクトリを探します。

例えば、 Python 実行形式が `/usr/local/bin/python' で見つかった
とすると、`Py_Initialize()' はライブラリが `/usr/local/lib/python2.5'
にあるものと仮定します。 (実際には、このパスは "フォールバック
(fallback)" のライブラリ 位置でもあり、`python' が `PATH'
上にない場合に使われます。) ユーザは `PYTHONHOME'
を設定することでこの動作をオーバライド したり、`PYTHONPATH'
を設定して追加のディレクトリを
標準モジュール検索パスの前に挿入したりできます。

埋め込みを行うアプリケーションでは、 `Py_Initialize()' を呼び出す _前に_
`Py_SetProgramName(FILE)' 

を呼び出すことで、上記の検索を操作できます。
この埋め込みアプリケーションでの設定は依然として `PYTHONHOME'
でオーバライドでき、標準のモジュール検索パスの前には以前として
`PYTHONPATH' が挿入されるので注意してください。
アプリケーションでモジュール検索パスを完全に制御したいのなら、 独自に
`Py_GetPath()' , `Py_GetPrefix()' , `Py_GetExecPrefix()' , および
`Py_GetProgramFullPath()' 

の実装を提供しなければなりません (これらは全て `Modules/getpath.c'
で定義されています)。

たまに、 Python を "初期化しない" ようにしたいことがあります。
例えば、あるアプリケーションでは実行を最初からやりなおし (start over)
させる (`Py_Initialize()' をもう一度呼び出させる) ように
したいかもしれません。あるいは、アプリケーションが Python を一旦
使い終えて、Python が確保したメモリを解放できるようにしたいかも
しれません。`Py_Finalize()' を使うと、こうした処理を
実現できます。また、関数 `Py_IsInitialized()' 

は、Python が現在初期化済みの状態にある場合に真を返します。
これらの関数についてのさらなる情報は、後の章で説明します。
`Py_Finalize' がPythonインタプリタに確保された全てのメモリを
_開放するわけではない_ことに注意してください。例えば、格調モジュールに
よって確保されたメモリは、現在のところ開放する事ができません。


File: python-api-jp.info,  Node: デバッグ版ビルド Debugging Builds,  Prev: Python の埋め込み,  Up: はじめに

1.5 デバッグ版ビルド (Debugging Builds)
=======================================

インタプリタと拡張モジュールに対しての追加チェックをするためのいくつかの
マクロを有効にしてPythonをビルドすることができます。
これらのチェックは、実行時に大きなオーバーヘッドを生じる傾向があります。
なので、デフォルトでは有効にされていません。

Pythonデバッグ版ビルドの全ての種類のリストが、Pythonソース配布(source
distribution)の中の `Misc/SpecialBuilds.txt' にあります。
参照カウントのトレース、メモリアロケータのデバッグ、インタプリタのメインループの
低レベルプロファイリングが利用可能です。よく使われるビルドについてのみ、
この節の残りの部分で説明します。

インタプリタを `Py_DEBUG' マクロを有効にしてコンパイルすると、 一般的に
「デバッグビルド」 といわれるPythonができます。 UNIX では、 `configure'
コマンドに `--with-pydebug' を追加することで、 `Py_DEBUG'
が有効になります。 その場合、暗黙的にPython専用ではない `_DEBUG'
も有効になります。 UNIX ビルドでは、 `Py_DEBUG'
が有効な場合、コンパイラの最適化が無効になります。

あとで説明する参照カウントデバッグの他に、以下の追加チェックも有効になります。

   * object allocator に対する追加チェック

   * パーサーとコンパイラに対する追加チェック

   *
     情報損失のために、大きい型から小さい型へのダウンキャストに対するチェック

   * 辞書(dict)と集合(set)の実装に対する、いくつもの assertion の追加。
     加えて、集合オブジェクトに `test_c_api' メソッドが追加されます。

   * フレームを作成する時の、引数の健全性チェック。

   *
     初期化されていない数に対する参照を検出するために、長整数のストレージが
     特定の妥当でないパターンで初期化されます。

   * 低レベルトレースと追加例外チェックがVM runtimeに追加されます。

   * メモリアリーナ(memory arena)の実装に対する追加チェック

   * threadモジュールに対する追加デバッグ機能.

ここで言及されていない追加チェックもあるでしょう。

`Py_TRACE_REFS' を宣言すると、参照トレースが有効になります。 全ての
`PyObject' に二つのフィールドを追加することで、
使用中のオブジェクトの循環二重連結リストが管理されます。
全ての割り当て(allocation)がトレースされます。
終了時に、全ての残っているオブジェクトが表示されます。
(インタラクティブモードでは、
インタプリタによる文の実行のたびに表示されます) `Py_TRACE_REFS' は
`Py_DEBUG' によって暗黙的に有効になります。

より詳しい情報については、Pythonのソース配布(source distribution)の中の
`Misc/SpecialBuilds.txt' を参照してください。


File: python-api-jp.info,  Node: 超高レベルレイヤ,  Next: 参照カウント 2,  Prev: はじめに,  Up: Top

2 超高レベルレイヤ
******************

この章の関数を使うとファイルまたはバッファにあるPythonソースコードを
実行できますが、より詳細なやり取りをインタプリタとすることはできないでしょう。

これらの関数のいくつかは引数として文法の開始記号を受け取ります。
使用できる開始記号は`Py_eval_input'と`Py_file_input'、
`Py_single_input'です。開始期号の説明はこれらを引数として取る
関数の後にあります。

これらの関数のいくつかが`FILE*'引数をとることにも注意してください。
注意深く扱う必要がある特別な問題には、異なるCライブラリの`FILE'構造体は
異なっていて互換性がない可能性があるということが関係しています。
実際に(少なくとも)Windowsでは、動的リンクされる拡張が異なるライブラリを
使うことが可能であり、したがって、`FILE*'引数がPythonランタイムが
使っているライブラリと同じライブラリによって作成されたことが確かならば、
単にこれらの関数へ渡すだけということに注意すべきです。

`int Py_Main(int argc, char **argv)'
     標準インタプリタのためのメインプログラム。Pythonを組み込む
     プログラムのためにこれを利用できるようにしています。
     ARGCとARGV引数をCプログラムの`main()'関数へ
     渡されるものとまったく同じに作成すべきです。
     引数リストが変更される可能性があるという点に注意することは重要です。
     (しかし、引数リストが指している文字列の内容は変更されません)。
     戻り値は`sys.exit()'関数へ渡される整数でしょう。
     例外が原因でインタプリタが終了した場合は`1'、あるいは、
     引数リストが有効なPythonコマンドラインになっていない場合は`2'です。

`int PyRun_AnyFile(FILE *fp, const char *filename)'
     下記の `PyRun_AnyFileExFlags()' のCLOSEIT を`0' に、FLAGS を
     `NULL'にして単純化したインタフェースです。

`int PyRun_AnyFileFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)'
     下記の `PyRun_AnyFileExFlags()' のCLOSEIT を`0'
     にして単純化したインタフェースです。

`int PyRun_AnyFileEx(FILE *fp, const char *filename, int closeit)'
     下記の `PyRun_AnyFileExFlags()' の FLAGS を
     `NULL'にして単純化したインタフェースです。

`int PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)'
     FPが対話的デバイス(コンソールや端末入力あるいはUNIX仮想端末)と
     関連づけられたファイルを参照しているならば、
     `PyRun_InteractiveLoop()'の値を返します。それ以外の場合は、
     `PyRun_SimpleFile()'の結果を返します。FILENAMEが
     `NULL'ならば、この関数はファイル名として`"???"'を使います。

`int PyRun_SimpleString(const char *command)'
     下記の `PyRun_SimpleStringFlags()' の PYCOMPILERFLAGS* を
     `NULL'にして単純化したインタフェースです。

`int PyRun_SimpleStringFlags(const char *command, PyCompilerFlags *flags)'
     `__main__'モジュールの中でFLAGS に従ってCOMMAND に含まれる Python
     ソースコードを
     実行します。`__main__'がまだ存在しない場合は作成されます。
     正常終了の場合は`0'を返し、また例外が発生した場合は`-1'を
     返します。エラーがあっても、例外情報を得る方法はありません。

`int PyRun_SimpleFile(FILE *fp, const char *filename)'
     下記の `PyRun_SimpleStringFileExFlags()' の CLOSEIT を `0'
     に、FLAGS を `NULL'にして単純化したイ ンタフェースです。

`int PyRun_SimpleFileFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)'
     下記の `PyRun_SimpleStringFileExFlags()' の CLOSEIT を `0'
     にして単純化したインタフェースです。

`int PyRun_SimpleFileEx(FILE *fp, const char *filename, int closeit)'
     下記の `PyRun_SimpleStringFileExFlags()' の FLAGS を
     `NULL'にして単純化したイ ンタフェースです。

`int PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)'
     Similar to `PyRun_SimpleStringFlags()', but the Python source
     `PyRun_SimpleString()'と似ていますが、Pythonソースコードを
     メモリ内の文字列ではなくFPから読み込みます。
     FILENAMEはそのファイルの名前でなければなりません。 CLOSEIT
     が真ならば、PyRun_SimpleFileExFlags は処理を戻す前に
     ファイルを閉じます。

`int PyRun_InteractiveOne(FILE *fp, const char *filename)'
     下記の `PyRun_InteractiveOneFlags()' のFLAGS を `NULL'
     にして単純化したインタフェースです。

`int PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)'
     対話的デバイスに関連付けられたファイルから文を一つ読み込み、 FLAGS
     に従って実行します。
     FILENAMEが`NULL'ならば、`"???"'が代わりに使われます。
     `sys.ps1'と`sys.ps2'を使って、ユーザにプロンプトを提示します。
     入力が正常に実行されたときは`0'を返します。例外が発生した場合は
     `-1'を返します。パースエラーの場合はPythonの一部として配布されている
     `errcode.h'インクルードファイルにあるエラーコードを返します。
     (`Python.h'は`errcode.h'をインクルードしません。したがって、
     必要ならば特別にインクルードしなければならないことに注意してください。)

`int PyRun_InteractiveLoop(FILE *fp, const char *filename)'
     下記の `PyRun_InteractiveLoopFlags()' のFLAGS を `0'
     にして単純化したインタフェースです。

`int PyRun_InteractiveLoopFlags(FILE *fp,  const char *filename, PyCompilerFlags *flags)'
     対話的デバイスに関連付けられたファイルから`EOF'
     に達するまで複数の文を
     読み込み実行します。FILENAMEが`NULL'ならば、`"???"'が代わりに
     使われます。`sys.ps1'と`sys.ps2'を使って、ユーザにプロンプトを
     提示します。`EOF'に達すると`0'を返します。

`struct _node* PyParser_SimpleParseString(const char *str, int start)'
     下記の `PyRun_SimpleParseStringFlagsFilename()' の FILENAME を
     `NULL' に、FLAGS を `0' にして単純化したイ ンタフェースです。

`struct _node* PyParser_SimpleParseStringFlags( const char *str, int start, int flags)'
     下記の `PyRun_SimpleParseStringFlagsFilename()' の FILENAME を
     `NULL' にして単純化したインタフェースです。

`struct _node* PyParser_SimpleParseStringFlagsFilename( const char *str, const char *filename, int start, int flags)'
     開始トークンSTARTを使ってSTRに含まれる Python ソースコード をFLAGS
     引数に従ってパースします。効率的に評価可能なコードオブジェ
     クトを作成するためにその結果を使うことができます。コード断片を何度も評
     価しなければならない場合に役に立ちます。

`struct _node* PyParser_SimpleParseFile(FILE *fp, const char *filename, int start)'
     下記の `PyRun_SimpleParseFileFlags()' のFLAGS を `0'
     にして単純化したインタフェースです。

`struct _node* PyParser_SimpleParseFileFlags(FILE *fp, const char *filename, int start, int flags)'
     `PyParser_SimpleParseStringFlagsFilename()'に似ていますが、
     Pythonソースコードをメモリ内の文字列ではなくFPから読み込みます。
     FILENAMEはそのファイルの名前でなけれななりません。

`PyObject* PyRun_String(const char *str, int start, PyObject *globals, PyObject *locals)'
     下記の `PyRun_StringFlags()' のFLAGS を`NULL'にして単
     純化したインタフェースです。

`PyObject* PyRun_StringFlags(const char *str, int start, PyObject *globals, PyObject *locals, PyCompilerFlags *flags)'
     辞書GLOBALSとLOCALSで指定されるコンテキストにおいて、
     STRに含まれるPythonソースコードをコンパイラフラグ FLAGS の
     もとで実行します。
     パラメータSTARTはソースコードをパースするために使われるべき
     開始トークンを指定します。

     コードを実行した結果をPythonオブジェクトとして返します。または、
     例外が発生したならば`NULL' を返します。

`PyObject* PyRun_File(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals)'
     下記の `PyRun_FileExFlags()' のCLOSEIT を`0' にし、 FLAGS
     を`NULL'にして単純化したインタフェースです。

`PyObject* PyRun_FileEx(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit)'
     下記の `PyRun_FileExFlags()' の FLAGS
     を`NULL'にして単純化したインタフェースです。

`PyObject* PyRun_FileFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, PyCompilerFlags *flags)'
     下記の `PyRun_FileExFlags()' のCLOSEIT を`0' にし
     て単純化したインタフェースです。


`PyObject* PyRun_FileExFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)'
     `PyRun_String()'と似ていますが、Pythonソースコードを
     メモリ内の文字列ではなくFPから読み込みます。 CLOSEIT
     を真にすると、`PyRun_FileExFlags()' から処理
     を戻す前にファイルを閉じます。
     FILENAMEはそのファイルの名前でなければなりません。

`PyObject* Py_CompileString(const char *str, const char *filename, int start)'
     下記の`Py_CompileStringFlags()' の FLAGS を `NULL' に
     して単純化したインタフェースです。

`PyObject* Py_CompileStringFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags)'
     STR内のPythonソースコードをパースしてコンパイルし、
     作られたコードオブジェクトを返します。開始トークンは
     STARTによって与えられます。これはコンパイル可能なコードを
     制限するために使うことができ、`Py_eval_input'、
     `Py_file_input'もしくは`Py_single_input'であるべきです。
     FILENAMEで指定されるファイル名はコードオブジェクトを構築するために使われ、
     トレースバックあるいは`SyntaxError'例外メッセージに出てくる可能性があります。
     コードがパースできなかったりコンパイルできなかったりした場合に、
     これは`NULL' を返します。

`int Py_eval_input'
     単独の式に対するPython文法の開始記号で、 `Py_CompileString()' と一緒に使います。

`int Py_file_input'
     ファイルあるいは他のソースから読み込まれた文の並びに対するPython文法の
     開始記号で、`Py_CompileString()' と
     一緒に使います。これは任意の長さのPythonソースコードをコンパイルするときに
     使う記号です。

`int Py_single_input'
     単一の文に対するPython文法の開始記号で、 `Py_CompileString()' と一緒に使います。
     これは対話式のインタプリタループのための記号です。

`struct PyCompilerFlags'
     コンパイラフラグを収めておくための構造体です。コードをコンパイルする
     だけの場合、この構造体が `int flags' として渡されます。コードを実
     行する場合には`PyCompilerFlags *flags' として渡されます。この場合、
     `from __future__  import' は FLAGS の内容を変更できます。

     `PyCompilerFlags *flags' が`NULL'の場合、 `cf_flags' は `0'
     として扱われ、`from __future__ import' による変更は 無視されます。

          struct PyCompilerFlags {
              int cf_flags;
          }


`int CO_FUTURE_DIVISION'
     このビットを FLAGS にセットすると、除算演算子 `/' は PEP 238 による
     「真の除算 (true division)」 として扱われます。


File: python-api-jp.info,  Node: 参照カウント 2,  Next: 例外処理,  Prev: 超高レベルレイヤ,  Up: Top

3 参照カウント
**************

この節のマクロはPythonオブジェクトの参照カウントを管理するために使われます。

`void Py_INCREF(PyObject *o)'
     オブジェクトOに対する参照カウントを一つ増やします。オブジェクトが
     `NULL'であってはいけません。それが`NULL'ではないと確信が持てないならば、
     `Py_XINCREF()'を使ってください。

`void Py_XINCREF(PyObject *o)'
     オブジェクトOに対する参照カウントを一つ増やします。オブジェクトが
     `NULL'であってもよく、その場合マクロは何の影響も与えません。

`void Py_DECREF(PyObject *o)'
     オブジェクトOに対する参照カウントを一つ減らします。オブジェクトが
     `NULL'であってはいけません。それが`NULL'ではないと確信が持てないならば、
     `Py_XDECREF()'を使ってください。参照カウントがゼロになったら、
     オブジェクトの型のメモリ解放関数(`NULL'であってはならない)が呼ばれます。

     _(例えば`__del__()'メソッドをもつクラスインスタンスが
     メモリ解放されたときに)メモリ解放関数は任意のPythonコードを呼び出すことが
     できます。このようなコードでは例外は伝播しませんが、実行されたコードは
     すべてのPythonグローバル変数に自由にアクセスできます。
     これが意味するのは、`Py_DECREF()'が呼び出されるより前では、
     グローバル変数から到達可能などんなオブジェクトも一貫した状態に
     あるべきであるということです。
     例えば、リストからオブジェクトを削除するコードは削除するオブジェクト
     への参照を一時変数にコピーし、リストデータ構造を更新し、それから
     一時変数に対して`Py_DECREF()'を呼び出すべきです。_

`void Py_XDECREF(PyObject *o)'
     オブジェクトOへの参照カウントを一つ減らします。オブジェクトは
     `NULL'でもかまいませんが、その場合マクロは何の影響も与えません。それ以外の
     場合、結果は`Py_DECREF()'と同じです。また、注意すべきことも
     同じです。

`void Py_CLEAR(PyObject *o)'
     O の参照カウントを減らします．オブジェクトは `NULL'でもよく，
     その場合このマクロは何も行いません．オブジェクトが
     `NULL'でなければ， 引数を `NULL'にした`Py_DECREF()'
     と同じ効果をもたらします．
     このマクロは一時変数を使って，参照カウントをデクリメントする前に
     引数を `NULL'にセットしてくれるので，`Py_DECREF()' に
     使うときの警告を気にしなくてすみます．

     ガベージコレクション中に追跡される可能性のある変数の参照デクリメントを
     行うには，このマクロを使うのがよいでしょう．

     _Added in Python version 2.4_

以下の関数: `Py_IncRef(PyObject *o)', `Py_DecRef(PyObject *o)'.
は，実行時の動的な Python 埋め込みで使われる関数です．
これらの関数はそれぞれ`Py_XINCREF()' および `Py_XDECREF()'
をエクスポートしただけです．

以下の関数やマクロ: `_Py_Dealloc()', `_Py_ForgetReference()',
`_Py_NewReference()'
は，インタプリタのコアの内部においてのみ使用するためのものです。
また、グローバル変数`_Py_RefTotal' も同様です。


File: python-api-jp.info,  Node: 例外処理,  Next: ユーティリティ関数,  Prev: 参照カウント 2,  Up: Top

4 例外処理
**********

この章で説明する関数を使うと、Pythonの例外の処理や送出ができるように
なります。Pythonの例外処理の基本をいくらか理解することが大切です。
例外はUNIX `errno'変数にやや似た機能を果たします: 発生した
中で最も新しいエラーの(スレッド毎の)グローバルなインジケータがあります。
実行に成功した場合にはほとんどの関数がこれをクリアしませんが、失敗したときには
エラーの原因を示すために設定します。ほとんどの関数はエラーインジケータも
返し、通常は関数がポインタを返すことになっている場合は`NULL'であり、
関数が整数を返す場合は`-1'です。(例外: `PyArg_*()'関数は
実行に成功したときに`1'を返し、失敗したときに`0'を返します).

ある関数が呼び出した関数がいくつか失敗したために、その関数が失敗しなければ
ならないとき、一般的にエラーインジケータを設定しません。呼び出した関数が
すでに設定しています。エラーを処理して例外をクリアするか、あるいは
(オブジェクト参照またはメモリ割り当てのような)それが持つどんなリソースも
取り除いた後に戻るかのどちらか一方を行う責任があります。エラーを処理する
準備をしていなければ、普通に続けるべきでは_ありません_。エラーのために
戻る場合は、エラーが設定されていると呼び出し元に知らせることが大切です。
エラーが処理されていない場合または丁寧に伝えられている場合には、
Python/C APIのさらなる呼び出しは意図した通りには動かない可能性があり、
不可解な形で失敗するかもしれません。

エラーインジケータは Python変数`sys.exc_type', `sys.exc_value' および
`sys.exc_traceback'に対応する三つのPythonオブジェクトからからなります。
いろいろな方法でエラーインジケータとやりとりするためにAPI関数が存在します。
各スレッドに別々のエラーインジケータがあります。

`void PyErr_Print()'
     `sys.stderr'へ標準トレースバックをプリントし、エラーインジケータを
     クリアします。エラーインジケータが設定されているときにだけ、この関数を
     呼び出してください。(それ以外の場合、致命的なエラーを引き起こすでしょう!)

`PyObject* PyErr_Occurred()'
     エラーインジケータが設定されているかテストします。設定されている場合は、
     例外の_型_(`PyErr_Set*()'関数の一つあるいは
     `PyErr_Restore()'への最も新しい呼び出しに対する第一引数)を返します。
     設定されていない場合は`NULL'を返します。あなたは戻り値への参照を持っていませんので、
     それに`Py_DECREF()'する必要はありません。_Note:_
     戻り値を特定の例外と
     比較しないでください。その代わり、下に示す`PyErr_ExceptionMatches()'を
     使ってください。(比較は簡単に失敗するでしょう。なぜなら、例外はクラスではなく
     インスタンスかもしれないし、あるいは、クラス例外の場合は期待される例外の
     サブクラスかもしれないからです。)

`int PyErr_ExceptionMatches(PyObject *exc)'
     `PyErr_GivenExceptionMatches(PyErr_Occurred(), EXC)'と同じ。
     例外が実際に設定されたときにだけ、これを呼び出だすべきです。例外が発生
     していないならば、メモリアクセス違反が起きるでしょう。

`int PyErr_GivenExceptionMatches(PyObject *given, PyObject *exc)'
     GIVEN例外がEXCの例外と一致するなら真を返します。これはEXCが
     クラスオブジェクトである場合も真を返します。これはGIVENがサブクラスの
     インスタンスであるときも真を返します。EXCがタプルならば、タプル内
     (と再帰的にサブタプル内)のすべての例外が一致するか調べられます。
     GIVENが`NULL'ならば、メモリアクセス違反が起きるでしょう。

`void PyErr_NormalizeException(PyObject**exc, PyObject**val, PyObject**tb)'
     ある状況では、以下の`PyErr_Fetch()'が返す値は
     "正規化されていない"可能性があります。つまり、`*EXC'は
     クラスオブジェクトだが`*VAL'は同じクラスのインスタンスでは
     ないという意味です。この関数はそのような場合にそのクラスをインスタンス化
     するために使われます。その値がすでに正規化されている場合は何も起きません。
     遅延正規化はパフォーマンスを改善するために実装されています。

`void PyErr_Clear()'
     エラーインジケータをクリアします。エラーインジケータが設定されていないならば、
     効果はありません。

`void PyErr_Fetch(PyObject **ptype, PyObject **pvalue, PyObject **ptraceback)'
     エラーインジケータをアドレスを渡す三つの変数の中へ取り出します。
     エラーインジケータが設定されていない場合は、三つすべての変数を`NULL'に
     設定します。エラーインジケータが設定されている場合はクリアされ、
     あなたは取り出されたそれぞれのオブジェクトへの参照を持つことになります。
     型オブジェクトが`NULL'でないときでさえ、その値とトレースバックオブジェクトは
     `NULL'かもしれません。_Note:_
     通常、この関数は例外を扱う必要のあるコード
     あるいはエラーインジケータを一時的に保存して元に戻す必要のあるコードに
     よってのみ使用されます。

`void PyErr_Restore(PyObject *type, PyObject *value, PyObject *traceback)'
     三つのオブジェクトからエラーインジケータを設定します。エラーインジケータが
     すでに設定されている場合は、最初にクリアされます。オブジェクトが`NULL'ならば、
     エラーインジケータがクリアされます。`NULL'のtypeと非`NULL'のvalueあるいは
     tracebackを渡してはいけません。例外の型(type)はクラスであるべきです。
     無効な例外の型(type)あるいは値(value)を渡してはいけません。
     (これらの規則を破ると後で気付きにくい問題の原因となるでしょう。)
     この呼び出しはそれぞれのオブジェクトへの参照を取り除きます:
     あなたは
     呼び出しの前にそれぞれのオブジェクトへの参照を持たなければならないのであり、
     また呼び出しの後にはもはやこれらの参照を持っていません。
     (これを理解していない場合は、この関数を使ってはいけません。注意しておきます。)
     _Note:_
     通常この関数はエラーインジケータを一時的に保存し元に戻す必要のある
     コードによってのみに使われます。現在の例外状態を保存するためには
     `PyErr_Fetch()'を使ってください。

`void PyErr_SetString(PyObject *type, const char *message)'
     これはエラーインジケータを設定するための最も一般的な方法です。第一引数は
     例外の型を指定します。通常は標準例外の一つ、例えば`PyExc_RuntimeError'です。
     その参照カウントを増加させる必要はありません。第二引数はエラーメッセージで、
     文字列オブジェクトへ変換されます。

`void PyErr_SetObject(PyObject *type, PyObject *value)'
     この関数は`PyErr_SetString()'に似ていますが、
     例外の"値(value)"として任意のPythonオブジェクトを指定することができます。

`PyObject* PyErr_Format(PyObject *exception, const char *format, ...)'
     この関数はエラーインジケータを設定し`NULL'を返します。
     EXCEPTIONはPython例外(インスタンスではなくクラス)であるべきです。
     FORMATは文字列であるべきであり、`printf()'に似た
     書式化コードを含んでいます。書式化コードの前の`幅.精度(width.precision)'は
     解析されますが、幅の部分は無視されます。

     書式文字               型                     コメント
     ------                 -----                  -----
     %%                     _n/a_                  リテラルの % 文字。
     %c                     int                    一文字.
                                                   Cのintで表現される。
     %d                     int                    `printf("%d")'
                                                   と完全に同じ。
     %u                     unsigned int           `printf("%u")'
                                                   と完全に同じ。
     %ld                    long                   `printf("%ld")'
                                                   と完全に同じ。
     %lu                    unsigned long          `printf("%lu")'
                                                   と完全に同じ。
     %zd                    Py_ssize_t             `printf("%zd")'
                                                   と完全に同じ。
     %zu                    size_t                 `printf("%zu")'
                                                   と完全に同じ.
     %i                     int                    `printf("%i")'
                                                   と完全に同じ。
     %x                     int                    `printf("%x")'
                                                   と完全に同じ。
     %s                     char*                  NULL終端の C
                                                   の文字配列。
     %p                     void*                  C
                                                   ポインタの16進表現。
                                                   プラットフォームのprintfによらず、必ずリテラル
                                                   `0x'
                                                   が頭につくことが保証される
                                                   という以外、`printf("%p")'とほぼ同じ。

     認識できない書式化文字があると書式化文字列の残りすべてがそのまま
     結果の文字列へコピーされ、余分の引数はどれも捨てられます。

`void PyErr_SetNone(PyObject *type)'
     これは`PyErr_SetObject(TYPE, Py_None)'を省略したものです。

`int PyErr_BadArgument()'
     これは`PyErr_SetString(PyExc_TypeError, MESSAGE)'を省略したもので、
     ここでMESSAGEは組み込み操作が不正な引数で呼び出されたということを表しています。
     主に内部で使用するためのものです。

`PyObject* PyErr_NoMemory()'
     これは`PyErr_SetNone(PyExc_MemoryError)'を省略したもので、
     `NULL'を返します。したがって、メモリ不足になったとき、
     オブジェクト割り当て関数は`return PyErr_NoMemory();'と
     書くことができます。

`PyObject* PyErr_SetFromErrno(PyObject *type)'
     Cライブラリ関数がエラーを返してC変数`errno'を設定したときに、
     これは例外を発生させるために便利な関数です。第一要素が
     整数`errno'値で、第二要素が (`strerror()' から得られる)対応する
     エラーメッセージであるタプルオブジェクトを構成します。それから、
     `PyErr_SetObject(TYPE, OBJECT)'を呼び出します。
     UNIXでは、`errno'値が`EINTR'であるとき、すなわち
     割り込まれたシステムコールを表しているとき、これは
     `PyErr_CheckSignals()'を呼び出し、それがエラーインジケータを
     設定した場合は設定されたままにしておきます。関数は常に`NULL'を返します。
     したがって、システムコールがエラーを返したとき、システムコールの
     ラッパー関数は`return PyErr_SetFromErrno(TYPE);'と
     書くことができます。

`PyObject* PyErr_SetFromErrnoWithFilename(PyObject *type, const char *filename)'
     `PyErr_SetFromErrno()'に似ていて、FILENAMEが`NULL'でない場合に、
     それがTYPEのコンストラクタに第三引数として渡されるというふるまいが追加
     されています。`IOError'と`OSError'のような例外の場合では、
     これが例外インスタンスの`filename'属性を定義するために使われます。

`PyObject* PyErr_SetFromWindowsErr(int ierr)'
     これは`WindowsError'を発生させるために便利な関数です。
     `0'のIERRとともに呼び出された場合、`GetLastError()'が
     返すエラーコードが代りに使われます。IERRあるいは
     `GetLastError()'によって与えられるエラーコードのWindows用の説明を
     取り出すために、Win32関数`FormatMessage()'を呼び出します。それから、
     第一要素がIERR値で第二要素が(`FormatMessage()'から得られる)
     対応するエラーメッセージであるタプルオブジェクトを構成します。そして、
     `PyErr_SetObject(PYEXC_WINDOWSERROR, OBJECT)'を呼び出します。
     この関数は常に`NULL'を返します。 利用可能範囲: Windows。

`PyObject* PyErr_SetExcFromWindowsErr(PyObject *type, int ierr)'
     `PyErr_SetFromWindowsErr()'に似ていて、送出する例外の型を
     指定する引数が追加されています。 利用可能範囲: Windows。 _Added in
     Python version 2.3_

`PyObject* PyErr_SetFromWindowsErrWithFilename(int ierr, const char *filename)'
     `PyErr_SetFromWindowsErr()'に似ていて、FILENAMEが`NULL'でない場合には
     `WindowsError'のコンストラクタへ第三引数として渡されるという振る舞いが
     追加されています。 利用可能範囲: Windows。

`PyObject* PyErr_SetExcFromWindowsErrWithFilename(PyObject *type, int ierr, char *filename)'
     `PyErr_SetFromWindowsErrWithFilename()'に似ていて、
     発生させる例外の型を指定する引数が追加されています。 利用可能範囲:
     Windows。 _Added in Python version 2.3_

`void PyErr_BadInternalCall()'
     `PyErr_SetString(PyExc_TypeError, MESSAGE)'を省略したものです。
     ここでMESSAGEは内部操作(例えば、Python/C API関数)が不正な引数と
     ともに呼び出されたということを示しています。主に内部で使用するためのもの
     です。

`int PyErr_WarnEx(PyObject *category, char *message, int stacklevel)'
     警告メッセージを出します。CATEGORY引数は警告カテゴリ(以下を参照)
     かまたは`NULL'で、MESSAGE引数はメッセージ文字列です。STACKLEVELは
     フレームの数を示す正の整数です;
     警告はそのスタックフレームの中の実行している行から
     発行されます。STACKLEVELが1だと、 `PyErr_WarnEx()' が、2だと
     その上の関数が、Warningの発行元になります。

     この関数は通常警告メッセージをSYS.STDERRへプリントします。
     けれども、ユーザが警告をエラーへ変更するように指定することも可能です。
     そのような場合には、これは例外を発生させます。警告機構がもつ問題のために
     その関数が例外を発生させるということも可能です。(実装ではその厄介な仕事を
     行うために`warnings'モジュールをインポートします)。
     例外が発生させられなければ、戻り値は`0'です。あるいは、例外が発生させ
     られると`-1'です。(警告メッセージが実際にプリントされるかどうかを決定
     することはできず、また何がその例外の原因なのかを決定することもできない。
     これは意図的なものです。)例外が発生した場合、呼び出し元は通常の例外処理を
     行います(例えば、`Py_DECREF()'は参照を持っており、エラー値を
     返します)。

     警告カテゴリは`Warning'のサブクラスでなければならない。
     デフォルト警告カテゴリは`RuntimeWarning'です。
     標準Python警告カテゴリは`PyExc_'にPython例外名が続く名前の
     グローバル変数を用いて変更できます。これらは型`PyObject*'を
     持ち、すべてクラスオブジェクトです。それらの名前は
     `PyExc_Warning', `PyExc_UserWarning', `PyExc_UnicodeWarning',
     `PyExc_DeprecationWarning', `PyExc_SyntaxWarning',
     `PyExc_RuntimeWarning', `PyExc_FutureWarning' です。
     `PyExc_Warning'は`PyExc_Exception'のサブクラスです。
     その他の警告カテゴリは`PyExc_Warning'のサブクラスです。

     警告をコントロールするための情報については、`warnings'モジュールの
     ドキュメンテーションとコマンドライン・ドキュメンテーションの
     `-W'オプションを参照してください。 警告コントロールのためのC
     APIはありません。

`int PyErr_Warn(PyObject *category, char *message)'
     警告メッセージを出します。CATEGORY引数は警告カテゴリ(以下を参照)
     かまたは`NULL'で、MESSAGE引数はメッセージ文字列です。 警告は 、
     `PyErr_WarnEx()' を STACKLEVEL に 1 を指定した時と同じく、
     `PyErr_Warn()' を呼び出した関数から発行されます。

     非推奨; `PyErr_WarnEx()' を使って下さい。

`int PyErr_WarnExplicit(PyObject *category, const char *message, const char *filename, int lineno, const char *module, PyObject *registry)'
     すべての警告の属性を明示的に制御した警告メッセージを出します。
     これはPython関数`warnings.warn_explicit()'の直接的なラッパで、
     さらに情報を得るにはそちらを参照してください。そこに説明されているデフォルトの
     効果を得るために、MODULEとREGISTRY引数は`NULL'に設定することができます。

`int PyErr_CheckSignals()'
     この関数はPythonのシグナル処理とやりとりすることができます。
     シグナルがそのプロセスへ送られたかどうかチェックし、そうならば対応する
     シグナルハンドラを呼び出します。 `signal' モジュールがサポートされている場合は、
     これはPythonで書かれたシグナルハンドラを呼び出せます。すべての場合で、
     `SIGINT' のデフォルトの効果は `KeyboardInterrupt'例外を発生させることです。例外が発生した場合、
     エラーインジケータが設定され、関数は`1'を返します。
     そうでなければ、関数は`0'を返します。エラーインジケータが以前に
     設定されている場合は、それがクリアされるかどうかわからない。

`void PyErr_SetInterrupt()'
     この関数は廃止されています。`SIGINT' シグナルが
     到達した影響をシミュレートします -- 次に
     `PyErr_CheckSignals()'が呼ばれるとき、 `KeyboardInterrupt'は送出されるでしょう。インタプリタロックを
     保持することなく呼び出すことができます。

`PyObject* PyErr_NewException(char *name, PyObject *base, PyObject *dict)'
     このユーティリティ関数は新しい例外オブジェクトを作成して返します。
     NAME引数は新しい例外の名前、`module.class'形式の
     C文字列でなければならない。 BASEとDICT引数は通常`NULL'です。
     これはすべての例外のためのルート、組み込み名`Exception'
     (Cでは`PyExc_Exception'としてアクセス可能)を根として
     導出されたクラスオブジェクトを作成します。

     新しいクラスの`__module__'属性はNAME引数の前半部分(最後のドットまで)に
     設定され、クラス名は後半部分(最後のドットの後)に設定されます。
     BASE引数は代わりのベースクラスを指定するために使えます;
     一つのクラスでも、 クラスのタプルでも構いません。
     DICT引数はクラス変数とメソッドの辞書を指定するために使えます。

`void PyErr_WriteUnraisable(PyObject *obj)'
     例外が設定されているがインタプリタが実際に例外を発生させることができないときに、
     このユーティリティ関数は警告メッセージを`sys.stderr'へプリントします。
     例えば、例外が`__del__()'メソッドで発生したときに使われます。

     発生させられない例外が生じたコンテキストを特定するための一つの引数OBJとともに
     関数が呼び出されます。OBJのreprが警告メッセージにプリントされるでしょう。

* Menu:

* 標準例外::
* 文字列例外の廃止::


File: python-api-jp.info,  Node: 標準例外,  Next: 文字列例外の廃止,  Prev: 例外処理,  Up: 例外処理

4.1 標準例外
============

`PyExc_'の後ろにPythonの例外名が続く名前をもつグローバル変数として、
すべての標準Python例外が利用可能です。これらは型`PyObject*'を
持ち、すべてクラスオブジェクトです。完璧を期するために、すべての変数を
以下に列挙します:

C名                      Python名                 注記
------                   -----                    -----
PyExc_BaseException      `BaseException'          (1), (4)
PyExc_Exception          `Exception'              (1)
PyExc_StandardError      `StandardError'          (1)
PyExc_ArithmeticError    `ArithmeticError'        (1)
PyExc_LookupError        `LookupError'            (1)
PyExc_AssertionError     `AssertionError'         
PyExc_AttributeError     `AttributeError'         
PyExc_EOFError           `EOFError'               
PyExc_EnvironmentError   `EnvironmentError'       (1)
PyExc_FloatingPointError `FloatingPointError'     
PyExc_IOError            `IOError'                
PyExc_ImportError        `ImportError'            
PyExc_IndexError         `IndexError'             
PyExc_KeyError           `KeyError'               
PyExc_KeyboardInterrupt  `KeyboardInterrupt'      
PyExc_MemoryError        `MemoryError'            
PyExc_NameError          `NameError'              
PyExc_NotImplementedError`NotImplementedError'    
PyExc_OSError            `OSError'                
PyExc_OverflowError      `OverflowError'          
PyExc_ReferenceError     `ReferenceError'         (2)
PyExc_RuntimeError       `RuntimeError'           
PyExc_SyntaxError        `SyntaxError'            
PyExc_SystemError        `SystemError'            
PyExc_SystemExit         `SystemExit'             
PyExc_TypeError          `TypeError'              
PyExc_ValueError         `ValueError'             
PyExc_WindowsError       `WindowsError'           (3)
PyExc_ZeroDivisionError  `ZeroDivisionError'      

注記:
`(1)'
     これは別の標準例外のためのベースクラスです。

`(2)'
     これは`weakref.ReferenceError'と同じです。

`(3)'
     Windowsでのみ定義されています。
     プリプロセッサマクロ`MS_WINDOWS'が定義されているかテストすることで、
     これを使うコードを保護してください。

`(4)'
     _Added in Python version 2.5_


File: python-api-jp.info,  Node: 文字列例外の廃止,  Prev: 標準例外,  Up: 例外処理

4.2 文字列例外の廃止
====================

Pythonへ組み込まれるすべての例外あるいは標準ライブラリに提供されている例外は、
`BaseException'から導出されています。 

インタプリタで既存のコードが変更なしで動作するように、文字列例外は今でも
サポートされています。しかし、これも将来のリリースで変更されるでしょう。


File: python-api-jp.info,  Node: ユーティリティ関数,  Next: 抽象オブジェクトレイヤ abstract objects layer,  Prev: 例外処理,  Up: Top

5 ユーティリティ関数
********************

この章の関数は、 C で書かれたコードをプラットフォーム間で可搬性の
あるものにする上で役立つものから、C から Python モジュールを使う
もの、そして関数の引数を解釈したり、 C の値から Python の値を
構築するものまで、様々なユーティリティ的タスクを行います。

* Menu:

* オペレーティングシステム関連のユーティリティ::
* プロセス制御::
* モジュールの import::
* データ整列化 data marshalling のサポート::
* 引数の解釈と値の構築::


File: python-api-jp.info,  Node: オペレーティングシステム関連のユーティリティ,  Next: プロセス制御,  Prev: ユーティリティ関数,  Up: ユーティリティ関数

5.1 オペレーティングシステム関連のユーティリティ
================================================

`int Py_FdIsInteractive(FILE *fp, const char *filename)'
     FILENAME という名前の標準 I/O ファイル FP が対話的 (interactive)
     であると考えられる場合に真 (非ゼロ) を返します。
     これは`isatty(fileno(FP))' が真になるファイルの場合です。
     グローバルなフラグ `Py_InteractiveFlag' が真の場合には、 FILENAME
     ポインタが `NULL' か、名前が `'<stdin>'' または `'???''
     のいずれかに等しい場合にも真を返します。

`long PyOS_GetLastModificationTime(char *filename)'
     ファイル FILENAME の最終更新時刻を返します。 結果は標準 C
     ライブラリ関数 `time()' が返すタイムスタンプと
     同じ様式で符号化されています。

`void PyOS_AfterFork()'
     プロセスが fork した後の内部状態を更新するための関数です; fork 後
     Python インタプリタを使い続ける場合、新たなプロセス内で
     この関数を呼び出さねばなりません。新たなプロセスに新たな実行
     可能物をロードする場合、この関数を呼び出す必要はありません。

`int PyOS_CheckStack()'
     インタプリタがスタック空間を使い尽くしたときに真を返します。
     このチェック関数には信頼性がありますが、`USE_STACKCHECK'
     が定義されている場合 (現状では Microsoft Visual C++ コンパイラ
     でビルドした Windows 版) にしか利用できません .  `USE_CHECKSTACK'
     は自動的に定義されます; 自前のコードで
     この定義を変更してはなりません。

`PyOS_sighandler_t PyOS_getsig(int i)'
     シグナル I に対する現在のシグナルハンドラを返します。 この関数は
     `sigaction()' または `signal()' のいずれかに対する薄いラッパです。
     `sigaction()' や `signal()' を直接呼び出しては なりません!
     `PyOS_sighandler_t' は `void (*)(int)' の typedef による別名です。

`PyOS_sighandler_t PyOS_setsig(int i, PyOS_sighandler_t h)'
     シグナル I に対する現在のシグナルハンドラを H に設定 します;
     以前のシグナルハンドラを返します。 この関数は `sigaction()' または
     `signal()' のいずれかに対する薄いラッパです。 `sigaction()' や
     `signal()' を直接呼び出しては なりません!  `PyOS_sighandler_t' は
     `void (*)(int)' の typedef による別名です。


File: python-api-jp.info,  Node: プロセス制御,  Next: モジュールの import,  Prev: オペレーティングシステム関連のユーティリティ,  Up: ユーティリティ関数

5.2 プロセス制御
================

`void Py_FatalError(const char *message)'
     致命的エラーメッセージ (fatal error message) を出力してプロセスを
     強制終了 (kill)
     します。後始末処理は行われません。この関数は、Python
     インタプリタを使い続けるのが危険であるような状況が検出されたとき;
     例えば、オブジェクト管理が崩壊していると思われるときにのみ、呼び出され
     るようにしなければなりません。UNIXでは、標準 C ライブラリ関数
     `abort()'  を呼び出して `core' を生成しようと試みます。

`void Py_Exit(int status)'
     現在のプロセスを終了 (exit) します。この関数は `Py_Finalize()'  を呼び出し、
     次いで標準 C ライブラリ関数 `exit(STATUS)'  を呼び出します。

`int Py_AtExit(void (*func) ())'
     `Py_Finalize()'  から呼び出される 後始末処理を行う関数 (cleanup
     function) を登録します。
     後始末関数は引数無しで呼び出され、値を返しません。 最大で 32 の  後始末処理関数を登録できます。
     登録に成功すると、`Py_AtExit()' は `0' を返します; 失敗すると `-1'
     を返します。最後に登録した後始末処理関数から
     先に呼び出されます。各関数は高々一度しか呼び出されません。 Python
     の内部的な終了処理は後始末処理関数より以前に完了している
     ので、FUNC からはいかなる Python API も呼び出してはなりません。


File: python-api-jp.info,  Node: モジュールの import,  Next: データ整列化 data marshalling のサポート,  Prev: プロセス制御,  Up: ユーティリティ関数

5.3 モジュールの import
=======================

`PyObject* PyImport_ImportModule(const char *name)'
     この関数は下で述べる `PyImport_ImportModuleEx()'
     を単純化したインタフェースで、 GLOBALS および LOCALS 引数を
     `NULL'のままにしたものです。 NAME 引数にドットが含まれる場合
     (あるパッケージの サブモジュールを指定している場合)、FROMLIST
     引数が リスト `['*']' に追加され、戻り値がモジュールを含む
     トップレベルパッケージではなく名前つきモジュール (named module) に
     なるようにします。 (残念ながらこのやり方には、NAME
     が実際にはサブモジュールでなく
     サブパッケージを指定している場合、パッケージの `__all__'  変数に指定されている
     サブモジュールがロードされてしまうという副作用があります。) import
     されたモジュールへの新たな参照を返します。失敗した
     場合には例外をセットし、`NULL' を返します。 Python 2.4 以前では、
     失敗した場合でもモジュールは生成されていることがあります --
     `sys.modules' を使って調べてください。 Python 2.4 以降では、
     import に失敗した モジュールは `sys.modules' に残りません。

     _Changed in Python version 2.4_ 

`PyObject* PyImport_ImportModuleEx(char *name, PyObject *globals, PyObject *locals, PyObject *fromlist)'
     モジュールを import します。モジュールの import については
     組み込みの Python 関数`__import__()' を読むとよく分かります。というのも、標準の
     `__import__()' はこの関数を直接呼び出しているからです。

     戻り値は import
     されたモジュールかトップレベルパッケージへの新たな参照
     になります。失敗した場合には例外をセットし、`NULL' を返します
     (Python 2.4
     よりも前のバージョンでは、モジュールは生成されている場合が
     あります) `__import__()' と同じく、パッケージに対してサブモジュール
     を要求した場合の戻り値は通常、空でない FROMLIST を指定しない
     限りトップレベルパッケージになります。 _Changed in Python version
     2.4_

`PyObject* PyImport_Import(PyObject *name)'
     現在の "import フック関数" を呼び出すための高水準のインタフェース
     です。この関数は現在のグローバル変数辞書内の `__builtins__' から
     `__import__()' 関数を呼び出します。
     すなわち、現在の環境にインストールされている import フック、
     例えば `rexec'  や `ihooks'  を使って import を行います。

`PyObject* PyImport_ReloadModule(PyObject *m)'
     モジュールを再ロード (reload)
     します。モジュールの再ロードについては 組み込みの Python
     関数`reload()' を読むとよく分かります。というのも、標準の `reload'
     はこの関数を直接呼び出しているからです。
     戻り値は再ロードしたモジュールかトップレベルパッケージへの新たな参照
     になります。失敗した場合には例外をセットし、`NULL' を返します
     (その場合でも、モジュールは生成されている場合があります)

`PyObject* PyImport_AddModule(const char *name)'
     モジュール名に対応するモジュールオブジェクトを返します。 NAME
     引数は `package.module' の形式でもかまいません。
     まずモジュール辞書に該当するモジュールがあるかどうか調べ、
     なければ新たなモジュールを生成してモジュール辞書に挿入します。
     失敗した場合には例外をセットして `NULL' を返します。 _Note:_
     この関数はモジュールの import やロードを行いません;
     モジュールがまだロードされていなければ、空のモジュール
     オブジェクトを得ることになります。 `PyImport_ImportModule()'
     やその別形式を使って モジュールを import
     してください。ドット名表記で 指定したNAME
     が存在しない場合、パッケージ構造は 作成されません。


`PyObject* PyImport_ExecCodeModule(char *name, PyObject *co)'
     モジュール名 (`package.module' 形式でもかまいません) および Python
     のバイトコードファイルや組み込み関数 `compile()'  で得られたコードオブジェクトを元にモジュールを
     ロードします。
     モジュールオブジェクトへの新たな参照を返します。失敗した
     場合には例外をセットし、`NULL' を返します。Python 2.4 以前では、
     失敗した場合でもモジュールは生成されていることがありました。
     Python 2.4 以降では、たとえ`PyImport_ExecCodeModule()' の処理に
     入った時にNAME が `sys.modules' に入っていたとしても、 import
     に失敗したモジュールは `sys.modules' に残りません。
     初期化の不完全なモジュールを `sys.modules' に残すのは危険
     であり、そのようなモジュールを import
     するコードにとっては、モジュール の状態がわからない
     (モジュール作者の意図から外れた壊れた状態かもしれない) からです。

     この関数は、すでに import されているモジュールの場合には再ロードを
     行います。意図的にモジュールの再ロードを行う方法は
     `PyImport_ReloadModule()' を参照してください。

     NAME が`package.module' 形式のドット名表記で
     あった場合、まだ作成されていないパッケージ構造はその作成されない
     ままになります。

     _Changed in Python version 2.4_

`long PyImport_GetMagicNumber()'
     Python バイトコードファイル (いわゆる `.pyc' および `.pyo'
     ファイル) のマジックナンバを返します。マジックナンバは
     バイトコードファイルの先頭 4 バイトにリトルエンディアン整列で
     配置されています。

`PyObject* PyImport_GetModuleDict()'
     モジュール管理のための辞書 (いわゆる `sys.modules' )を返します。
     この辞書はインタプリタごとに一つだけある変数なので注意してください。

`void _PyImport_Init()'
     import 機構を初期化します。 内部使用だけのための関数です。

`void PyImport_Cleanup()'
     モジュールテーブルを空にします。 内部使用だけのための関数です。

`void _PyImport_Fini()'
     import 機構を終了処理します。 内部使用だけのための関数です。

`PyObject* _PyImport_FindExtension(char *, char *)'
     内部使用だけのための関数です。

`PyObject* _PyImport_FixupExtension(char *, char *)'
     内部使用だけのための関数です。

`int PyImport_ImportFrozenModule(char *name)'
     NAME という名前のフリーズ (freeze) されたモジュールをロード
     します。成功すると `1' を、モジュールが見つからなかった場合には
     `0' を、初期化が失敗した場合には例外をセットして`-1' を
     返します。ロードに成功したモジュールにアクセスするには
     `PyImport_ImportModule()' を使ってください。 (Note
     この関数名はいささか誤称めいています -- この関数は すでに import
     済みのモジュールをリロードしてしまいます。)

`struct _frozen'
     `freeze'  ユーティリティが生成するような
     フリーズ化モジュールデスクリプタの構造体型定義です。 (Python
     ソース配布物の `Tools/freeze/' を参照してください)
     この構造体の定義は `Include/import.h' にあり、以下のように
     なっています:

          struct _frozen {
              char *name;
              unsigned char *code;
              int size;
          };


`struct _frozen* PyImport_FrozenModules'
     このポインタは `struct _frozen' のレコードからなり、
     終端の要素のメンバが `NULL' かゼロになっているような配列
     を指すよう初期化されます。フリーズされたモジュールを import する
     とき、このテーブルを検索します。サードパーティ製のコードから
     このポインタに仕掛けを講じて、動的に生成されたフリーズ化モジュールの
     集合を提供するようにできます。

`int PyImport_AppendInittab(char *name, void (*initfunc)(void))'
     既存の組み込みモジュールテーブルに単一のモジュールを追加します。
     この関数は利便性を目的とした `PyImport_ExtendInittab()'
     のラッパ関数で、テーブルが拡張できないときには `-1' を返します。
     新たなモジュールは NAME で import でき、最初に import を
     試みた際に呼び出される関数として INITFUNC を使います。
     `Py_Initialize()' よりも前に呼び出さねばなりません。

`struct _inittab'
     組み込みモジュールリスト内の一つのエントリを記述している構造体です。
     リスト内の各構造体には、インタプリタ内に組み込まれているモジュールの
     名前と初期化関数が指定されています。 Python
     を埋め込むようなプログラムは、この構造体の配列と
     `PyImport_ExtendInittab()' を組み合わせて、追加の
     組み込みモジュールを提供できます。構造体は`Include/import.h'
     で以下のように定義されています:

          struct _inittab {
              char *name;
              void (*initfunc)(void);
          };


`int PyImport_ExtendInittab(struct _inittab *newtab)'
     組み込みモジュールのテーブルに一群のモジュールを追加します。 配列
     NEWTAB は `name' フィールドが `NULL' になっている センチネル
     (sentinel) エントリで終端されていなければなりません;
     センチネル値を与えられなかった場合にはメモリ違反になるかもしれません。
     成功すると `0' を、内部テーブルを拡張するのに十分なメモリを
     確保できなかった場合には `-1' を返します。操作が失敗した場合、
     モジュールは一切内部テーブルに追加されません。 `Py_Initialize()'
     よりも前に呼び出さねばなりません。


File: python-api-jp.info,  Node: データ整列化 data marshalling のサポート,  Next: 引数の解釈と値の構築,  Prev: モジュールの import,  Up: ユーティリティ関数

5.4 データ整列化 (data marshalling) のサポート
==============================================

以下のルーチン群は、`marshal' モジュールと同じ形式を使った
整列化オブジェクトを C コードから使えるようにします。
整列化形式でデータを書き出す関数に加えて、データを読み戻す関数
もあります。整列化されたデータを記録するファイルはバイナリモードで
開かれていなければなりません。

数値は最小桁が先にくるように記録されます。

このモジュールでは、二つのバージョンのデータ形式をサポートしています。
バージョン 0 は従来のもので、(Python 2.4 で新たに追加された) バージョン
1 は intern 化された文字列をファイル内で共有し、逆マーシャル化の時にも
共有されるようにします。PY_MARSHAL_VERSION は現在のバージョン
(バージョン 1) を示します。

`void PyMarshal_WriteLongToFile(long value, FILE *file, int version)'
     `long' 型の整数値 VALUE を FILE へ整列化します。 この関数は VALUE
     の下桁 32 ビットを書き込むだけです; ネイティブの `long'
     型サイズには関知しません。

     _Changed in Python version 2.4_

`void PyMarshal_WriteObjectToFile(PyObject *value, FILE *file, int version)'
     Python オブジェクトVALUE を FILE へ整列化します。

     _Changed in Python version 2.4_

`PyObject* PyMarshal_WriteObjectToString(PyObject *value, int version)'
     VALUE の整列化表現が入った文字列オブジェクトを返します。

     _Changed in Python version 2.4_

以下の関数を使うと、整列化された値を読み戻せます。

`long PyMarshal_ReadLongFromFile(FILE *file)'
     読み出し用に開かれた `FILE*' 内のデータストリームから、 C の
     `long' 型データを読み出して返します。 この関数は、ネイティブの
     `long' のサイズに関係なく、 32 ビットの値だけを読み出せます。

`int PyMarshal_ReadShortFromFile(FILE *file)'
     読み出し用に開かれた `FILE*' 内のデータストリームから、 C の
     `short' 型データを読み出して返します。 この関数は、ネイティブの
     `short' のサイズに関係なく、 16 ビットの値だけを読み出せます。

`PyObject* PyMarshal_ReadObjectFromFile(FILE *file)'
     読み出し用に開かれた `FILE*' 内のデータストリームから、 Python
     オブジェクトを読み出して返します。 エラーが生じた場合、適切な例外
     (`EOFError' または `TypeError') を送出して `NULL'を返します。

`PyObject* PyMarshal_ReadLastObjectFromFile(FILE *file)'
     読み出し用に開かれた `FILE*' 内のデータストリームから、 Python
     オブジェクトを読み出して返します。
     `PyMarshal_ReadObjectFromFile()' と違い、この関数は
     ファイル中に後続のオブジェクトが存在しないと仮定し、ファイルから
     メモリ上にファイルデータを一気にメモリにロードして、逆整列化機構が
     ファイルから一バイトづつ読み出す代わりにメモリ上のデータを操作
     できるようにします。対象のファイルから他に何も読み出さないと
     分かっている場合にのみ、この関数を使ってください。
     エラーが生じた場合、適切な例外 (`EOFError' または `TypeError')
     を送出して `NULL'を返します。

`PyObject* PyMarshal_ReadObjectFromString(char *string, Py_ssize_t len)'
     STRING が指しているLEN バイトの文字列バッファに納められた
     データストリームから Python オブジェクトを読み出して返します。
     エラーが生じた場合、適切な例外 (`EOFError' または `TypeError')
     を送出して `NULL'を返します。


File: python-api-jp.info,  Node: 引数の解釈と値の構築,  Prev: データ整列化 data marshalling のサポート,  Up: ユーティリティ関数

5.5 引数の解釈と値の構築
========================

これらの関数は独自の拡張モジュール用の関数やメソッドを作成する際に
便利です。詳しい情報や用例は  に あります。

最初に説明する 3 つの関数、 `PyArg_ParseTuple()'、
`PyArg_ParseTupleAndKeywords()'、および `PyArg_Parse()' はいずれも
_書式化文字列 (format string)_ を使います。
書式化文字列は、関数が受け取るはずの引数に関する情報を伝えるのに
用いられます。いずれの関数における書式化文字列も、同じ書式を
使っています。

書式化文字列は、ゼロ個またはそれ以上の "書式化単位 (format unit)"
から成り立ちます。一つの書式化単位は一つの Python オブジェクトを
表します; 通常は単一の文字か、書式化単位からなる文字列を括弧で
囲ったものになります。例外として、括弧で囲われていない
書式化単位文字列が単一のアドレス引数に対応する場合がいくつかあります。
以下の説明では、引用符のついた形式は書式化単位です;
(丸)括弧で囲った部分は書式化単位に対応する Python のオブジェクト型
です; [角] 括弧は値をアドレス渡しする際に使う C の変数型です。

``s' (文字列型または Unicode オブジェクト型) {[const char * }]'
     Python の文字列または Unicode オブジェクトを、キャラクタ文字列を
     指す C のポインタに変換します。
     変換先の文字列自体の記憶領域を提供する必要はありません;
     キャラクタ型ポインタ変数のアドレスを渡すと、すでに存在している
     文字列へのポインタをその変数に記録します。C 文字列は NUL で
     終端されています。Python の文字列型は、NUL
     バイトが途中に埋め込まれて いてはなりません;
     もし埋め込まれていれば`TypeError' 例外を 送出します。Unicode
     オブジェクトはデフォルトエンコーディングを使って C
     文字列に変換されます。変換に失敗すると `UnicodeError' を
     送出します。

``s#' (文字列型、Unicode オブジェクト型または任意の読み出しバッファ互換型)'
     {[const char *, int }] これは `s'
     の変化形で、値を二つの変数に記録します。一つ目の変数は
     キャラクタ文字列へのポインタで、二つ目はその長さです。
     この書式化単位の場合には、Python 文字列に null バイトが埋め込まれて
     いてもかまいません。 Unicode オブジェクトの場合、デフォルト
     エンコーディングでの変換が可能ならば、変換したオブジェクトから文字列
     へのポインタを返します。その他の読み出しバッファ互換オブジェクトは
     生の内部データ表現への参照を返します。

``z' (文字列型または `None') {[const char * }]'
     `s' に似ていますが、Python オブジェクトは `None' でも
     よく、その場合には C のポインタは `NULL'にセットされます。

``z#' (文字列型、`None'、または任意の読み出しバッファ互換型) {[const char *, int }]'
     `s#' の `s' を `z' にしたような意味です。

``u' (Unicode オブジェクト型) {[Py_UNICODE * }]'
     Python の Unicode オブジェクトを、NUL で終端された 16 ビットの
     Unicode (UTF-16) データに変換します。`s' と同様に、 Unicode
     データバッファ用に記憶領域を提供する必要はありません; `Py_UNICODE'
     型ポインタ変数のアドレスを渡すと、すでに存在している Unicode
     データへのポインタをその変数に記録します。

``u#' (Unicode オブジェクト型) {[Py_UNICODE *, int }]'
     これは `u' の変化形で、値を二つの変数に記録します。一つ目の変数は
     Unicode データバッファへのポインタで、二つ目はその長さです。 非
     Unicode のオブジェクトの場合、読み出しバッファのポインタを
     `Py_UNICODE' 型シーケンスへのポインタと解釈して扱います。

``es' (文字列型、Unicode オブジェクト型または任意の読み出しバッファ互換型){[const char *encoding, char **buffer }]'
     これは `s' の変化形で、Unicode オブジェクトや Unicode に
     変換可能なオブジェクトをキャラクタ型バッファにエンコードするために
     用いられます。NUL
     バイトが埋め込まれていない文字列でのみ動作します。

     この書式化単位には二つの引数が必要です。一つ目は入力にのみ用いられ、
     NUL で終端されたエンコード名文字列を指す `const char*' 型で
     なければなりません。指定したエンコード名を Python が理解できない
     場合には例外を送出します。第二の引数は `char**' でなければ
     なりません; この引数が参照しているポインタの値は、引数に指定した
     テキストの内容が入ったバッファへのポインタになります。
     テキストは最初の引数に指定したエンコード方式でエンコードされます。

     `PyArg_ParseTuple()' を使うと、必要なサイズのバッファを
     確保し、そのバッファにエンコード後のデータをコピーして、 *BUFFER
     がこの新たに確保された記憶領域を指すように変更します。
     呼び出し側には、確保されたバッファを使い終わった後に
     `PyMem_Free()' で解放する責任があります。

``et' (文字列型、Unicode オブジェクト型または文字列バッファ互換型) {[const char *encoding, char **buffer }]'
     `es' と同じです。ただし、8 ビット幅の文字列オブジェクトを
     エンコードし直さずに渡します。その代わり、実装では文字列オブジェクトが
     パラメタに渡したエンコードを使っているものと仮定します。

``es#' (文字列型、Unicode オブジェクト型または文字列バッファ互換型) {[const char *encoding, char **buffer, int *buffer_length }]'
     `s#' の変化形で、Unicode オブジェクトや Unicode に
     変換可能なオブジェクトをキャラクタ型バッファにエンコードするために
     用いられます。`es'
     書式化単位と違って、この変化形はバイトが埋め込まれて
     いてもかまいません。

     この書式化単位には三つの引数が必要です。一つ目は入力にのみ用いられ、
     NUL で終端されたエンコード名文字列を指す `const char*' 型か
     `NULL'でなければなりません。`NULL'の場合にはデフォルトエンコーディング
     を使います。指定したエンコード名を Python が理解できない
     場合には例外を送出します。第二の引数は `char**' でなければ
     なりません; この引数が参照しているポインタの値は、引数に指定した
     テキストの内容が入ったバッファへのポインタになります。
     テキストは最初の引数に指定したエンコード方式でエンコードされます。
     第三の引数は整数へのポインタでなければなりません; ポインタが参照
     している整数の値は出力バッファ内のバイト数にセットされます。

     この書式化単位の処理には二つのモードがあります:

     *BUFFER が`NULL' ポインタを指している場合、関数は
     必要なサイズのバッファを確保し、そのバッファにエンコード後の
     データをコピーして、*BUFFER がこの新たに確保された
     記憶領域を指すように変更します。
     呼び出し側には、確保されたバッファを使い終わった後に
     `PyMem_Free()' で解放する責任があります。

     *BUFFER が非 `NULL' のポインタ (すでにメモリ確保済みの バッファ)
     を指している場合、`PyArg_ParseTuple()'
     はこのメモリ位置をバッファとして用い、*BUFFER_LENGTH
     の初期値をバッファサイズとして用います。`PyArg_ParseTuple()'
     は次にエンコード済みのデータをバッファにコピーして、NUL で終端
     します。バッファの大きさが足りなければ `ValueError'
     がセットされます。

     どちらの場合も、 *BUFFER_LENGTH は終端の NUL バイトを
     含まないエンコード済みデータの長さにセットされます。

``et#' (文字列型、Unicode オブジェクト型または文字列バッファ互換型) {[const char *encoding, char **buffer }]'
     `es#' と同じです。ただし、文字列オブジェクトを
     エンコードし直さずに渡します。その代わり、実装では文字列オブジェクトが
     パラメタに渡したエンコードを使っているものと仮定します。

``b' (整数型) {[char }]'
     Python の整数型を、 C の `char' 型の小さな整数に変換します。

``B' (整数型) {[unsigned char }]'
     Python の整数型を、オーバフローチェックを行わずに、 C の `unsigned
     char' 型の小さな整数に変換します。_Added in Python version 2.3_

``h' (整数型) {[short int }]'
     Python の整数型を、 C の `short int' 型に変換します。

``H' (整数型) {[unsigned short int }]'
     Python の整数型を、オーバフローチェックを行わずに、 C の `unsigned
     short int' 型に変換します。_Added in Python version 2.3_

``i' (整数型) {[int }]'
     Python の整数型を、 C の `int' 型に変換します。

``I' (整数型) {[unsigned int }]'
     Python の整数型を、オーバフローチェックを行わずに、 C の `unsigned
     int' 型に変換します。_Added in Python version 2.3_

``l' (整数型) {[long int }]'
     Python の整数型を、 C の `long int' 型に変換します。

``k' (整数型) {[unsigned long }]'
     Python
     の整数型もしくは長整数型を、オーバフローチェックを行わずに、 C の
     `unsigned long int' 型に変換します。_Added in Python version 2.3_

``L' (整数型) {[PY_LONG_LONG }]'
     Python の整数型を、 C の `long long' 型に変換します。
     この書式化単位は、`long long' 型 (または Windows の `_int64' 型)
     がサポートされているプラットフォームでのみ 利用できます。 Convert
     a Python integer to a C `long long'.  This format is only
     available on platforms that support `long long' (or `_int64' on
     Windows).

``K' (整数型) {[unsigned PY_LONG_LONG }]'
     Python
     の整数型もしくは長整数型を、オーバフローチェックを行わずに、 C の
     `unsigned long long' 型に変換します。 この書式化単位は、`unsigned
     long long' 型 (または Windows の `unsigned _int64' 型)
     がサポートされているプラットフォームでのみ 利用できます。_Added in
     Python version 2.3_

``n' (integer) {[Py_ssize_t }]'
     Python の整数型もしくは長整数型をCの `Py_ssize_t' 型に変換します。
     _Added in Python version 2.5_

``c' (長さ 1 の文字列型) {[char }]'
     長さ 1 の文字列として表現されている Python キャラクタを C の
     `char' 型に変換します。

``f' (浮動小数点型) {[float }]'
     Python の浮動小数点型を、 C の `float' 型に変換します。

``d' (浮動小数点型) {[double }]'
     Python の浮動小数点型を、 C の `double' 型に変換します。

``D' (複素数型) {[Py_complex }]'
     Python の複素数型を、 C の `Py_complex' 構造体に変換します。

``O' (オブジェクト) {[PyObject * }]'
     Python オブジェクトを (一切変換を行わずに) C の Python
     オブジェクト型 ポインタに保存します。これにより、C
     プログラムは実際のオブジェクトを
     受け渡しされます。オブジェクトの参照カウントは増加しません。
     保存されるポインタが `NULL'になることはありません。

``O!' (オブジェクト) {[TYPEOBJECT, PyObject * }]'
     Python オブジェクトを C の Python
     オブジェクト型ポインタに保存します。 `O' に似ていますが、二つの C
     の引数をとります: 一つ目の引数は Python
     の型オブジェクトへのアドレスで、二つ目の引数は
     オブジェクトへのポインタが保存されている (`PyObject*' の) C の
     変数へのアドレスです。Python オブジェクトが指定した型ではない場合、
     `TypeError' を送出します。

``O&' (オブジェクト) {[CONVERTER, ANYTHING }]'
     Python オブジェクトを CONVERTER 関数を介して C の変数に変換します。
     二つの引数をとります: 一つ目は関数で、二つ目は (任意の型の) C 変数
     へのアドレスを`void *' 型に変換したものです。 CONVERTER
     は以下のようにして呼び出されます:

     STATUS` = 'CONVERTER`('OBJECT, ADDRESS`);'

     ここで OBJECT は変換対象の Python オブジェクトで、 ADDRESS は
     `PyArg_Parse*()' に渡した `void*' 型の引数です。戻り値 STATUS
     は変換に成功した際に `1'、 失敗した場合には `0'
     になります。変換に失敗した場合、 CONVERTER
     関数は例外を送出しなくてはなりません。

``S' (文字列型) {[PyStringObject * }]'
     `O' に似ていますが、Python オブジェクトは文字列オブジェクトで
     なければなりません。
     オブジェクトが文字列オブジェクトでない場合には`TypeError'
     を送出します。 C 変数は `PyObject*'
     で宣言しておいてもかまいません。

``U' (Unicode 文字列型) {[PyUnicodeObject * }]'
     `O' に似ていますが、Python オブジェクトは Unicode オブジェクトで
     なければなりません。 オブジェクトが Unicode
     オブジェクトでない場合には`TypeError' を送出します。 C 変数は
     `PyObject*' で宣言しておいてもかまいません。

``t#' (読み出し専用キャラクタバッファ) {[char *, int }]'
     `s#' に似ていますが、読み出し専用バッファインタフェースを
     実装している任意のオブジェクトを受理します。 `char*'
     変数はバッファの最初のバイトを指すようにセットされ、 `int'
     はバッファの長さにセットされます。
     単一セグメントからなるバッファオブジェクトだけを受理します;
     それ以外の場合には `TypeError' を送出します。

``w' (読み書き可能なキャラクタバッファ) {[char * }]'
     `s' と同様ですが、読み書き可能なバッファインタフェースを
     実装している任意のオブジェクトを受理します。
     呼び出し側は何らかの別の手段でバッファの長さを決定するか、
     あるいは`w#' を使わねばなりません。
     単一セグメントからなるバッファオブジェクトだけを受理します;
     それ以外の場合には `TypeError' を送出します。

``w#' (読み書き可能なキャラクタバッファ) {[char *, int }]'
     `s#' に似ていますが、読み書き可能なバッファインタフェースを
     実装している任意のオブジェクトを受理します。 `char*'
     変数はバッファの最初のバイトを指すようにセットされ、 `int'
     はバッファの長さにセットされます。
     単一セグメントからなるバッファオブジェクトだけを受理します;
     それ以外の場合には `TypeError' を送出します。

``(ITEMS)' (タプル) {[MATCHING-ITEMS }]'
     オブジェクトはITEMS に入っている書式化単位の数だけの長さを持つ
     Python のシーケンス型でなくてはなりません。各 C 引数は ITEMS 内の
     個々の書式化単位に対応づけできねばなりません。
     シーケンスの書式化単位は入れ子構造にできます。

     _Note:_ Python のバージョン 1.5.2
     より以前は、この書式化指定文字列は
     パラメタ列ではなく、個別のパラメタが入ったタプルでなければなりません
     でした。このため、以前は `TypeError' を引き起こしていたよう
     なコードが現在は例外を出さずに処理されるかもしれません。
     とはいえ、既存のコードにとってこれは問題ないと思われます。

Python 整数型を要求している場所に Python 長整数型を渡すのは 可能です;
しかしながら、適切な値域チェックはまったく行われません --
値を受け取るためのフィールドが、値全てを受け取るには小さすぎる
場合、上桁のビット群は暗黙のうちに切り詰められます (実際のところ、
このセマンティクスは C のダウンキャスト (downcast) から継承して います
-- その恩恵は人それぞれかもしれませんが)。

その他、書式化文字列において意味を持つ文字がいくつかあります。
それらの文字は括弧による入れ子内には使えません。以下に文字を 示します:

``|''
     Python 引数リスト中で、この文字以降の引数がオプションであることを
     示します。 オプションの引数に対応する C
     の変数はデフォルトの値で初期化して おかねばなりません --
     オプションの引数が省略された場合、 `PyArg_ParseTuple()' は対応する
     C 変数の内容に 手を加えません。

``:''
     この文字があると、書式化単位の記述はそこで終わります;
     コロン以降の文字列は、エラーメッセージにおける関数名
     (`PyArg_ParseTuple()' が送出する例外の "付属値 (associated
     value)") として使われます。

``;''
     この文字があると、書式化単位の記述はそこで終わります;
     セミコロン以降の文字列は、デフォルトエラーメッセージを
     _置き換える_ エラーメッセージとして使われます。
     言うまでもなく、`:' と `;' は相互に排他の文字です。

呼び出し側に提供される Python オブジェクトの参照は全て _借りた
(borrowed)_ ものです; オブジェクトの参照カウントを
デクリメントしてはなりません!

以下の関数に渡す補助引数 (additional argument) は、書式化文字列から
決定される型へのアドレスでなければなりません; 補助引数に指定した
アドレスは、タプルから入力された値を保存するために使います。
上の書式化単位のリストで説明したように、補助引数を入力値として
使う場合がいくつかあります; その場合、対応する書式化単位
の指定する形式に従うようにせねばなりません。

変換を正しく行うためには、ARG オブジェクトは
書式化文字に一致しなければならず、かつ書式化文字列内の
書式化単位に全て値が入るようにせねばなりません。
成功すると、`PyArg_Parse*()' 関数は真を返します。
それ以外の場合には偽を返し、適切な例外を送出します。

`int PyArg_ParseTuple(PyObject *args, const char *format, ...)'
     固定引数のみを引数にとる関数のパラメタを解釈して、ローカルな
     変数に変換します。
     成功すると真を返します;失敗すると偽を返し、適切な例外を送出します。

`int PyArg_VaParse(PyObject *args, const char *format, va_list vargs)'
     `PyArg_ParseTuple()' と同じですが、可変長の引数では なく VA_LIST
     を引数にとります。

`int PyArg_ParseTupleAndKeywords(PyObject *args, PyObject *kw, const char *format, char *keywords[], ...)'
     固定引数およびキーワード引数をとる関数のパラメタを解釈して、ローカルな
     変数に変換します。
     成功すると真を返します;失敗すると偽を返し、適切な例外を送出します。

`int PyArg_VaParseTupleAndKeywords(PyObject *args, PyObject *kw, const char *format, char *keywords[], va_list vargs)'
     `PyArg_ParseTupleAndKeywords()' と同じですが、可変長の引数では
     なく VA_LIST を引数にとります。

`int PyArg_Parse(PyObject *args, const char *format, ...)'
     "旧スタイル" の関数における引数リストを分析するために使われる
     関数です -- 旧スタイルの関数は、引数解釈手法に `METH_OLDARGS'
     を使います。
     新たに書かれるコードでのパラメタ解釈にはこの関数の使用は奨められず、
     標準のインタプリタにおけるほとんどのコードがもはや引数解釈の
     ためにこの関数を使わないように変更済みです。
     この関数を残しているのは、この関数が依然として引数以外のタプルを
     分析する上で便利だからですが、この目的においては将来も使われ
     つづけるかもしれません。

`int PyArg_UnpackTuple(PyObject *args, const char *name, Py_ssize_t min, Py_ssize_t max, ...)'
     パラメータ取得を簡単にした形式で、引数の型を指定する書式化文字列を
     使いません。
     パラメタの取得にこの手法を使う関数は、関数宣言テーブル、またはメソッド
     宣言テーブル内で`METH_VARARGS' として宣言しなくては なりません。
     実引数の入ったタプルは ARGS に渡します;
     このタプルは本当のタプルでなくてはなりません。
     タプルの長さは少なくとも MIN で、MAX を超えてはなりません; MIN と
     MAX が等しくてもかまいません。
     補助引数を関数に渡さなくてはならず、各補助引数は`PyObject*'
     変数へのポインタでなくてはなりません; これらの補助引数には、 ARGS
     の値が入ります; 値の参照は借りた参照です。
     オプションのパラメタに対応する変数のうち、ARGS に指定していない
     ものには値が入りません; 呼び出し側はそれらの値を初期化しておかねば
     なりません。 この関数は成功すると真を返し、ARGS
     がタプルでない場合や
     間違った数の要素が入っている場合に偽を返します; 何らかの失敗が
     起きた場合には例外をセットします。

     この関数の使用例を以下に示します。この例は、弱参照のための
     `_weakref' 補助モジュールのソースコードからとったものです:

          static PyObject *
          weakref_ref(PyObject *self, PyObject *args)
          {
              PyObject *object;
              PyObject *callback = NULL;
              PyObject *result = NULL;

              if (PyArg_UnpackTuple(args, "ref", 1, 2, &object, &callback)) {
                  result = PyWeakref_NewRef(object, callback);
              }
              return result;
          }

     この例における`PyArg_UnpackTuple()' 呼び出しは、
     `PyArg_ParseTuple()' を使った以下の呼び出し:

          PyArg_ParseTuple(args, "O|O:ref", &object, &callback)

     と全く等価です。

     _Added in Python version 2.2_

`PyObject* Py_BuildValue(const char *format, ...)'
     `PyArg_Parse*()' ファミリの関数が受け取るのと似た
     形式の書式化文字列および値列に基づいて、新たな値を生成します。
     生成した値を返します。エラーの場合には`NULL' を返します; `NULL'
     を返す場合、例外を送出するでしょう。

     `Py_BuildValue()' は常にタプルを生成するとは限りません。
     この関数がタプルを生成するのは、書式化文字列に二つ以上の書式化単位
     が入っているときだけです。書式化文字列が空の場合、`None'
     を返します; 書式化単位が厳密に一つだけ入っている場合、
     書式化単位で指定されている何らかのオブジェクト単体を返します。
     サイズがゼロや 1 のタプルを返すように強制するには、
     丸括弧で囲われた書式化文字列を使います。

     書式化単位 `s' や `s#' の場合のように、オブジェクトを
     構築する際にデータを供給するためにメモリバッファをパラメタとして渡す
     場合には、指定したデータはコピーされます。`Py_BuildValue()'
     が生成したオブジェクトは、呼び出し側が提供したバッファを決して参照
     しません。 別の言い方をすれば、`malloc()'
     を呼び出してメモリを確保し、 それを `Py_BuildValue()'
     に渡した場合、コード内で `Py_BuildValue()' が返った後で`free()' を
     呼び出す責任があるということです。

     以下の説明では、引用符のついた形式は書式化単位です;
     (丸)括弧で囲った部分は書式化単位が返す Python のオブジェクト型
     です; [角] 括弧は関数に渡す値の C 変数型です。

     書式化文字列内では、(`s#' のような書式化単位を除いて) スペース、
     タブ、コロンおよびコンマは無視されます。
     これらの文字を使うと、長い書式化文字列をちょっとだけ読みやすく
     できます。

    ``s' (文字列型) {[char * }]'
          null 終端された C 文字列から Python オブジェクトに変換します。
          C 文字列ポインタが `NULL'の場合、 `None' になります。

    ``s#' (文字列型) {[char *, int }]'
          C 文字列とその長さから Python オブジェクトに変換します。 C
          文字列ポインタが `NULL'の場合、長さは無視され `None'
          になります。

    ``z' (string or `None') {[char * }]'
          `s' と同じです。

    ``z#' (string or `None') {[char *, int }]'
          `s#' と同じです。

    ``u' (Unicode string) {[Py_UNICODE * }]'
          null 終端された Unicode (UCS-2 または UCS-4)
          データのバッファから Python オブジェクトに変換します。
          Unicode バッファポインタが `NULL'の場合、 `None' になります。

    ``u#' (Unicode string) {[Py_UNICODE *, int }]'
          null 終端された Unicode (UCS-2 または UCS-4)
          データのバッファと その長さから Python
          オブジェクトに変換します。 Unicode バッファポインタが
          `NULL'の場合、長さは無視され `None' になります。

    ``i' (整数型) {[int }]'
          通常の C の `int' を Python の整数オブジェクトに変換します。

    ``b' (整数型) {[char }]'
          `i' と同じです。 通常のC の `char' を Python
          の整数オブジェクトに変換します。

    ``h' (整数型) {[short int }]'
          通常のC の `short int' を Python
          の整数オブジェクトに変換します。

    ``l' (整数型) {[long int }]'
          C の `long int' を Python の整数オブジェクトに変換します。

    ``B' (integer) {[unsigned char }]'
          C の `unsigned char' を Python
          の整数オブジェクトに変換します。

    ``H' (integer) {[unsigned short int }]'
          C の `unsigned short int' を Python
          の整数オブジェクトに変換します。

    ``I' (integer/long) {[unsigned int }]'
          C の `unsigned int' を Python
          の整数オブジェクト、あるいは、値が `sys.maxint'
          より大きければ長整数オブジェクトに変換します。

    ``k' (integer/long) {[unsigned long }]'
          C の `unsigned long' を Python
          の整数オブジェクト、あるいは、値が `sys.maxint'
          より大きければ長整数オブジェクトに変換します。

    ``L' (long) {[PY_LONG_LONG }]'
          C の `long long' を Python の長整数オブジェクトに変換します。
          `long long'
          をサポートしているプラットフォームでのみ利用可能です。

    ``K' (long) {[unsigned PY_LONG_LONG }]'
          C の `unsigned long long' を Python
          の長整数オブジェクトに変換します。 `long long'
          をサポートしているプラットフォームでのみ利用可能です。

    ``n' (int) {[Py_ssize_t }]'
          C の `unsigned long' を Python の整数オブジェクト、あるいは
          長整数オブジェクトに変換します。 _Added in Python version 2.5_

    ``c' (string of length 1) {[char }]'
          文字を表す通常の C の `int' を、長さ 1 の Python の文字列
          オブジェクトに変換します。

    ``d' (浮動小数点型) {[double }]'
          C の `double' を Python の浮動小数点数に変換します。

    ``f' (浮動小数点型) {[float }]'
          `d' と同じです。

    ``D' (複素数型) {[Py_complex * }]'
          C の `Py_complex' 構造体を Python の複素数に変換します。

    ``O' (オブジェクト) {[PyObject * }]'
          Python オブジェクトを手を加えずに渡します
          (ただし、参照カウントは 1
          インクリメントします)。渡したオブジェクトが `NULL' ポインタ
          の場合、この引数を生成するのに使った何らかの呼び出しがエラーに
          なったのが原因であると仮定して、例外をセットします。
          従ってこのとき `Py_BuildValue()' は `NULL' を返しますが
          `Py_BuildValue()' 自体は例外を送出しません。
          例外をまだ送出していなければ`SystemError' をセットします。

    ``S' (オブジェクト) {[PyObject * }]'
          `O' と同じです。

    ``N' (オブジェクト) {[PyObject * }]'
          `O' と同じです。ただし、オブジェクトの参照カウントを
          インクリメントしません。オブジェクトが引数リスト内のオブジェクト
          コンストラクタ呼び出しによって生成されている場合に便利です。

    ``O&' (オブジェクト) {[CONVERTER, ANYTHING }]'
          ANYTHING を CONVERTER 関数を介して Python オブジェクトに
          変換します。この関数は ANYTHING  (`void *' と互換の型で
          なければなりません) を引数にして呼び出され、"新たな"
          オブジェクト を返すか、失敗した場合には `NULL'
          を返すようにしなければなりません。

    ``(ITEMS)' (タプル型) {[MATCHING-ITEMS }]'
          C の値からなる配列を、同じ要素数を持つ Python
          のタプルに変換します。

    ``[ITEMS ' (リスト型) {[MATCHING-ITEMS]}]'
          C の値からなる配列を、同じ要素数を持つ Python
          のリストに変換します。

    ``{ITEMS}' (辞書型) {[MATCHING-ITEMS }]'
          C の値からなる配列を Python
          の辞書に変換します。一連のペアからなる C
          の値が、それぞれキーおよび値となって辞書に追加されます。


     書式化文字列に関するエラーが生じると、`SystemError' 例外を
     セットして `NULL' を返します。


File: python-api-jp.info,  Node: 抽象オブジェクトレイヤ abstract objects layer,  Next: 具象オブジェクト concrete object レイヤ,  Prev: ユーティリティ関数,  Up: Top

6 抽象オブジェクトレイヤ (abstract objects layer)
*************************************************

この章で説明する関数は、Python オブジェクトとのやりとりを型や
(数値型全て、シーケンス型全てといった) 大まかなオブジェクト型の種類に
関係なく行います。関数を適用対象でないオブジェクトに対して 使った場合、
Python の例外が送出されることになります。

これらの関数は、`PyList_New()'で作成された後に`NULL'以外の値を
設定されていないリストのような、適切に初期化されていないオブジェクトに対して
使うことはできません。

* Menu:

* オブジェクトプロトコル object protocol::
* 数値型プロトコル number protocol::
* シーケンス型プロトコル sequence protocol::
* マップ型プロトコル mapping protocol::
* イテレータプロトコル iterator protocol::
* バッファプロトコル buffer protocol::


File: python-api-jp.info,  Node: オブジェクトプロトコル object protocol,  Next: 数値型プロトコル number protocol,  Prev: 抽象オブジェクトレイヤ abstract objects layer,  Up: 抽象オブジェクトレイヤ abstract objects layer

6.1 オブジェクトプロトコル (object protocol)
============================================

`int PyObject_Print(PyObject *o, FILE *fp, int flags)'
     オブジェクト O をファイル FP に出力します。 失敗すると`-1'
     を返します。 FLAGS
     引数は何らかの出力オプションを有効にする際に使います。
     現在サポートされている唯一のオプションは`Py_PRINT_RAW' です;
     このオプションを指定すると、`repr()' の代わりに `str()'
     を使ってオブジェクトを書き込みます。

`int PyObject_HasAttrString(PyObject *o, const char *attr_name)'
     O が属性 ATTR_NAME を持つときに `1' を、それ以外の ときに `0'
     を返します。この関数は Python の式 `hasattr(O, ATTR_NAME)'
     と同じです。 この関数は常に成功します。

`PyObject* PyObject_GetAttrString(PyObject *o, const char *attr_name)'
     オブジェクト O から、名前 ATTR_NAME の属性を取得します。
     成功すると属性値を返し失敗すると `NULL' を返します。 この関数は
     Python の式 `O.ATTR_NAME' と同じです。

`int PyObject_HasAttr(PyObject *o, PyObject *attr_name)'
     O が属性 ATTR_NAME を持つときに `1' を、それ以外の ときに `0'
     を返します。この関数は Python の式 `hasattr(O, ATTR_NAME)'
     と同じです。 この関数は常に成功します。

`PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name)'
     オブジェクト O から、名前 ATTR_NAME の属性を取得します。
     成功すると属性値を返し失敗すると `NULL' を返します。 この関数は
     Python の式 `O.ATTR_NAME' と同じです。

`int PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v)'
     オブジェクト O のATTR_NAME という名の属性に、値 V
     を設定します。失敗すると `-1' を返します。 この関数は Python の式
     `O.ATTR_NAME = V' と同じです。

`int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v)'
     オブジェクト O のATTR_NAME という名の属性に、値 V
     を設定します。失敗すると `-1' を返します。 この関数は Python の式
     `O.ATTR_NAME = V' と同じです。

`int PyObject_DelAttrString(PyObject *o, const char *attr_name)'
     オブジェクト O のATTR_NAME という名の属性を削除します。 失敗すると
     `-1' を返します。 この関数は Python の文 `del O.ATTR_NAME'
     と同じです。

`int PyObject_DelAttr(PyObject *o, PyObject *attr_name)'
     オブジェクト O のATTR_NAME という名の属性を削除します。 失敗すると
     `-1' を返します。 この関数は Python の文 `del O.ATTR_NAME'
     と同じです。

`PyObject* PyObject_RichCompare(PyObject *o1, PyObject *o2, int opid)'
     O1 と O2 を OPID に指定した演算によって比較します。 OPID は
     `Py_LT', `Py_LE', `Py_EQ', `Py_NE', `Py_GT', または `Py_GE',
     のいずれかでなければならず、それぞれ `<', `<=', `==', `!=', `>',
     および `>=' に対応します。 この関数は Python の式 `O1 op O2'
     と同じで、 `op' が OPID に対応する演算子です。
     成功すると比較結果の値を返し失敗すると `NULL' を返します。

`int PyObject_RichCompareBool(PyObject *o1, PyObject *o2, int opid)'
     O1 と O2 を OPID に指定した演算によって比較します。 OPID は
     `Py_LT', `Py_LE', `Py_EQ', `Py_NE', `Py_GT', または `Py_GE',
     のいずれかでなければならず、それぞれ `<', `<=', `==', `!=', `>',
     および `>=' に対応します。 比較結果が真ならば `1' を、偽ならば `0'
     を、 エラーが発生すると `-1' を返します。 この関数は Python の式
     `O1 op O2' と同じで、 `op' が OPID に対応する演算子です。

`int PyObject_Cmp(PyObject *o1, PyObject *o2, int *result)'
     O1 と O2 の値を比較します。このときO1 が比較ルーチンを
     持っていればそれを使い、なければ O2 のルーチンを使います。
     比較結果は RESULT に返されます。失敗すると `-1' を返します。
     Python 文  `RESULT = cmp(O1, O2)' と同じです。

`int PyObject_Compare(PyObject *o1, PyObject *o2)'
     O1 と O2 の値を比較します。このときO1 が比較ルーチンを
     持っていればそれを使い、なければ O2 のルーチンを使います。
     比較結果は RESULT に返されます。失敗すると `-1' を返します。
     Python 文  `RESULT = cmp(O1, O2)'
     と同じです。成功すると比較結果を返します。エラーが生じた場合の
     戻り値は未定義です; `PyErr_Occurred()' を使ってエラー検出を
     行って下さい。Python 式  `cmp(O1,  O2)' と同じです。

`PyObject* PyObject_Repr(PyObject *o)'
     O の文字列表現を計算します。成功すると文字列表現を返し、
     失敗すると `NULL' を返します。Python 式`repr(O)'
     と同じです。この関数は組み込み関数 `repr()'  や逆クオート表記の処理で
     呼び出されます。

`PyObject* PyObject_Str(PyObject *o)'
     O の文字列表現を計算します。成功すると文字列表現を返し、
     失敗すると `NULL' を返します。Python 式`str(O)'
     と同じです。この関数は組み込み関数 `str()'  や`print' 文の処理で
     呼び出されます。

`PyObject* PyObject_Unicode(PyObject *o)'
     O の Unicode 文字列表現を計算します。成功すると Unicode
     文字列表現を返し失敗すると `NULL' を返します。 Python
     式`unicode(O)' と同じです。この関数は組み込み関数 `unicode()'  の処理で呼び出されます。

`int PyObject_IsInstance(PyObject *inst, PyObject *cls)'
     INST が CLS のインスタンスか、 CLS のサブクラスの
     インスタンスの場合に `-1' を返し、そうでなければ `0' を
     返します。エラーの時には `-1' を返し、例外をセットします。 CLS
     がクラスオブジェクトではなく型オブジェクトの場合、
     `PyObject_IsInstance()' は INST がCLS で あるときに `1'
     を返します。CLS をタプルで指定した場合、 CLS
     に指定した全てのエントリについてチェックを行います。
     少なくとも一つのエントリに対するチェックが `1' を返せば結果は `1'
     になり、そうでなければ `0' になります。 INST
     がクラスインスタンスでなく、かつ CLS が
     型オブジェクトでもクラスオブジェクトでもタプルでもない場合、 INST
     には `__class__' 属性がなくてはなりません -- この場合、`__class__'
     属性の値と、CLS の値の間の
     クラス関係を、関数の戻り値を決定するのに使います。 _Added in
     Python version 2.1_ _Changed in Python version 2.2_

サブクラスの決定はかなり正攻法で行いますが、クラスシステムの拡張を
実装する人たちに知っておいて欲しいちょっとした問題点があります。 `A' と
`B' がクラスオブジェクトの場合、 `B' が `A' のサブクラスとなるのは、`B'
が `A' を 直接的あるいは間接的に継承 (inherit) している場合です。
両方がクラスオブジェクトでない場合、二つのオブジェクト間の
クラス関係を決めるには、より汎用の機構を使います。 B が A
のサブクラスであるか調べたとき、A が B
と等しければ、`PyObject_IsSubclass()' は真を返します。 A および B
が異なるオブジェクトなら、B の `__bases__' 属性から深さ優先探索
(depth-first search)で A を探索します -- オブジェクトに`__bases__'
があるだけで、 この決定法を適用する条件を満たしているとみなされます。

`int PyObject_IsSubclass(PyObject *derived, PyObject *cls)'
     クラス DERIVED が CLS と同じクラスか、CLS の導出 クラスの場合に
     `1' を返し、それ以外の場合には `0' を 返します。エラーが生じると
     `-1' を返します。 CLS をタプルで指定した場合、CLS
     に指定した全てのエントリに ついてチェックを行います。
     少なくとも一つのエントリに対するチェックが `1' を返せば結果は `1'
     になり、そうでなければ `0' になります。 DERIVED または CLS
     のいずれかが実際のクラスオブジェクト (あるいはタプル)
     でない場合、上で述べた汎用アルゴリズムを使います。 _Added in
     Python version 2.1_ _Changed in Python version 2.3_

`int PyCallable_Check(PyObject *o)'
     オブジェクト O が呼び出し可能オブジェクトかどうか調べます。
     オブジェクトが呼び出し可能であるときに `1' を返し、
     そうでないときには `0' を返します。
     この関数呼び出しは常に成功します。

`PyObject* PyObject_Call(PyObject *callable_object, PyObject *args, PyObject *kw)'
     呼び出し可能な Python オブジェクト CALLABLE_OBJECT を
     タプルで指定された引数 ARGS および辞書で指定された名前つき 引数
     (named argument) KW とともに呼び出します。名前つき引数を
     必要としない場合、 KW を `NULL' にしてもかまいません。 ARGS は
     `NULL' であってはなりません。引数が全く必要ない場合には
     空のタプルを使ってください。
     成功すると呼び出し結果として得られたオブジェクトを返し、
     失敗すると `NULL' を返します。 Python の式 `apply(CALLABLE_OBJECT,
     ARGS, KW)' あるいは `CALLABLE_OBJECT(*ARGS, **KW)' と同じです。 _Added
     in Python version 2.2_

`PyObject* PyObject_CallObject(PyObject *callable_object, PyObject *args)'
     呼び出し可能な Python オブジェクト CALLABLE_OBJECT を
     タプルで指定された引数 ARGS とともに呼び出します。  引数を
     必要としない場合、 ARGS を `NULL' にしてもかまいません。
     成功すると呼び出し結果として得られたオブジェクトを返し、
     失敗すると `NULL' を返します。 Python の式 `apply(CALLABLE_OBJECT,
     ARGS)' あるいは `CALLABLE_OBJECT(*ARGS)' と同じです。 

`PyObject* PyObject_CallFunction(PyObject *callable, char *format, ...)'
     呼び出し可能な Python オブジェクト CALLABLE_OBJECT を 可変数個の C
     引数とともに呼び出します。C 引数は `Py_BuildValue()'
     形式のフォーマット文字列を使って記述します。 FORMAT
     は`NULL'にしてもよく、与える引数がないことを表します。
     成功すると呼び出し結果として得られたオブジェクトを返し、
     失敗すると `NULL' を返します。 Python の式 `apply(CALLABLE, ARGS)'
     あるいは `CALLABLE(*ARGS)' と同じです。 もしも、`PyObject *' args
     だけを引数に渡す場合は、`PyObject_CallFunctionObjArgs'
     がより速い方法であることを覚えておいてください。 

`PyObject* PyObject_CallMethod(PyObject *o, char *method, char *format, ...)'
     オブジェクト O の METHOD という名前のメソッドを、 可変数個の C
     引数とともに呼び出します。C 引数はタプルを生成するような
     `Py_BuildValue()' 形式のフォーマット文字列を使って記述します。
     FORMAT は`NULL'にしてもよく、与える引数がないことを表します。
     成功すると呼び出し結果として得られたオブジェクトを返し、
     失敗すると `NULL' を返します。 Python の式 `O.METHOD(ARGS)'
     と同じです。 もしも、`PyObject *' args
     だけを引数に渡す場合は、`PyObject_CallMethodObjArgs'
     がより速い方法であることを覚えておいてください。

`PyObject* PyObject_CallFunctionObjArgs(PyObject *callable, ..., `NULL')'
     呼び出し可能な Python オブジェクト CALLABLE_OBJECT を 可変数個の
     `PyObject*' 引数とともに呼び出します。 引数列は末尾に
     `NULL'がついた可変数個のパラメタとして与えます。
     成功すると呼び出し結果として得られたオブジェクトを返し 失敗すると
     `NULL' を返します。 _Added in Python version 2.2_

`PyObject* PyObject_CallMethodObjArgs(PyObject *o, PyObject *name, ..., `NULL')'
     オブジェクト O のメソッドを呼び出します、メソッド名は Python
     文字列オブジェクトNAME で与えます。可変数個の `PyObject*'
     引数と共に呼び出されます.  引数列は末尾に
     `NULL'がついた可変数個のパラメタとして与えます。
     成功すると呼び出し結果として得られたオブジェクトを返し 失敗すると
     `NULL' を返します。 _Added in Python version 2.2_

`long PyObject_Hash(PyObject *o)'
     オブジェクト O のハッシュ値を計算して返します。 失敗すると `-1'
     を返します。 Python の式 `hash(O)'  と同じです。

`int PyObject_IsTrue(PyObject *o)'
     O が真を表すとみなせる場合には `1' を、 そうでないときには `0'
     を返します。 Python の式 `not not O' と同じです。 失敗すると `-1'
     を返します。

`int PyObject_Not(PyObject *o)'
     O が真を表すとみなせる場合には `0' を、 そうでないときには `1'
     を返します。 Python の式 `not O' と同じです。 失敗すると `-1'
     を返します。

`PyObject* PyObject_Type(PyObject *o)'
     O が `NULL'でない場合、オブジェクトO のオブジェクト型に
     相当する型オブジェクトを返します。失敗すると `SystemError'
     を送出して `NULL'を返します。 Python の式 `type(O)'と同じです。 

     この関数は戻り値の参照カウントをインクリメントします。
     参照カウントのインクリメントが必要でない限り、広く使われていて
     `PyTypeObject*' 型のポインタを返す表記法 `O->ob_type'
     の代わりに使う理由は全くありません。

`int PyObject_TypeCheck(PyObject *o, PyTypeObject *type)'
     オブジェクト O が、 TYPE か TYPE のサブタイプで
     あるときに真を返します。どちらのパラメタも
     `NULL'であってはなりません。 _Added in Python version 2.2_

`Py_ssize_t PyObject_Length(PyObject *o)'
`Py_ssize_t PyObject_Size(PyObject *o)'
     O の長さを返します。オブジェクトO がシーケンス型プロトコルと
     マップ型プロトコルの両方を提供している場合、シーケンスとしての長さを
     返します。エラーが生じると `-1' を返します。 Python の式
     `len(O)'と同じです。 

`PyObject* PyObject_GetItem(PyObject *o, PyObject *key)'
     成功するとオブジェクト KEY に対応する O の要素を返し、 失敗すると
     `NULL' を返します。 Python の式 `O[KEY]' と同じです。

`int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)'
     オブジェクト KEY を値 V に対応付けます。 失敗すると `-1'
     を返します。 Python の文 `O[KEY] = V' と同じです。

`int PyObject_DelItem(PyObject *o, PyObject *key)'
     オブジェクト O から KEY に対する対応付けを削除します。 失敗すると
     `-1' を返します。 Python の文 `del O[KEY]' と同じです。

`int PyObject_AsFileDescriptor(PyObject *o)'
     Python オブジェクトからファイル記述子を取り出します。
     オブジェクトが整数か長整数なら、その値を返します。
     (長)整数でない場合、オブジェクトに `fileno()' メソッドがあれば
     呼び出します; この場合、 `fileno()' メソッドは
     整数または長整数をファイル記述子の値として返さなければなりません。
     失敗すると `-1' を返します。

`PyObject* PyObject_Dir(PyObject *o)'
     この関数は Python の式 `dir(O)' と同じで、
     オブジェクトの変数名に割り当てている文字列からなるリスト
     (空の場合もあります) を返します。エラーの場合には `NULL'
     を返します。引数を `NULL'にすると、Python における`dir()'
     と同様に、現在のローカルな名前を返します; この場合、
     アクティブな実行フレームがなければ `NULL' を返しますが、
     `PyErr_Occurred()' は偽を返します。

`PyObject* PyObject_GetIter(PyObject *o)'
     Python の式 `iter(O)' と同じです。
     引数にとったオブジェクトに対する新たなイテレータか、
     オブジェクトがすでにイテレータの場合にはオブジェクト自身を
     返します。オブジェクトが反復処理不可能であった場合には `TypeError'
     を送出して `NULL' を返します。


File: python-api-jp.info,  Node: 数値型プロトコル number protocol,  Next: シーケンス型プロトコル sequence protocol,  Prev: オブジェクトプロトコル object protocol,  Up: 抽象オブジェクトレイヤ abstract objects layer

6.2 数値型プロトコル (number protocol)
======================================

`int PyNumber_Check(PyObject *o)'
     オブジェクト O が数値型プロトコルを提供している場合に `1'
     を返し、そうでないときには偽を返します。
     この関数呼び出しは常に成功します。

`PyObject* PyNumber_Add(PyObject *o1, PyObject *o2)'
     成功するとO1 と O2 を加算した結果を返し、 失敗すると `NULL'
     を返します。 Python の式 `O1 + O2' と同じです。

`PyObject* PyNumber_Subtract(PyObject *o1, PyObject *o2)'
     成功するとO1 から O2 を減算した結果を返し、 失敗すると `NULL'
     を返します。 Python の式 `O1 - O2' と同じです。

`PyObject* PyNumber_Multiply(PyObject *o1, PyObject *o2)'
     成功するとO1 と O2 を乗算した結果を返し、失敗すると `NULL'
     を返します。 Python の式 `O1 * O2' と同じです。

`PyObject* PyNumber_Divide(PyObject *o1, PyObject *o2)'
     成功すると O1 を O2 で除算した結果を返し, 失敗すると `NULL'
     を返します。 Python の式 `O1 / O2' と同じです。

`PyObject* PyNumber_FloorDivide(PyObject *o1, PyObject *o2)'
     成功するとO1 を O2 で除算した切捨て値を返し、 失敗すると `NULL'
     を返します。 "旧仕様の" 整数間での除算と同じです。 _Added in
     Python version 2.2_

`PyObject* PyNumber_TrueDivide(PyObject *o1, PyObject *o2)'
     成功すると、数学的な O1 の O2 による除算値に対する 妥当な近似
     (reasonable approximation) を返し、 失敗すると `NULL' を返します。
     全ての実数を 2
     を基数として表現するのは不可能なため、二進の浮動小数点数は
     "近似値" しか表現できません。このため、戻り値も近似になります。
     この関数に二つの整数を渡した際、浮動小数点の値を返すことがあります。
     _Added in Python version 2.2_

`PyObject* PyNumber_Remainder(PyObject *o1, PyObject *o2)'
     成功すると O1 を O2 で除算した剰余を返し、 失敗すると `NULL'
     を返します。 Python の式 `O1 % O2' と同じです。

`PyObject* PyNumber_Divmod(PyObject *o1, PyObject *o2)'
     組み込み関数 `divmod()'  を参照してください。 失敗すると `NULL'
     を返します。 Python の式 `divmod(O1, O2)' と同じです。

`PyObject* PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)'
     組み込み関数`pow()'  を参照してください。 失敗すると `NULL'
     を返します。 Python の式 `pow(O1, O2, O3)'と同じです。 O3
     はオプションです。 O3 を無視させたいなら、 `Py_None'
     を入れてください (O3 に`NULL'
     を渡すと、不正なメモリアクセスを引き起こすことが あります)。

`PyObject* PyNumber_Negative(PyObject *o)'
     成功するとO の符号反転を返し、失敗すると `NULL' を返します。
     Python の式 `-O' と同じです。

`PyObject* PyNumber_Positive(PyObject *o)'
     成功すると O を返し、失敗すると `NULL' を返します。 Python の式
     `+O' と同じです。

`PyObject* PyNumber_Absolute(PyObject *o)'
     成功すると O の絶対値を返し、失敗すると `NULL' を返します。 Python
     の式 `abs(O)' と同じです。 

`PyObject* PyNumber_Invert(PyObject *o)'
     成功すると O のビット単位反転 (bitwise negation) を返し、
     失敗すると `NULL' を返します。Python の式 `~O' と同じです。

`PyObject* PyNumber_Lshift(PyObject *o1, PyObject *o2)'
     成功すると O1 を O2 だけ左シフトした結果を返し、 失敗すると `NULL'
     を返します。 Python の式 `O1 <`<' O2' と同じです。

`PyObject* PyNumber_Rshift(PyObject *o1, PyObject *o2)'
     成功すると O1 を O2 だけ右シフトした結果を返し、 失敗すると `NULL'
     を返します。 Python の式 `O1 >`>' O2' と同じです。

`PyObject* PyNumber_And(PyObject *o1, PyObject *o2)'
     成功すると O1 と O2 の "ビット単位論理積 (bitwise and)" を返し、
     失敗すると `NULL' を返します。 Python の式 `O1 & O2' と同じです。

`PyObject* PyNumber_Xor(PyObject *o1, PyObject *o2)'
     成功すると O1 と O2 の "ビット単位排他的論理和 (bitwise exclusive
     or)" を返し、 失敗すると `NULL' を返します。 Python の式 `O1 ^ O2'
     と同じです。

`PyObject* PyNumber_Or(PyObject *o1, PyObject *o2)'
     成功すると O1 と O2 の "ビット単位論理和 (bitwise or)" を返し
     失敗すると `NULL' を返します。 Python の式 `O1 | O2' と同じです。

`PyObject* PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)'
     成功するとO1 と O2 を加算した結果を返し、 失敗すると `NULL'
     を返します。 O1 が _in-place_ 演算をサポートする場合、in-place
     演算を 行います。 Python の文 `O1 += O2' と同じです。

`PyObject* PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)'
     成功するとO1 から O2 を減算した結果を返し、 失敗すると `NULL'
     を返します。 O1 が _in-place_ 演算をサポートする場合、in-place
     演算を 行います。 Python の文 `O1 -= O2' と同じです。

`PyObject* PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)'
     成功するとO1 と O2 を乗算した結果を返し、 失敗すると `NULL'
     を返します。 O1 が _in-place_ 演算をサポートする場合、in-place
     演算を 行います。 Python の文 `O1 *= O2' と同じです。

`PyObject* PyNumber_InPlaceDivide(PyObject *o1, PyObject *o2)'
     成功すると O1 を O2 で除算した結果を返し, 失敗すると `NULL'
     を返します。 O1 が _in-place_ 演算をサポートする場合、in-place
     演算を 行います。 Python の文 `O1 /= O2' と同じです。

`PyObject* PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)'
     成功するとO1 を O2 で除算した切捨て値を返し、 失敗すると `NULL'
     を返します。 O1 が _in-place_ 演算をサポートする場合、in-place
     演算を 行います。 Python の文 `O1 //= O2' と同じです。 _Added in
     Python version 2.2_

`PyObject* PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)'
     成功すると、数学的な O1 の O2 による除算値に対する 妥当な近似
     (reasonable approximation) を返し、 失敗すると `NULL' を返します。
     全ての実数を 2
     を基数として表現するのは不可能なため、二進の浮動小数点数は
     "近似値" しか表現できません。このため、戻り値も近似になります。
     この関数に二つの整数を渡した際、浮動小数点の値を返すことがあります。
     O1 が _in-place_ 演算をサポートする場合、in-place 演算を 行います。
     _Added in Python version 2.2_

`PyObject* PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)'
     成功すると O1 を O2 で除算した剰余を返し、 , 失敗すると `NULL'
     を返します。 O1 が _in-place_ 演算をサポートする場合、in-place
     演算を 行います。 Python の文 `O1 %= O2' と同じです。

`PyObject* PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)'
     組み込み関数`pow()'  を参照してください。 失敗すると `NULL'
     を返します。 O1 が _in-place_ 演算をサポートする場合、in-place
     演算を 行います。 この関数は O3 が `Py_None' の場合は Python 文
     `O1 **= O2' と同じで、それ以外の場合は `pow(O1, O2, O3)' の
     in-place 版です。 O3 を無視させたいなら、 `Py_None'
     を入れてください (O3 に`NULL'
     を渡すと、不正なメモリアクセスを引き起こすことが あります)。

`PyObject* PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)'
     成功すると O1 を O2 だけ左シフトした結果を返し、 失敗すると `NULL'
     を返します。 O1 が _in-place_ 演算をサポートする場合、in-place
     演算を 行います。 Python の文 `O1 <`<=' O2' と同じです。

`PyObject* PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)'
     成功すると O1 を O2 だけ右シフトした結果を返し、 失敗すると `NULL'
     を返します。 O1 が _in-place_ 演算をサポートする場合、in-place
     演算を 行います。 Python の文 `O1 >>= O2' と同じです。

`PyObject* PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)'
     成功すると O1 と O2 の "ビット単位論理積 (bitwise and)" を返し、
     失敗すると `NULL' を返します。 O1 が _in-place_
     演算をサポートする場合、in-place 演算を行います。 Python の文 `O1
     &= O2' と同じです。

`PyObject* PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)'
     成功すると O1 と O2 の "ビット単位排他的論理和 (bitwise exclusive
     or)" を返し、失敗すると `NULL' を返します。 O1 が _in-place_
     演算をサポートする場合、in-place 演算を 行います。 Python の文 `O1
     ^= O2' と同じです。

`PyObject* PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)'
     成功すると O1 と O2 の "ビット単位論理和 (bitwise or)" を返し
     失敗すると `NULL' を返します。 O1 が _in-place_
     演算をサポートする場合、in-place 演算を 行います。 Python の文 `O1
     |= O2' と同じです。

`int PyNumber_Coerce(PyObject **p1, PyObject **p2)'
     この関数は`PyObject*' 型の二つの変数のアドレスを引数にとります。
     `*P1' と`*P2' が指すオブジェクトが同じ型の場合、
     それぞれの参照カウントをインクリメントして `0' (成功) を返します。
     オブジェクトを変換して共通の数値型にできる場合、 `*p1' と `*p2'
     を変換後の値に置き換えて (参照カウントを '新しく' して) 、`0'
     を返します。
     変換が不可能な場合や、その他何らかのエラーが生じた場合、`-1'
     (失敗) を返し、参照カウントをインクリメントしません。
     `PyNumber_Coerce(&o1, &o2)' の呼び出しは Python 文 `O1, O2 =
     coerce(O1, O2)' と同じです。 

`PyObject* PyNumber_Int(PyObject *o)'
     成功するとO を整数に変換したものを返し、 失敗すると `NULL'
     を返します。
     引数の値が整数の範囲外の場合、長整数を代わりに返します。 Python
     の式 `int(O)'  と同じです。

`PyObject* PyNumber_Long(PyObject *o)'
     成功するとO を長整数に変換したものを返し、 失敗すると `NULL'
     を返します。 Python の式 `long(O)'  と同じです。

`PyObject* PyNumber_Float(PyObject *o)'
     成功するとO を浮動小数点数に変換したものを返し、 失敗すると `NULL'
     を返します。 Python の式 `float(O)'  と同じです。

`PyObject* PyNumber_Index(PyObject *o)'
     OをPythonのintもしくはlong型に変換し、成功したらその値を、失敗したら
     `NULL'が返され、TypeError例外が送出されます。 _Added in Python
     version 2.5_

`Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)'
     Oを整数として解釈可能だった場合、Py_ssize_t型の値に変換して返します。
     もしOがPythonのintもしくはlongに変換できたのに、Py_ssize_tへの変換が
     `OverflowError'になる場合は、EXC引数で渡された型
     (普通は`IndexError'か`OverflowError') の例外を送出します。
     もし、EXCが`NULL'なら、例外はクリアされて、値が負の場合はPY_SSIZE_T_MINへ、
     正の場合はPY_SSIZE_T_MAXへと制限されます。 _Added in Python
     version 2.5_

`int PyIndex_Check(PyObject *o)'
     Oがインデックス整数であるときにTrueを返します。
     (tp_as_number構造体のnb_indexスロットが埋まっている場合) _Added in
     Python version 2.5_


File: python-api-jp.info,  Node: シーケンス型プロトコル sequence protocol,  Next: マップ型プロトコル mapping protocol,  Prev: 数値型プロトコル number protocol,  Up: 抽象オブジェクトレイヤ abstract objects layer

6.3 シーケンス型プロトコル (sequence protocol)
==============================================

`int PySequence_Check(PyObject *o)'
     オブジェクトがシーケンス型プロトコルを提供している場合に `1'
     を返し、 そうでないときには `0' を返します。
     この関数呼び出しは常に成功します。

`Py_ssize_t PySequence_Size(PyObject *o)'
     成功するとシーケンス O 中のオブジェクトの数を返し、 失敗すると
     `-1' を返します。
     シーケンス型プロトコルをサポートしないオブジェクトに対しては、
     Python の式 `len(O)'  と同じ になります。

`Py_ssize_t PySequence_Length(PyObject *o)'
     `PySequence_Size()' の別名です。

`PyObject* PySequence_Concat(PyObject *o1, PyObject *o2)'
     成功するとO1 と O2 の連結 (concatenation) を返し、 失敗すると
     `NULL' を返します。 Python の式 `O1 + O2' と同じです。

`PyObject* PySequence_Repeat(PyObject *o, Py_ssize_t count)'
     成功するとオブジェクトO の COUNT 回繰り返しを返し、 失敗すると
     `NULL' を返します。 Python の式 `O * COUNT' と同じです。

`PyObject* PySequence_InPlaceConcat(PyObject *o1, PyObject *o2)'
     成功するとO1 と O2 の連結 (concatenation) を返し、 失敗すると
     `NULL' を返します。 O1 が _in-place_
     演算をサポートする場合、in-place 演算を 行います。 Python の式 `O1
     += O2' と同じです。

`PyObject* PySequence_InPlaceRepeat(PyObject *o, Py_ssize_t count)'
     成功するとオブジェクトO の COUNT 回繰り返しを返し、 失敗すると
     `NULL' を返します。 O1 が _in-place_
     演算をサポートする場合、in-place 演算を 行います。 Python の式 `O
     *= COUNT' と同じです。

`PyObject* PySequence_GetItem(PyObject *o, Py_ssize_t i)'
     成功すると O の I 番目の要素を返し、 失敗すると `NULL' を返します。
     Python の式 `O[I]' と同じです。

`PyObject* PySequence_GetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2)'
     成功するとO の I1 から I2 までの間のスライスを返し、 失敗すると
     `NULL' を返します。 Python の式 `O[I1:I2]' と同じです。

`int PySequence_SetItem(PyObject *o, int Py_ssize_t, PyObject *v)'
     O の I 番目の要素に V を代入します。 失敗すると `-1' を返します。
     Python の文 `O[I] = V' と同じです。 この関数は V
     への参照を盗み取り_ません_。

`int PySequence_DelItem(PyObject *o, Py_ssize_t i)'
     O の I 番目の要素を削除します。 失敗すると `-1' を返します。
     Python の文 `del O[I]' と同じです。

`int PySequence_SetSlice(PyObject *o, Py_ssize_t i1, Py_ssize_t i2, PyObject *v)'
     O の I1 から I2 までの間のスライスに V を代入します。 Python の文
     `O[I1:I2] = V' と同じです。

`int PySequence_DelSlice(PyObject *o, int Py_ssize_t, int Py_ssize_t)'
     シーケンスオブジェクト O の I1 から I2 までの間の
     スライスを削除します。失敗すると `-1' を返します。 Python の文
     `del O[I1:I2]' と同じです。

`int PySequence_Count(PyObject *o, PyObject *value)'
     O における VALUE の出現回数、すなわち `O[KEY] == VALUE' となる KEY
     の個数を 返します。失敗すると `-1' を返します。 Python の式
     `O.count(VALUE)' と同じです。

`int PySequence_Contains(PyObject *o, PyObject *value)'
     O にVALUE が入っているか判定します。 O のある要素が VALUE と等価
     (equal) ならば`1' を 返し、それ以外の場合には `0' を返します。
     エラーが発生すると `-1' を返します。 Python の式 `VALUE in O'
     と同じです。

`int PySequence_Index(PyObject *o, PyObject *value)'
     `O[I] == VALUE' となる最初に見つかったインデクス I を返します。
     エラーが発生すると `-1' を返します。 Python の式 `O.index(VALUE)'
     と同じです。

`PyObject* PySequence_List(PyObject *o)'
     任意のシーケンス O と同じ内容を持つリストオブジェクトを返します。
     返されるリストは必ず新しいリストオブジェクトになります。

`PyObject* PySequence_Tuple(PyObject *o)'
     任意のシーケンス O と同じ内容を持つタプルオブジェクトを返します。
     失敗したら`NULL'を返します。 O
     がタプルの場合、新たな参照を返します。
     それ以外の場合、適切な内容が入ったタプルを構築して返します。
     Pythonの式 `tuple(O)' と同じです。 

`PyObject* PySequence_Fast(PyObject *o, const char *m)'
     シーケンス O がすでにタプルやリストであれば O を返し、
     そうでなければ O をタプルで返します。
     返されるタプルのメンバにアクセスするには
     `PySequence_Fast_GET_ITEM()' を使ってください。 失敗すると `NULL'
     を返します。 オブジェクトがシーケンスでなければ、M
     がメッセージテキストに なっている`TypeError' を送出します。


`PyObject* PySequence_Fast_GET_ITEM(PyObject *o, Py_ssize_t i)'
     O が`NULL'でなく、`PySequence_Fast()' が返した
     オブジェクトであり、かつI がインデクスの範囲内にあると 仮定して、O
     の I 番目の要素を返します。

`PyObject** PySequence_Fast_ITEMS(PyObject *o)'
     PyObject ポインタの背後にあるアレイを返します．この関数では，O は
     `PySequence_Fast()' の返したオブジェクトであり，
     `NULL'でないものと仮定しています． _Added in Python version 2.4_

`PyObject* PySequence_ITEM(PyObject *o, Py_ssize_t i)'
     成功すると the Ith element of O を返し、 失敗すると `NULL'
     を返します。 `PySequence_GetItem()' ですが、 `PySequence_Check(O)'
     が真になるかチェックせず、 負のインデクスに対する調整を行いません。
     _Added in Python version 2.3_

`int PySequence_Fast_GET_SIZE(PyObject *o)'
     O が`NULL'でなく、`PySequence_Fast()' が返した
     オブジェクトであると仮定して、O の長さを返します。 O
     のサイズは`PySequence_Size()' を呼び出しても
     得られますが、`PySequence_Fast_GET_SIZE()' の方が O
     をリストかタプルであると仮定して処理するため、より高速です。


File: python-api-jp.info,  Node: マップ型プロトコル mapping protocol,  Next: イテレータプロトコル iterator protocol,  Prev: シーケンス型プロトコル sequence protocol,  Up: 抽象オブジェクトレイヤ abstract objects layer

6.4 マップ型プロトコル (mapping protocol)
=========================================

`int PyMapping_Check(PyObject *o)'
     オブジェクトがマップ型プロトコルを提供している場合に `1' を返し、
     そうでないときには `0' を返します。
     この関数呼び出しは常に成功します。

`Py_ssize_t PyMapping_Length(PyObject *o)'
     成功するとオブジェクト O 中のキーの数を返し、 失敗すると `-1'
     を返します。
     マップ型プロトコルを提供していないオブジェクトに対しては、 Python
     の式 `len(O)'  と同じ になります。

`int PyMapping_DelItemString(PyObject *o, char *key)'
     オブジェクト O から KEY に関する対応付けを削除します。 失敗すると
     `-1' を返します。 Python の文 `del O[KEY]' と同じです。

`int PyMapping_DelItem(PyObject *o, PyObject *key)'
     オブジェクト O から KEY に対する対応付けを削除します。 失敗すると
     `-1' を返します。 Python の文 `del O[KEY]' と同じです。

`int PyMapping_HasKeyString(PyObject *o, char *key)'
     成功すると、マップ型オブジェクトがキー KEY を持つ場合に `1'
     を返し、そうでないときには `0' を返します。 Python の式
     `O.has_key(KEY)' と同じです。 この関数呼び出しは常に成功します。

`int PyMapping_HasKey(PyObject *o, PyObject *key)'
     マップ型オブジェクトがキー KEY を持つ場合に `1' を返し、
     そうでないときには `0' を返します。 Python の式 `O.has_key(KEY)'
     と同じです。 この関数呼び出しは常に成功します。

`PyObject* PyMapping_Keys(PyObject *o)'
     成功するとオブジェクト O のキーからなるリストを返します。
     失敗すると `NULL'を返します。 Python の式 `O.keys()' と同じです。

`PyObject* PyMapping_Values(PyObject *o)'
     成功するとオブジェクト O
     のキーに対応する値からなるリストを返します。 失敗すると
     `NULL'を返します。 Python の式 `O.values()' と同じです。

`PyObject* PyMapping_Items(PyObject *o)'
     成功するとオブジェクト O の要素対、すなわちキーと値のペアが
     入ったタプルからなるリストを返します。 失敗すると
     `NULL'を返します。 Python の式 `O.items()' と同じです。

`PyObject* PyMapping_GetItemString(PyObject *o, char *key)'
     オブジェクト KEY に対応するO の要素を返します。 失敗すると
     `NULL'を返します。 Python の式 `O[KEY]' と同じです。

`int PyMapping_SetItemString(PyObject *o, char *key, PyObject *v)'
     オブジェクトO で KEY を値 V に対応付けます。 失敗すると `-1'
     を返します。 Python の文 `O[KEY] = V' と同じです。


File: python-api-jp.info,  Node: イテレータプロトコル iterator protocol,  Next: バッファプロトコル buffer protocol,  Prev: マップ型プロトコル mapping protocol,  Up: 抽象オブジェクトレイヤ abstract objects layer

6.5 イテレータプロトコル (iterator protocol)
============================================

_Added in Python version 2.2_

イテレータを扱うための固有の関数は二つしかありません。

`int PyIter_Check(PyObject *o)'
     O がイテレータプロトコルをサポートする場合に真を返します。

`PyObject* PyIter_Next(PyObject *o)'
     反復処理 O における次の値を返します。オブジェクトが
     イテレータの場合、この関数は反復処理における次の値を取り出します。
     要素が何も残っていない場合には例外がセットされていない状態で
     `NULL' を 返します。オブジェクトがイテレータでない場合には
     `TypeError' を送出します。要素を取り出す際にエラーが生じると
     `NULL' を返し、 発生した例外を送出します。

イテレータの返す要素にわたって反復処理を行うループを書くと、 C
のコードは以下のようになるはずです:

     PyObject *iterator = PyObject_GetIter(obj);
     PyObject *item;

     if (iterator == NULL) {
         /* エラーの伝播処理をここに書く */
     }

     while (item = PyIter_Next(iterator)) {
         /* 取り出した要素で何らかの処理を行う */
         ...
         /* 終わったら参照を放棄する */
         Py_DECREF(item);
     }

     Py_DECREF(iterator);

     if (PyErr_Occurred()) {
         /* エラーの伝播処理をここに書く */
     }
     else {
         /* 別の処理を続ける */
     }


File: python-api-jp.info,  Node: バッファプロトコル buffer protocol,  Prev: イテレータプロトコル iterator protocol,  Up: 抽象オブジェクトレイヤ abstract objects layer

6.6 バッファプロトコル (buffer protocol)
========================================

`int PyObject_AsCharBuffer(PyObject *obj, const char **buffer, Py_ssize_t *buffer_len)'
     文字ベースの入力として使える読み出し専用メモリ上の位置へのポインタを
     返します。OBJ 引数は単一セグメントからなる
     文字バッファインタフェースをサポートしていなければなりません。
     成功すると `0'を返し、BUFFER をメモリの位置に、 BUFFER_LEN
     をバッファの長さに設定します。エラーの際には `-1'
     を返し、`TypeError' をセットします。 _Added in Python version 1.6_

`int PyObject_AsReadBuffer(PyObject *obj, const void **buffer, Py_ssize_t *buffer_len)'
     任意のデータを収めた読み出し専用のメモリ上の位置へのポインタを
     返します。OBJ 引数は単一セグメントからなる読み出し可能
     バッファインタフェースをサポートしていなければなりません。
     成功すると `0'を返し、BUFFER をメモリの位置に、 BUFFER_LEN
     をバッファの長さに設定します。エラーの際には `-1'
     を返し、`TypeError' をセットします。 _Added in Python version 1.6_

`int PyObject_CheckReadBuffer(PyObject *o)'
     O が単一セグメントからなる読み出し可能バッファインタフェース
     をサポートしている場合に `1' を返します。それ以外の場合には `0'
     を返します。 _Added in Python version 2.2_

`int PyObject_AsWriteBuffer(PyObject *obj, void **buffer, Py_ssize_t *buffer_len)'
     書き込み可能なメモリ上の位置へのポインタを返します。OBJ
     引数は単一セグメントからなる文字バッファインタフェース
     をサポートしていなければなりません。成功すると `0'を返し、 BUFFER
     をメモリの位置に、 BUFFER_LEN をバッファの
     長さに設定します。エラーの際には `-1' を返し、 `TypeError'
     をセットします。 _Added in Python version 1.6_


File: python-api-jp.info,  Node: 具象オブジェクト concrete object レイヤ,  Next: 初期化 initialization、終了処理 finalization、スレッド,  Prev: 抽象オブジェクトレイヤ abstract objects layer,  Up: Top

7 具象オブジェクト (concrete object) レイヤ
*******************************************

この章ではは、特定の Python オブジェクト型固有の関数について述べて
います。これらの関数に間違った方のオブジェクトを渡すのは良い考え
であありません; Python プログラムから何らかのオブジェクトを受け取った
とき、そのオブジェクトが正しい型になっているか確信をもてないの
なら、まず型チェックを行わなければなりません; 例えば、あるオブジェクト
が辞書型か調べるには、`PyDict_Check()' を使います。 この章は Python
のオブジェクト型における "家計図" に従って構成 されています。

_この章で述べている関数は、渡されたオブジェクトの型を注意深く
チェックしはするものの、多くの関数は渡されたオブジェクトが有効な `NULL'
なのか有効なオブジェクトなのかをチェックしません。 これらの関数に
`NULL' を渡させてしまうと、関数はメモリアクセス
違反を起こして、インタプリタを即座に終了させてしまうはずです。_

* Menu:

* 基本オブジェクト fundamental object::
* 数値型オブジェクト numeric object::
* シーケンスオブジェクト sequence object::
* マップ型オブジェクト mapping object::
* その他のオブジェクト::


File: python-api-jp.info,  Node: 基本オブジェクト fundamental object,  Next: 数値型オブジェクト numeric object,  Prev: 具象オブジェクト concrete object レイヤ,  Up: 具象オブジェクト concrete object レイヤ

7.1 基本オブジェクト (fundamental object)
=========================================

この節では、Python の型オブジェクトと単量子 (singleton) オブジェクト
`None' について述べます。

* Menu:

* 型オブジェクト type object::
* None オブジェクト::


File: python-api-jp.info,  Node: 型オブジェクト type object,  Next: None オブジェクト,  Prev: 基本オブジェクト fundamental object,  Up: 基本オブジェクト fundamental object

7.1.1 型オブジェクト (type object)
----------------------------------

`PyTypeObject'
     組み込み型を記述する際に用いられる、オブジェクトを表す C
     構造体です。

`PyObject* PyType_Type'
     型オブジェクト自身の型オブジェクトです; Python レイヤにおける
     `type'や`types.TypeType' と同じオブジェクトです。 

`int PyType_Check(PyObject *o)'
     オブジェクト O が型オブジェクトの場合に真を返します。
     標準型オブジェクトから導出されたサブタイプ (subtype)
     のインスタンスも 含みます。その他の場合には偽を返します。

`int PyType_CheckExact(PyObject *o)'
     オブジェクト O が型オブジェクトの場合に真を返します。
     標準型のサブタイプの場合は含みません。その他の場合には偽を返します。
     _Added in Python version 2.2_

`int PyType_HasFeature(PyObject *o, int feature)'
     型オブジェクト O に、型機能 FEATURE が設定されている
     場合に真を返します。型機能は各々単一ビットのフラグで表されます。

`int PyType_IS_GC(PyObject *o)'
     型オブジェクトが O が循環参照検出をサポートしている場合に
     真を返します; この関数は型機能フラグ `Py_TPFLAGS_HAVE_GC'
     の設定状態をチェックします。 _Added in Python version 2.0_

`int PyType_IsSubtype(PyTypeObject *a, PyTypeObject *b)'
     A が B のサブタイプの場合に真を返します。 _Added in Python version
     2.2_

`PyObject* PyType_GenericAlloc(PyTypeObject *type, Py_ssize_t nitems)'
     _Added in Python version 2.2_

`PyObject* PyType_GenericNew(PyTypeObject *type, PyObject *args, PyObject *kwds)'
     _Added in Python version 2.2_

`int PyType_Ready(PyTypeObject *type)'
     型オブジェクトの後始末処理 (finalize) を行います。この関数は
     全てのオブジェクトで初期化を完了するために呼び出されなくては
     なりません。
     この関数は、基底クラス型から継承したスロットを型オブジェクトに追加する
     役割があります。 成功した場合には `0' を返し、エラーの場合には
     `-1' を 返して例外情報を設定します。 _Added in Python version 2.2_


File: python-api-jp.info,  Node: None オブジェクト,  Prev: 型オブジェクト type object,  Up: 基本オブジェクト fundamental object

7.1.2 None オブジェクト
-----------------------

`None' に対する `PyTypeObject' は、 Python/C API では
直接公開されていないので注意してください。 `None' は単量子 (singleton)
なので、オブジェクトのアイデンティティテスト (C では `==')
を使うだけで十分だからです。 同じ理由から、`PyNone_Check()'
関数はありません。

`PyObject* Py_None'
     Python における `None' オブジェクトで、値がないことを表します。
     このオブジェクトにはメソッドがありません。リファレンスカウントに
     ついては、このオブジェクトも他のオブジェクトと同様に扱う必要が
     あります。

`Py_RETURN_NONE'
     C 関数から `Py_None' を戻す操作を適切に行うためのマクロです。


File: python-api-jp.info,  Node: 数値型オブジェクト numeric object,  Next: シーケンスオブジェクト sequence object,  Prev: 基本オブジェクト fundamental object,  Up: 具象オブジェクト concrete object レイヤ

7.2 数値型オブジェクト (numeric object)
=======================================

* Menu:

* 通常整数型オブジェクト plain integer object::
* Bool 型オブジェクト::
* 長整数型オブジェクト long integer object::
* 浮動小数点型オブジェクト floating point object::
* 浮動小数点オブジェクト complex number object::


File: python-api-jp.info,  Node: 通常整数型オブジェクト plain integer object,  Next: Bool 型オブジェクト,  Prev: 数値型オブジェクト numeric object,  Up: 数値型オブジェクト numeric object

7.2.1 (通常)整数型オブジェクト (plain integer object)
-----------------------------------------------------

`PyIntObject'
     この `PyObject' のサブタイプは Python
     の整数型オブジェクトを表現します。

`PyTypeObject PyInt_Type'
     この `PyTypeObject' のインスタンスは Python の
     (長整数でない)整数型を表現します。 これは `int'や`types.IntType'
     と同じオブジェクトです。 

`int PyInt_Check(PyObject *o)'
     O が `PyInt_Type' 型か `PyInt_Type'
     型のサブタイプであるときに真を返します。 _Changed in Python
     version 2.2_

`int PyInt_CheckExact(PyObject *o)'
     O が `PyInt_Type' 型で、かつ `PyInt_Type'
     型のサブタイプでないときに真を返します。 _Added in Python version
     2.2_

`PyObject* PyInt_FromString(char *str, char **pend, int base)'
     STR の文字列値に基づいて、新たな `PyIntObject' または
     `PyLongObject' を返します。このとき BASE
     を基数として文字列を解釈します。 PEND が `NULL' でなければ、
     `*PEND' は STR 中で
     数が表現されている部分以後の先頭の文字のアドレスを指しています。
     BASE が `0' ならば、STR の先頭の文字列に基づいて 基数を決定します:
     もし STR が `'0x'' または `'0X'' で始まっていれば、基数に 16
     を使います; STR が `'0'' で始まっていれば、基数に 8 を使います;
     その他の場合には基数に 10 を 使います。BASE が `0'
     でなければ、BASE は `2' 以上 `36'
     以下の数でなければなりません。先頭に空白がある場合は
     無視されます。数字が全くない場合、`ValueError' が送出
     されます。使用しているマシンの `long int' 型で表現し切れないくらい
     大きな数が文字列に入っており、オーバフロー警告が抑制されていれば、
     `PyLongObject' を返します。オーバフロー警告が抑制されていなければ、
     `NULL' を返します。

`PyObject* PyInt_FromLong(long ival)'
     IVAL の値を使って新たな整数オブジェクトを生成します。

     現在の実装では、`-5' から `256' までの全ての整数
     に対する整数オブジェクトの配列を保持するようにしており、
     この範囲の数を生成すると、実際には既存のオブジェクトに
     対する参照が返るようになっています。従って、 `1' の
     値を変えることすら可能です。変えてしまった場合の Python の
     挙動は未定義です :-)

`PyObject* PyInt_FromSsize_t(Py_ssize_t ival)'
     IVALの値を使って新たな整数オブジェクトを生成します。
     値が`LONG_MAX'を超えている場合、長整数オブジェクトを返します。

     _Added in Python version 2.5_

`long PyInt_AsLong(PyObject *io)'
     オブジェクトがまだ `PyIntObject' でなければまず型キャストを試み、
     次にその値を返します。 エラーが発生した場合、`-1'が返されます。
     その時呼び出し側は、`PyErr_Occurred()'を使って、エラーが発生したのか、
     単に値が-1だったのかを判断するべきです。

`long PyInt_AS_LONG(PyObject *io)'
     オブジェクト IO の値を返します。エラーチェックを行いません。

`unsigned long PyInt_AsUnsignedLongMask(PyObject *io)'
     オブジェクトがまだ `PyIntObject' または `PyLongObject' で
     なければまず型キャストを試み、次にその値を`unsigned long' 型で
     返します。この関数はオーバフローをチェックしません。 _Added in
     Python version 2.3_

`unsigned PY_LONG_LONG PyInt_AsUnsignedLongLongMask(PyObject *io)'
     オブジェクトがまだ `PyIntObject' または `PyLongObject' で
     なければまず型キャストを試み、次にその値を`unsigned long long' 型で
     返します。オーバフローをチェックしません。 _Added in Python
     version 2.3_

`Py_ssize_t PyInt_AsSsize_t(PyObject *io)'
     オブジェクトがまだ`PyIntObject'でなければまず型キャストを試み、
     次にその値を`Py_ssize_t'型で返します。 _Added in Python version
     2.5_

`long PyInt_GetMax()'
     システムの知識に基づく、扱える最大の整数値
     (システムのヘッダファイル に定義されている `LONG_MAX' )
     を返します。


File: python-api-jp.info,  Node: Bool 型オブジェクト,  Next: 長整数型オブジェクト long integer object,  Prev: 通常整数型オブジェクト plain integer object,  Up: 数値型オブジェクト numeric object

7.2.2 Bool 型オブジェクト
-------------------------

Python の Bool 型は整数のサブクラスとして実装されています。ブール型の
値は、`Py_False' と `Py_True' の 2 つしかありません。
従って、通常の生成／削除関数はブール型にはあてはまりません。
とはいえ、以下のマクロが利用できます。

`int PyBool_Check(PyObject *o)'
     O が `PyBool_Type' の場合に真を返します。 _Added in Python version
     2.3_

`PyObject* Py_False'
     Python における `False'
     オブジェクトです。このオブジェクトはメソッド
     を持ちません。参照カウントの点では、他のオブジェクトと同様に扱う必要が
     あります。

`PyObject* Py_True'
     Python における `True' オブジェクトです。このオブジェクトはメソッド
     を持ちません。参照カウントの点では、他のオブジェクトと同様に扱う必要が
     あります。

`Py_RETURN_FALSE'
     `Py_False' に適切な参照カウントのインクリメントを行って、
     関数から返すためのマクロです。 _Added in Python version 2.4_

`Py_RETURN_TRUE'
     `Py_True' に適切な参照カウントのインクリメントを行って、
     関数から返すためのマクロです。 _Added in Python version 2.4_

`int PyBool_FromLong(long v)'
     V の値に応じて`Py_True' または`Py_False' への
     新しい参照を返します。 _Added in Python version 2.3_


File: python-api-jp.info,  Node: 長整数型オブジェクト long integer object,  Next: 浮動小数点型オブジェクト floating point object,  Prev: Bool 型オブジェクト,  Up: 数値型オブジェクト numeric object

7.2.3 長整数型オブジェクト (long integer object)
------------------------------------------------

`PyLongObject'
     この `PyObject' のサブタイプは長整数型を表現します。

`PyTypeObject PyLong_Type'
     この `PyTypeObject' のインスタンスは Python 長整数型を表現します。
     これは `long'や`types.LongType' と同じオブジェクトです。 

`int PyLong_Check(PyObject *p)'
     引数が `PyLongObject' か `PyLongObject'
     のサブタイプのときに真を返します。  _Changed in Python version 2.2_

`int PyLong_CheckExact(PyObject *p)'
     引数が `PyLongObject' 型で、かつ `PyLongObject'
     型のサブタイプでないときに真を返します。 _Added in Python version
     2.2_

`PyObject* PyLong_FromLong(long v)'
     V から新たな `PyLongObject' オブジェクトを生成して返します。
     失敗のときには `NULL' を返します。

`PyObject* PyLong_FromUnsignedLong(unsigned long v)'
     C の `unsigned long' 型から新たな `PyLongObject' オブジェクト
     を生成して返します。 失敗のときには `NULL' を返します。

`PyObject* PyLong_FromLongLong(PY_LONG_LONG v)'
     C の `long long' 型から新たな `PyLongObject' オブジェクトを
     生成して返します。失敗のときには `NULL' を返します。

`PyObject* PyLong_FromUnsignedLongLong(unsigned PY_LONG_LONG v)'
     C の `unsigned long long' 型から新たな `PyLongObject'
     オブジェクトを生成して返します。失敗のときには `NULL' を返します。

`PyObject* PyLong_FromDouble(double v)'
     V の整数部から新たな `PyLongObject' オブジェクトを生成して
     返します。失敗のときには `NULL' を返します。

`PyObject* PyLong_FromString(char *str, char **pend, int base)'
     STR の文字列値に基づいて、新たな `PyLongObject' を返します。
     このとき BASE を基数として文字列を解釈します。 PEND が `NULL'
     でなければ、 `*PEND' は STR 中で
     数が表現されている部分以後の先頭の文字のアドレスを指しています。
     BASE が `0' ならば、STR の先頭の文字列に基づいて 基数を決定します:
     もし STR が `'0x'' または `'0X'' で始まっていれば、基数に 16
     を使います; STR が `'0'' で始まっていれば、基数に 8 を使います;
     その他の場合には基数に 10 を 使います。BASE が `0'
     でなければ、BASE は `2' 以上 `36'
     以下の数でなければなりません。先頭に空白がある場合は
     無視されます。数字が全くない場合、`ValueError' が送出 されます。

`PyObject* PyLong_FromUnicode(Py_UNICODE *u, Py_ssize_t length, int base)'
     Unicode の数字配列を Python の長整数型に変換します。最初のパラメタ
     U は、 Unicode 文字列の最初の文字を指し、LENGTH には
     文字数を指定し、BASE には変換時の基数を指定します。 基数は範囲 [2,
     36] になければなりません; 範囲外の基数を指定すると、 `ValueError'
     を送出します。 _Added in Python version 1.6_

`PyObject* PyLong_FromVoidPtr(void *p)'
     Python 整数型または長整数型をポインタ P から生成します。
     ポインタに入れる値は `PyLong_AsVoidPtr()' を使って
     得られるような値です。 _Added in Python version 1.5.2_ _Changed in
     Python version 2.5_

`long PyLong_AsLong(PyObject *pylong)'
     PYLONG の指す長整数値を、 C の `long' 型表現で返します。 PYLONG が
     `LONG_MAX'  よりも 大きい場合、 `OverflowError' を送出します。 

`unsigned long PyLong_AsUnsignedLong(PyObject *pylong)'
     PYLONG の指す長整数値を、 C の `unsigned long' 型表現で返します。
     PYLONG が `ULONG_MAX'  よりも 大きい場合、 `OverflowError'
     を送出します。 

`PY_LONG_LONG PyLong_AsLongLong(PyObject *pylong)'
     PYLONG の指す長整数値を、 C の `long long' 型表現で返します。
     PYLONG が `long long' で表せない場合、 `OverflowError'
     を送出します。 _Added in Python version 2.2_

`unsigned PY_LONG_LONG PyLong_AsUnsignedLongLong(PyObject *pylong)'
     PYLONG の指す値を、 C の `unsigned long long' 型表現で 返します。
     PYLONG が `unsigned long long' で表せない場合、 正の値なら
     `OverflowError' を、負の値なら `TypeError' を送出します。 _Added
     in Python version 2.2_

`unsigned long PyLong_AsUnsignedLongMask(PyObject *io)'
     Python 長整数値を、 オーバフローチェックを行わずに C の `unsigned
     long' 型表現で返します。 _Added in Python version 2.3_

`unsigned PY_LONG_LONG PyLong_AsUnsignedLongLongMask(PyObject *io)'
     Python 長整数値を、 オーバフローチェックを行わずに C の `unsigned
     long long' 型表現で返します。 _Added in Python version 2.3_

`double PyLong_AsDouble(PyObject *pylong)'
     PYLONG の指す値を、 C の `double' 型表現で返します。 PYLONG が
     `double' を使って近似表現できない場合、 `OverflowError'
     例外を送出して `-1.0' を返します。

`void* PyLong_AsVoidPtr(PyObject *pylong)'
     Python の整数型か長整数型を指す PYLONG を、 C の `void'
     ポインタに変換します。PYLONG を変換できなければ、 `OverflowError'
     を送出します。この関数は `PyLong_FromVoidPtr()'
     で値を生成するときに使うような `void'
     ポインタ型を生成できるだけです。 _Added in Python version 1.5.2_
     _Changed in Python version 2.5_


File: python-api-jp.info,  Node: 浮動小数点型オブジェクト floating point object,  Next: 浮動小数点オブジェクト complex number object,  Prev: 長整数型オブジェクト long integer object,  Up: 数値型オブジェクト numeric object

7.2.4 浮動小数点型オブジェクト (floating point object)
------------------------------------------------------

`PyFloatObject'
     この `PyObject' のサブタイプは Python 浮動小数点型オブジェクト
     を表現します。

`PyTypeObject PyFloat_Type'
     この `PyTypeObject' のインスタンスは Python 浮動小数点型を
     表現します。これは `float'や`types.FloatType'
     と同じオブジェクトです。 

`int PyFloat_Check(PyObject *p)'
     引数が `PyFloatObject' か `PyFloatObject'
     のサブタイプのときに真を返します。  _Changed in Python version 2.2_

`int PyFloat_CheckExact(PyObject *p)'
     引数が `PyFloatObject' 型で、かつ `PyFloatObject'
     型のサブタイプでないときに真を返します。 _Added in Python version
     2.2_

`PyObject* PyFloat_FromString(PyObject *str, char **pend)'
     STR の文字列値をもとに `PyFloatObject' オブジェクトを生成
     します。失敗すると `NULL' を返します。引数 PEND は無視されます。
     この引数は後方互換性のためだけに残されています。

`PyObject* PyFloat_FromDouble(double v)'
     V から `PyFloatObject' オブジェクトを生成して返します。 失敗すると
     `NULL' を返します。

`double PyFloat_AsDouble(PyObject *pyfloat)'
     PYFLOAT の指す値を、 C の `double' 型表現で返します。

`double PyFloat_AS_DOUBLE(PyObject *pyfloat)'
     PYFLOAT の指す値を、 C の `double' 型表現で返しますが、
     エラーチェックを行いません。


File: python-api-jp.info,  Node: 浮動小数点オブジェクト complex number object,  Prev: 浮動小数点型オブジェクト floating point object,  Up: 数値型オブジェクト numeric object

7.2.5 浮動小数点オブジェクト (complex number object)
----------------------------------------------------

Python の複素数オブジェクトは、 C API 側から見ると二つの別個の
型として実装されています: 一方は Python プログラムに対して公開
されている Python のオブジェクトで、他方は実際の複素数値を 表現する C
の構造体です。 API では、これら双方を扱う関数を提供して います。

* Menu:

* C 構造体としての複素数::
* Python オブジェクトとしての複素数型::


File: python-api-jp.info,  Node: C 構造体としての複素数,  Next: Python オブジェクトとしての複素数型,  Prev: 浮動小数点オブジェクト complex number object,  Up: 浮動小数点オブジェクト complex number object

7.2.5.1 C 構造体としての複素数
..............................

複素数の C 構造体を引数として受理したり、戻り値として返したりする
関数は、ポインタ渡しを行うのではなく _値渡し_ を行うので
注意してください。これは API 全体を通して一貫しています。

`Py_complex'
     Python 複素数オブジェクトの値の部分に対応する C の構造体です。
     複素数オブジェクトを扱うほとんどの関数は、この型の構造体を
     場合に応じて入力や出力として使います。構造体は以下のように
     定義されています:

          typedef struct {
             double real;
             double imag;
          } Py_complex;


`Py_complex _Py_c_sum(Py_complex left, Py_complex right)'
     二つの複素数の和を C の `Py_complex' 型で返します。

`Py_complex _Py_c_diff(Py_complex left, Py_complex right)'
     二つの複素数の差を C の `Py_complex' 型で返します。

`Py_complex _Py_c_neg(Py_complex complex)'
     複素数 COMPLEX の符号反転 C の `Py_complex' 型で返します。

`Py_complex _Py_c_prod(Py_complex left, Py_complex right)'
     二つの複素数の積を C の `Py_complex' 型で返します。

`Py_complex _Py_c_quot(Py_complex dividend, Py_complex divisor)'
     二つの複素数の商を C の `Py_complex' 型で返します。

`Py_complex _Py_c_pow(Py_complex num, Py_complex exp)'
     指数 EXP の NUM 乗を C の `Py_complex' 型で返します。


File: python-api-jp.info,  Node: Python オブジェクトとしての複素数型,  Prev: C 構造体としての複素数,  Up: 浮動小数点オブジェクト complex number object

7.2.5.2 Python オブジェクトとしての複素数型
...........................................

`PyComplexObject'
     この `PyObject' のサブタイプは Python の複素数オブジェクトを
     表現します。

`PyTypeObject PyComplex_Type'
     この `PyTypeObject' のインスタンスは Python
     の複素数型を表現します。
     Pythonの`complex'や`types.ComplexType'と同じオブジェクトです。

`int PyComplex_Check(PyObject *p)'
     引数が `PyComplexObject' 型か `PyComplexObject'
     型のサブタイプのときに真を返します。 _Changed in Python version
     2.2_

`int PyComplex_CheckExact(PyObject *p)'
     引数が `PyComplexObject' 型で、かつ `PyComplexObject'
     型のサブタイプでないときに真を返します。 _Added in Python version
     2.2_

`PyObject* PyComplex_FromCComplex(Py_complex v)'
     C の `Py_complex' 型から Python の複素数値を生成します。

`PyObject* PyComplex_FromDoubles(double real, double imag)'
     新たな `PyComplexObject' オブジェクトを REAL と IMAG
     から生成します。

`double PyComplex_RealAsDouble(PyObject *op)'
     OP の実数部分を C の `double' 型で返します。

`double PyComplex_ImagAsDouble(PyObject *op)'
     OP の虚数部分を C の `double' 型で返します。

`Py_complex PyComplex_AsCComplex(PyObject *op)'
     複素数値 OP から `Py_complex' 型を生成します。


File: python-api-jp.info,  Node: シーケンスオブジェクト sequence object,  Next: マップ型オブジェクト mapping object,  Prev: 数値型オブジェクト numeric object,  Up: 具象オブジェクト concrete object レイヤ

7.3 シーケンスオブジェクト (sequence object)
============================================

シーケンスオブジェクトに対する一般的な操作については前の章ですでに
述べました; この節では、Python 言語にもともと備わっている
特定のシーケンスオブジェクトについて扱います。

* Menu:

* 文字列オブジェクト string object::
* Unicode オブジェクト Unicode object::
* Buffer Objects::
* タプルオブジェクト tuple object::
* List Objects::


File: python-api-jp.info,  Node: 文字列オブジェクト string object,  Next: Unicode オブジェクト Unicode object,  Prev: シーケンスオブジェクト sequence object,  Up: シーケンスオブジェクト sequence object

7.3.1 文字列オブジェクト (string object)
----------------------------------------

以下の関数では、文字列が渡されるはずのパラメタに非文字列が渡された
場合に `TypeError' を送出します。

`PyStringObject'
     この `PyObject' のサブタイプは Python の文字列オブジェクトを
     表現します。

`PyTypeObject PyString_Type'
     この `PyTypeObject' のインスタンスは Python の文字列型を
     表現します; このオブジェクトは Python レイヤにおける
     `str'や`types.TypeType' と同じです。 .

`int PyString_Check(PyObject *o)'
     O が文字列型か文字列型のサブタイプであるときに真を返します。
     _Changed in Python version 2.2_

`int PyString_CheckExact(PyObject *o)'
     O が文字列型で、かつ文字列型のサブタイプでないときに真を返します。
     _Added in Python version 2.2_

`PyObject* PyString_FromString(const char *v)'
     V を値に持つ文字列オブジェクトを返します。失敗すると `NULL'
     を返します。パラメタ V は `NULL' であってはなりません;
     `NULL'かどうかはチェックしません。

`PyObject* PyString_FromStringAndSize(const char *v, Py_ssize_t len)'
     値が V で長さが LEN の新たな文字列オブジェクト
     を返します。失敗すると `NULL' を返します。V が `NULL'
     の場合、文字列の中身は未初期化の状態になります。

`PyObject* PyString_FromFormat(const char *format, ...)'
     C 関数 `printf()' 形式の FORMAT 文字列と可変個の
     引数をとり、書式化済みの文字列長を計算した上で、書式化を行った結果を
     値とする Python 文字列にして返します。可変個の引数部は C の
     データ型でなくてはならず、かつ FORMAT 文字列内の書式指定文字
     (format character) に一致する型でなくてはなりません。利用できる
     書式化文字は以下の通りです:

     書式指定文字           型                     コメント
     ------                 -----                  -----
     %%                     _n/a_                  文字 % のリテラル。
     %c                     int                    C
                                                   の整数型で表現される単一の文字。
     %d                     int                    C の`printf("%d")'
                                                   と全く同じ。
     %u                     unsigned int           C の`printf("%u")'
                                                   と全く同じ。
     %ld                    long                   C の`printf("%ld")'
                                                   と全く同じ。
     %lu                    unsigned long          C の`printf("%lu")'
                                                   と全く同じ。
     %zd                    Py_ssize_t             C の`printf("%zd")'
                                                   と全く同じ。
     %zu                    size_t                 C の`printf("%zu")'
                                                   と全く同じ。
     %i                     int                    C の`printf("%i")'
                                                   と全く同じ。
     %x                     int                    C の`printf("%x")'
                                                   と全く同じ。
     %s                     char*                  null で終端された C
                                                   の文字列。
     %p                     void*                  C ポインタの 16
                                                   進表記。`printf("%p")'
                                                   とほとんど同じだが、プラットフォームにおける
                                                   `printf' の定義に
                                                   関わりなく先頭にリテラル
                                                   `0x' が付きます。

     識別できない書式指定文字があった場合、残りの書式文字列はそのまま出力文字列に
     コピーされ、残りの引数は無視されます。

`PyObject* PyString_FromFormatV(const char *format, va_list vargs)'
     `PyString_FromFormat()' と同じです。ただし、こちらの関数は
     二つしか引数をとりません。

`Py_ssize_t PyString_Size(PyObject *string)'
     文字列オブジェクト STRING 内の文字列値の長さを返します。

`Py_ssize_t PyString_GET_SIZE(PyObject *string)'
     `PyString_Size()' をマクロで実装したもので、
     エラーチェックを行いません。

`char* PyString_AsString(PyObject *string)'
     STRING の中身を NUL 文字終端された表現で返します。
     ポインタはSTRING オブジェクトの内部バッファを指し、
     バッファのコピーを指すわけではありません。
     `PyString_FromStringAndSize(NULL, SIZE)' を使って
     生成した文字列でない限り、バッファ内のデータはいかなる変更も
     してはなりません。この文字列をデアロケートしてはなりません。
     STRING が Unicode オブジェクトの場合、この関数は STRING
     のデフォルトエンコーディング版を計算し、
     デフォルトエンコーディング版に対して操作を行います。 STRING
     が文字列オブジェクトですらない場合、 `PyString_AsString()' は
     `NULL' を返して `TypeError' を送出します。

`char* PyString_AS_STRING(PyObject *string)'
     `PyString_AsString()' をマクロで実装したもので、
     エラーチェックを行いません。文字列オブジェクトだけをサポート
     します; Unicode オブジェクトを渡してはなりません。

`int PyString_AsStringAndSize(PyObject *obj, char **buffer, Py_ssize_t *length)'
     OBJ の中身を NUL 文字終端された表現にして、出力用の変数 BUFFER と
     LENGTH を使って返します。

     この関数は文字列オブジェクトと Unicode オブジェクトのどちらも
     入力として受理します。 Unicode オブジェクトの場合、オブジェクトを
     デフォルトエンコーディングでエンコードしたバージョン (default
     encoded version) を返します。LENGTH が `NULL' の
     場合、値を返させるバッファには NUL 文字を入れてはなりません; NUL
     文字が入っている場合、関数は `-1' を返し、 `TypeError'
     を送出します。

     BUFFER は OBJ の内部文字列バッファを参照し、
     バッファのコピーを参照するわけではありません。
     `PyString_FromStringAndSize(NULL, SIZE)' を使って
     生成した文字列でない限り、バッファ内のデータはいかなる変更も
     してはなりません。この文字列をデアロケートしてはなりません。

     STRING が Unicode オブジェクトの場合、この関数は STRING
     のデフォルトエンコーディング版を計算し、
     デフォルトエンコーディング版に対して操作を行います。 STRING
     が文字列オブジェクトですらない場合、 `PyString_AsStringAndSize()'
     は `-1' を返して `TypeError' を送出します。

`void PyString_Concat(PyObject **string, PyObject *newpart)'
     新しい文字列オブジェクトを *STRING に作成し、 NEWPART の内容を
     STRING に追加します; 呼び出し側は新たな参照を所有
     することになります。STRING の以前の値に対する参照は盗み取られ
     ます。新たな文字列を生成できなければ、STRING に対する古い参照は
     無視され、 *STRING の値は `NULL' に設定されます; その際、
     適切な例外情報が設定されます。

`void PyString_ConcatAndDel(PyObject **string, PyObject *newpart)'
     新しい文字列オブジェクトを *STRING に作成し、 NEWPART の内容を
     STRING に追加します。こちらのバージョンの関数は NEWPART
     への参照をデクリメントします。

`int _PyString_Resize(PyObject **string, Py_ssize_t newsize)'
     "変更不能" である文字列オブジェクトをサイズ変更する手段です。
     新たな文字列オブジェクトを作成するときにのみ使用してください;
     文字列がすでにコードの他の部分で使われているかもしれない場合には、
     この関数を使ってはなりません。入力する文字列オブジェクトの参照カウント
     が 1 でない場合、この関数を呼び出すとエラーになります。
     左側値には、既存の文字列オブジェクトのアドレスを渡し
     (このアドレスには
     書き込み操作が起きるかもしれません)、新たなサイズを指定します。
     成功した場合、 *STRING はサイズ変更された文字列オブジェクトを
     保持し、`0' が返されます; *STRING の値は、入力したときの
     値と異なっているかもしれません。文字列の再アロケーションに失敗した場合、
     *STRING に入っていた元の文字列オブジェクトを解放し、 *STRING を
     `NULL' にセットし、メモリ例外をセットし、 `-1' を返します。

`PyObject* PyString_Format(PyObject *format, PyObject *args)'
     新たな文字列オブジェクトを  FORMAT と ARGS から生成します。
     `FORMAT % ARGS' と似た働きです。引数 ARGS
     はタプルでなければなりません。

`void PyString_InternInPlace(PyObject **string)'
     引数 *STRING をインプレースで隔離 (intern) します。 引数は Python
     文字列オブジェクトを指すポインタへのアドレスで
     なくてはなりません。*STRING と等しい、すでに隔離済みの
     文字列が存在する場合、そのオブジェクトを *STRING に 設定します
     (かつ、元の文字列オブジェクトの参照カウントをデクリメントし、
     すでに隔離済みの文字列オブジェクトの参照カウントをインクリメントします)。
     (補足: 参照カウントについては沢山説明して来ましtが、この関数は
     参照カウント中立 (reference-count-neutral) と考えてください;
     この関数では、関数の呼び出し後にオブジェクトに対して参照の所有権を
     持てるのは、関数を呼び出す前にすでに所有権を持っていた場合に限ります。)

`PyObject* PyString_InternFromString(const char *v)'
     `PyString_FromString()' と `PyString_InternInPlace()'
     を組み合わせたもので、
     隔離済みの新たな文字列オブジェクトを返すか、同じ値を持つすでに
     隔離済みの文字列オブジェクトに対する新たな ("所有権を得た") 参照
     を返します。

`PyObject* PyString_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)'
     SIZE からなるエンコード済みのバッファ S を ENCODING
     の名前で登録されている codec に
     渡してデコードし、オブジェクトを生成します。 ENCODING および
     ERRORS は 組み込み関数 `unicode()' に与える同名のパラメタと
     同じ意味を持ちます。使用する codec の検索は、 Python の codec
     レジストリを使って行います。codec が例外を送出した場合には `NULL'
     を返します。

`PyObject* PyString_AsDecodedObject(PyObject *str, const char *encoding, const char *errors)'
     文字列オブジェクトをENCODING の名前で登録されている codec に
     渡してデコードし、Python オブジェクトを返します。 ENCODING および
     ERRORS は 文字列型の `encode()' メソッドに与える同名のパラメタと
     同じ意味を持ちます。使用する codec の検索は、 Python の codec
     レジストリを使って行います。codec が例外を送出した場合には `NULL'
     を返します。

`PyObject* PyString_Encode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)'
     SIZE で指定されたサイズの `char' バッファを ENCODING
     の名前で登録されている codec に渡してエンコードし、 Python
     オブジェクトを返します。ENCODING および ERRORS は 文字列型の
     `encode()' メソッドに与える同名のパラメタと
     同じ意味を持ちます。使用する codec の検索は、 Python の codec
     レジストリを使って行います。codec が例外を送出した場合には `NULL'
     を返します。

`PyObject* PyString_AsEncodedObject(PyObject *str, const char *encoding, const char *errors)'
     エンコード名 ENCODING で登録された codec を使って
     文字列オブジェクトをエンコードし、その結果を Python オブジェクト
     として返します。ENCODING および ERRORS は 文字列型の `encode()'
     メソッドに与える同名のパラメタと 同じ意味を持ちます。使用する
     codec の検索は、 Python の codec レジストリを使って行います。codec
     が例外を送出した場合には `NULL' を返します。


File: python-api-jp.info,  Node: Unicode オブジェクト Unicode object,  Next: Buffer Objects,  Prev: 文字列オブジェクト string object,  Up: シーケンスオブジェクト sequence object

7.3.2 Unicode オブジェクト (Unicode object)
-------------------------------------------

以下は Python の Unicode 実装に用いられている基本 Unicode
オブジェクト型です:

`Py_UNICODE'
     この型はUnicode序数(Unicode
     ordinal)を保持するための基礎単位として、 Pythonが内部的に使います。
     Pythonのデフォルトのビルドでは、`Py_UNICODE'として16-bit型を利用し、
     Unicodeの値を内部ではUCS-2で保持します。
     UCS4版のPythonをビルドすることもできます。(最近の多くのLinuxディストリビューションでは
     UCS4版のPythonがついてきます)
     UCS4版ビルドでは`Py_UNICODE'に32-bit型を利用し、内部ではUnicode
     データをUCS4で保持します。
     `wchar_t'が利用できて、PythonのUnicodeに関するビルドオプションと
     一致するときは、`Py_UNICODE'は`wchar_t'をtypedefでエイリアス
     され、ネイティブプラットフォームに対する互換性を高めます。
     それ以外のすべてのプラットフォームでは、`Py_UNICODE'は `unsigned
     short' (UCS2) か `unsigned long' (UCS4) の
     typedefによるエイリアスになります。

UCS2とUCS4のPythonビルドの間にはバイナリ互換性がないことに注意してください。
拡張やインタフェースを書くときには、このことを覚えておいてください。

`PyUnicodeObject'
     この `PyObject' のサブタイプは Unicode オブジェクトを表現します。

`PyTypeObject PyUnicode_Type'
     この `PyTypeObject' のインスタンスは Python の Unicode 型を
     表現します。
     Pythonレイヤにおける`unicode'や`types.UnicodeType'と同じ
     オブジェクトです。

以下の API は実際には C マクロで、Unicode オブジェクト内部の
読み出し専用データに対するチェックやアクセスを高速に行います:

`int PyUnicode_Check(PyObject *o)'
     O が Unicode 文字列型か Unicode 文字列型のサブタイプで
     あるときに真を返します。 _Changed in Python version 2.2_

`int PyUnicode_CheckExact(PyObject *o)'
     O が Unicode 文字列型で、かつ Unicode 文字列型のサブタイプで
     ないときに真を返します。 _Added in Python version 2.2_

`Py_ssize_t PyUnicode_GET_SIZE(PyObject *o)'
     オブジェクトのサイズを返します。 O は `PyUnicodeObject'
     でなければなりません (チェックはしません)。

`Py_ssize_t PyUnicode_GET_DATA_SIZE(PyObject *o)'
     オブジェクトの内部バッファのサイズをバイト数で返します。 O は
     `PyUnicodeObject' でなければなりません (チェックはしません)。

`Py_UNICODE* PyUnicode_AS_UNICODE(PyObject *o)'
     オブジェクト内部の`Py_UNICODE' バッファへのポインタを返します。 O
     は `PyUnicodeObject' でなければなりません (チェックは しません)。

`const char* PyUnicode_AS_DATA(PyObject *o)'
     オブジェクト内部バッファへのポインタを返します。 O は
     `PyUnicodeObject' でなければなりません (チェックはしません)。

Unicode は数多くの異なる文字プロパティ (character property)
を提供しています。よく使われる文字プロパティは、以下のマクロ
で利用できます。これらのマクロは Python の設定に応じて、 各々 C
の関数に対応付けられています。

`int Py_UNICODE_ISSPACE(Py_UNICODE ch)'
     CH が空白文字かどうかに応じて 1 または 0 を返します。

`int Py_UNICODE_ISLOWER(Py_UNICODE ch)'
     CH が小文字かどうかに応じて 1 または 0 を返します。

`int Py_UNICODE_ISUPPER(Py_UNICODE ch)'
     CH が大文字かどうかに応じて 1 または 0 を返します。

`int Py_UNICODE_ISTITLE(Py_UNICODE ch)'
     CH がタイトルケース文字 (titlecase character) かどうかに 応じて 1
     または 0 を返します。

`int Py_UNICODE_ISLINEBREAK(Py_UNICODE ch)'
     CH が改行文字かどうかに応じて 1 または 0 を返します。

`int Py_UNICODE_ISDECIMAL(Py_UNICODE ch)'
     CH が 10 進の数字文字かどうかに応じて 1 または 0 を返します。

`int Py_UNICODE_ISDIGIT(Py_UNICODE ch)'
     CH が 2 進の数字文字かどうかに応じて 1 または 0 を返します。

`int Py_UNICODE_ISNUMERIC(Py_UNICODE ch)'
     CH が数字文字かどうかに応じて 1 または 0 を返します。

`int Py_UNICODE_ISALPHA(Py_UNICODE ch)'
     CH がアルファベット文字かどうかに応じて 1 または 0 を返します。

`int Py_UNICODE_ISALNUM(Py_UNICODE ch)'
     CH が英数文字かどうかに応じて 1 または 0 を返します。

以下の API は、高速に直接文字変換を行うために使われます:

`Py_UNICODE Py_UNICODE_TOLOWER(Py_UNICODE ch)'
     CH を小文字に変換したものを返します。

`Py_UNICODE Py_UNICODE_TOUPPER(Py_UNICODE ch)'
     CH を大文字に変換したものを返します。

`Py_UNICODE Py_UNICODE_TOTITLE(Py_UNICODE ch)'
     CH をタイトルケース文字に変換したものを返します。

`int Py_UNICODE_TODECIMAL(Py_UNICODE ch)'
     CH を 10 進の正の整数に変換したものを返します。 不可能ならば `-1'
     を返します。このマクロは例外を送出しません。

`int Py_UNICODE_TODIGIT(Py_UNICODE ch)'
     CH を一桁の 2 進整数に変換したものを返します。 不可能ならば `-1'
     を返します。このマクロは例外を送出しません。

`double Py_UNICODE_TONUMERIC(Py_UNICODE ch)'
     CH を `double' に変換したものを返します。 不可能ならば `-1.0'
     を返します。このマクロは例外を送出しません。

Unicode オブジェクトを生成したり、Unicode のシーケンスとしての基本的な
プロパティにアクセスしたりするには、以下の API を使ってください:

`PyObject* PyUnicode_FromUnicode(const Py_UNICODE *u, Py_ssize_t size)'
     SIZE で指定された長さを持つ Py_UNICODE 型バッファ U から Unicode
     オブジェクトを生成します。U を `NULL' にしても
     よく、その場合オブジェクトの内容は未定義です。バッファに必要な情報を
     埋めるのはユーザの責任です。バッファの内容は新たなオブジェクトに
     コピーされます。バッファが `NULL' でない場合、戻り値は共有された
     オブジェクトになることがあります。従って、この関数が返す Unicode
     オブジェクトを変更してよいのは U が `NULL' のときだけです。

`Py_UNICODE* PyUnicode_AsUnicode(PyObject *unicode)'
     Unicode オブジェクトの内部バッファ `Py_UNICODE' に対する読み出し
     専用のポインタを返します。UNICODE が Unicode オブジェクトで
     なければ `NULL' を返します。

`Py_ssize_t PyUnicode_GetSize(PyObject *unicode)'
     Unicode オブジェクトの長さを返します。

`PyObject* PyUnicode_FromEncodedObject(PyObject *obj, const char *encoding, const char *errors)'
     あるエンコード方式でエンコードされたオブジェクト OBJ を Unicode
     オブジェクトに型強制して、参照カウントをインクリメントして
     返します。

     型強制は以下のようにして行われます:

     文字列やその他の char バッファ互換オブジェクトの場合、オブジェクト
     は ENCODING に従ってデコードされます。このとき ERROR で
     定義されたエラー処理を用います。これら二つの引数は `NULL' にでき、
     その場合デフォルト値が使われます (詳細は次の節を参照してください)

     その他のUnicodeオブジェクトを含むオブジェクトは `TypeError'
     例外を引き起こします。

     この API は、エラーが生じたときには `NULL' を返します。
     呼び出し側は返されたオブジェクトを decref する責任があります。

`PyObject* PyUnicode_FromObject(PyObject *obj)'
     `PyUnicode_FromEncodedObject(obj, NULL, "strict")'
     を行うショートカットで、インタプリタは Unicode への型強制が必要な
     際に常にこの関数を使います。

プラットフォームで `wchar_t' がサポートされていて、かつ wchar.h
が提供されている場合、Python は以下の関数を使って `wchar_t'
に対するインタフェースを確立することがあります。 このサポートは、Python
自体の `Py_UNICODE' 型がシステムの `wchar_t'
と同一の場合に最適化をもたらします。

`PyObject* PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)'
     SIZE の `wchar_t' バッファ W から Unicode オブジェクト
     を生成します。失敗すると `NULL' を返します。

`Py_ssize_t PyUnicode_AsWideChar(PyUnicodeObject *unicode, wchar_t *w, Py_ssize_t size)'
     Unicode オブジェクトの内容を `wchar_t' バッファ W
     にコピーします。最大で SIZE 個の `wchar_t' 文字を (末尾の
     0-終端文字を除いて) コピーします。コピーした `wchar_t'
     文字の個数を返します。エラーの時には -1 を返します。 `wchar_t'
     文字列は 0-終端されている場合も、されていない場合も
     あります。関数の呼び出し手の責任で、アプリケーションの必要に応じて
     `wchar_t' 文字列を 0-終端してください。

* Menu:

* 組み込み codec built-in codec::
* メソッドおよびスロット関数 slot function::


File: python-api-jp.info,  Node: 組み込み codec built-in codec,  Next: メソッドおよびスロット関数 slot function,  Prev: Unicode オブジェクト Unicode object,  Up: Unicode オブジェクト Unicode object

7.3.2.1 組み込み codec (built-in codec)
.......................................

Python では、処理速度を高めるために C で書かれた一そろいの codec
を提供しています。これらの codec は全て以下の関数を介して
直接利用できます。

以下の API の多くが、 ENCODING と ERRORS という二つの
引数をとります。これらのパラメタは、組み込みの Unicode オブジェクト
コンストラクタである `unicode()' における同名のパラメタと同じ
セマンティクスになっています。

ENCODING を `NULL' にすると、デフォルトエンコーディング である
ASCIIを使います。ファイルシステムに関する関数の呼び出し
では、ファイル名に対するエンコーディングとして
`Py_FileSystemDefaultEncoding' を使わねばなりません。
この変数は読み出し専用の変数として扱わねばなりません:
この変数は、あるシステムによっては静的な文字列に対するポインタで
あったり、また別のシステムでは、(アプリケーションが setlocale
を読んだときなどに) 変わったりもします。

ERRORS で指定するエラー処理もまた、 `NULL' を指定できます。 `NULL'
を指定すると、codec で定義されているデフォルト処理の使用を
意味します。全ての組み込み codec で、デフォルトのエラー処理は "strict"
(`ValueError' を送出する) になっています。

個々の codec は全て同様のインタフェースを使っています。個別の codec
の説明では、説明を簡単にするために以下の汎用のインタフェースとの
違いだけを説明しています。

以下は汎用 codec の API です:

`PyObject* PyUnicode_Decode(const char *s, Py_ssize_t size, const char *encoding, const char *errors)'
     何らかのエンコード方式でエンコードされた、 SIZE バイトの 文字列 S
     をデコードして Unicode オブジェクトを生成します。 ENCODING と
     ERRORS は、組み込み関数 unicode() の同名の
     パラメタと同じ意味を持ちます。使用する codec の検索は、 Python の
     codec レジストリを使って行います。codec が例外を送出した場合には
     `NULL' を返します。

`PyObject* PyUnicode_Encode(const Py_UNICODE *s, Py_ssize_t size, const char *encoding, const char *errors)'
     SIZE で指定されたサイズの `Py_UNICODE' バッファを エンコードした
     Python 文字列オブジェクトを返します。 ENCODING および ERRORS は
     Unicode 型の `encode()' メソッドに与える同名のパラメタと
     同じ意味を持ちます。使用する codec の検索は、 Python の codec
     レジストリを使って行います。codec が例外を送出した場合には `NULL'
     を返します。

`PyObject* PyUnicode_AsEncodedString(PyObject *unicode, const char *encoding, const char *errors)'
     Unicode オブジェクトをエンコードし、その結果を Python 文字列
     オブジェクトとして返します。ENCODING および ERRORS は Unicode 型の
     `encode()' メソッドに与える同名のパラメタと
     同じ意味を持ちます。使用する codec の検索は、 Python の codec
     レジストリを使って行います。codec が例外を送出した場合には `NULL'
     を返します。

以下は UTF-8 codec の APIです:

`PyObject* PyUnicode_DecodeUTF8(const char *s, Py_ssize_t size, const char *errors)'
     UTF-8 でエンコードされた SIZE バイトの文字列 S から Unicode
     オブジェクトを生成します。codec が例外を送出した場合には `NULL'
     を返します。

`PyObject* PyUnicode_DecodeUTF8Stateful(const char *s, Py_ssize_t size, const char *errors, Py_ssize_t *consumed)'
     CONSUMED が `NULL' の場合、`PyUnicode_DecodeUTF8()'
     と同じように動作します。 CONSUMED が `NULL' でない場合、
     `PyUnicode_DecodeUTF8Stateful()' は末尾の不完全な UTF-8 バイト列
     をエラーとみなしません。これらのバイト列はデコードされず、デコードされた
     バイト数を CONSUMED に返します。 _Added in Python version 2.4_

`PyObject* PyUnicode_EncodeUTF8(const Py_UNICODE *s, Py_ssize_t size, const char *errors)'
     SIZE で指定された長さを持つ `Py_UNICODE' 型バッファを UTF-8
     でエンコードし、 Python 文字列オブジェクトにして返します。 codec
     が例外を送出した場合には `NULL' を返します。

`PyObject* PyUnicode_AsUTF8String(PyObject *unicode)'
     UTF-8 で Unicode オブジェクトをエンコードし、結果を Python 文字列
     オブジェクトとして返します。エラー処理は "strict" です。 codec
     が例外を送出した場合には`NULL' を返します。

以下は UTF-16 codec の APIです:

`PyObject* PyUnicode_DecodeUTF16(const char *s, Py_ssize_t size, const char *errors, int *byteorder)'
     UTF-16 でエンコードされたバッファ S から SIZE バイト
     デコードして、結果を Unicode オブジェクトで返します。 ERRORS は
     (`NULL' でない場合) エラー処理方法を定義します。 デフォルト値は
     "strict" です。

     BYTEORDER が `NULL' でない場合、デコード機構は以下の
     ように指定されたバイト整列 (byte order) に従ってデコードを開始
     します:

             *byteorder == -1: リトルエンディアン
             *byteorder == 0:  ネイティブ
             *byteorder == 1:  ビッグエンディアン

     その後、入力データ中に見つかった全てのバイト整列マーカ (byte order
     mark, BOM) に従って、バイト整列を切り替えます。 BOM
     はデコード結果の Unicode 文字列中にはコピーされません。
     デコードを完結した後、*BYTEORDER は入力データの終点現在に
     おけるバイト整列に設定されます。

     BYTEORDER が `NULL' の場合、 codec はネイティブバイト整列の
     モードで開始します。

     codec が例外を送出した場合には`NULL' を返します。

`PyObject* PyUnicode_DecodeUTF16Stateful(const char *s, Py_ssize_t size, const char *errors, int *byteorder, Py_ssize_t *consumed)'
     CONSUMED が `NULL' の場合、`PyUnicode_DecodeUTF16()'
     と同じように動作します。 CONSUMED が `NULL' でない場合、
     `PyUnicode_DecodeUTF16Stateful()' は末尾の不完全な UTF-16 バイト列
     (奇数長のバイト列や分割されたサロゲートペア)
     をエラーとみなしません。
     これらのバイト列はデコードされず、デコードされたバイト数を CONSUMED
     に返します。 _Added in Python version 2.4_

`PyObject* PyUnicode_EncodeUTF16(const Py_UNICODE *s, Py_ssize_t size, const char *errors, int byteorder)'
     S 中の Unicode データを UTF-16 でエンコードした結果が入っている
     Python 文字列オブジェクトを返します。 BYTEORDER が `0'
     でない場合、出力は以下のバイト整列 指定に従って書き出されます:

             byteorder == -1: リトルエンディアン
             byteorder == 0:  ネイティブ (BOM マーカを書き出します)
             byteorder == 1:  ビッグエンディアン

     バイトオーダが `0' の場合、出力結果となる文字列は常に Unicode BOM
     マーカ (U+FEFF) で始まります。それ以外のモードでは、 BOM
     マーカを頭につけません。

     PY_UNICODE_WIDE が定義されている場合、単一の`Py_UNICODE'
     値はサロゲートペアとして表現されることがあります。 PY_UNICODE_WIDE
     が定義されていなければ、各`Py_UNICODE' 値 は UCS-2
     文字として表現されます。

     codec が例外を送出した場合には`NULL' を返します。

`PyObject* PyUnicode_AsUTF16String(PyObject *unicode)'
     ネイティブバイトオーダの UTF-16 でエンコードされた Python
     文字列を返します。 文字列は常に BOM
     マーカから始まります。エラー処理は "strict" です。 codec
     が例外を送出した場合には`NULL' を返します。

以下は "Unicode Escape" codec の APIです:

`PyObject* PyUnicode_DecodeUnicodeEscape(const char *s, Py_ssize_t size, const char *errors)'
     Unicode-Escape でエンコードされた SIZE バイトの文字列 S から
     Unicode オブジェクトを生成します。codec が例外を送出した場合には
     `NULL' を返します。

`PyObject* PyUnicode_EncodeUnicodeEscape(const Py_UNICODE *s, Py_ssize_t size)'
     SIZE で指定された長さを持つ `Py_UNICODE' 型バッファを
     Unicode-Escape でエンコードし、 Python
     文字列オブジェクトにして返します。 codec が例外を送出した場合には
     `NULL' を返します。

`PyObject* PyUnicode_AsUnicodeEscapeString(PyObject *unicode)'
     Unicode-Escape で Unicode オブジェクトをエンコードし、結果を
     Python 文字列オブジェクトとして返します。エラー処理は "strict"
     です。 codec が例外を送出した場合には`NULL' を返します。

以下は "Raw Unicode Escape" codec の APIです:

`PyObject* PyUnicode_DecodeRawUnicodeEscape(const char *s, Py_ssize_t size, const char *errors)'
     Raw-Unicode-Escape でエンコードされた SIZE バイトの文字列 S から
     Unicode オブジェクトを生成します。codec が例外を送出した場合には
     `NULL' を返します。

`PyObject* PyUnicode_EncodeRawUnicodeEscape(const Py_UNICODE *s, Py_ssize_t size, const char *errors)'
     SIZE で指定された長さを持つ `Py_UNICODE' 型バッファを
     Raw-Unicode-Escape でエンコードし、 Python
     文字列オブジェクトにして返します。 codec が例外を送出した場合には
     `NULL' を返します。

`PyObject* PyUnicode_AsRawUnicodeEscapeString(PyObject *unicode)'
     Raw-Unicode-Escape で Unicode オブジェクトをエンコードし、結果を
     Python 文字列オブジェクトとして返します。エラー処理は "strict"
     です。 codec が例外を送出した場合には`NULL' を返します。

以下は Latin-1 codec の APIです: Latin-1 は、 Unicode 序数の最初の 256
個に対応し、 エンコード時にはこの 256 個だけを受理します。

`PyObject* PyUnicode_DecodeLatin1(const char *s, Py_ssize_t size, const char *errors)'
     Latin-1 でエンコードされた SIZE バイトの文字列 S から Unicode
     オブジェクトを生成します。codec が例外を送出した場合には `NULL'
     を返します。

`PyObject* PyUnicode_EncodeLatin1(const Py_UNICODE *s, Py_ssize_t size, const char *errors)'
     SIZE で指定された長さを持つ `Py_UNICODE' 型バッファを Latin-1
     でエンコードし、 Python 文字列オブジェクトにして返します。 codec
     が例外を送出した場合には `NULL' を返します。

`PyObject* PyUnicode_AsLatin1String(PyObject *unicode)'
     Latin-1 で Unicode オブジェクトをエンコードし、結果を Python 文字列
     オブジェクトとして返します。エラー処理は "strict" です。 codec
     が例外を送出した場合には`NULL' を返します。

以下は ASCII codec の APIです: 7 ビットの ASCII
データだけを受理します。その他のコードは エラーになります。

`PyObject* PyUnicode_DecodeASCII(const char *s, Py_ssize_t size, const char *errors)'
     ASCII でエンコードされた SIZE バイトの文字列 S から Unicode
     オブジェクトを生成します。codec が例外を送出した場合には `NULL'
     を返します。

`PyObject* PyUnicode_EncodeASCII(const Py_UNICODE *s, Py_ssize_t size, const char *errors)'
     SIZE で指定された長さを持つ `Py_UNICODE' 型バッファを ASCII
     でエンコードし、 Python 文字列オブジェクトにして返します。 codec
     が例外を送出した場合には `NULL' を返します。

`PyObject* PyUnicode_AsASCIIString(PyObject *unicode)'
     ASCII で Unicode オブジェクトをエンコードし、結果を Python 文字列
     オブジェクトとして返します。エラー処理は "strict" です。 codec
     が例外を送出した場合には`NULL' を返します。

以下は mapping codec の APIです:

この codec は、多くの様々な codec を実装する際に使われるという点で
特殊な codec です (実際、`encodings' パッケージに入っている 標準 codecs
のほとんどは、この codec を使っています)。 この codec
は、文字のエンコードやデコードにマップ型 (mapping) を使います。

デコード用のマップ型は、文字列型の字列一組みを、 Unicode 型の字列一組、
整数 (Unicode 序数として解釈されます) または `None' ("定義されていない
対応付け(undefined mapping)" を意味し、エラーを引き起こします) の
いずれかに対応付けなければなりません。

デコード用のマップ型は、Unicode 型の字列一組みを、 string 型の字列一組、
整数 (Latin-1 序数として解釈されます) または `None' ("定義されていない
対応付け(undefined mapping)" を意味し、エラーを引き起こします) の
いずれかに対応付けなければなりません。

マップ型オブジェクトは、 `__getitem__' マップ型インタフェース
をサポートしなければなりません。

ある文字の検索が LookupError によって失敗すると、その文字は
そのままコピーされます。すなわち、その文字の序数値がそれぞれ Unicode
または Latin-1 として解釈されます。このため、codec を
実現するマップ型に入れる必要がある対応付け関係は、ある文字を別の
コード点に対応付けるものだけです。

`PyObject* PyUnicode_DecodeCharmap(const char *s, Py_ssize_t size, PyObject *mapping, const char *errors)'
     エンコードされた SIZE バイトの文字列 S から MAPPING
     に指定されたオブジェクトを使って Unicode オブジェクトを
     生成します。codec が例外を送出した場合には`NULL' を返します。
     もし、MAPPINGが`NULL'だった場合、latin-1でデコーディングされます。
     それ以外の場合では、MAPPINGはbyteに対する辞書マップ (訳注:
     sに含まれる文字のunsignedな値をint型でキーとして、値として変換対象の
     Unicode文字を表すUnicode文字列になっているような辞書)
     か、ルックアップテーブルと して扱われるunicode文字列です。

     文字列(訳注:
     mappingがunicode文字列として渡された場合)の長さより大きい
     byte値や、(訳注: mappingにしたがって変換した結果が) U+FFFE
     "characters" になる Byte値は、"undefined mapping"
     として扱われます。 _Changed in Python version 2.4_

`PyObject* PyUnicode_EncodeCharmap(const Py_UNICODE *s, Py_ssize_t size, PyObject *mapping, const char *errors)'
     SIZE で指定された長さを持つ `Py_UNICODE' 型バッファを MAPPING
     に指定されたオブジェクトを使ってエンコードし、 Python
     文字列オブジェクトにして返します。 codec が例外を送出した場合には
     `NULL' を返します。

`PyObject* PyUnicode_AsCharmapString(PyObject *unicode, PyObject *mapping)'
     Unicode オブジェクトを MAPPING に指定されたオブジェクトを使って
     エンコードし、結果を Python 文字列オブジェクトとして返します。
     エラー処理は "strict" です。 codec が例外を送出した場合には`NULL'
     を返します。

以下の codec API は Unicode から Unicode への対応付けを行う
特殊なものです。

`PyObject* PyUnicode_TranslateCharmap(const Py_UNICODE *s, Py_ssize_t size, PyObject *table, const char *errors)'
     で 指定された長さを持つ `Py_UNICODE' バッファを、 文字変換マップ
     TABLE を適用して変換し、変換結果を Unicode
     オブジェクトで返します。codec が例外を発行した場合には `NULL'
     を返します。

     対応付けを行う TABLE は、 Unicode 序数を表す整数を Unicode
     序数を表す整数または `None' に対応付けます。 (`None'
     の場合にはその文字を削除します)

     対応付けテーブルが提供する必要があるメソッドは `__getitem__()'
     インタフェースだけです; 従って、辞書や
     シーケンス型を使ってもうまく動作します。対応付けを行っていない
     (`LookupError' を起こすような) 文字序数に対しては、
     変換は行わず、そのままコピーします。

以下は MBCS codec の API です。この codec は現在のところ、 Windows
上だけで利用でき、変換の実装には Win32 MBCS 変換機構 (Win32 MBCS
converter) を使っています。 MBCS (または DBCS) はエンコード方式の種類
(class) を表す言葉で、単一の
エンコード方式を表すわけでなないので注意してください。
利用されるエンコード方式 (target encoding) は、 codec を動作
させているマシン上のユーザ設定で定義されています。

`PyObject* PyUnicode_DecodeMBCS(const char *s, Py_ssize_t size, const char *errors)'
     MBCS でエンコードされた SIZE バイトの文字列 S から Unicode
     オブジェクトを生成します。codec が例外を送出した場合には `NULL'
     を返します。

`PyObject* PyUnicode_DecodeMBCSStateful(const char *s, int size, const char *errors, int *consumed)'
     CONSUMEDが`NULL'のとき、`PyUnicode_DecodeMBCS()'と同じ動作をします。
     CONSUMEDが`NULL'でないとき、`PyUnicode_DecodeMBCSStateful()'は
     文字列の最後にあるマルチバイト文字の前半バイトをデコードせず、
     CONSUMEDにデコードしたバイト数を格納します。 _Added in Python
     version 2.5_

`PyObject* PyUnicode_EncodeMBCS(const Py_UNICODE *s, Py_ssize_t size, const char *errors)'
     SIZE で指定された長さを持つ `Py_UNICODE' 型バッファを MBCS
     でエンコードし、 Python 文字列オブジェクトにして返します。 codec
     が例外を送出した場合には `NULL' を返します。

`PyObject* PyUnicode_AsMBCSString(PyObject *unicode)'
     MBCS で Unicode オブジェクトをエンコードし、結果を Python 文字列
     オブジェクトとして返します。エラー処理は "strict" です。 codec
     が例外を送出した場合には`NULL' を返します。


File: python-api-jp.info,  Node: メソッドおよびスロット関数 slot function,  Prev: 組み込み codec built-in codec,  Up: Unicode オブジェクト Unicode object

7.3.2.2 メソッドおよびスロット関数 (slot function)
..................................................

以下の API は Unicode オブジェクトおよび文字列を入力に取り
(説明では、どちらも文字列と表記しています)、場合に応じて Unicode
オブジェクトか整数を返す機能を持っています。

これらの関数は全て、例外が発生した場合には `NULL' または `-1'
を返します。

`PyObject* PyUnicode_Concat(PyObject *left, PyObject *right)'
     二つの文字列を結合して、新たな Unicode 文字列を生成します。

`PyObject* PyUnicode_Split(PyObject *s, PyObject *sep, Py_ssize_t maxsplit)'
     Unicode 文字列のリストを分割して、 Unicode 文字列からなるリスト
     を返します。 SEP が `NULL' の場合、全ての空白文字を使って
     分割を行います。それ以外の場合、指定された文字を使って分割を
     行います。最大で MAXSPLIT 個までの分割を行います。 MAXSPLIT
     が負ならば分割数に制限を設けません。
     分割結果のリスト内には分割文字は含みません。

`PyObject* PyUnicode_Splitlines(PyObject *s, int keepend)'
     Unicode 文字列を改行文字で区切り、Unicode 文字列からなるリスト
     を返します。CRLF は一個の改行文字とみなします。KEEPEND が 0
     の場合、分割結果のリスト内に改行文字を含めません。

`PyObject* PyUnicode_Translate(PyObject *str, PyObject *table, const char *errors)'
     文字列に文字変換マップ TABLE を適用して変換し、変換結果を Unicode
     オブジェクトで返します。

     対応付けを行う TABLE は、 Unicode 序数を表す整数を Unicode
     序数を表す整数または `None' に対応付けます。 (`None'
     の場合にはその文字を削除します)

     対応付けテーブルが提供する必要があるメソッドは `__getitem__()'
     インタフェースだけです; 従って、辞書や
     シーケンス型を使ってもうまく動作します。対応付けを行っていない
     (`LookupError' を起こすような) 文字序数に対しては、
     変換は行わず、そのままコピーします。

     ERRORS は codecs で通常使われるのと同じ意味を持ちます。 ERRORS は
     `NULL' にしてもよく、デフォルトエラー処理の 使用を意味します。

`PyObject* PyUnicode_Join(PyObject *separator, PyObject *seq)'
     指定した SEPARATOR で文字列からなるシーケンスを連結 (join) し、
     連結結果を Unicode 文字列で返します。

`int PyUnicode_Tailmatch(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)'
     SUBSTR が指定された末尾条件 (DIRECTION == -1 は 前方一致、
     DIRECTION ==1 は後方一致) で STR[START:END] とマッチする場合に 1
     を返し、 それ以外の場合には 0 を返します。 エラーが発生した時は
     `-1' を返します。

`Py_ssize_t PyUnicode_Find(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end, int direction)'
     STR[START:END] 中にSUBSTR が最初に
     出現する場所を返します。このとき指定された検索方向 DIRECTION
     (DIRECTION == 1 は順方向検索、 DIRECTION == -1 は 逆方向検索)
     で検索します。戻り値は最初にマッチが見つかった場所の
     インデクスです; 戻り値 `-1' はマッチが見つからなかったことを
     表し、`-2' はエラーが発生して例外情報が設定されていることを
     表します。

`Py_ssize_t PyUnicode_Count(PyObject *str, PyObject *substr, Py_ssize_t start, Py_ssize_t end)'
     `STR[START:END]' に SUBSTR
     が重複することなく出現する回数を返します。
     エラーが発生した場合には `-1' を返します。

`PyObject* PyUnicode_Replace(PyObject *str, PyObject *substr, PyObject *replstr, Py_ssize_t maxcount)'
     STR 中に出現する SUBSTR を最大で MAXCOUNT 個 REPLSTR
     に置換し、置換結果を Unicode オブジェクトにして 返します。
     MAXCOUNT == -1 にすると、全ての SUBSTR を置換します。

`int PyUnicode_Compare(PyObject *left, PyObject *right)'
     二つの文字列を比較して、左引数が右引数より小さい場合、
     左右引数が等価の場合、左引数が右引数より大きい場合、について、
     それぞれ -1, 0, 1 を返します。

`int PyUnicode_RichCompare(PyObject *left,  PyObject *right,  int op)'
     二つのunicode文字列を比較して、下のうちの一つを返します:
        * `NULL' を、例外が発生したときに返します。

        * `Py_True' もしくは `Py_False'
          を、正しく比較できた時に返します。

        * `Py_NotImplemented' を、leftとrightがのどちらかに対する
          `PyUnicode_FromObject()' が失敗したときに返します。(原文: in
          case the type combination is unknown)

     `Py_EQ' と `Py_NE' の比較は、引数からUnicodeへの変換が
     `UnicodeDecodeError' で失敗した時に、 `UnicodeWarning'
     を発生する可能性があることに注意してください。

     OP に入れられる値は、 `Py_GT', `Py_GE', `Py_EQ', `Py_NE', `Py_LT',
     and `Py_LE' のどれかです。

`PyObject* PyUnicode_Format(PyObject *format, PyObject *args)'
     新たな文字列オブジェクトを FORMAT および ARGS から
     生成して返します; このメソッドは `FORMAT % ARGS'
     のようなものです。引数 ARGS はタプルでなくてはなりません。

`int PyUnicode_Contains(PyObject *container, PyObject *element)'
     ELEMENT が CONTAINER 内にあるか調べ、その結果に応じて
     真または偽を返します。

     ELEMENT は単要素の Unicode 文字に型強制できなければ
     なりません。エラーが生じた場合には `-1' を返します。


File: python-api-jp.info,  Node: Buffer Objects,  Next: タプルオブジェクト tuple object,  Prev: Unicode オブジェクト Unicode object,  Up: シーケンスオブジェクト sequence object

7.3.3 Buffer Objects
--------------------

C で実装された Python オブジェクトは、"バッファインタフェース (buffer  interface)"
と呼ばれる一連の
関数を公開していることがあります。これらの関数は、あるオブジェクトの
データを生 (raw) のバイト列形式で公開するために使います。
このオブジェクトの使い手は、バッファインタフェースを使うことで、
オブジェクトをあらかじめコピーしておく必要なしに、オブジェクトの
データに直接アクセスできます。

バッファインタフェースをサポートするオブジェクトの例として、
文字列型とアレイ (array) 型の二つがあります。文字列オブジェクトは、
その内容をバッファインタフェースのバイト単位形式で公開して
います。アレイもその内容を公開していますが、注意する必要が
あるのはアレイの要素は複数バイトの値になりうる、ということです。

バッファインタフェースの使い手の一例として、ファイルオブジェクトの
`write()' メソッドがあります。バッファインタフェースを
介してバイト列を公開しているオブジェクトは全て、ファイルへの書き出し
ができます。オブジェクトのバッファインタフェースを操作し、
対象となるオブジェクトからデータを返させる `PyArg_ParseTuple()'
には数多くのデータ書式化コードが あります。

バッファインタフェースに関するより詳しい情報は、
"バッファオブジェクト構造体" 節 (~*Note バッファオブジェクト構造体
buffer object structure:: 節) の、 `PyBufferProcs'  の説明のところに
あります。

"バッファオブジェクト" はヘッダファイル `bufferobject.h'
の中で定義されています (このファイルは `Python.h' がインクルード
しています)。 バッファオブジェクトは、 Python プログラミングの
レベルからは文字列オブジェクトと非常によく似ているように見えます:
スライス、インデクス指定、結合、その他標準の文字列操作をサポート
しています。しかし、バッファオブジェクトのデータは二つのデータソース:
何らかのメモリブロックか、バッファインタフェースを公開している
別のオブジェクト、のいずれかに由来しています。

バッファオブジェクトは、他のオブジェクトのバッファインタフェースから
Python プログラマにデータを公開する方法として便利です。
バッファオブジェクトはゼロコピーなスライス機構 (zero-copy slicing
mechanism) としても使われます。ブロックメモリを参照するという
バッファオブジェクトの機能を使うことで、任意のデータをきわめて簡単に
Python プログラマに公開できます。メモリブロックは巨大でも
かまいませんし、C 拡張モジュール内の定数配列でもかまいません。
また、オペレーティングシステムライブラリ側に渡す前の、
操作用の生のブロックメモリでもかまいませんし、
構造化されたデータをネイティブのメモリ配置形式でやりとりするため
にも使えます。

`PyBufferObject'
     この `PyObject' のサブタイプはバッファオブジェクトを表現します。

`PyTypeObject PyBuffer_Type'
     Python バッファ型 (buffer type) を表現する`PyTypeObject' です;
     Python レイヤにおける `buffer' や `types.BufferType'
     と同じオブジェクトです。 

`int Py_END_OF_BUFFER'
     この定数は、`PyBuffer_FromObject()' または の
     `PyBuffer_FromReadWriteObject()' SIZE パラメタに 渡します。
     このパラメタを渡すと、`PyBufferObject' は指定された OFFSET
     からバッファの終わりまでを BASE オブジェクトとして参照します。
     このパラメタを使うことで、関数の呼び出し側が BASE オブジェクト
     のサイズを調べる必要がなくなります。

`int PyBuffer_Check(PyObject *p)'
     引数が`PyBuffer_Type' 型のときに真を返します。

`PyObject* PyBuffer_FromObject(PyObject *base, Py_ssize_t offset, Py_ssize_t size)'
     新たな読み出し専用バッファオブジェクトを返します。BASE が
     読み出し専用バッファに必要なバッファプロトコルをサポートしていない
     場合や、厳密に一つのバッファセグメントを提供していない場合には
     `TypeError' を送出し、OFFSET がゼロ以下の場合には `ValueError'
     を送出します。 バッファオブジェクトはは BASE
     オブジェクトに対する参照を保持し、 バッファオブジェクトのの内容は
     BASE オブジェクトの OFFSET から SIZE
     バイトのバッファインタフェースへの参照になります。 SIZE が
     `Py_END_OF_BUFFER' の場合、新たに作成する
     バッファオブジェクトの内容は BASE から公開されているバッファの
     末尾までにわたります。

`PyObject* PyBuffer_FromReadWriteObject(PyObject *base, Py_ssize_t offset, Py_ssize_t size)'
     新たな書き込み可能バッファオブジェクトを返します。パラメタおよび例外
     は `PyBuffer_FromObject' と同じです。BASE オブジェクト
     が書き込み可能バッファに必要なバッファプロトコルを公開していない
     場合、`TypeError' を送出します。

`PyObject* PyBuffer_FromMemory(void *ptr, Py_ssize_t size)'
     メモリ上の指定された場所から指定されたサイズのデータを読み出せる、
     新たな読み出し専用バッファオブジェクトを返します。
     この関数が返すバッファオブジェクトが存続する間、PTR で与え
     られたメモリバッファがデアロケートされないようにするのは呼び出し側の
     責任です。SIZE がゼロ以下の場合には`ValueError' を
     送出します。SIZE には `Py_END_OF_BUFFER' を指定しては
     _なりません_; 指定すると、`ValueError' を送出します。

`PyObject* PyBuffer_FromReadWriteMemory(void *ptr, Py_ssize_t size)'
     `PyBuffer_FromMemory()' に似ていますが、書き込み可能な
     バッファを返します。

`PyObject* PyBuffer_New(Py_ssize_t size)'
     SIZE バイトのメモリバッファを独自に維持する新たな書き込み可能
     バッファオブジェクトを返します。 SIZE
     がゼロまたは正の値でない場合、`ValueError' を
     送出します。(`PyObject_AsWriteBuffer()' が返すような)
     メモリバッファは特に整列されていないので注意して下さい。


File: python-api-jp.info,  Node: タプルオブジェクト tuple object,  Next: List Objects,  Prev: Buffer Objects,  Up: シーケンスオブジェクト sequence object

7.3.4 タプルオブジェクト (tuple object)
---------------------------------------

`PyTupleObject'
     この `PyObject' のサブタイプは Python のタプルオブジェクトを
     表現します。

`PyTypeObject PyTuple_Type'
     この `PyTypeObject' のインスタンスは Python のタプル型を
     表現します; Python レイヤにおける `tuple' や `types.TupleType'
     と同じオブジェクトです。 

`int PyTuple_Check(PyObject *p)'
     P がタプルオブジェクトか、タプル型のサブタイプのインスタンス
     である場合に真を返します。 _Changed in Python version 2.2_

`int PyTuple_CheckExact(PyObject *p)'
     P がタプルオブジェクトで、かつタプル型のサブタイプのインスタンス
     でない場合に真を返します。 _Added in Python version 2.2_

`PyObject* PyTuple_New(Py_ssize_t len)'
     サイズが LEN 新たなタプルオブジェクトを返します。 失敗すると
     `NULL' を返します。

`PyObject* PyTuple_Pack(Py_ssize_t n, ...)'
     サイズ N 新たなタプルオブジェクトを返します。失敗すると`NULL'
     を返します。タプルの値は後続の N 個の Python オブジェクトを指す C
     引数になります。`PyTuple_Pack(2, A, B)' は `Py_BuildValue("(OO)",
     A, B)' と同じです。 _Added in Python version 2.4_

`int PyTuple_Size(PyObject *p)'
     タプルオブジェクトへのポインタを引数にとり、そのタプルのサイズを
     返します。

`int PyTuple_GET_SIZE(PyObject *p)'
     タプル P のサイズを返しますが、P は非 `NULL' でなくては
     ならず、タプルオブジェクトを指していなければなりません;
     エラーチェックを行いません。

`PyObject* PyTuple_GetItem(PyObject *p, Py_ssize_t pos)'
     P の指すタプルオブジェクト内の、位置 POS にあるオブジェクト
     を返します。 POS が範囲を超えている場合、 `NULL' を返して
     `IndexError' 例外をセットします。

`PyObject* PyTuple_GET_ITEM(PyObject *p, Py_ssize_t pos)'
     `PyTuple_GetItem()' に似ていますが、引数に対する
     エラーチェックを行いません。

`PyObject* PyTuple_GetSlice(PyObject *p, Py_ssize_t low, Py_ssize_t high)'
     P の指すタプルオブジェクト内の、位置 LOW から HIGH
     までのスライスを取り出して、タプルオブジェクトとして 返します。

`int PyTuple_SetItem(PyObject *p, Py_ssize_t pos, PyObject *o)'
     P の指すタプルオブジェクト内の位置 POS に、 オブジェクト O
     への参照を挿入します。成功した場合には `0' を返します。 _Note:_
     この関数は O への参照を "盗み取り" ます。

`void PyTuple_SET_ITEM(PyObject *p, Py_ssize_t pos, PyObject *o)'
     `PyTuple_SetItem()' に似ていますが、エラーチェックを
     行わず、新たなタプルに値を入れるとき _以外には使ってはなりません_。
     _Note:_ この関数は O への参照を "盗み取り" ます。

`int _PyTuple_Resize(PyObject **p, Py_ssize_t newsize)'
     タプルをリサイズする際に使えます。NEWSIZE はタプルの新たな
     長さです。タプルは変更不能なオブジェクト _ということになっている_
     ので、この関数は対象のオブジェクトに対してただ一つしか参照がない時
     以外には使ってはなりません。タプルがコード中の他の部分ですでに参照
     されている場合には、この関数を _使ってはなりません_。
     タプルは常に指定サイズの末尾まで伸縮します。 成功した場合には `0'
     を返します。 クライアントコードは、`*P' の値が呼び出し前と同じに
     なると気体してはなりません。 `*P'
     が置き換えられた場合、オリジナルの `*P' は破壊されます。失敗すると
     `-1' を返し、 `*P' を `NULL' に設定して、  `MemoryError' または
     `SystemError' を送出します。 _Changed in Python version 2.2_


File: python-api-jp.info,  Node: List Objects,  Prev: タプルオブジェクト tuple object,  Up: シーケンスオブジェクト sequence object

7.3.5 List Objects
------------------

`PyListObject'
     この `PyObject' のサブタイプは Python のリストオブジェクトを
     表現します。

`PyTypeObject PyList_Type'
     この `PyTypeObject' のインスタンスは Python
     のタプル型を表現します。 これは Python レイヤにおける `list' や
     `types.ListType' と同じオブジェクトです。 

`int PyList_Check(PyObject *p)'
     引数が `PyListObject' である場合に真を返します。

`PyObject* PyList_New(Py_ssize_t len)'
     サイズが LEN 新たなリストオブジェクトを返します。 失敗すると
     `NULL' を返します。 _Note:_ LEN
     が0より大きいとき、返されるリストオブジェクトの要素には `NULL'
     がセットされています。 なので、`PyList_SetItem()'
     で本当にオブジェクトをセットする
     までは、Pythonコードにこのオブジェクトを渡したり、`PySequence_SetItem()'
     のような抽象APIを利用してはいけません。

`Py_ssize_t PyList_Size(PyObject *list)'
     リストオブジェクトLIST の長さを返します;
     リストオブジェクトにおける `len(LIST)' と同じです。 

`Py_ssize_t PyList_GET_SIZE(PyObject *list)'
     マクロ形式でできた `PyList_Size()' で、エラーチェックを しません。

`PyObject* PyList_GetItem(PyObject *list, Py_ssize_t index)'
     P の指すリストオブジェクト内の、位置 POS にあるオブジェクト
     を返します。
     位置は正である必要があり、リスとの終端からのインデックスは
     サポートされていません。POS が範囲を超えている場合、 `NULL'
     を返して `IndexError' 例外をセットします。

`PyObject* PyList_GET_ITEM(PyObject *list, Py_ssize_t i)'
     マクロ形式でできた `PyList_GetItem()' で、エラーチェックを
     しません。

`int PyList_SetItem(PyObject *list, Py_ssize_t index, PyObject *item)'
     リストオブジェクト内の位置 INDEX に、オブジェクト ITEM
     を挿入します。成功した場合には`0' を返し、失敗すると `-1'
     を返します。 _Note:_ この関数は ITEM への参照を "盗み取り"
     ます。また、
     変更先のインデクスにすでに別の要素が入っている場合、その
     要素に対する参照を放棄します。

`void PyList_SET_ITEM(PyObject *list, Py_ssize_t i, PyObject *o)'
     `PyList_SetItem()' をマクロによる実装で、エラーチェック
     を行いません。この関数は、新たなリストのまだ要素を入れたことのない
     位置に要素を入れるときにのみ使います。 _Note:_ この関数は ITEM
     への参照を "盗み取り" ます。また、 `PyList_SetItem()'
     と違って、要素の置き換えが生じても
     置き換えられるオブジェクトへの参照を放棄 _しません_; その結果、
     LIST 中の位置 I で参照されていたオブジェクト
     がメモリリークを引き起こします。

`int PyList_Insert(PyObject *list, Py_ssize_t index, PyObject *item)'
     要素 ITEM をインデクス INDEX の前に挿入します。 成功すると `0'
     を返します。失敗すると `-1' を返し、 例外をセットします。
     `LIST.insert(INDEX, ITEM)' に類似した 機能です。

`int PyList_Append(PyObject *list, PyObject *item)'
     オブジェクト ITEM を LIST の末尾に追加します。 成功すると `0'
     を返します; 失敗すると `-1' を返し、
     例外をセットします。`LIST.append(ITEM)' に類似した機能です。

`PyObject* PyList_GetSlice(PyObject *list, Py_ssize_t low, Py_ssize_t high)'
     LIST 内の、LOW から HIGH の _間の_ オブジェクト
     からなるリストを返します。失敗すると `NULL' を返し、
     例外をセットします。 `LIST[LOW:HIGH]' に類似した機能です。

`int PyList_SetSlice(PyObject *list, Py_ssize_t low, Py_ssize_t high, PyObject *itemlist)'
     LIST 内の、LOW から HIGH の間のオブジェクトを、 ITEMLIST
     の内容にします。 `LIST[LOW:HIGH] = ITEMLIST'
     と類似の機能です。ITEMLIST は `NULL' でもよく、空リストの 代入
     (指定スライスの削除) になります。 成功した場合には `0'
     を、失敗した場合には `-1' を返します。

`int PyList_Sort(PyObject *list)'
     LIST の内容をインプレースでソートします。成功した場合には `0'
     を、失敗した場合には `-1' を返します。 success, `-1' on failure.
     `LIST.sort()' と同じです。

`int PyList_Reverse(PyObject *list)'
     LIST の要素をインプレースで反転します。成功した場合には `0'
     を、失敗した場合には `-1' を返します。 `LIST.reverse()'
     と同じです。

`PyObject* PyList_AsTuple(PyObject *list)'
     LIST の内容が入った新たなタプルオブジェクトを返します;
     `tuple(LIST)'.   と同じです。


File: python-api-jp.info,  Node: マップ型オブジェクト mapping object,  Next: その他のオブジェクト,  Prev: シーケンスオブジェクト sequence object,  Up: 具象オブジェクト concrete object レイヤ

7.4 マップ型オブジェクト (mapping object)
=========================================

* Menu:

* 辞書オブジェクト dictionary object::


File: python-api-jp.info,  Node: 辞書オブジェクト dictionary object,  Prev: マップ型オブジェクト mapping object,  Up: マップ型オブジェクト mapping object

7.4.1 辞書オブジェクト (dictionary object)
------------------------------------------

`PyDictObject'
     この `PyObject' のサブタイプは Python の辞書オブジェクト
     を表現します。

`PyTypeObject PyDict_Type'
     この `PyTypeObject' のインスタンスは Python の辞書を表現します。
     このオブジェクトは、Python プログラムには `dict' および
     `types.DictType' として公開されています。 

`int PyDict_Check(PyObject *p)'
     引数が `PyDictObject' のときに真を返します。

`int PyDict_CheckExact(PyObject *p)'
     P が辞書型オブジェクトであり、かつ辞書型のサブクラスのインスタンス
     でない場合に真を返します。 _Added in Python version 2.4_

`PyObject* PyDict_New()'
     P が辞書型オブジェクトで、かつ辞書型のサブタイプのインスタンス
     でない場合に真を返します。

`PyObject* PyDictProxy_New(PyObject *dict)'
     あるマップ型オブジェクトに対して、読み出し専用に制限されたプロキシ
     オブジェクト (proxy object) を返します。通常、この関数は
     動的でないクラス型 (non-dynamic class type) のクラス辞書を
     変更させないためにプロキシを作成するために使われます。 _Added in
     Python version 2.2_

`void PyDict_Clear(PyObject *p)'
     現在辞書に入っている全てのキーと値のペアを除去して空にします。

`int PyDict_Contains(PyObject *p, PyObject *key)'
     辞書 P に KEY が入っているか判定します。 P の要素が KEY
     に一致した場合は `1' を返し、 それ以外の場合には `0'
     を返します。エラーの場合 `-1' を返します。この関数は Python
     の式`KEY in P' と等価です。 _Added in Python version 2.4_

`PyObject* PyDict_Copy(PyObject *p)'
     P と同じキーと値のペアが入った新たな辞書を返します。 _Added in
     Python version 1.6_

`int PyDict_SetItem(PyObject *p, PyObject *key, PyObject *val)'
     辞書 P に、 KEY をキーとして値 VALUE を 挿入します。 KEY
     はハッシュ可能でなければなりません; ハッシュ可能でない場合、
     `TypeError' を送出します。 成功した場合には `0'
     を、失敗した場合には `-1' を返します。

`int PyDict_SetItemString(PyObject *p, const char *key, PyObject *val)'
     辞書 P に、 KEY をキーとして値 VALUE を 挿入します。 KEY は
     `char*' 型でなければなりません。
     キーオブジェクトは`PyString_FromString(KEY)' で生成 されます。
     成功した場合には `0' を、失敗した場合には `-1' を返します。 

`int PyDict_DelItem(PyObject *p, PyObject *key)'
     辞書 P から KEY をキーとするエントリを除去します。 KEY
     はハッシュ可能でなければなりません; ハッシュ可能でない場合、
     `TypeError' を送出します。 成功した場合には `0'
     を、失敗した場合には `-1' を返します。


`int PyDict_DelItemString(PyObject *p, char *key)'
     辞書 P から文字列 KEY をキーとするエントリを除去します。
     成功した場合には `0' を、失敗した場合には `-1' を返します。

`PyObject* PyDict_GetItem(PyObject *p, PyObject *key)'
     辞書P 内で KEY をキーとするオブジェクトを返します。 キー KEY
     が存在しない場合には `NULL' を返しますが、例外を セット
     _しません_。

`PyObject* PyDict_GetItemString(PyObject *p, const char *key)'
     `PyDict_GetItem()' と同じですが、KEY は `PyObject*' ではなく
     `char*' で指定します。

`PyObject* PyDict_Items(PyObject *p)'
     辞書オブジェクトのメソッド `item()' のように、
     辞書内の全ての要素対が入った `PyListObject' を返します。
     (`items()' については  を 参照してください。)

`PyObject* PyDict_Keys(PyObject *p)'
     辞書オブジェクトのメソッド `keys()' のように、
     辞書内の全てのキーが入った `PyListObject' を返します。 (`keys()'
     については  を 参照してください。)

`PyObject* PyDict_Values(PyObject *p)'
     辞書オブジェクトのメソッド `values()' のように、
     辞書内の全ての値が入った `PyListObject' を返します。 (`values()'
     については  を 参照してください。)

`Py_ssize_t PyDict_Size(PyObject *p)'
     辞書内の要素の数を返します。辞書に対して `len(P)' を
     実行するのと同じです。 

`int PyDict_Next(PyObject *p, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue)'
     辞書 P 内の全てのキー/値のペアにわたる反復処理を行います。 PPOS
     が参照している `int' 型は、この関数で反復処理
     を開始する際に、最初に関数を呼び出すよりも前に `0' に
     初期化しておかなければなりません; この関数は辞書内の各ペアを
     取り上げるごとに真を返し、全てのペアを取り上げたことが分かると
     偽を返します。パラメタ PKEY および PVALUE には、
     それぞれ辞書の各々のキーと値を指すポインタか、または `NULL'
     が入ります。この関数から返される参照はすべて借りた参照になります。
     反復処理中に PPOS を変更してはなりません。この値は
     内部的な辞書構造体のオフセットを表現しており、構造体はスパース
     なので、オフセットの値に一貫性がないためです。

     以下に例を示します:

          PyObject *key, *value;
          int pos = 0;

          while (PyDict_Next(self->dict, &pos, &key, &value)) {
              /* 取り出した値で何らかの処理を行う... */
              ...
          }

     反復処理中に辞書 P を変更してはなりません。 (Python 2.1 からは)
     辞書を反復処理する際に、キーに対応する値を
     変更しても大丈夫になりましたが、キーの集合を変更しないことが
     前提です。以下に例を示します:

          PyObject *key, *value;
          int pos = 0;

          while (PyDict_Next(self->dict, &pos, &key, &value)) {
              int i = PyInt_AS_LONG(value) + 1;
              PyObject *o = PyInt_FromLong(i);
              if (o == NULL)
                  return -1;
              if (PyDict_SetItem(self->dict, key, o) < 0) {
                  Py_DECREF(o);
                  return -1;
              }
              Py_DECREF(o);
          }


`int PyDict_Merge(PyObject *a, PyObject *b, int override)'
     マップ型オブジェクト B の全ての要素にわたって、反復的に
     キー/値のペアを辞書 A に追加します。 B
     は辞書か、`PyMapping_Keys()' または `PyObject_GetItem()'
     をサポートする何らかのオブジェクト にできます。 OVERRIDE
     が真ならば、A のキーと一致するキーが B
     にある際に、既存のペアを置き換えます。それ以外の場合は、B
     のキーに一致するキーが A にないときのみ追加を行います。
     成功した場合には `0' を返し、例外が送出された場合には `-1'
     を返します。 _Added in Python version 2.2_

`int PyDict_Update(PyObject *a, PyObject *b)'
     C で表せば `PyDict_Merge(A, B, 1)' と同じ、 Python
     で表せば`A.update(B)' と同じです。 成功した場合には `0'
     を返し、例外が送出された場合には `-1' を返します。 _Added in
     Python version 2.2_

`int PyDict_MergeFromSeq2(PyObject *a, PyObject *seq2, int override)'
     SEQ2 内のキー/値ペアを使って、辞書A の内容を更新したり
     統合したりします。SEQ2 は、キー/値のペアとみなせる長さ 2 の
     反復可能オブジェクト(iterable object)
     を生成する反復可能オブジェクトで
     なければなりません。重複するキーが存在する場合、OVERRIDE が
     真ならば先に出現したキーを使い、そうでない場合は後に出現したキーを
     使います。 成功した場合には `0' を返し、例外が送出された場合には
     `-1' を返します。

     (戻り値以外は) 等価な Python コードを書くと、以下のようになります:

          def PyDict_MergeFromSeq2(a, seq2, override):
              for key, value in seq2:
                  if override or key not in a:
                      a[key] = value

     _Added in Python version 2.2_


File: python-api-jp.info,  Node: その他のオブジェクト,  Prev: マップ型オブジェクト mapping object,  Up: 具象オブジェクト concrete object レイヤ

7.5 その他のオブジェクト
========================

* Menu:

* ファイルオブジェクト file object::
* インスタンスオブジェクト instance object::
* 関数オブジェクト Function Objects::
* メソッドオブジェクト method object::
* モジュールオブジェクト module object::
* イテレータオブジェクト iterator object::
* デスクリプタオブジェクト descriptor object::
* スライスオブジェクト slice object::
* 弱参照オブジェクト weak reference object::
* Cオブジェクト CObject::
* セルオブジェクト cell object::
* ジェネレータオブジェクト::
* DateTime オブジェクト::
* 集合オブジェクト Set Objects::


File: python-api-jp.info,  Node: ファイルオブジェクト file object,  Next: インスタンスオブジェクト instance object,  Prev: その他のオブジェクト,  Up: その他のオブジェクト

7.5.1 ファイルオブジェクト (file object)
----------------------------------------

Python の組み込みファイルオブジェクトは、全て標準 C ライブラリの
`FILE*' サポートの上に実装されています。以下の詳細説明は
一実装に関するもので、将来の Python のリリースで変更されるかも
しれません。

`PyFileObject'
     この `PyObject' のサブタイプは Python のファイル型オブジェクトを
     表現します。

`PyTypeObject PyFile_Type'
     この `PyTypeObject' のインスタンスは Python のファイル型を
     表現します。このオブジェクトは `file' および `types.FileType'
     として Python プログラムで公開されています。 

`int PyFile_Check(PyObject *p)'
     引数が `PyFileObject' か `PyFileObject'
     のサブタイプのときに真を返します。 _Changed in Python version 2.2_

`int PyFile_CheckExact(PyObject *p)'
     引数が `PyFileObject' 型で、かつ `PyFileObject'
     型のサブタイプでないときに真を返します。 _Added in Python version
     2.2_

`PyObject* PyFile_FromString(char *filename, char *mode)'
     成功すると、FILENAME に指定した名前のファイルを MODE に
     指定したファイルモードで開いて得た新たなファイルオブジェクトを返します。
     MODE のセマンティクスは標準 C ルーチン `fopen()'  と同じです。失敗すると`NULL'
     を返します。

`PyObject* PyFile_FromFile(FILE *fp, char *name, char *mode, int (*close)(FILE*))'
     すでに開かれている標準 C ファイルポインタ FP から 新たな
     `PyFileObject' を生成します。この関数で生成した
     ファイルオブジェクトは、閉じる際にCLOSE に指定した関数を
     呼び出します。失敗すると`NULL'を返します。

`FILE* PyFile_AsFile(PyObject *p)'
     P に関連付けられたファイルオブジェクトを `FILE*' で返します。

`PyObject* PyFile_GetLine(PyObject *p, int n)'
     `P.readline([N])' と同じで、この関数は オブジェクト P
     の各行を読み出します。 P は ファイルオブジェクトか、`readline()'
     メソッドを持つ 何らかのオブジェクトでかまいません。N が `0'
     の場合、 行の長さに関係なく正確に 1 行だけ読み出します。N が `0'
     より大きければ、N バイト以上のデータは 読み出しません;
     従って、行の一部だけが返される場合があります。
     どちらの場合でも、読み出し後すぐにファイルの終端に到達した場合には
     空文字列を返します。N が `0' より小さければ、長さに 関わらず 1
     行だけを読み出しますが、すぐにファイルの終端に到達した 場合には
     `EOFError' を送出します。 

`PyObject* PyFile_Name(PyObject *p)'
     P に指定したファイルの名前を文字列オブジェクトで 返します。

`void PyFile_SetBufSize(PyFileObject *p, int n)'
     `setvbuf()'  があるシステムでのみ
     利用できます。この関数を呼び出してよいのはファイルオブジェクトの
     生成直後のみです。

`int PyFile_Encoding(PyFileObject *p, char *enc)'
     Unicode オブジェクトをファイルに出力するときにのエンコード方式を
     ENC にします。成功すると `1' を、失敗すると `0' を返します。
     _Added in Python version 2.3_

`int PyFile_SoftSpace(PyObject *p, int newflag)'
     この関数はインタプリタの内部的な利用のために存在します。
     この関数はP の `softspace'  属性を NEWFLAG に
     設定し、以前の設定値を返します。この関数を正しく動作させるために、
     P がファイルオブジェクトである必然性はありません; 任意の
     オブジェクトをサポートします (`softspace' 属性が設定
     されているかどうかのみが問題だと思ってください)。
     この関数は全てのエラーを解消し、属性値が存在しない場合や属性値を
     取得する際にエラーが生じると、`0' を以前の値として返します。
     この関数からはエラーを検出できませんが、そもそもそういう必要は
     ありません。

`int PyFile_WriteObject(PyObject *obj, PyObject *p, int flags)'
     オブジェクト OBJ をファイルオブジェクト P に書き込みます。 FLAG
     がサポートするフラグは `Py_PRINT_RAW'  だけです; このフラグ
     を指定すると、 オブジェクトに`repr()' ではなく `str()'
     を適用した結果をファイルに書き出します。 成功した場合には `0'
     を返し、失敗すると `-1' を返して 適切な例外をセットします。

`int PyFile_WriteString(const char *s, PyObject *p)'
     文字列 S をファイルオブジェクト P に書き出します。
     成功した場合には `0' を返し、失敗すると `-1' を返して
     適切な例外をセットします。


File: python-api-jp.info,  Node: インスタンスオブジェクト instance object,  Next: 関数オブジェクト Function Objects,  Prev: ファイルオブジェクト file object,  Up: その他のオブジェクト

7.5.2 インスタンスオブジェクト (instance object)
------------------------------------------------

インスタンスオブジェクト固有の関数はきわめてわずかです。

`PyTypeObject PyInstance_Type'
     クラスインスタンスの型オブジェクトです。

`int PyInstance_Check(PyObject *obj)'
     OBJ がインスタンスの場合に真を返します。

`PyObject* PyInstance_New(PyObject *class, PyObject *arg, PyObject *kw)'
     特定クラスの新たなインスタンスを生成します。パラメタ ARG および KW
     はそれぞれオブジェクトのコンストラクタに渡す
     実引数およびキーワードパラメタとして使われます。

`PyObject* PyInstance_NewRaw(PyObject *class, PyObject *dict)'
     特定クラスの新たなインスタンスを、コンストラクタを呼ばずに生成します。
     CLASS は新たに作成するオブジェクトのクラスです。DICT パラメタは
     オブジェクトの `__dict__' に使われます; DICT が `NULL'
     なら、インスタンス用に新たな辞書が作成されます。


File: python-api-jp.info,  Node: 関数オブジェクト Function Objects,  Next: メソッドオブジェクト method object,  Prev: インスタンスオブジェクト instance object,  Up: その他のオブジェクト

7.5.3 関数オブジェクト (Function Objects)
-----------------------------------------

Pythonの関数にはいくつかの種類があります。

`PyFunctionObject'
     関数に使われるCの構造体

`PyTypeObject PyFunction_Type'
     `PyTypeObject' 型のインスタンスで、 Python の関数型を表します。
     これは Python プログラムに `types.FunctionType'
     として公開されます。 

`int PyFunction_Check(PyObject *o)'
     O が関数オブジェクト (`PyFunction_Type'を持っている) なら true
     を返します。 引数は`NULL' であってはいけません。

`PyObject* PyFunction_New(PyObject *code, PyObject *globals)'
     コードオブジェクト CODE
     に関連付けられた新しい関数オブジェクトを返します。 GLOBALS
     はこの関数からアクセスできるグローバル変数の辞書でなければなりません。

     関数のドキュメント文字列、名前および __MODULE__
     はコードオブジェクトから
     取得されます。引数のデフォルト値やクロージャは `NULL'
     にセットされます。

`PyObject* PyFunction_GetCode(PyObject *op)'
     関数オブジェクト OP に関連付けられたコードオブジェクトを返します。

`PyObject* PyFunction_GetGlobals(PyObject *op)'
     関数オブジェクト OP に関連付けられたglobals辞書を返します。

`PyObject* PyFunction_GetModule(PyObject *op)'
     関数オブジェクト OP の __MODULE__ 属性を返します。　
     これは普通はモジュール名の文字列が入っていますが、Python コードから
     他のオブジェクトをセットされることもあります。

`PyObject* PyFunction_GetDefaults(PyObject *op)'
     関数オブジェクト OP の引数のデフォルト値を返します。
     引数のタプルか `NULL' になります。

`int PyFunction_SetDefaults(PyObject *op, PyObject *defaults)'
     関数オブジェクト OP の引数のデフォルト値を設定します。 DEFAULTS は
     PY_NONE か タプル でなければいけません。

     失敗した時は、`SystemError' を発生し、`-1' を返します。

`PyObject* PyFunction_GetClosure(PyObject *op)'
     関数オブジェクト OP に設定されたクロージャを返します。 `NULL' か
     cell オブジェクトのタプルです。

`int PyFunction_SetClosure(PyObject *op, PyObject *closure)'
     関数オブジェクト OP にクロージャを設定します。 CLOSURE は、
     PY_NONE もしくは cell オブジェクトのタプルでなければなりません。

     失敗した時は、`SystemError'を送出し、 `-1' を返します。


File: python-api-jp.info,  Node: メソッドオブジェクト method object,  Next: モジュールオブジェクト module object,  Prev: 関数オブジェクト Function Objects,  Up: その他のオブジェクト

7.5.4 メソッドオブジェクト (method object)
------------------------------------------

メソッドオブジェクトを操作する上で便利な関数がいくつかあります。

`PyTypeObject PyMethod_Type'
     この `PyTypeObject' のインスタンスは Python のメソッドオブジェクト
     型を表現します。このオブジェクトは、`types.MethodType' として
     Python プログラムに公開されています。

`int PyMethod_Check(PyObject *o)'
     O がメソッドオブジェクト (`PyMethod_Type' 型である)
     場合に真を返します。パラメタは `NULL' にできません。

`PyObject* PyMethod_New(PyObject *func, PyObject *self, PyObject *class)'
     任意の呼び出し可能オブジェクトFUNC を使った新たなメソッド
     オブジェクトを返します; 関数 FUNC は、メソッドが呼び出された
     時に呼び出されるオブジェクトです。このメソッドをインスタンスに
     束縛 (bind) したい場合、 SELF をインスタンス自体にして、 CLASS
     をSELF のクラスにしなければなりません。 それ以外の場合は SELF を
     `NULL' に、 CLASS を
     非束縛メソッドを提供しているクラスにしなければなりません。

`PyObject* PyMethod_Class(PyObject *meth)'
     メソッドオブジェクト METH を生成したクラスオブジェクトを返します;
     インスタンスがメソッドオブジェクトを生成した場合、戻り値は
     インスタンスのクラスになります。

`PyObject* PyMethod_GET_CLASS(PyObject *meth)'
     `PyMethod_Class()' をマクロで実装したバージョンで、
     エラーチェックを行いません。

`PyObject* PyMethod_Function(PyObject *meth)'
     METH に関連付けられている関数オブジェクトを返します。

`PyObject* PyMethod_GET_FUNCTION(PyObject *meth)'
     `PyMethod_Function()' のマクロ版で、エラーチェックを 行いません。

`PyObject* PyMethod_Self(PyObject *meth)'
     METH が束縛メソッドの場合には、メソッドに関連付けられている
     インスタンスを返します。それ以外の場合には `NULL' を返します。

`PyObject* PyMethod_GET_SELF(PyObject *meth)'
     `PyMethod_Self()' のマクロ版で、エラーチェックを 行いません。


File: python-api-jp.info,  Node: モジュールオブジェクト module object,  Next: イテレータオブジェクト iterator object,  Prev: メソッドオブジェクト method object,  Up: その他のオブジェクト

7.5.5 モジュールオブジェクト (module object)
--------------------------------------------

モジュールオブジェクト固有の関数は数個しかありません。

`PyTypeObject PyModule_Type'
     この `PyTypeObject' のインスタンスは Python
     のモジュールオブジェクト 型を表現します。
     このオブジェクトは、Python プログラムには `types.ModuleType' として公開されています。

`int PyModule_Check(PyObject *p)'
     O がモジュールオブジェクトかモジュールオブジェクトのサブタイプで
     あるときに真を返します。 _Changed in Python version 2.2_

`int PyModule_CheckExact(PyObject *p)'
     O がモジュールオブジェクトで、かつモジュールオブジェクトの
     サブタイプでないときに真を返します。 `PyModule_Type'.  _Added in
     Python version 2.2_

`PyObject* PyModule_New(const char *name)'
     `__name__' 属性が NAME に設定された新たなモジュール
     オブジェクトを返します。モジュールの `__doc__' および `__name__'
     属性だけに値が入っています; `__file__'
     属性に値を入れるのは呼び出し側の責任です。 

`PyObject* PyModule_GetDict(PyObject *module)'
     MODULE の名前空間を実現する辞書オブジェクトを返します;
     このオブジェクトはモジュールオブジェクトの `__dict__'
     と同じです。この関数が失敗することはありません。 拡張モジュールでは、この関数で得たモジュールの`__dict__'
     を直接いじるより、他の`PyModule_*()' および `PyObject_*()'
     関数を使うよう勧めます。

`char* PyModule_GetName(PyObject *module)'
     MODULE の `__name__' の値を返します。
     モジュールがこの属性を提供していない場合や文字列型でない場合、
     `SystemError' を送出して `NULL' を返します。 

`char* PyModule_GetFilename(PyObject *module)'
     MODULE をロードするために使ったファイルの名前を、MODULE の
     `__file__' 属性から調べて返します。`__file__'
     が定義されていない場合や文字列型でない場合、 `SystemError'
     を送出して `NULL' を返します。 

`int PyModule_AddObject(PyObject *module, const char *name, PyObject *value)'
     MODULE にオブジェクトをNAME として追加します。
     この関数はモジュールの初期化関数から利用される便宜関数です。
     エラーのときには `-1' を、成功したときには `0' を 返します。
     _Added in Python version 2.0_

`int PyModule_AddIntConstant(PyObject *module, const char *name, long value)'
     MODULE に整数定数をNAME として追加します。
     この便宜関数はモジュールの初期化関数から利用されています。
     エラーのときには `-1' を、成功したときには `0' を 返します。
     _Added in Python version 2.0_

`int PyModule_AddStringConstant(PyObject *module, const char *name, char *value)'
     MODULE に文字列定数をNAME として追加します。
     この便宜関数はモジュールの初期化関数から利用されています。 文字列
     VALUE は null 終端されていなければなりません。 エラーのときには
     `-1' を、成功したときには `0' を 返します。 _Added in Python
     version 2.0_


File: python-api-jp.info,  Node: イテレータオブジェクト iterator object,  Next: デスクリプタオブジェクト descriptor object,  Prev: モジュールオブジェクト module object,  Up: その他のオブジェクト

7.5.6 イテレータオブジェクト (iterator object)
----------------------------------------------

Python では二種類のイテレータオブジェクトを提供しています。
一つ目はシーケンスイテレータで、`__getitem__()' メソッドを
サポートする任意のシーケンスを取り扱います。二つ目は呼び出し可能
オブジェクトとセンチネル値 (sentinel value) を扱い、
シーケンス内の要素ごとに呼び出し可能オブジェクトを呼び出して、
センチネル値が返されたときに反復処理を終了します。

`PyTypeObject PySeqIter_Type'
     `PySeqIter_New()' や、組み込みシーケンス型に対して 1
     引数形式の組み込み関数`iter()' を呼び出したときに
     返される、イテレータオブジェクトの型オブジェクトです。 _Added in
     Python version 2.2_

`int PySeqIter_Check(op)'
     `PySeqIter_Type' の型が OP のときに真を返します。 _Added in Python
     version 2.2_

`PyObject* PySeqIter_New(PyObject *seq)'
     一般的なシーケンスオブジェクト SEQ を扱うイテレータを返します。
     反復処理は、シーケンスが添字指定操作の際に `IndexError' を
     返したときに終了します。 _Added in Python version 2.2_

`PyTypeObject PyCallIter_Type'
     `PyCallIter_New()' や、組み込み関数 `iter()' の 2
     引数形式が返すイテレータオブジェクトの型オブジェクトです。
     `iter()' built-in function.  _Added in Python version 2.2_

`int PyCallIter_Check(op)'
     `PyCallIter_Type' の型が OP のときに真を返します。 _Added in
     Python version 2.2_

`PyObject* PyCallIter_New(PyObject *callable, PyObject *sentinel)'
     新たなイテレータを返します。最初のパラメタ CALLABLE は
     引数なしで呼び出せる Python の呼び出し可能オブジェクトなら
     なんでもかまいません; CALLABLEは、呼び出されるたびに
     次の反復処理対象オブジェクトを返さなければなりません。
     生成されたイテレータは、 CALLABLEが SENTINEL に等しい
     値を返すと反復処理を終了します。 _Added in Python version 2.2_


File: python-api-jp.info,  Node: デスクリプタオブジェクト descriptor object,  Next: スライスオブジェクト slice object,  Prev: イテレータオブジェクト iterator object,  Up: その他のオブジェクト

7.5.7 デスクリプタオブジェクト (descriptor object)
--------------------------------------------------

"デスクリプタ (descriptor)" は、あるオブジェクトのいくつかの属性
について記述したオブジェクトです。デスクリプタオブジェクトは
型オブジェクトの辞書内にあります。

`PyTypeObject PyProperty_Type'
     組み込みデスクリプタ型の型オブジェクトです。 _Added in Python
     version 2.2_

`PyObject* PyDescr_NewGetSet(PyTypeObject *type, struct PyGetSetDef *getset)'
     _Added in Python version 2.2_

`PyObject* PyDescr_NewMember(PyTypeObject *type, struct PyMemberDef *meth)'
     _Added in Python version 2.2_

`PyObject* PyDescr_NewMethod(PyTypeObject *type, struct PyMethodDef *meth)'
     _Added in Python version 2.2_

`PyObject* PyDescr_NewWrapper(PyTypeObject *type, struct wrapperbase *wrapper, void *wrapped)'
     _Added in Python version 2.2_

`int PyDescr_IsData(PyObject *descr)'
     デスクリプタオブジェクト DESCR がデータ属性のデスクリプタの
     場合には真を、メソッドデスクリプタの場合には偽を返します。 DESCR
     はデスクリプタオブジェクトでなければなりません;
     エラーチェックは行いません。 _Added in Python version 2.2_

`PyObject* PyWrapper_New(PyObject *, PyObject *)'
     _Added in Python version 2.2_


File: python-api-jp.info,  Node: スライスオブジェクト slice object,  Next: 弱参照オブジェクト weak reference object,  Prev: デスクリプタオブジェクト descriptor object,  Up: その他のオブジェクト

7.5.8 スライスオブジェクト (slice object)
-----------------------------------------

`PyTypeObject PySlice_Type'
     スライスオブジェクトの型オブジェクトです。 `slice' や
     `types.SliceType' と同じです。 

`int PySlice_Check(PyObject *ob)'
     OB がスライスオブジェクトの場合に真を返します; OB は `NULL'
     であってはなりません。

`PyObject* PySlice_New(PyObject *start, PyObject *stop, PyObject *step)'
     指定した値から新たなスライスオブジェクトを返します。パラメタ
     START, STOP, および STEP はスライスオブジェクトに
     おける同名の属性として用いられます。これらの値はいずれも `NULL'
     にでき、対応する値には `None' が使われます。新たな
     オブジェクトをアロケーションできない場合には `NULL' を返します。

`int PySlice_GetIndices(PySliceObject *slice, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step)'
     スライスオブジェクト SLICE における START, STOP, および STEP
     のインデクス値を取得します。このときシーケンスの 長さを LENGTH
     と仮定します。LENGTH よりも大きな
     インデクスになるとエラーとして扱います。

     成功のときには `0' を、エラーのときには例外をセットせずに `-1'
     を返します (ただし、指定インデクスのいずれか一つが `None'
     ではなく、かつ整数に変換できなかった場合を 除きます。この場合、
     `-1' を返して例外をセットします)。

     おそらくこの関数を使う気にはならないでしょう。バージョン 2.3 以前の
     Python でスライスオブジェクトを使いたいのなら、
     `PySlice_GetIndicesEx' のソースを適切に名前変更して
     自分の拡張モジュールのソースコード内に組み込むとよいでしょう。

`int PySlice_GetIndicesEx(PySliceObject *slice, Py_ssize_t length, Py_ssize_t *start, Py_ssize_t *stop, Py_ssize_t *step, Py_ssize_t *slicelength)'
     `PySlice_GetIndices' の置き換えとして使える関数です。

     スライスオブジェクト SLICE における START, STOP, および STEP
     のインデクス値を取得します。このときシーケンスの 長さを LENGTH
     と仮定します。スライスの長さを SLICELENGTH
     に記憶します。境界をはみだしたインデクスは、通常のスライスを扱うのと
     同じ一貫したやり方でクリップされます。

     成功のときには `0' を、エラーのときには例外をセットして `-1'
     を返します。

     _Added in Python version 2.3_


File: python-api-jp.info,  Node: 弱参照オブジェクト weak reference object,  Next: Cオブジェクト CObject,  Prev: スライスオブジェクト slice object,  Up: その他のオブジェクト

7.5.9 弱参照オブジェクト (weak reference object)
------------------------------------------------

Python は _弱参照_ を第一級オブジェクト (first-class object)
としてサポートします。弱参照を直接実装する二種類の固有のオブジェクト
型があります。第一は単純な参照オブジェクトで、第二はオリジナルの
オブジェクトに対して可能な限りプロキシとして振舞うオブジェクトです。

`int PyWeakref_Check(ob)'
     OB が参照オブジェクトかプロキシオブジェクトの場合に真を返します。
     _Added in Python version 2.2_

`int PyWeakref_CheckRef(ob)'
     OB が参照オブジェクトの場合に真を返します。 _Added in Python
     version 2.2_

`int PyWeakref_CheckProxy(ob)'
     OB がプロキシオブジェクトの場合に真を返します。 _Added in Python
     version 2.2_

`PyObject* PyWeakref_NewRef(PyObject *ob, PyObject *callback)'
     OB に対する弱参照オブジェクトを返します。この関数は常に
     新たな参照を返しますが、必ずしも新たなオブジェクトを作る保証は
     ありません; 既存の参照オブジェクトが返されることもあります。
     第二のパラメタ CALLBACK は呼び出し可能オブジェクトで、 OB
     がガーベジコレクションされた際に通知を受け取ります; CALLBACK
     は弱参照オブジェクト自体を単一のパラメタとして
     受け取ります。CALLBACK は `None' や `NULL' にしても かまいません。
     OB が弱参照できないオブジェクトの場合や、 CALLBACK
     が呼び出し可能オブジェクト、`None'、`NULL'
     のいずれでもない場合は、`NULL' を返して`TypeError' を送出します。
     _Added in Python version 2.2_

`PyObject* PyWeakref_NewProxy(PyObject *ob, PyObject *callback)'
     OB に対する弱参照プロキシオブジェクトを返します。この関数は常に
     新たな参照を返しますが、必ずしも新たなオブジェクトを作る保証は
     ありません; 既存の参照オブジェクトが返されることもあります。
     第二のパラメタ CALLBACK は呼び出し可能オブジェクトで、 OB
     がガーベジコレクションされた際に通知を受け取ります; CALLBACK
     は弱参照オブジェクト自体を単一のパラメタとして
     受け取ります。CALLBACK は `None' や `NULL' にしても かまいません。
     OB が弱参照できないオブジェクトの場合や、 CALLBACK
     が呼び出し可能オブジェクト、`None'、`NULL'
     のいずれでもない場合は、`NULL' を返して`TypeError' を送出します。
     _Added in Python version 2.2_

`PyObject* PyWeakref_GetObject(PyObject *ref)'
     弱参照 REF が参照しているオブジェクトを返します。
     被参照オブジェクトがすでに存続していない場合、 `None' を 返します。
     _Added in Python version 2.2_

`PyObject* PyWeakref_GET_OBJECT(PyObject *ref)'
     `PyWeakref_GetObject()' に似ていますが、マクロで実装
     されていて、エラーチェックを行いません。 _Added in Python version
     2.2_


File: python-api-jp.info,  Node: Cオブジェクト CObject,  Next: セルオブジェクト cell object,  Prev: 弱参照オブジェクト weak reference object,  Up: その他のオブジェクト

7.5.10 Cオブジェクト (CObject)
------------------------------

このオブジェクトの使用法に関する情報は、 _Python
インタプリタの拡張と埋め込み_ 1.12 節、 "Providing a C API for an
Extension Module," を参照してください。

`PyCObject'
     この `PyObject' のサブタイプは不透明型値 (opaque value) を
     表現します。C 拡張モジュールが Python コードから不透明型値を
     (`void*' ポインタで) 他の C コードに渡す必要があるときに 便利です。
     正規の import 機構を使って動的にロードされるモジュール内で定義
     されている C API にアクセスするために、あるモジュール内で定義
     されている C 関数ポインタを別のモジュールでも利用できるように
     するためによく使われます。

`int PyCObject_Check(PyObject *p)'
     引数が `PyCObject' の場合に真を返します。

`PyObject* PyCObject_FromVoidPtr(void* cobj, void (*destr)(void *))'
     `void *'COBJ から `PyCObject' を生成します。 関数 DESTR が `NULL'
     でない場合、オブジェクトを再利用する際に 呼び出します。

`PyObject* PyCObject_FromVoidPtrAndDesc(void* cobj, void* desc, void (*destr)(void *, void *))'
     `void *'COBJ から `PyCObject' を生成します。 関数 DESTR が `NULL'
     でない場合、オブジェクトを再利用する際に 呼び出します。 引数 DESC
     を使って、デストラクタ関数に追加のコールバックデータ を渡せます。

`void* PyCObject_AsVoidPtr(PyObject* self)'
     `PyCObject' オブジェクト SELF を生成するのに用いた オブジェクト
     `void *' を返します。

`void* PyCObject_GetDesc(PyObject* self)'
     `PyCObject' オブジェクト SELF を生成するのに用いた
     コールバックデータ `void *' を返します。

`int PyCObject_SetVoidPtr(PyObject* self, void* cobj)'
     SELF 内の void ポインタ COBJ に設定します。 `PyCObject'
     にデストラクタが関連づけられていてはなりません。
     成功すると真値を返し、失敗すると偽値を返します。


File: python-api-jp.info,  Node: セルオブジェクト cell object,  Next: ジェネレータオブジェクト,  Prev: Cオブジェクト CObject,  Up: その他のオブジェクト

7.5.11 セルオブジェクト (cell object)
-------------------------------------

"セル (cell)" オブジェクトは、複数のスコープから参照される
変数群を実装するために使われます。セルは各変数について作成され、
各々の値を記憶します; この値を参照する各スタックフレームにおける
ローカル変数には、そのスタックフレームの外側で同じ値を参照している
セルに対する参照が入ります。セルで表現された値にアクセスすると、
セルオブジェクト自体の代わりにセル内の値が使われます。この
セルオブジェクトを使った間接参照 (dereference) は、インタプリタに
よって生成されたバイトコード内でサポートされている必要があります;
セルオブジェクトにアクセスした際に、自動的に間接参照は起こり
ません。上記以外の状況では、セルオブジェクトは役に立たないはずです。

`PyCellObject'
     セルオブジェクトに使われる C 構造体です。

`PyTypeObject PyCell_Type'
     セルオブジェクトに対応する型オブジェクトです。

`int PyCell_Check(ob)'
     OB がセルオブジェクトの場合に真を返します; OB は `NULL'
     であってはなりません。

`PyObject* PyCell_New(PyObject *ob)'
     値 OB の入った新たなセルオブジェクトを生成して返します。 引数を
     `NULL' にしてもかまいません。

`PyObject* PyCell_Get(PyObject *cell)'
     CELL の内容を返します。

`PyObject* PyCell_GET(PyObject *cell)'
     CELL の内容を返しますが、CELL が非 `NULL' でかつ
     セルオブジェクトであるかどうかチェックしません。

`int PyCell_Set(PyObject *cell, PyObject *value)'
     セルオブジェクト CELL の内容を VALUE に設定します。
     この関数は現在のセルの全ての内容に対する参照を解放します。 VALUE
     は `NULL' でもかまいません。CELL は 非`NULL' でなければなりません;
     もしCELL がセルオブジェクトでない 場合、 `-1'
     を返します。成功すると `0' を返します。

`void PyCell_SET(PyObject *cell, PyObject *value)'
     セルオブジェクト CELL の値を VALUE に設定します。
     参照カウントに対する変更はなく、安全のためのチェックは何も
     行いません; CELL は非`NULL' でなければならず、かつ
     セルオブジェクトでなければなりません。


File: python-api-jp.info,  Node: ジェネレータオブジェクト,  Next: DateTime オブジェクト,  Prev: セルオブジェクト cell object,  Up: その他のオブジェクト

7.5.12 ジェネレータオブジェクト
-------------------------------

ジェネレータ (generator) オブジェクトは、 Python がジェネレータ型
イテレータを実装するために使っているオブジェクトです。
ジェネレータオブジェクトは、通常、`PyGen_New' で明示的に生成
されることはなく、値を逐次生成するような関数に対してイテレーションを
行うときに生成されます。

`PyGenObject'
     ジェネレータオブジェクトに使われている C 構造体です。

`PyTypeObject PyGen_Type'
     ジェネレータオブジェクトに対応する型オブジェクトです。

`int PyGen_Check(ob)'
     OB がジェネレータオブジェクトの場合に真を返します。OB が `NULL'
     であってはなりません。

`int PyGen_CheckExact(ob)'
     OB の型がPYGEN_TYPEの場合に真を返します。OB が `NULL'
     であってはなりません。

`PyObject* PyGen_New(PyFrameObject *frame)'
     FRAME オブジェクトに基づいて新たなジェネレータオブジェクトを
     生成して返します。 この関数はFRAMEへの参照を盗みます。 パラメタが
     `NULL' であってはなりません。


File: python-api-jp.info,  Node: DateTime オブジェクト,  Next: 集合オブジェクト Set Objects,  Prev: ジェネレータオブジェクト,  Up: その他のオブジェクト

7.5.13 DateTime オブジェクト
----------------------------

`datetime' モジュールでは、様々な日付オブジェクトや時刻オブジェクト
を提供しています。以下に示す関数を使う場合には、あらかじめヘッダファイル
`datetime.h' をソースに include し (`Python.h' はこのファイルを include
しません)、`PyDateTime_IMPORT()' マクロを起動しておく
必要があります。このマクロは以下のマクロで使われる静的変数
`PyDateTimeAPI' に C 構造体へのポインタを入れます。

以下は型チェックマクロです:

`int PyDate_Check(PyObject *ob)'
     OB が`PyDateTime_DateType' 型か`PyDateTime_DateType'
     型のサブタイプのオブジェクトの場合に真を返します; OB は `NULL'
     であってはなりません。 _Added in Python version 2.4_

`int PyDate_CheckExact(PyObject *ob)'
     OB が`PyDateTime_DateType' 型のオブジェクトの場合に真を返します;
     OB は `NULL' であってはなりません。 _Added in Python version 2.4_

`int PyDateTime_Check(PyObject *ob)'
     OB が`PyDateTime_DateTimeType' 型か `PyDateTime_DateTimeType'
     型のサブタイプのオブジェクトの 場合に真を返します; OB は `NULL'
     であってはなりません。 _Added in Python version 2.4_

`int PyDateTime_CheckExact(PyObject *ob)'
     OB が`PyDateTime_DateTimeType'
     型のオブジェクトの場合に真を返します; OB は `NULL'
     であってはなりません。 _Added in Python version 2.4_

`int PyTime_Check(PyObject *ob)'
     OB が`PyDateTime_TimeType' 型か`PyDateTime_TimeType'
     型のサブタイプのオブジェクトの場合に真を返します; OB は `NULL'
     であってはなりません。 _Added in Python version 2.4_

`int PyTime_CheckExact(PyObject *ob)'
     OB が`PyDateTime_TimeType' 型のオブジェクトの場合に真を返します;
     OB は `NULL' であってはなりません。 _Added in Python version 2.4_

`int PyDelta_Check(PyObject *ob)'
     OB が`PyDateTime_DeltaType' 型か`PyDateTime_DeltaType'
     型のサブタイプのオブジェクトの場合に真を返します; OB は `NULL'
     であってはなりません。 _Added in Python version 2.4_

`int PyDelta_CheckExact(PyObject *ob)'
     OB が`PyDateTime_DeltaType' 型のオブジェクトの場合に真を返します;
     OB は `NULL' であってはなりません。 _Added in Python version 2.4_

`int PyTZInfo_Check(PyObject *ob)'
     OB が`PyDateTime_TZInfoType' 型か`PyDateTime_TZInfoType'
     型のサブタイプのオブジェクトの場合に真を返します; OB は `NULL'
     であってはなりません。 _Added in Python version 2.4_

`int PyTZInfo_CheckExact(PyObject *ob)'
     OB が`PyDateTime_TZInfoType' 型のオブジェクトの場合に真を返します;
     OB は `NULL' であってはなりません。 _Added in Python version 2.4_

以下はオブジェクトを作成するためのマクロです:

`PyObject* PyDate_FromDate(int year, int month, int day)'
     指定された年、月、日の`datetime.date' オブジェクトを返します。
     _Added in Python version 2.4_

`PyObject* PyDateTime_FromDateAndTime(int year, int month, int day, int hour, int minute, int second, int usecond)'
     指定された年、月、日、時、分、秒、マイクロ秒の`datetime.datetime'
     オブジェクトを返します。 _Added in Python version 2.4_

`PyObject* PyTime_FromTime(int hour, int minute, int second, int usecond)'
     指定された時、分、秒、マイクロ秒の`datetime.time'
     オブジェクトを返します。 _Added in Python version 2.4_

`PyObject* PyDelta_FromDSU(int days, int seconds, int useconds)'
     指定された日、秒、マイクロ秒の`datetime.timedelta' オブジェクトを
     返します。マイクロ秒と秒が `datetime.timedelta' オブジェクトで
     定義されている範囲に入るように正規化を行います。 _Added in Python
     version 2.4_

以下のマクロは date オブジェクトからフィールド値を取り出すための
ものです。引数は`PyDateTime_Date' またはそのサブクラス (例えば
`PyDateTime_DateTime')の インスタンスでなければなりません。引数を
`NULL' にしてはならず、 型チェックは行いません:

`int PyDateTime_GET_YEAR(PyDateTime_Date *o)'
     年を正の整数で返します。 _Added in Python version 2.4_

`int PyDateTime_GET_MONTH(PyDateTime_Date *o)'
     月を 1 から 12 の間の整数で返します。 _Added in Python version 2.4_

`int PyDateTime_GET_DAY(PyDateTime_Date *o)'
     日を 1 から 31 の間の整数で返します。 _Added in Python version 2.4_

以下のマクロは datetime オブジェクトからフィールド値を取り出すための
ものです。引数は`PyDateTime_DateTime' またはそのサブクラスの
インスタンスでなければなりません。引数を `NULL' にしてはならず、
型チェックは行いません:

`int PyDateTime_DATE_GET_HOUR(PyDateTime_DateTime *o)'
     時を 0 から 23 の間の整数で返します。 _Added in Python version 2.4_

`int PyDateTime_DATE_GET_MINUTE(PyDateTime_DateTime *o)'
     分を 0 から 59 の間の整数で返します。 _Added in Python version 2.4_

`int PyDateTime_DATE_GET_SECOND(PyDateTime_DateTime *o)'
     秒を 0 から 59 の間の整数で返します。 _Added in Python version 2.4_

`int PyDateTime_DATE_GET_MICROSECOND(PyDateTime_DateTime *o)'
     マイクロ秒を 0 から 999999 の間の整数で返します。 _Added in Python
     version 2.4_

以下のマクロは time オブジェクトからフィールド値を取り出すための
ものです。引数は`PyDateTime_Time' またはそのサブクラスの
インスタンスでなければなりません。引数を `NULL' にしてはならず、
型チェックは行いません:

`int PyDateTime_TIME_GET_HOUR(PyDateTime_Time *o)'
     時を 0 から 23 の間の整数で返します。 _Added in Python version 2.4_

`int PyDateTime_TIME_GET_MINUTE(PyDateTime_Time *o)'
     分を 0 から 59 の間の整数で返します。 _Added in Python version 2.4_

`int PyDateTime_TIME_GET_SECOND(PyDateTime_Time *o)'
     秒を 0 から 59 の間の整数で返します。 _Added in Python version 2.4_

`int PyDateTime_TIME_GET_MICROSECOND(PyDateTime_Time *o)'
     マイクロ秒を 0 から 999999 の間の整数で返します。 _Added in Python
     version 2.4_

以下のマクロは DB API を実装する上での便宜用です:

`PyObject* PyDateTime_FromTimestamp(PyObject *args)'
     `dateitme.datetime.fromtimestamp()' に渡すのに適した引数タプルから
     新たな `datetime.datetime' オブジェクトを生成して返します。 _Added
     in Python version 2.4_

`PyObject* PyDate_FromTimestamp(PyObject *args)'
     `dateitme.date.fromtimestamp()' に渡すのに適した引数タプルから
     新たな `datetime.date' オブジェクトを生成して返します。 _Added in
     Python version 2.4_


File: python-api-jp.info,  Node: 集合オブジェクト Set Objects,  Prev: DateTime オブジェクト,  Up: その他のオブジェクト

7.5.14 集合オブジェクト (Set Objects)
-------------------------------------

_Added in Python version 2.5_

このセクションでは `set' と `frozenset'
の公開APIについて詳しく述べます。
以降で説明していない機能は、抽象オブジェクトプロトコル (
`PyObject_CallMethod()', `PyObject_RichCompareBool()',
`PyObject_Hash()', `PyObject_Repr()', `PyObject_IsTrue()',
`PyObject_Print()', `PyObject_GetIter()' を含む) か抽象数値プロトコル (
`PyNumber_Add()', `PyNumber_Subtract()', `PyNumber_Or()',
`PyNumber_Xor()', `PyNumber_InPlaceAdd()', `PyNumber_InPlaceSubtract()',
`PyNumber_InPlaceOr()', `PyNumber_InPlaceXor()' を含む)
を使って利用できます。

`PySetObject'
     この `PyObject' を継承した型は、 `set' と `frozenset' 両方の
     内部データを保存するのに用いられます。 `PyDictObject'
     と同じように、小さい集合(set)に対しては(タプルのように)固定サイズであり、
     そうでない集合に対しては(リストと同じように)可変長のメモリブロックを用います。
     この構造体のどのフィールドも、非公開で変更される可能性があると考えて下さい。
     すべてのアクセスは、構造体の中の値を直接操作するのではなく、ドキュメントされた
     APIを用いて行うべきです。

`PyTypeObject PySet_Type'
     この `PyTypeObject' のインスタンスは、Pythonの `set' 型を表します。

`PyTypeObject PyFrozenSet_Type'
     この `PyTypeObject' のインスタンスは、Pythonの `frozenset'
     型を表します。

以降の型チェックマクロはすべてのPythonオブジェクトに対するポインタに対して動作します。
同様に、コンストラクタはすべてのイテレート可能なPythonオブジェクトに対して動作します。

`int PyAnySet_Check(PyObject *p)'
     P が `set' か `frozenset' 、あるいはそのサブタイプのオブジェクトで
     あれば、trueを返します。

`int PyAnySet_CheckExact(PyObject *p)'
     P が `set' か `frozenset' のどちらかのオブジェクトであるときに
     true を返します。 サブタイプのオブジェクトは含みません。

`int PyFrozenSet_CheckExact(PyObject *p)'
     P が `frozenset' のオブジェクトであるときに true を返します。
     サブタイプのオブジェクトは含みません。

`PyObject* PySet_New(PyObject *iterable)'
     ITERABLE が返すオブジェクトを含む新しい `set' を返します。
     ITERABLE が `NULL' のときは、空のsetを返します。
     成功したら新しいsetを、失敗したら `NULL' を返します。 ITERABLE
     がイテレート可能で無い場合は、 `TypeError' を送出します。
     このコンストラクタは set をコピーするときにも使えます。
     (`c=set(s)')

`PyObject* PyFrozenSet_New(PyObject *iterable)'
     ITERABLE が返すオブジェクトを含む新しい `frozenset' を返します。
     ITERABLE が `NULL' のときは、空のfrozensetを返します。 ITERABLE
     がイテレート可能で無い場合は、 `TypeError' を送出します。

以降の関数やマクロは、`set' と `frozenset' とそのサブタイプの
インスタンスに対して利用できます。

`int PySet_Size(PyObject *anyset)'
     `set' や `frozenset' のオブジェクトの長さを返します。
     `len(ANYSET)' と同じです。 ANYSET が
     `set'、`frozenset'及びそのサブタイプのオブジェクトで
     無い場合は、`PyExc_SystemError' を送出します。 

`int PySet_GET_SIZE(PyObject *anyset)'
     エラーチェックを行わない、`PySet_Size()' のマクロ形式。

`int PySet_Contains(PyObject *anyset, PyObject *key)'
     見つかったら１を、見つからなかったら0を、エラーが発生したときは-1を返します。
     Pythonの `__contains__()'
     メソッドと違って、この関数は非ハッシュsetを
     一時frozensetに自動で変換しません。
     KEYがハッシュ可能で無い場合、`TypeError'を送出します。
     ANYSETが`set', `frozenset' 及びそのサブタイプのオブジェクトで無い
     場合は `PyExc_SystemError' を送出します。

以降の関数は、`set'とそのサブタイプに対して利用可能です。 `frozenset' と
そのサブタイプには利用できません。

`int PySet_Add(PyObject *set, PyObject *key)'
     `set' のインスタンスに KEY を追加します。
     `frozenset'のインスタンスに使わないで下さい。
     成功したら0を、失敗したら-1を返します。
     KEYがハッシュ可能でないなら、`TypeError'を送出します。
     setを大きくする余裕が無い場合は、 `MemoryError'を送出します。
     SETが`set'とそのサブタイプのインスタンスで無い場合は、`SystemError'を送出します。

`int PySet_Discard(PyObject *set, PyObject *key)'
     見つかって削除したら1を返します。
     見つからなかったら何もせずに0を返します。
     エラーが発生したら-1を返します。
     keyが無くても`KeyError'を送出しません。
     KEYがハッシュ不可能であれば`TypeError'を送出します。
     Pythonの`discard()'メソッドと違って、この関数は非ハッシュsetsを
     一時frozensetに変換しません。
     SETが`set'とそのサブタイプのインスタンスで無いときは、
     `PyExc_SystemError'を送出します。

`PyObject* PySet_Pop(PyObject *set)'
     SETの中の要素のどれかに対する新しい参照を返し、
     そのオブジェクトをSETから削除します。 失敗したら`NULL'を返します。
     setが空の場合には`KeyError'を送出します。
     SETが`set'とそのサブタイプのインスタンスで無い場合は、
     `SystemError'を送出します。

`int PySet_Clear(PyObject *set)'
     setを空にします。


File: python-api-jp.info,  Node: 初期化 initialization、終了処理 finalization、スレッド,  Next: メモリ管理,  Prev: 具象オブジェクト concrete object レイヤ,  Up: Top

8 初期化 (initialization)、終了処理 (finalization)、スレッド
************************************************************

`void Py_Initialize()'
     Python インタプリタを初期化します。Python の埋め込みを行う
     アプリケーションでは、他のあらゆる Python/C API を使用するよりも
     前にこの関数を呼び出さねばなりません; ただし、
     `Py_SetProgramName()' , `PyEval_InitThreads()' ,
     `PyEval_ReleaseLock()' , および `PyEval_AcquireLock()' は例外です。
     この関数はロード済みモジュールのテーブル (`sys.modules') を初期化 し、基盤となるモジュール群、
     `__builtin__' , `__main__'  および `sys'  を生成します。
     また、モジュール検索パス 

     (`sys.path') も初期化します。 `sys.argv' の設定は行いません;
     設定するには、 `PySys_SetArgv()'  を使ってください。 この関数を
     (`Py_Finalize()'  を 呼ばずに) 再度呼び出しても何も行いません。
     戻り値はありません; 初期化が失敗すれば、それは致命的なエラーです。

`void Py_InitializeEx(int initsigs)'
     INITSIGSに1を指定すれば`Py_Initialize()'と同じ処理を実
     行しますが、Python埋め込みアプリケーションではINITSIGSを0として
     初期化時にシグナルハンドラの登録をスキップすることができます。
     _Added in Python version 2.4_

`int Py_IsInitialized()'
     Python インタプリタがすでに初期化済みの場合に真 (非ゼロ) を返し、
     そうでない場合には偽 (ゼロ) を返します。`Py_Finalize()'
     を呼び出すと、次に`Py_Initialize()' を呼び出すまで
     この関数は偽を返します。

`void Py_Finalize()'
     `Py_Initialize()' とそれ以後の Python/C API 関数で行った
     全ての初期化処理を取り消し、最後の `Py_Initialize()'
     呼び出し以後に Python インタプリタが生成した全てのサブインタプリタ
     (sub-interpreter, 下記の `Py_NewInterpreter()' を参照) を
     消去します。 理想的な状況では、この関数によって Python
     インタプリタが確保した メモリは全て解放されます。 この関数を
     (`Py_Initialize()' を呼ばずに) 再度呼び出しても 何も行いません。
     戻り値はありません; 終了処理中のエラーは無視されます。

     この関数が提供されている理由はいくつかあります。Python の埋め込みを
     行っているアプリケーションでは、アプリケーションを再起動することなく
     Python を再起動したいことがあります。また、動的ロード可能イブラリ
     (あるいは DLL) から Python インタプリタをロードするアプリケーション
     では、DLL をアンロードする前に Python が確保したメモリを解放したい
     と考えるかもしれません。アプリケーション内で起きているメモリリークを
     追跡する際に、開発者は Python が確保したメモリをアプリケーションの
     終了前に解放させたいと思う場合もあります。

     *バグおよび注意事項:* モジュールやモジュール内のオブジェクト
     はランダムな順番で削除されます; このため、他のオブジェクト
     (関数オブジェクトも含みます) やモジュールに依存するデストラクタ
     (`__del__()' メソッド) が失敗してしまうことがあります。
     動的にロードされるようになっている拡張モジュールが Python によって
     ロードされていた場合、アンロードされません。Python が確保した
     メモリがわずかながら解放されないかもしれません (メモリリークを
     発見したら、どうか報告してください)。オブジェクト間の循環参照に
     捕捉されているメモリは解放されないことがあります。拡張モジュール
     が確保したメモリは解放されないことがあります。拡張モジュールに
     よっては、初期化ルーチンを 2 度以上呼び出すと正しく動作
     しないことがあります; こうした状況は、`Py_Initialize()'
     や`Py_Finalize()' を 2 度以上呼び出すと起こり得ます。

`PyThreadState* Py_NewInterpreter()'
     新しいサブインタプリタ (sub-interpreter) を生成します。
     サブインタプリタとは、(ほぼ完全に) 個別に分割された Python
     コードの実行環境です。特に、新しいサブインタプリタは、 import
     されるモジュール全てについて個別のバージョンを持ち、
     これには基盤となるモジュール `__builtin__' , `__main__'  および
     `sys'  も含まれます。 ロード済みのモジュールからなるテーブル
     (`sys.modules') およびモジュール検索パス (`sys.path')
     もサブインタプリタ
     毎に別個のものになります。新たなサブインタプリタ環境には
     `sys.argv' 変数がありません。また、サブインタプリタは 新たな標準
     I/O ストリーム `sys.stdin', `sys.stdout' および `sys.stderr'
     を持ちます (とはいえ、これらのストリームは 根底にある C
     ライブラリの同じ `FILE' 構造体を参照しています)。 

     戻り値は、新たなサブインタプリタが生成したスレッド状態 (thread
     state) オブジェクトのうち、最初のものを指しています。
     このスレッド状態が現在のスレッド状態 (current thread state)
     になります。
     実際のスレッドが生成されるわけではないので注意してください;
     下記のスレッド状態に関する議論を参照してください。
     新たなインタプリタの生成に失敗すると、`NULL' を返します;
     例外状態はセットされませんが、これは例外状態が現在のスレッド状態に
     保存されることになっていて、現在のスレッド状態なるものが
     存在しないことがあるからです。 (他の Python/C API 関数のように、
     この関数を呼び出す前にはグローバルインタプリタロック (global
     interpreter lock) が保持されていなければならず、関数が
     処理を戻した際にも保持されたままになります; しかし、 他の Python/C
     API 関数とは違い、関数から戻ったときの現在のスレッド状態
     が関数に入るときと同じとは限らないので注意してください)。

     拡張モジュールは以下のような形で (サブ) インタプリタ間で共有
     されます: ある特定の拡張モジュールを最初に import すると、
     モジュールを通常通りに初期化し、そのモジュールの辞書の (浅い)
     コピーをしまい込んでおきます。他の (サブ) インタプリタが
     同じ拡張モジュールを import すると、新たなモジュールを初期化し、
     先ほどのコピーの内容で辞書の値を埋めます; 拡張モジュールの `init'
     関数は呼び出されません。この挙動は、 `Py_Finalize()'  および
     `Py_Initialize()'  を呼び出して
     インタプリタを完全に再初期化した後に拡張モジュールを import した
     際の挙動とは異なるので注意してください; 再初期化後に import を
     行うと、拡張モジュールの `initMODULE' は再度 _呼び出され_ ます。

     *バグと注意事項:* サブインタプリタ (とメインインタプリタ)
     は同じプロセスの一部分なので、インタプリタ間の絶縁性は完璧では
     ありません -- 例えば、 `os.close()'
     のような低レベルのファイル操作を使うと、 (偶然なり故意なりに)
     互いのインタプリタ下にある開かれたファイルに
     影響を及ぼせてしまいます。 拡張モジュールを (サブ)
     インタプリタ間で共有する方法のために、
     拡張モジュールによっては正しく動作しないかもしれません;
     拡張モジュールが (静的な) グローバル変数を利用している
     場合や、拡張モジュールが初期化後に自身のモジュール辞書を操作
     する場合には特にそうです。
     一つのサブインタプリタで生成されたオブジェクトは他のサブインタプリタ
     の名前空間への挿入が可能です;
     ユーザ定義関数、メソッド、インスタンス
     およびクラスをサブインタプリタをサブインタプリタ間で共有しないように
     十分注意してください。というのは、これらの共有オブジェクトが
     実行した import 文は間違った (サブ) インタプリタのロード済み
     モジュール辞書に影響を及ぼす場合があるからです (XXX この問題は
     修正が難しいバグで、将来のリリースで解決される予定です)

     この機能は PyObjC や ctypes のような、`PyGILState_*' API を利用する
     タイプの拡張モジュールと相性が悪いことにも注意してください。
     (これは、`PyGILState_*' 関数の動作特有の問題です)
     シンプルなことなら上手くいくかもしれませんが、いつ混乱させる動作をするかわかりません。

`void Py_EndInterpreter(PyThreadState *tstate)'
     指定されたスレッド状態 TSTATE で表現される (サブ) インタプリタを
     抹消します。TSTATE は現在のスレッド状態でなければなりません。
     下記のスレッド状態に関する議論を参照してください。関数呼び出しが
     戻ったとき、現在のスレッド状態は `NULL'になっています。
     このインタプリタに関連付けられた全てのスレッド状態は抹消されます。
     (この関数を呼び出す前にはグローバルインタプリタロックを保持して
     おかねばならず、ロックは関数が戻ったときも保持されています。)
     `Py_Finalize()'  は、その時点で
     明示的に抹消されていない全てのサブインタプリタを抹消します。

`void Py_SetProgramName(char *name)'
     この関数を呼び出すなら、最初に `Py_Initialize()'  を呼び出す
     よりも前に呼び出さねばなりません。この関数はインタプリタに
     プログラムの`main()'  関数に 指定した`argv[0]' 引数の値を教えます。
     この引数値は、`Py_GetPath()'  や、
     以下に示すその他の関数が、インタプリタの実行可能形式から Python
     ランタイムライブラリへの相対パスを取得するために使われます。
     デフォルトの値は`'python'' です。引数はゼロ終端された
     キャラクタ文字列で、静的な記憶領域に入っていなければならず、
     その内容はプログラムの実行中に変更してはなりません。 Python
     インタプリタ内のコードで、この記憶領域の内容を変更するものは
     一切ありません。

`char* Py_GetProgramName()'
     `Py_SetProgramName()'  で
     設定されたプログラム名か、デフォルトのプログラム名を返します。
     関数が返す文字列ポインタは静的な記憶領域を返します; 関数の
     呼び出し側はこの値を変更できません。

`char* Py_GetPrefix()'
     プラットフォーム非依存のファイル群がインストールされている場所である
     _prefix_ を返します。この値は `Py_SetProgramName()'
     でセットされたプログラム名や
     いくつかの環境変数をもとに、数々の複雑な規則から導出されます;
     例えば、プログラム名が`'/usr/local/bin/python'' の場合、prefix は
     `'/usr/local'' になります。
     関数が返す文字列ポインタは静的な記憶領域を返します; 関数の
     呼び出し側はこの値を変更できません。 この値はトップレベルの
     `Makefile' に指定されている変数 `prefix' や、ビルド値に
     `configure' スクリプト に指定した `--prefix' 引数に対応しています。
     この値は Python コードからは `sys.prefix' として利用できます。
     UNIX でも有用です。次に説明する関数も参照してください。

`char* Py_GetExecPrefix()'
     プラットフォーム_依存_ のファイルがインストールされている場所
     である_exec-prefix_ を返します。 この値は`Py_SetProgramName()'
     でセットされたプログラム名や
     いくつかの環境変数をもとに、数々の複雑な規則から導出されます;
     例えば、プログラム名が`'/usr/local/bin/python''
     の場合、exec-prefix は `'/usr/local'' になります。
     関数が返す文字列ポインタは静的な記憶領域を返します; 関数の
     呼び出し側はこの値を変更できません。 この値はトップレベルの
     `Makefile' に指定されている変数 `exec_prefix' や、ビルド値に
     `configure' スクリプト に指定した `--exec-prefix'
     引数に対応しています。 この値は Python コードからは
     `sys.exec_prefix' として利用できます。 UNIXのみで有用です。

     背景: プラットフォーム依存のファイル (実行形式や共有ライブラリ)
     が、 別個のディレクトリツリー内にインストールされている場合、
     exec-prefix は prefix と異なります。典型的なインストール形態では、
     プラットフォーム非依存のファイルが`/usr/local' に収められる一方、
     プラットフォーム依存のファイルは`/usr/local/plat' サブツリーに
     収められます。

     概して、プラットフォームとは、ハードウェアとソフトウェアファミリの
     組み合わせを指します。例えば、 Solaris 2.x を動作させている Sparc
     マシンは全て同じプラットフォームであるとみなしますが、Solaris 2.x
     を動作させている Intel マシンは違うプラットフォームになりますし、
     同じ Intel マシンでも Linux を動作させているならまた別の
     プラットフォームです。一般的には、同じオペレーティングシステムでも、
     メジャーリビジョンの違うものは異なるプラットフォームです。 非 UNIX
     のオペレーティングシステムの場合は話はまた別です; 非 UNIX
     のシステムでは、インストール方法はとても異なっていて、 prefix や
     exec-prefix には意味がなく、空文字列が設定されている
     ことがあります。コンパイル済みの Python バイトコードは
     プラットフォームに依存しないので注意してください (ただし、
     どのバージョンの Python でコンパイルされたかには依存します!)。

     システム管理者は、`mount' や `automount' プログラムを
     使って、各プラットフォーム用の`/usr/local/plat' を異なった
     ファイルシステムに置き、プラットフォーム間で `/usr/local' を
     共有するための設定方法を知っているはずです。

`char* Py_GetProgramFullPath()'
     Python 実行可能形式の完全なプログラム名を返します; この値は
     デフォルトのモジュール検索パスを (前述の`Py_SetProgramName()'  で設定された)
     プログラム名から導出する際に 副作用的に計算されます。
     関数が返す文字列ポインタは静的な記憶領域を返します; 関数の
     呼び出し側はこの値を変更できません。 この値は Python コードからは
     `sys.executable' として利用できます。 UNIXのみで有用です。 

`char* Py_GetPath()'
     デフォルトモジュール検索パスを返します; パスは (上の
     `Py_SetProgramName()' で設定された) プログラム名と、
     いくつかの環境変数から計算されます。戻り値となる文字列は、
     プラットフォーム依存のパスデリミタ文字で分割された一連の
     ディレクトリ名からなります。デリミタ文字は UNIXと Mac OS X
     では`:'、 Windows では`;' です。
     関数が返す文字列ポインタは静的な記憶領域を返します;
     関数の呼び出し側はこの値を変更できません。 この値は Python
     コードからはリスト `sys.path'  として
     利用できます。このリストは、値を修正して将来モジュールをロードする際に
     使う検索パスを変更できます。


`const char* Py_GetVersion()'
     Python インタプリタのバージョンを返します。バージョンは、

          "1.5 (#67, Dec 31 1997, 22:34:28) [GCC 2.7.2.2]"

     ような形式の文字列です。

     第一ワード (最初のスペース文字まで) は、現在の Python のバージョン
     です;
     最初の三文字は、メジャーバージョンとマイナーバージョン、そして
     それを分割しているピリオドです。関数が返す文字列ポインタは静的な
     記憶領域を返します; 関数の呼び出し側はこの値を変更できません。
     この値は Python コードからは`sys.version'として利用できます。 

`const char* Py_GetBuildNumber()'
     このPython実行ファイルが、Subversionのどのリビジョンからビルドされたかを表す
     文字列を返します。 リビジョンを混ぜて作られたPythonでは末尾に 'M'
     をつけるので、 この番号は文字列になっています。 _Added in Python
     version 2.5_

`const char* Py_GetPlatform()'
     現在のプラットフォームのプラットフォーム識別文字列を返します。
     UNIXでは、オペレーティングシステムの "公式の" 名前を小文字に
     変換し、後ろにメジャーリビジョン番号を付けた構成になっています;
     例えば Solaris 2.x は、SunOS 5.x, としても知られていますが、
     `'sunos5'' になります。Mac OS X では `'darwin'' です。 Windows
     では`'win'' です。 関数が返す文字列ポインタは静的な
     記憶領域を返します; 関数の呼び出し側はこの値を変更できません。
     この値は Python コードからは`sys.platform'として利用できます。 

`const char* Py_GetCopyright()'
     現在の Python バージョンに対する公式の著作権表示文字列、例えば
     `'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam''
     を返します。 関数が返す文字列ポインタは静的な 記憶領域を返します;
     関数の呼び出し側はこの値を変更できません。 この値は Python
     コードからは`sys.copyright'として利用できます。 

`const char* Py_GetCompiler()'
     現在使っているバージョンの Python をビルドする際に用いたコンパイラ
     を示す文字列を、各括弧で囲った文字列を返します。例えば:

          "[GCC 2.7.2.2]"

     になります。

     関数が返す文字列ポインタは静的な 記憶領域を返します;
     関数の呼び出し側はこの値を変更できません。 この値は Python
     コードからは`sys.version' の一部として 取り出せます。 

`const char* Py_GetBuildInfo()'
     現在使っている Python インタプリタインスタンスの、シーケンス番号と
     ビルド日時に関する情報を返します。例えば

          "#67, Aug  1 1997, 22:34:28"

     になります。

     関数が返す文字列ポインタは静的な 記憶領域を返します;
     関数の呼び出し側はこの値を変更できません。 この値は Python
     コードからは`sys.version' の一部として 取り出せます。 

`void PySys_SetArgv(int argc, char **argv)'
     ARGC および ARGV に基づいて `sys.argv' を設定
     します。このパラメタはプログラムの `main()' に渡したパラメタに似ていますが、最初の要素が
     Python インタプリタ
     の宿主となっている実行形式の名前ではなく、実行されるスクリプト名を
     参照しなければならない点が違います。実行するスクリプトがない場合、
     ARGV の最初の要素は空文字列にしてもかまいません。 この関数が
     `sys.argv' の初期化に失敗した場合、致命的
     エラー条件を`Py_FatalError()' でシグナルします。 

* Menu:

* スレッド状態 thread state とグローバルインタプリタロック global interpreter lock::
* プロファイルとトレース profiling and tracing::
* 高度なデバッガサポート advanced debugger support::


File: python-api-jp.info,  Node: スレッド状態 thread state とグローバルインタプリタロック global interpreter lock,  Next: プロファイルとトレース profiling and tracing,  Prev: 初期化 initialization、終了処理 finalization、スレッド,  Up: 初期化 initialization、終了処理 finalization、スレッド

8.1 スレッド状態 (thread state) とグローバルインタプリタロック (global interpreter lock)
========================================================================================

Python インタプリタは完全にスレッド安全 (thread safe) ではありません。
マルチスレッドの Python プログラムをサポートするために、グローバルな
ロックが存在していて、現在のスレッドが Python オブジェクトに安全に
アクセスする前に必ずロックを獲得しなければならなくなっています。
ロック機構がなければ、単純な操作でさえ、マルチスレッドプログラムの
実行に問題を引き起こす可能性があります: たとえば、二つのスレッドが
同じオブジェクトの参照カウントを同時にインクリメントすると、
結果的に参照カウントは二回でなく一回だけしかインクリメントされない
かもしれません。

このため、グローバルインタプリタロックを獲得したスレッドだけが Python
オブジェクトを操作したり、 Python/C API 関数を呼び出したり
できるというルールがあります。マルチスレッドの Python プログラムを
サポートするため、インタプリタは定期的に -- デフォルトの設定では
バイトコード 100 命令ごとに (この値は `sys.setcheckinterval()' で
変更できます) -- ロックを解放したり獲得したりします。
このロックはブロックが起こりうる I/O 操作の付近でも解放・獲得 され、I/O
を要求するスレッドが I/O 操作の完了を待つ間、他の
スレッドが動作できるようにしています。

Python インタプリタはスレッドごとに何らかの予約情報を持っておかねば
なりません -- このため、Python は `PyThreadState'  と呼ばれるデータ構造
を用います。 とはいえ、グローバル変数はまだ一つだけ残っています:
それは現在の `PyThreadState'  構造体を指すポインタです。
ほとんどのスレッドパッケージが "スレッドごとのグローバルデータ"
を保存する手段を持っている一方で、Python の内部的なプラットフォーム
非依存のスレッド抽象層はこれをサポートしていません。従って、
現在のスレッド状態を明示的に操作するようにしなければなりません。

ほとんどのケースで、このような操作は十分簡単にできます。
グローバルインタプリタロックを操作数ほとんどのコードは、以下のような
単純な構造を持ちます:

     スレッド状態をローカル変数に保存する。
     インタプリタロックを解放する。
     ...ブロックが起きるような何らかの I/O 操作...
     インタプリタロックを獲得する。
     ローカル変数からスレッド状態を回復する。

このやりかたは非常に一般的なので、作業を単純にするために二つの
マクロが用意されています:

     Py_BEGIN_ALLOW_THREADS
     ...ブロックが起きるような何らかの I/O 操作...
     Py_END_ALLOW_THREADS

`Py_BEGIN_ALLOW_THREADS' マクロは新たなブロック文を開始し、隠しローカル変数を宣言します;
`Py_END_ALLOW_THREADS' はブロック文を終了します。これらの二つのマクロを使うもうひとつの
利点は、Python をスレッドサポートなしでコンパイルしたとき、
マクロの内容、すなわちスレッド状態の退避とロック操作が空になると
いう点です。

スレッドサポートが有効になっている場合、上記のブロックは
以下のようなコードに展開されます:

         PyThreadState *_save;

         _save = PyEval_SaveThread();
         ...ブロックが起きるような何らかの I/O 操作...
         PyEval_RestoreThread(_save);

より低水準のプリミティブを使うと、以下のようにしてほぼ同じ効果を
得られます:

         PyThreadState *_save;

         _save = PyThreadState_Swap(NULL);
         PyEval_ReleaseLock();
         ...ブロックが起きるような何らかの I/O 操作...
         PyEval_AcquireLock();
         PyThreadState_Swap(_save);

上の二つには微妙な違いがあります; とりわけ、 `PyEval_RestoreThread()' 

はグローバル変数 `errno'  の値を保存しておいて
元に戻す点が異なります。というのは、ロック操作が `errno' に
何もしないという保証がないからです。また、スレッドサポートが無効化
されている場合、 `PyEval_SaveThread()'  および `PyEval_RestoreThread()'
はロックを操作しません; この場合、 `PyEval_ReleaseLock()'  および
`PyEval_AcquireLock()'  は
利用できません。この仕様は、スレッドサポートを無効化してコンパイル
されているインタプリタが、スレッドサポートが有効化された状態で
コンパイルされている動的ロード拡張モジュールをロードできる
ようにするためのものです。

グローバルインタプリタロックは、現在のスレッド状態を指すポインタを
保護するために使われます。ロックを解放してスレッド状態を退避する際、
ロックを解放する前に現在のスレッド状態ポインタを取得しておかなければ
なりません (他のスレッドがすぐさまロックを獲得して、自らの
スレッド状態をグローバル変数に保存してしまうかもしれないからです)。
逆に、ロックを獲得してスレッド状態を復帰する際には、
グローバル変数にスレッド状態ポインタを保存する前にロックを獲得して
おかなければなりません。

なぜここまで詳しく説明しようとするかおわかりでしょうか? それは、 C
でスレッドを生成した場合、そのスレッドにはグローバルインタプリタ
ロックがなく、スレッド状態データ構造体もないからです。このような
スレッドが Python/C API を利用するには、まずスレッド状態データ構造体を
生成し、次にロックを獲得し、そしてスレッド状態ポインタを保存すると
いったように、自分自身をブートストラップして生成しなければ
なりません。スレッドが作業を終えたら、スレッド状態ポインタを
リセットして、ロックを解放し、最後にスレッド状態データ構造体を
メモリ解放しなければなりません。

スレッドデータ構造体を生成する際には、インタプリタ状態データ構造体を
指定する必要があります。インタプリタ状態データ構造体は、
インタプリタ内の全てのスレッド間で共有されているグローバルなデータ、
例えばモジュール管理データ (code{sys.modules}) を保持しています。
必要に応じて、新たなインタプリタ状態データ構造体を作成するなり、 Python
メインスレッドが使っているインタプリタ状態データ構造体
を共有するなりできます (後者のデータにアクセスするためには、
スレッド状態データ構造体を獲得して、その `interp' メンバ
にアクセスしなければなりません; この処理は、Python が作成した
スレッドから行うか、Python を初期化した後で主スレッドから行わねば
なりません)。

インタプリタオブジェクトにアクセスできるという仮定の下では、C の
スレッドから Python を呼び出す際の典型的な常套句は以下のようになります。

バージョン 2.3 からは、上記の事を全て自動で行われて、 スレッドは
`PyGILState_*()' の恩恵に預かることができます。 C のスレッドから Python
を呼び出す典型的な方法は以下のとおりです。

         PyGILState_STATE gstate;
         gstate = PyGILState_Ensure();

         /* Perform Python actions here.  */
         result = CallSomeFunction();
         /* evaluate result */

         /* Release the thread. No Python API allowed beyond this point. */
         PyGILState_Release(gstate);

`PyGILState_*()'関数は、(`Py_Initialize()'によって自動的に作られる)
グローバルインタプリタ一つだけが存在すると仮定する事に気をつけて下さい。
Python は (`Py_NewInterpreter()'を使って)
追加のインタプリタを作成できることに
変わりはありませんが、複数インタプリタと `PyGILState_*()' API を混ぜて
使うことはサポートされていません。

`PyInterpreterState'
     このデータ構造体は、協調動作する多数のスレッド間で共有されている
     状態 (state) を表現します。同じインタプリタに属するスレッドは
     モジュール管理情報やその他いくつかの内部的な情報を共有しています。
     この構造体には公開 (public) のメンバはありません。

     異なるインタプリタに属するスレッド間では、利用可能なメモリ、
     開かれているファイルデスクリプタなどといったプロセス状態を除き、
     初期状態では何も共有されていません。グローバルインタプリタロック
     もまた、スレッドがどのインタプリタに属しているかに関わらず
     すべてのスレッドで共有されています。

`PyThreadState'
     単一のスレッドの状態を表現する表現するデータ構造体です。
     データメンバ `PyInterpreterState *'`interp'
     だけが公開されていて、スレッドのインタプリタ状態を指すポインタに
     なっています。

`void PyEval_InitThreads()'
     グローバルインタプリタロックを初期化し、獲得します。
     この関数は、主スレッドが第二のスレッドを生成する以前や、
     `PyEval_ReleaseLock()'  や `PyEval_ReleaseThread(TSTATE)' といった他のスレッド操作に入るよりも前に呼び出されるようにして
     おかなければなりません。

     二度目に呼び出すと何も行いません。この関数を `Py_Initialize()'  の前に呼び出しても
     安全です。

     主スレッドしか存在しないのであれば、ロック操作は必要ありません。
     これはよくある状況ですし (ほとんどの Python プログラムはスレッドを
     使いません)、ロック操作はインタプリタをごくわずかに低速化します。
     従って、初期状態ではロックは生成されません。ロックを使わない状況は、
     すでにロックを獲得している状況と同じです: 単一のスレッドしか
     なければ、オブジェクトへのアクセスは全て安全です。従って、
     この関数がロックを初期化すると、同時にロックを獲得するようになって
     います。Python の `thread'  モジュールは、
     新たなスレッドを作成する前に、ロックが存在するか、あるいはまだ
     作成されていないかを調べ、`PyEval_InitThreads()' を
     呼び出します。この関数から処理が戻った場合、ロックが作成作成され、呼び出
     し元スレッドがそのロックを獲得している事が保証されています。

     どのスレッドが現在グローバルインタプリタロックを (存在する場合)
     持っているか分からない時にこの関数を使うのは安全では *ありません*
     。

     この関数はコンパイル時にスレッドサポートを無効化すると利用できません。

`int PyEval_ThreadsInitialized()'
     `PyEval_InitThreads()'をすでに呼び出している場合は真 (非ゼロ)
     を返します。この関数は、ロックを獲得せずに呼び出すことができますので、シ
     ングルスレッドで実行している場合にはロック関連のAPI呼び出しを避けるため
     に使うことができます。
     この関数はコンパイル時にスレッドサポートを無効化すると利用できません。
     _Added in Python version 2.4_

`void PyEval_AcquireLock()'
     グローバルインタプリタロックを獲得します。
     ロックは前もって作成されていなければなりません。
     この関数を呼び出したスレッドがすでにロックを獲得している場合、
     デッドロックに陥ります。
     この関数はコンパイル時にスレッドサポートを無効化すると利用できません。

`void PyEval_ReleaseLock()'
     グローバルインタプリタロックを解放します。
     ロックは前もって作成されていなければなりません。
     この関数はコンパイル時にスレッドサポートを無効化すると利用できません。

`void PyEval_AcquireThread(PyThreadState *tstate)'
     グローバルインタプリタロックを獲得し、現在のスレッド状態を TSTATE
     に設定します。TSTATE は `NULL'であっては
     なりません。ロックはあらかじめ作成されていなければなりません。
     この関数を呼び出したスレッドがすでにロックを獲得している場合、
     デッドロックに陥ります。
     この関数はコンパイル時にスレッドサポートを無効化すると利用できません。

`void PyEval_ReleaseThread(PyThreadState *tstate)'
     現在のスレッド状態をリセットして `NULL'
     にし、グローバルインタプリタ
     ロックを解放します。ロックはあらかじめ作成されていなければならず、
     かつ現在のスレッドが保持していなければなりません。TSTATE は
     `NULL'であってはなりませんが、その値が現在のスレッド状態を
     表現しているかどうかを調べるためにだけ使われます -- もしそうで
     なければ、致命的エラーが報告されます。
     この関数はコンパイル時にスレッドサポートを無効化すると利用できません。

`PyThreadState* PyEval_SaveThread()'
     (インタプリタロックが生成されていて、スレッドサポートが有効の
     場合) インタプリタロックを解放して、スレッド状態を `NULL'にし、
     以前のスレッド状態 (`NULL'にはなりません) を返します。
     ロックがすでに生成されている場合、現在のスレッドがロックを獲得
     していなければなりません。

`void PyEval_RestoreThread(PyThreadState *tstate)'
     (インタプリタロックが生成されていて、スレッドサポートが有効の
     場合) インタプリタロックを獲得して、現在のスレッド状態を TSTATE
     に設定します。TSTATE は `NULL'であっては なりません。
     この関数を呼び出したスレッドがすでにロックを獲得している場合、
     デッドロックに陥ります。
     (この関数はコンパイル時にスレッドサポートを無効化すると利用できません。)

以下のマクロは、通常末尾にセミコロンを付けずに使います; Python
ソース配布物内の使用例を見てください。

`Py_BEGIN_ALLOW_THREADS'
     このマクロを展開すると `{ PyThreadState *_save; _save =
     PyEval_SaveThread();' になります。
     マクロに開き波括弧が入っていることに注意してください; この波括弧は
     後で `Py_END_ALLOW_THREADS' マクロと対応させなければ なりません。
     マクロについての詳しい議論は上記を参照してください。
     コンパイル時にスレッドサポートが無効化されていると何も行いません。

`Py_END_ALLOW_THREADS'
     このマクロを展開すると `PyEval_RestoreThread(_save); }'
     になります。 マクロに開き波括弧が入っていることに注意してください;
     この波括弧は 事前の `Py_BEGIN_ALLOW_THREADS' マクロと対応して
     いなければなりません。
     マクロについての詳しい議論は上記を参照してください。
     コンパイル時にスレッドサポートが無効化されていると何も行いません。

`Py_BLOCK_THREADS'
     このマクロを展開すると `PyEval_RestoreThread(_save);' になります:
     閉じ波括弧のない`Py_END_ALLOW_THREADS' と同じです。
     コンパイル時にスレッドサポートが無効化されていると何も行いません。

`Py_UNBLOCK_THREADS'
     このマクロを展開すると `_save = PyEval_SaveThread();' になります:
     閉じ波括弧のない`Py_BEGIN_ALLOW_THREADS' と同じです。
     コンパイル時にスレッドサポートが無効化されていると何も行いません。

以下の全ての関数はコンパイル時にスレッドサポートが有効になっている
時だけ利用でき、呼び出すのはインタプリタロックがすでに作成されている
場合だけにしなくてはなりません。

`PyInterpreterState* PyInterpreterState_New()'
     新しいインタプリタ状態オブジェクトを生成します。
     インタプリタロックを保持しておく必要はありませんが、この関数を次々に
     呼び出す必要がある場合には保持しておいたほうがよいでしょう。

`void PyInterpreterState_Clear(PyInterpreterState *interp)'
     インタプリタ状態オブジェクト内の全ての情報をリセットします。
     インタプリタロックを保持していなければなりません。

`void PyInterpreterState_Delete(PyInterpreterState *interp)'
     インタプリタ状態オブジェクトを破壊します。
     インタプリタロックを保持しておく必要はありません。
     インタプリタ状態は`PyInterpreterState_Clear()' であらかじめ
     リセットしておかなければなりません。

`PyThreadState* PyThreadState_New(PyInterpreterState *interp)'
     指定したインタプリタオブジェクトに属する新たなスレッド状態オブジェクトを
     生成します。
     インタプリタロックを保持しておく必要はありませんが、この関数を次々に
     呼び出す必要がある場合には保持しておいたほうがよいでしょう。

`void PyThreadState_Clear(PyThreadState *tstate)'
     スレッド状態オブジェクト内の全ての情報をリセットします。
     インタプリタロックを保持していなければなりません。

`void PyThreadState_Delete(PyThreadState *tstate)'
     スレッド状態オブジェクトを破壊します。
     インタプリタロックを保持していなければなりません。
     スレッド状態は`PyThreadState_Clear()' であらかじめ
     リセットしておかなければなりません。

`PyThreadState* PyThreadState_Get()'
     現在のスレッド状態を返します。
     インタプリタロックを保持していなければなりません。
     現在のスレッド状態が `NULL'なら、(呼び出し側が `NULL'チェックを
     しなくてすむように)
     この関数は致命的エラーを起こすようになっています。

`PyThreadState* PyThreadState_Swap(PyThreadState *tstate)'
     現在のスレッド状態を TSTATE に指定したスレッド状態と入れ変えます。
     TSTATE は`NULL'であってはなりません。
     インタプリタロックを保持していなければなりません。

`PyObject* PyThreadState_GetDict()'
     拡張モジュールがスレッド固有の状態情報を保存できるような辞書を返します。
     各々の拡張モジュールが辞書に状態情報を保存するためには唯一のキーを
     使わねばなりません。
     現在のスレッド状態がない時にこの関数を呼び出してもかまいません。
     この関数が `NULL'を返す場合、例外はまったく送出されず、呼び出し側は
     現在のスレッド状態が利用できないと考えねばなりません。 _Changed in
     Python version 2.3_

`int PyThreadState_SetAsyncExc(long id, PyObject *exc)'
     スレッド内で非同期的に例外を送出します。 ID
     引数はターゲットとなるスレッドのスレッド id です; EXC
     は送出する例外オブジェクトです。 この関数は EXC
     に対する参照を一切盗み取りません。
     素朴な間違いを防ぐため、この関数を呼び出すには独自に C
     拡張モジュール を書かねばなりません。
     グローバルインタプリタロックを保持した状態で呼び出さなければなりません。

     変更を受けたスレッド状態の数を返します;
     これは普通は1ですが、スレッドidが
     見つからなかった場合は0になります。 もし EXC が `NULL'
     であれば、そのスレッドで保留されている 例外があればクリアします。
     この関数自体は例外を送出しません。 _Added in Python version 2.3_

`PyGILState_STATE PyGILState_Ensure()'
     Pythonの状態やスレッドロックに関わらず、実行中スレッドでPython C
     APIの呼
     び出しが可能となるようにします。この関数はスレッド内で何度でも呼び出すこ
     とができますが、必ず全ての呼び出しに対応して
     `PyGILState_Release()'を呼び出す必要があります。

     通常、`PyGILState_Ensure()'呼び出しと
     `PyGILState_Release()'呼び出しの間でこれ以外のスレッド関連API
     を使用することができますが、Release()の前にスレッド状態は復元されていな
     ければなりません。通常の`Py_BEGIN_ALLOW_THREADS'マクロと
     `Py_END_ALLOW_THREADS'も使用することができます。

     戻り値は`PyGILState_Acquire()'呼び出し時のスレッド状態を隠蔽し
     た"ハンドル"で、`PyGILState_Release()'に渡してPythonを同じ状態
     に保たなければなりません。再起呼び出しも可能ですが、ハンドルを共有するこ
     とは_できません_ - それぞれの`PyGILState_Ensure'呼び出し
     でハンドルを保存し、対応する`PyGILState_Release'呼び出しで渡し
     てください。

     関数から復帰したとき、実行中のスレッドはGILを所有しています。処理の失敗
     は致命的なエラーです。

     _Added in Python version 2.3_

`void PyGILState_Release(PyGILState_STATE)'
     獲得したすべてのリソースを開放します。この関数を呼び出すと、Pythonの状態
     は対応する`PyGILState_Ensure'を呼び出す前と同じとなります。(通
     常、この状態は呼び出し元でははわかりませんので、GILState
     APIを利用するよ うにしてください。）

     `PyGILState_Ensure()'を呼び出す場合は、必ず同一スレッド内で対
     応する`PyGILState_Release()'を呼び出してください。 _Added in
     Python version 2.3_


File: python-api-jp.info,  Node: プロファイルとトレース profiling and tracing,  Next: 高度なデバッガサポート advanced debugger support,  Prev: スレッド状態 thread state とグローバルインタプリタロック global interpreter lock,  Up: 初期化 initialization、終了処理 finalization、スレッド

8.2 プロファイルとトレース (profiling and tracing)
==================================================

Python インタプリタは、プロファイル: 分析 (profile) や実行の トレース:
追跡 (trace) といった機能を組み込むために低水準の
サポートを提供しています。このサポートは、プロファイルや
デバッグ、適用範囲分析 (coverage analysis) ツールなどに使われます。

Python 2.2 になってから、この機能の実装は実質的に作り直され、 C
から呼び出すためのインタフェースが追加されました。 この C
インタフェースは、プロファイルやトレース作業時に、 Python
レベルの呼び出し可能オブジェクトが呼び出されることによる
オーバヘッドを避け、直接 C 関数呼び出しが行えるようにしています。
プロファイルやトレース機能の本質的な特性は変わっていません;
インタフェースではとレース関数をスレッドごとにインストールでき、
トレース関数に報告される基本イベント (basic event) は以前の
バージョンにおいて Python レベルのトレース関数で報告されていた
ものと同じです。

`int (*Py_tracefunc)(PyObject *obj, PyFrameObject *frame, int what, PyObject *arg)'
     `PyEval_SetProfile()' および `PyEval_SetTrace()'
     を使って登録できるトレース関数の形式です。最初のパラメタは
     オブジェクトで、登録関数に OBJ として渡されます。 FRAME
     はイベントが属している実行フレームオブジェクトで、 WHAT は定数
     `PyTrace_CALL', `PyTrace_EXCEPTION', `PyTrace_LINE',
     `PyTrace_RETURN', `PyTrace_C_CALL', `PyTrace_C_EXCEPTION',
     あるいは`PyTrace_C_RETURN' のいずれかで、ARG は WHAT
     の値によって以下のように 異なります:

     WHAT の値                          ARG の意味
     ------                             -----
     PyTrace_CALL                       常に `NULL'です。
     PyTrace_EXCEPTION                  `sys.exc_info()'
                                        の返す例外情報です。
     PyTrace_LINE                       常に `NULL'です。
     PyTrace_RETURN                     呼び出し側に返される予定の値です。
     PyTrace_C_CALL                     呼び出している関数の名前です。
     PyTrace_C_EXCEPTION                常に `NULL'です。
     PyTrace_C_RETURN                   常に `NULL'です。


`int PyTrace_CALL'
     関数やメソッドが新たに呼び出されたり、ジェネレータが新たなエントリの
     処理に入ったことを報告する際の、`Py_tracefunc' のWHAT の
     値です。イテレータやジェネレータ関数の生成は、対応するフレーム内の
     Python バイトコードに制御の委譲 (control transfer) が起こらない
     ため報告されないので注意してください。

`int PyTrace_EXCEPTION'
     例外が送出された際の`Py_tracefunc' のWHAT の値です。
     現在実行されているフレームで例外がセットされ、何らかのバイトコードが
     処理された後に、WHAT にこの値がセットされた状態でコールバック
     関数が呼び出されます。

     この結果、例外の伝播によって Python が呼び出しスタックを逆戻りする
     際に、各フレームから処理が戻るごとにコールバック関数が呼び出されます。
     トレース関数だけがこれらのイベントを受け取ります; プロファイラは
     この種のイベントを必要としません。

`int PyTrace_LINE'
     行番号イベントを報告するときに (プロファイル関数ではなく)
     トレース関数のWHAT パラメタとして渡す値です。

`int PyTrace_RETURN'
     関数呼び出しが例外の伝播なしに返るときに `Py_tracefunc' 関数のWHAT
     パラメタとして渡す値です。

`int PyTrace_C_CALL'
     C関数を呼び出す直前に `Py_tracefunc' 関数のWHAT
     パラメタとして渡す値です。

`int PyTrace_C_EXCEPTION'
     C関数が例外を送出したときに `Py_tracefunc' 関数のWHAT
     パラメタとして渡す値です。

`int PyTrace_C_RETURN'
     C関数から戻るときに `Py_tracefunc' 関数のWHAT
     パラメタとして渡す値です。

`void PyEval_SetProfile(Py_tracefunc func, PyObject *obj)'
     プロファイル関数を FUNC に設定します。OBJ パラメタは
     関数の第一パラメタとして渡され、何らかの Python
     オブジェクトかまたは
     `NULL'になります。プロファイル関数がスレッド状態を維持する必要が
     あるなら、各々のスレッドに異なる OBJ を使うことで、状態を
     記憶しておく便利でスレッドセーフな場所を提供できます。プロファイル
     関数は、モニタされているイベントのうち、行番号イベントを除く全ての
     イベントに対して呼び出されます。

`void PyEval_SetTrace(Py_tracefunc func, PyObject *obj)'
     トレース関数を FUNC にセットします。 `PyEval_SetProfile()'
     に似ていますが、トレース関数は
     行番号イベントを受け取る点が違います。


File: python-api-jp.info,  Node: 高度なデバッガサポート advanced debugger support,  Prev: プロファイルとトレース profiling and tracing,  Up: 初期化 initialization、終了処理 finalization、スレッド

8.3 高度なデバッガサポート (advanced debugger support)
======================================================

以下の関数は高度なデバッグツールでの使用のためだけのものです。

`PyInterpreterState* PyInterpreterState_Head()'
     インタプリタ状態オブジェクトからなるリストのうち、先頭にあるもの
     を返します。 _Added in Python version 2.2_

`PyInterpreterState* PyInterpreterState_Next(PyInterpreterState *interp)'
     インタプリタ状態オブジェクトからなるリストのうち、INTERP の
     次にあるものを返します。 _Added in Python version 2.2_

`PyThreadState * PyInterpreterState_ThreadHead(PyInterpreterState *interp)'
     インタプリタ INTERP に関連付けられているスレッドからなるリストの
     うち、先頭にある `PyThreadState' オブジェクトを返します。 _Added
     in Python version 2.2_

`PyThreadState* PyThreadState_Next(PyThreadState *tstate)'
     TSTATE と同じ`PyInterpreterState' オブジェクトに属している
     スレッド状態オブジェクトのうち、TSTATE の次にあるものを返します。
     _Added in Python version 2.2_


File: python-api-jp.info,  Node: メモリ管理,  Next: オブジェクト実装サポート object implementation support,  Prev: 初期化 initialization、終了処理 finalization、スレッド,  Up: Top

9 メモリ管理
************

* Menu:

* 概要::
* メモリインタフェース::
* 例::

