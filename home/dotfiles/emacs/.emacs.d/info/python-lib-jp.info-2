これは python-lib-jp.info、python-lib-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-lib-jp.info,  Node: 標準エンコーディング,  Next: encodingsidna --- アプリケーションにおける国際化ドメイン名 IDNA,  Prev: エンコーディングと Unicode,  Up: codecs

4.8.3 標準エンコーディング
--------------------------

Python には数多くの codec が組み込みで付属します。これらは C 言語の
関数、対応付けを行うテーブルの両方で提供されています。以下のテーブル
では codec と、いくつかの良く知られている別名と、エンコーディング
が使われる言語を列挙します。別名のリスト、言語のリストともしらみつぶしに
網羅されているわけではありません。大文字と小文字、またはアンダースコア
の代りにハイフンにしただけの綴りも有効な別名です。

多くの文字セットは同じ言語をサポートしています。これらの文字セットは
個々の文字 (例えば、EURO SIGN がサポートされているかどうか) や、
文字のコード部分への割り付けが異なります。特に欧州言語では、
典型的に以下の変種が存在します:

   * ISO 8859 コードセット

   * Microsoft Windows コードページで、8859 コード形式から導出されて
     いるが、制御文字を追加のグラフィック文字と置き換えたもの

   * IBM EBCDIC コードページ

   * ASCII 互換の IBM PC コードページ

Codec                    別名                     言語
------                   -----                    -----
ascii                    646, us-ascii            英語
big5                     big5-tw, csbig5          繁体字中国語
big5hkscs                big5-hkscs, hkscs        繁体字中国語
cp037                    IBM037, IBM039           英語
cp424                    EBCDIC-CP-HE, IBM424     ヘブライ語
cp437                    437, IBM437              英語
cp500                    EBCDIC-CP-BE,            西ヨーロッパ言語
                         EBCDIC-CP-CH, IBM500     
cp737                                             ギリシャ語
cp775                    IBM775                   バルト沿岸国
cp850                    850, IBM850              西ヨーロッパ
cp852                    852, IBM852              中央および東ヨーロッパ
cp855                    855, IBM855              ブルガリア、ベラルーシ、マケドニア、ロシア、セルビア
cp856                                             ヘブライ語
cp857                    857, IBM857              トルコ語
cp860                    860, IBM860              ポルトガル語
cp861                    861, CP-IS, IBM861       アイスランド語
cp862                    862, IBM862              ヘブライ語
cp863                    863, IBM863              カナダ
cp864                    IBM864                   アラビア語
cp865                    865, IBM865              デンマーク、ノルウェー
cp866                    866, IBM866              ロシア語
cp869                    869, CP-GR, IBM869       ギリシャ語
cp874                                             タイ語
cp875                                             ギリシャ語
cp932                    932, ms932, mskanji,     日本語
                         ms-kanji                 
cp949                    949, ms949, uhc          韓国語
cp950                    950, ms950               繁体字中国語
cp1006                                            Urdu
cp1026                   ibm1026                  トルコ語
cp1140                   ibm1140                  西ヨーロッパ
cp1250                   windows-1250             中央および東ヨーロッパ
cp1251                   windows-1251             ブルガリア、ベラルーシ、マケドニア、ロシア、セルビア
cp1252                   windows-1252             西ヨーロッパ
cp1253                   windows-1253             ギリシャ
cp1254                   windows-1254             トルコ
cp1255                   windows-1255             ヘブライ
cp1256                   windows1256              アラビア
cp1257                   windows-1257             バルト沿岸国
cp1258                   windows-1258             ベトナム
euc_jp                   eucjp, ujis, u-jis       日本語
euc_jis_2004             jisx0213, eucjis2004     日本語
euc_jisx0213             eucjisx0213              日本語
euc_kr                   euckr, korean, ksc5601,  韓国語
                         ks_c-5601,               
                         ks_c-5601-1987,          
                         ksx1001, ks_x-1001       
gb2312                   chinese,                 簡体字中国語
                         csiso58gb231280,         
                         euc-cn, euccn,           
                         eucgb2312-cn,            
                         gb2312-1980, gb2312-80,  
                         iso-ir-58                
gbk                      936, cp936, ms936        簡体字中国語
gb18030                  gb18030-2000             簡体字中国語
hz                       hzgb, hz-gb, hz-gb-2312  簡体字中国語
iso2022_jp               csiso2022jp, iso2022jp,  日本語
                         iso-2022-jp              
iso2022_jp_1             iso2022jp-1,             日本語
                         iso-2022-jp-1            
iso2022_jp_2             iso2022jp-2,             日本語, 韓国語,
                         iso-2022-jp-2            簡体字中国語, 西欧,
                                                  ギリシャ語
iso2022_jp_2004          iso2022jp-2004,          日本語
                         iso-2022-jp-2004         
iso2022_jp_3             iso2022jp-3,             日本語
                         iso-2022-jp-3            
iso2022_jp_ext           iso2022jp-ext,           日本語
                         iso-2022-jp-ext          
iso2022_kr               csiso2022kr, iso2022kr,  韓国語
                         iso-2022-kr              
latin_1                  iso-8859-1, iso8859-1,   西ヨーロッパ
                         8859, cp819, latin,      
                         latin1, L1               
iso8859_2                iso-8859-2, latin2, L2   中央および東ヨーロッパ
iso8859_3                iso-8859-3, latin3, L3   エスペラント、マルタ
iso8859_4                iso-8859-4, latin4, L4   バルト沿岸国
iso8859_5                iso-8859-5, cyrillic     ブルガリア、ベラルーシ、マケドニア、ロシア、セルビア
iso8859_6                iso-8859-6, arabic       アラビア語
iso8859_7                iso-8859-7, greek,       ギリシャ語
                         greek8                   
iso8859_8                iso-8859-8, hebrew       ヘブライ語
iso8859_9                iso-8859-9, latin5, L5   トルコ語
iso8859_10               iso-8859-10, latin6, L6  北欧
iso8859_13               iso-8859-13              バルト沿岸国
iso8859_14               iso-8859-14, latin8, L8  ケルト
iso8859_15               iso-8859-15              西ヨーロッパ
johab                    cp1361, ms1361           韓国語
koi8_r                                            ロシア語
koi8_u                                            ウクライナ
mac_cyrillic             maccyrillic              ブルガリア、ベラルーシ、マケドニア、ロシア、セルビア
mac_greek                macgreek                 ギリシャ
mac_iceland              maciceland               アイスランド
mac_latin2               maclatin2,               中央および東ヨーロッパ
                         maccentraleurope         
mac_roman                macroman                 西ヨーロッパ
mac_turkish              macturkish               トルコ語
ptcp154                  csptcp154, pt154,        カザフ
                         cp154, cyrillic-asian    
shift_jis                csshiftjis, shiftjis,    日本語
                         sjis, s_jis              
shift_jis_2004           shiftjis2004,            日本語
                         sjis_2004, sjis2004      
shift_jisx0213           shiftjisx0213,           日本語
                         sjisx0213, s_jisx0213    
utf_16                   U16, utf16               全ての言語
utf_16_be                UTF-16BE                 全ての言語 (BMP only)
utf_16_le                UTF-16LE                 全ての言語 (BMP only)
utf_7                    U7, unicode-1-1-utf-7    全ての言語
utf_8                    U8, UTF, utf8            全ての言語
utf_8_sig                                         全ての言語

codec のいくつかは Python 特有のものなので、それらの codec 名は Python
の外では無意味なものとなります。これらの codec の中には Unicode
文字列からバイト文字列への変換を行わず、むしろ単一の
引数をもつ全写像関数はエンコーディングとみなせるという Python codec
の性質を利用したものもあります。

以下に列挙した codec では、"エンコード" 方向の結果は常にバイト文字列
方向です。"デコード" 方向の結果はテーブル内の被演算子型として列挙
されています。

Codec              別名               被演算子の型       目的
------             ------             ------             ------
base64_codec       base64, base-64    byte string        被演算子を MIME
                                                         base64
                                                         に変換します。
bz2_codec          bz2                byte string        被演算子をbz2を使って圧縮します。
hex_codec          hex                byte string        被演算子をバイトあたり
                                                         2 桁の 16
                                                         進数の表現に変換します。
idna                                  Unicode string     RFC 3490
                                                         の実装です。
                                                         _Added in Python
                                                         version 2.3_
                                                         `encodings.idna'
                                                         も参照してください。
mbcs               dbcs               Unicode string     Windows のみ:
                                                         被演算子を ANSI
                                                         コードページ
                                                         (CP_ACP) に従って
                                                         エンコードします。
palmos                                Unicode string     PalmOS 3.5
                                                         のエンコーディングです。
punycode                              Unicode string     RFC 3492
                                                         を実装しています。
                                                         _Added in Python
                                                         version 2.3_
quopri_codec       quopri,            byte string        被演算子を MIME
                   quoted-printable,                     quoted printable
                   quotedprintable                       形式に変換します。
raw_unicode_escape                    Unicode string     Python
                                                         ソースコードにおける
                                                         raw Unicode
                                                         リテラルとして
                                                         適切な文字列を生成します。
rot_13             rot13              Unicode string     被演算子のシーザー暗号
                                                         (Caesar-cypher)
                                                         を返します。
string_escape                         byte string        Python
                                                         ソースコードにおける文字列リテラルとして適切な
                                                         文字列を生成します。
undefined                             any                全ての変換に対して例外を送出します。
                                                         バイト列と
                                                         Unicode
                                                         文字列との間で自動的な型強制をおこないたくない
                                                         時にシステムエンコーディングとして使うことができます。
unicode_escape                        Unicode string     Python
                                                         ソースコードにおける
                                                         Unicode
                                                         リテラルとして適切な
                                                         文字列を生成します。
unicode_internal                      Unicode string     被演算子の内部表現を返します。
uu_codec           uu                 byte string        被演算子を
                                                         uuencode
                                                         を用いて変換します。
zlib_codec         zip, zlib          byte string        被演算子を gzip
                                                         を用いて圧縮します。


File: python-lib-jp.info,  Node: encodingsidna --- アプリケーションにおける国際化ドメイン名 IDNA,  Next: encodingsutf_8_sig --- BOM 印付き UTF-8,  Prev: 標準エンコーディング,  Up: codecs

4.8.4 `encodings.idna' -- アプリケーションにおける国際化ドメイン名 (IDNA)
-------------------------------------------------------------------------

国際化ドメイン名実装

_Added in Python version 2.3_

このモジュールでは RFC 3490 (アプリケーションにおける国際化 ドメイン名,
IDNA: Internationalized Domain Names in Applications) および RFC 3492 (Nameprep:
国際化ドメイン名 (IDN) の ための stringprep プロファイル)
を実装しています。 このモジュールは `punycode' エンコーディングおよび
`stringprep' の上に構築されています。

これらの RFC はともに、非 ASCII 文字の入ったドメイン名をサポートする
ためのプロトコルを定義しています。 ("www.Alliancefranc,aise.nu"
のような) 非 ASCII 文字を含む ドメイン名は、
ASCIIと互換性のあるエンコーディング (ACE、
"www.xn-alliancefranaise-npb.nu" のような形式) に変換されます。
ドメイン名の ACE 形式は、DNS クエリ、HTTP `Host' フィールド
などといった、プロトコル中で任意の文字を使えないような全ての局面で
用いられます。 この変換はアプリケーション内で行われます;
可能ならユーザからは 不可視となります: アプリケーションは Unicode
ドメインラベルを ワイヤ上に載せる際に IDNA に、 ACE ドメインラベルを
ユーザに提供する前に Unicode に、それぞれ透過的に変換しなければ
なりません。

Python ではこの変換をいくつかの方法でサポートします: `idna' codec は
Unicode と ACE 間の変換を行います。さらに、 `socket' モジュールは
Unicode ホスト名を ACE に透過的に
変換するため、アプリケーションはホスト名を `socket'
モジュールに渡す際にホスト名の変換に煩わされることがありません。
その上で、ホスト名を関数パラメタとして持つ、`httplib' や `ftplib'
のようなモジュールでは Unicode ホスト名を 受理します (`httplib'
でもまた、`Host:' フィールドにある IDNA
ホスト名を、フィールド全体を送信する場合に透過的に送信 します)。

(逆引きなどによって) ワイヤ越しにホスト名を受信する際、Unicode
への自動変換は行われません: こうしたホスト名をユーザに提供
したいアプリケーションでは、Unicode にデコードしてやる必要が あります。

`encodings.idna' ではまた、nameprep 手続きを実装しています。 nameprep
はホスト名に対してある正規化を行って、国際化ドメイン名で
大小文字を区別しないようにするとともに、類似の文字を一元化します。
nameprep 関数は必要なら直接使うこともできます。

`nameprep(label)'
     LABEL を nameprep したバージョンを返します。現在の実装では
     クエリ文字列を仮定しているので、 `AllowUnassigned' は真です。

`ToASCII(label)'
     RFC 3490 仕様に従ってラベルを ASCIIに変換します。
     `UseSTD3ASCIIRules' は偽であると仮定します。

`ToUnicode(label)'
     RFC 3490 仕様に従ってラベルを Unicode に変換します。


File: python-lib-jp.info,  Node: encodingsutf_8_sig --- BOM 印付き UTF-8,  Prev: encodingsidna --- アプリケーションにおける国際化ドメイン名 IDNA,  Up: codecs

4.8.5 `encodings.utf_8_sig' -- BOM 印付き UTF-8
-----------------------------------------------

UTF-8 codec with BOM signature

_Added in Python version 2.5_

このモジュールは UTF-8 codec
の変種を実装します。この変種はエンコーディング時に UTF-8
でエンコードされた BOM を UTF-8
でエンコードされたバイト列の前に追加します。
内部状態を持つエンコーダにとって、これは一度だけ(バイトストリームの最初の書き込み時)
行なわれます。デコーディングに際してはデータ開始の UTF-8
でエンコードされた BOM がもしあったらスキップします。


File: python-lib-jp.info,  Node: unicodedata,  Next: stringprep,  Prev: codecs,  Up: 文字列処理

4.9 Unicode データベース
========================

Access the Unicode Database.

このモジュールは、全ての Unicode 文字の属性を定義している Unicode
文字データベースへのアクセスを提供します。このデータベース内のデータは、`ftp://ftp.unicode.org/'
で公開されている `UnicodeData.txt' ファイルのバージョン 4.1.0
に基づいています。

このモジュールは、UnicodeData ファイルフォーマット 4.1.0
(`http://www.unicode.org/Public/4.1.0/ucd/UCD.html'
を参照）で定義されているものと、同じ名前と記号を使います。このモジュールで定義されている関数は、以下のとおりです。

`lookup(name)'
     名前に対応する文字を探します。その名前の文字が見つ かった場合、
     その Unicode
     文字が返されます。見つからなかった場合には、`KeyError'
     を発生させます。

`name(unichr[, default])'
     Unicode 文字 UNICHR
     に付いている名前を、文字列で返します。名前が定義されていない場合には
     DEFAULT が返されますが、この引数が与えられていなければ
     `ValueError' を発生させます。

`decimal(unichr[, default])'
     Unicode 文字 UNICHR
     に割り当てられている十進数を、整数で返します。この値が定義されていない場合には
     DEFAULT が返されますが、この引数が与えられていなければ
     `ValueError' を発生させます。

`digit(unichr[, default])'
     Unicode 文字 UNICHR
     に割り当てられている二進数を、整数で返します。この値が定義されていない場合には
     DEFAULT が返されますが、この引数が与えられていなければ
     `ValueError' を発生させます。

`numeric(unichr[, default])'
     Unicode 文字 UNICHR に割り当てられている数値を、float
     型で返します。 この値が定義されていない場合には DEFAULT
     が返されますが、この引 数が与えられていなければ `ValueError'
     を発生させます。

`category(unichr)'
     Unicode 文字 UNICHR に割り当てられた、汎用カテゴリを返します。

`bidirectional(unichr)'
     Unicode 文字 UNICHR
     に割り当てられた、双方向カテゴリを返します。そのような値が定義されていない場合、空の文字列が返されます。

`combining(unichr)'
     Unicode 文字 UNICHR
     に割り当てられた正規結合クラスを返します。結合クラス定義されていない場合、`0'
     が返されます。

`east_asian_width(unichr)'
     UNICHR as string.  ユニコード文字UNICHRに割り当てられたeast asian
     widthを文字列で 返します。 _Added in Python version 2.4_

`mirrored(unichr)'
     Unicode 文字 UNICHR
     に割り当てられた、鏡像化のプロパティを返します。
     その文字が双方向テキスト内で鏡像化された文字である場合には `1'
     を、それ以外の場合には `0' を返します。

`decomposition(unichr)'
     Unicode 文字 UNICHR
     に割り当てられた、文字分解マッピングを、文字列型で返します。そのようなマッピングが定義されていない場合、空の文字列が返されます。

`normalize(form, unistr)'
     Unicode 文字列 UNISTR の正規形 FORM を返します。 FORM
     の有効な値は、'NFC'、'NFKC'、'NFD'、'NFKD' です。

     Unicode 規格は標準等価性 (canonical equivalence) と 互換等価性
     (compatibility equivalence) に基づいて、様々な
     Unicode文字列の正規形を定義します。Unicode
     では、複数の方法で表現できる文字があります。たとえば、文字 U+00C7
     (LATIN CAPITAL LETTER C WITH CEDILLA) は、U+0043 (LATIN CAPITAL
     LETTER C) U+0327 (COMBINING CEDILLA)
     というシーケンスとしても表現できます。

     各文字には、2つの正規形があり、それぞれ 正規形 C と 正規形 D
     といいます。正規形 D (NFD) は標準分解 (canonical decomposition)
     としても知られており、各文字を分解された形に変換します。正規形 C
     (NFC) は標準分解を適用した後、結合済文字を再構成します。

     互換等価性に基づいて、2つの正規形が加えられています。Unicode
     では、一般に他の文字との統合がサポートされている文字があります。たとえば、U+2160
     (ROMAN NUMERAL ONE) は事実上 U+0049 (LATIN CAPITAL LETTER I)
     と同じものです。しかし、Unicode では、既存の文字集合 (たとえば
     gb2312) との互換性のために、これがサポートされています。

     正規形 KD (NFKD) は、互換分解 (compatibility decomposition)
     を適用します。すなわち、すべての互換文字を、等価な文字で置換します。
     正規形 KC (NFKC) は、互換分解を適用してから、標準分解を適用します。

     _Added in Python version 2.3_

更に、本モジュールは以下の定数を公開します。

`unidata_version'
     このモジュールで使われている Unicode データベースのバージョン。

     _Added in Python version 2.3_

`ucd_3_2_0'
     これはモジュール全体と同じメソッドを具えたオブジェクトですが、Unicode
     データベース バージョン 3.2
     を代わりに使っており、この特定のバージョンの Unicode データベースを
     必要とするアプリケーション(IDNA など)のためものです。

     _Added in Python version 2.5_

例:

     >>> unicodedata.lookup('LEFT CURLY BRACKET')
     u'{'
     >>> unicodedata.name(u'/')
     'SOLIDUS'
     >>> unicodedata.decimal(u'9')
     9
     >>> unicodedata.decimal(u'a')
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: not a decimal
     >>> unicodedata.category(u'A')  # 'L'etter, 'u'ppercase
     'Lu'
     >>> unicodedata.bidirectional(u'\u0660') # 'A'rabic, 'N'umber
     'AN'


File: python-lib-jp.info,  Node: stringprep,  Next: fpformat,  Prev: unicodedata,  Up: 文字列処理

4.10 インターネットのための文字列調製
=====================================

RFC 3453 による文字列調製

_Added in Python version 2.3_

(ホスト名のような) インターネット上にある存在に識別名をつける際、
しばしば識別名間の "等価性" 比較を行う必要があります。
厳密には、例えば大小文字の区別をするかしないかいったように、
比較をどのように行うかはアプリケーションの領域に依存します。
また、例えば "印字可能な" 文字で構成された識別名だけを許可すると
いったように、可能な識別名を制限することも必要となるかもしれません。

RFC 3454 では、インターネットプロトコル上で Unicode 文字列を "調製
(prepare)" するためのプロシジャを定義しています。文字列は
通信路に載せられる前に調製プロシジャで処理され、その結果ある正規化
された形式になります。RFC ではあるテーブルの集合を定義しており、
それらはプロファイルにまとめられています。各プロファイルでは、どの
テーブルを使い、`stringprep' プロシジャのどのオプション部分が
プロファイルの一部になっているかを定義しています。 `stringprep'
プロファイルの一つの例は `nameprep' で、
国際化されたドメイン名に使われます。

`stringprep' は RFC 3453 のテーブルを公開しているに
過ぎません。これらのテーブルは辞書やリストとして表　現するには
バリエーションが大きすぎるので、このモジュールでは Unicode
文字データベースを内部的に利用しています。モジュールソースコード 自体は
`mkstringprep.py' ユーティリティを使って生成されました。

その結果、これらのテーブルはデータ構造体ではなく、関数として
公開されています。RFC には 2 種類のテーブル: 集合およびマップ、
が存在します。集合については、`stringprep' は "特性関数 (characteristic
function)" 、すなわち引数が
集合の一部である場合に真を返す関数を提供します。マップに対しては、
マップ関数: キーが与えられると、それに関連付けられた値を返す関数、
を提供します。以下はこのモジュールで利用可能な全ての関数を列挙した
ものです。

`in_table_a1(code)'
     CODE がテーブル {A.1} (Unicode 3.2 における未割り当てコード点:
     unassigned code point) かどうか判定します。

`in_table_b1(code)'
     CODE がテーブル {B.1} (一般には何にも対応付けられていない:
     commonly mapped to nothing) かどうか判定します。


`map_table_b2(code)'
     テーブル {B.2} (NFKC で用いられる大小文字の対応付け) に従って、
     CODE に対応付けられた値を返します。


`map_table_b3(code)'
     テーブル {B.3} (正規化を伴わない大小文字の対応付け) に従って、
     CODE に対応付けられた値を返します。

`in_table_c11(code)'
     CODE がテーブル {C.1.1} (ASCII スペース文字) かどうか判定します。

`in_table_c12(code)'
     CODE がテーブル {C.1.2} (非 ASCII スペース文字)
     かどうか判定します。


`in_table_c11_c12(code)'
     CODE がテーブル {C.1} (スペース文字、C.1.1 および C.1.2 の和集合)
     かどうか判定します。


`in_table_c21(code)'
     CODE がテーブル {C.2.1} (ASCII 制御文字) かどうか判定します。

`in_table_c22(code)'
     CODE がテーブル {C.2.2} (非 ASCII 制御文字) かどうか判定します。

`in_table_c21_c22(code)'
     CODE がテーブル {C.2} (制御文字、C.2.1 および C.2.2 の和集合)
     かどうか判定します。

`in_table_c3(code)'
     CODE がテーブル {C.3} (プライベート利用) かどうか判定します。

`in_table_c4(code)'
     CODE がテーブル {C.4} (非文字コード点: non-character code points)
     かどうか判定します。

`in_table_c5(code)'
     CODE がテーブル {C.5} (サロゲーションコード) かどうか判定します。

`in_table_c6(code)'
     CODE がテーブル {C.6} (平文:plain text として不適切) かどうか
     判定します。


`in_table_c7(code)'
     CODE がテーブル {C.7} (標準表現:canonical representation
     として不適切) かどうか判定します。

`in_table_c8(code)'
     CODE がテーブル {C.8} (表示プロパティの変更または撤廃) か
     どうか判定します。

`in_table_c9(code)'
     CODE がテーブル {C.9} (タグ文字) かどうか判定します。

`in_table_d1(code)'
     CODE がテーブル {D.1} (双方向プロパティ "R" または "AL"
     を持つ文字) かどうか判定します。

`in_table_d2(code)'
     CODE がテーブル {D.2} (双方向プロパティ "L" を持つ文字)
     かどうか判定します。


File: python-lib-jp.info,  Node: fpformat,  Prev: stringprep,  Up: 文字列処理

4.11 浮動小数点の変換
=====================

浮動小数点をフォーマットする汎用関数。

_Note:_ This module is unneeded: everything here could be done via the
`%' string interpolation operator.

`fpformat' モジュールは浮動小数点数の表示を 100% 純粋に Python だけで
行うための関数を定義しています。 _Note:_
このモジュールは必要ありません: このモジュールのすべてのことは、 `%'
を使って、文字列の補間演算により可能です。

`fpformat' モジュールは次にあげる関数と例外を定義しています。

`fix(x, digs)'
     X を `[-]ddd.ddd' の形にフォーマットします。 小数点の後ろに DIGS
     桁と、小数点の前に少なくとも1桁です。 `var{digs} <= 0'
     の場合、小数点以下は切り捨てられます。

     X は数字か数字を表した文字列です。

     DIGS は整数です。

     返り値は文字列です。

`sci(x, digs)'
     X を `[-]d.dddE[+-]ddd' の形にフォーマットします。 小数点の後ろに
     DIGS 桁と、小数点の前に1桁だけです。

     `var{digs} <= 0'
     の場合、1桁だけ残され、小数点以下は切り捨てられます。

     X は実数か実数を表した文字列です。

     DIGS は整数です。

     返り値は文字列です。

`NotANumber'
     `fix()' や `sci()' にパラメータとして渡された文字列 X が
     数字として認識できなかった場合、例外が発生します。
     標準の例外が文字列の場合、この例外は `ValueError'
     のサブクラスです。
     例外値は、例外を発生させた不適切にフォーマットされた文字列です。


例:

     >>> import fpformat
     >>> fpformat.fix(1.23, 1)
     '1.2'


File: python-lib-jp.info,  Node: データ型,  Next: 数値と数学モジュール,  Prev: 文字列処理,  Up: Top

5 データ型
**********

この章で解説されるモジュールは日付や時間、型が固定された配列、ヒープキュ
ー、同期キュー、集合のような種々の特殊なデータ型を 提供します。

この章で解説されるモジュールの完全な一覧は:

* Menu:

* datetime::
* calendar::
* collections::
* heapq::
* bisect::
* array::
* sets::
* sched::
* mutex::
* Queue::
* weakref::
* UserDict::
* UserList::
* UserString::
* types::
* new::
* copy::
* pprint::
* repr::


File: python-lib-jp.info,  Node: datetime,  Next: calendar,  Prev: データ型,  Up: データ型

5.1 基本的な日付型および時間型
==============================

基本的な日付型および時間型。

_Added in Python version 2.3_

`datetime' モジュールでは、日付や時間データを簡単な方法と
複雑な方法の両方で操作するためのクラスを提供しています。
日付や時刻を対象にした四則演算がサポートされている一方で、
このモジュールの実装では出力の書式化や操作を目的とした
データメンバの効率的な取り出しに焦点を絞っています。

日付および時刻オブジェクトには、"naive" および "aware" の
2種類があります。この区別はオブジェクトがタイムゾーン
や夏時間、あるいはその他のアルゴリズム的、政治的な理由に
よる時刻の修正に関する何らかの表記をもつかどうかによるものです。
特定の数字がメートルか、マイルか、質量を表すかといったことが
プログラムの問題であるように、 naive な `datetime'
オブジェクトが標準世界時 (UTC: Coordinated Universal time)
を表現するか、ローカルの時刻を表現するか、
ありは他のいずれかのタイムゾーンにおける時刻を表現するかは
純粋にプログラムの問題となります。 naive な `datetime' オブジェクトは、
現実世界のいくつかの側面を無視するという犠牲のもとに、
理解しやすく、かつ利用しやすくなっています。

より多くの情報を必要とするアプリケーションのために、 `datetime' および
`time' オブジェクトはオプションの タイムゾーン情報メンバ、`tzinfo'
を持っています。このメンバ には抽象クラス `tzinfo'
のサブクラスのインスタンスが入って います。`tzinfo' オブジェクトは UTC
時刻からのオフセット、
タイムゾーン名、夏時間が有効になっているかどうか、といった情報
を記憶しています。 `datetime' モジュールでは具体的な `tsinfo' クラスを
提供していないので注意してください。必要な詳細仕様を備えた
タイムゾーン機能を提供するのはアプリケーションの責任です。
世界各国における時刻の修正に関する法則は合理的というよりも政治的な
ものであり、全てのアプリケーションに適した標準というものが
存在しないのです。

`datetime' モジュールでは以下の定数を公開しています:

`MINYEAR'
     `date' や `datetime' オブジェクトで許されている、
     年を表現する最小の数字です。`MINYEAR' は `1' です。

`MAXYEAR'
     `date' や `datetime' オブジェクトで許されている、
     年を表現する最大の数字です。`MAXYEAR' は `9999' です。

See also:
     *Note calendar:: 汎用のカレンダー関連関数。 *Note time::
     時刻へのアクセスと変換。

* Menu:

* 利用可能なデータ型::
* timedelta オブジェクト::
* date オブジェクト::
* datetime オブジェクト::
* time オブジェクト::
* tzinfo オブジェクト::
* strftime の振る舞い::
* 使用例::


File: python-lib-jp.info,  Node: 利用可能なデータ型,  Next: timedelta オブジェクト,  Prev: datetime,  Up: datetime

5.1.1 利用可能なデータ型
------------------------

`date'
     理想化された naive な日付表現で、実質的には、これまでもこれからも
     現在のグレゴリオ暦 (Gregorian calender) であると仮定しています。
     属性: `year'、 `month'、および `day'。

`time'
     理想化された時刻表現で、あらゆる特定の日における影響から独立
     しており、毎日厳密に 24*60*60 秒であると仮定します ("うるう秒:
     leap seconds" の概念はありません)。 属性: `hour'、
     `minute'、`second'、 `microsecond'、 および `tzinfo'。

`datetime'
     日付と時刻を組み合わせたもの。 属性: `year'、 `month'、 `day'、
     `hour'、 `minute'、 `second'、 `microsecond'、および `tzinfo'。

`timedelta'
     `date'、`time'、あるいは `datetime' クラスの
     二つのインスタンス間の時間差をマイクロ秒精度で表す経過時間値です。

`tzinfo'
     タイムゾーン情報オブジェクトの抽象基底クラスです。 `datetime'
     および `time' クラスで用いられ、 カスタマイズ可能な時刻修正の概念
     (たとえばタイムゾーンや 夏時間の計算）を提供します。

これらの型のオブジェクトは変更不可能 (immutable) です。

`date' 型のオブジェクトは常に naive です。

`time' や `datetime' 型のオブジェクト D は naive にも aware
にもできます。D は `D.tzinfo' が `None' でなく、かつ
`D.tzinfo.utcoffset(D)' が `None' を返さない場合に aware
となります。`D.tzinfo' が `None' の場合や、`D.tzinfo' は `None' では
ないが `D.tzinfo.utcoffset(D)' が `None' を 返す場合には、D は naive
となります。

naive なオブジェクトと aware なオブジェクトの区別は `timedelta'
オブジェクトにはあてはまりません。

サブクラスの関係は以下のようになります:

     object
         timedelta
         tzinfo
         time
         date
             datetime


File: python-lib-jp.info,  Node: timedelta オブジェクト,  Next: date オブジェクト,  Prev: 利用可能なデータ型,  Up: datetime

5.1.2 `timedelta' オブジェクト
------------------------------

`timedelta' オブジェクトは経過時間、すなわち二つの日付
や時刻間の差を表します。

`timedelta([days[, seconds[, microseconds[, milliseconds[, minutes[, hours[, weeks]]]]]]])'
     全ての引数がオプションで、デフォルト値は0です。引数は整数、長整
     数、浮動小数点数にすることができ、正でも負でもかまいません。

     DAYS、SECONDS および MICROSECONDS のみが
     内部に記憶されます。引数は以下のようにして変換されます:

        * 1 ミリ秒は 1000 マイクロ秒に変換されます。

        * 1 分は 60 秒に変換されます。

        * 1 時間は 3600 秒に変換されます。

        * 1 週間は 7 日に変換されます。

     その後、日、秒、マイクロ秒は値が一意に表されるように、

        * `0 <= MICROSECONDS < 1000000'

        * `0 <= SECONDS < 3600*24' (一日中の秒数)

        * `-999999999 <= DAYS <= 999999999'

     で正規化されます。

     引数のいずれかが浮動小数点であり、小数のマイクロ秒が存在する場合、
     小数のマイクロ秒は全ての引数から一度取り置かれ、それらの和は
     最も近いマイクロ秒に丸められます。浮動小数点の引数がない場合、
     値の変換と正規化の過程は厳密な (失われる情報がない)
     ものとなります。

     日の値を正規化した結果、指定された範囲の外側になった場合には、
     `OverflowError' が送出されます。

     負の値を正規化すると、一見混乱するような値になります。 例えば、

          >>> d = timedelta(microseconds=-1)
          >>> (d.days, d.seconds, d.microseconds)
          (-1, 86399, 999999)


クラス属性を以下に示します:

`min'
     最小の値を表す `timedelta' オブジェクトで、
     `timedelta(-999999999)' です。

`max'
     最大の値を表す `timedelta' オブジェクトで、
     `timedelta(days=999999999, hours=23, minutes=59, seconds=59,
     microseconds=999999)' です。

`resolution'
     `timedelta' オブジェクトが等しくならない最小の
     時間差で、`timedelta(microseconds=1)' です。

正規化のために、`timedelta.max' >`-timedelta.min'
となるので注意してください。`-timedelta.max' は `timedelta'
オブジェクトとして表現することができません。

以下に (読み出し専用の) インスタンス属性を示します:

属性                                 値
------                               -----
days                                 両端値を含む -999999999 から
                                     999999999 の間
seconds                              両端値を含む 0 から 86399 の間
microseconds                         両端値を含む 0 から 999999 の間

サポートされている操作を以下に示します:

演算                                 結果
------                               -----
T1 = T2 + T3                         T2 と T3 を加算します。演算後、
                                     T1-T2 == T3 および T1-T3 == T2 は
                                     真になります。 (1)
T1 = T2 - T3                         T2 と T3 の差分です。演算後、  T1
                                     == T2 - T3 および T2 == T1 + T3 は
                                     真になります。 (1)
T1 = T2 * I or T1 = I * T2           整数や長整数による乗算です。演算後、
                                     T1 // i == T2 は `i != 0'
                                     であれば真となります。
                                     一般的に、 T1 * i == T1 * (i-1) +
                                     T1 は真となります。(1)
T1 = T2 // I                         端数を切り捨てて除算され、剰余
                                     (がある場合) は捨てられます。(3)
+T1                                  同じ値を持つ`timedelta'
                                     オブジェクトを返します。(2)
-T1                                  `timedelta'(-T1.DAYS, -T1.SECONDS,
                                     -T1.MICROSECONDS)、および T1* -1
                                     と同じです。 (1)(4)
abs(T)                               `t.days >= 0' のときには +T
                                     、`t.days < 0' の ときには -T
                                     となります。(2)

注釈:

`(1)'
     この操作は厳密ですが、オーバフローするかもしれません。

`(2)'
     この操作は厳密であり、オーバフローしないはずです。

`(3)'
     0 による除算は  `ZeroDivisionError' を送出します。

`(4)'
     -TIMEDELTA.MAX は `timedelta'
     オブジェクトで表現することができません。

上に列挙した操作に加えて、`timedelta' オブジェクトは `date' および
`datetime' オブジェクトとの間で 加減算をサポートしています
(下を参照してください)。

`timedelta' オブジェクト間の比較はサポートされており、
より小さい経過時間を表す `timedelta' オブジェクトが より小さい
timedelta と見なされます。
型混合の比較がデフォルトのオブジェクトアドレス比較となってしまう
のを抑止するために、`timedelta' オブジェクトと異なる型の
オブジェクトが比較されると、比較演算子が `==' または `!=' でないかぎり
`TypeError' が送出されます。 後者の場合、それぞれ `False' または `True'
を返します。

`timedelta' オブジェクトはハッシュ可能 (辞書のキーとして利用可能)
であり、効率的な pickle 化をサポートします、また、ブール演算コンテキスト
では、 `timedelta' オブジェクトは `timedelta(0)' に等しくない
場合かつそのときに限り真となります。


File: python-lib-jp.info,  Node: date オブジェクト,  Next: datetime オブジェクト,  Prev: timedelta オブジェクト,  Up: datetime

5.1.3 `date' オブジェクト
-------------------------

`date' オブジェクトは日付 (年、月、および日) を表します。
日付は理想的なカレンダー、すなわち現在のグレゴリオ暦を過去と未来の
両方向に無限に延長したもので表されます。1 年の 1 月 1 日は日番号 1、 1
年 1 月 2 日は日番号 2、となっていきます。この暦法は、
全ての計算における基本カレンダーである、 Dershowitz と Reingold の書籍
における "予期的グレゴリオ (proleptic Gregorian)" 暦の定義に一致します。

`date(year, month, day)'
     全ての引数が必要です。引数は整数でも長整数でもよく、以下の範囲に
     入らなければなりません:

        * `MINYEAR <= YEAR <= MAXYEAR'

        * `1 <= MONTH <= 12'

        * `1 <= DAY <= 指定された月と年における日数'

     範囲を超えた引数を与えた場合、`ValueError' が送出 されます。

他のコンストラクタ、および全てのクラスメソッドを以下に示します:

`today()'
     現在のローカルな日付を返します。 `date.fromtimestamp(time.time())'
     と等価です。

`fromtimestamp(timestamp)'
     `time.time()' が返すような POSIX タイムスタンプ
     に対応する、ローカルな日付を返します。
     タイムスタンプがプラットフォームにおける C 関数 `localtime()'
     でサポートされている範囲を超えている場合には `ValueError'
     を送出することがあります。 この値はよく 1970 年から 2038
     年に制限されていることがあります。
     うるう秒がタイムスタンプの概念に含まれている非 POSIX システム
     では、`fromtimestamp()' はうるう秒を無視します。

`fromordinal(ordinal)'
     予期的グレゴリオ暦順序に対応する日付を表し、1 年 1 月 1 日が序数 1
     となります。`1 <= ORDINAL <= date.max.toordinal()'
     でない場合、`ValueError' が送出されます。 任意の日付 D に対し、
     `date.fromordinal(D.toordinal()) ==  D' となります。

以下にクラス属性を示します:

`min'
     表現できる最も古い日付で、`date(MINYEAR, 1, 1)' です。

`max'
     表現できる最も新しい日付で、 `date(MAXYEAR, 12, 31)' です。

`resolution'
     等しくない日付オブジェクト間の最小の差で、 `timedelta(days=1)'
     です。

以下に (読み出し専用の) インスタンス属性を示します:

`year'
     両端値を含む `MINYEAR' から `MAXYEAR' までの値です。

`month'
     両端値を含む 1 から 12 までの値です。

`day'
     1 から与えられた月と年における日数までの値です。

サポートされている操作を以下に示します:

演算                                 結果
------                               -----
DATE2 = DATE1 + TIMEDELTA            DATE2 はから DATE1 から
                                     `TIMEDELTA.days' 日
                                     移動した日付です。 (1)
DATE2 = DATE1 - TIMEDELTA            `DATE2 + TIMEDELTA == DATE1'
                                     であるような日付 DATE2
                                     を計算します。 (2)
TIMEDELTA = DATE1 - DATE2            (3)
DATE1 < DATE2                        DATE1 が時刻として DATE2
                                     よりも前を表す場合に、 DATE1
                                     はDATE2
                                     よりも小さいと見なされます。 (4)

注釈:
`(1)'
     DATE2 は `TIMEDELTA.days > 0' の場合進む方向に、 `TIMEDELTA.days <
     0' の場合戻る方向に移動します。 演算後は、`DATE2 - DATE1 ==
     TIMEDELTA.days' となります。 `TIMEDELTA.seconds' および
     `TIMEDELTA.microseconds' は無視されます。 `DATE2.year' が
     `MINYEAR' になってしまったり、 `MAXYEAR'
     より大きくなってしまう場合には `OverflowError' が送出されます。

`(2)'
     この操作は date1 + (-timedelta) と等価ではありません。なぜならば、
     date1 - timedeltaがオーバフローしない場合でも、-timedelta 単体が
     オーバフローする可能性があるからです。 `TIMEDELTA.seconds' および
     `TIMEDELTA.microseconds' は無視されます。

`(3)'
     この演算は厳密で、オーバフローしません。timedelta.seconds および
     timedelta.microseconds は 0 で、演算後には date2 + timedelta ==
     date1 となります。

`(4)'
     別の言い方をすると、`DATE1.toordinal() < DATE2.toordinal()'
     であり、かつそのときに限り `date1 < date2' となります。
     型混合の比較がデフォルトのオブジェクトアドレス比較となってしまう
     のを抑止するために、`timedelta' オブジェクトと異なる型の
     オブジェクトが比較されると `TypeError' が送出されます。
     しかしながら、被比較演算子のもう一方が `timetuple' 属性を
     持つ場合には `NotImplemented' が返されます。
     このフックにより、他種の日付オブジェクトに型混合比較を実装する
     チャンスを与えています。 そうでない場合、`timedelta'
     オブジェクトと異なる型の オブジェクトが比較されると、比較演算子が
     `==' または `!=' でないかぎり `TypeError' が送出されます。
     後者の場合、それぞれ `False' または `True' を返します。


`date' オブジェクトは辞書のキーとして用いることができます。
ブール演算コンテキストでは、全ての `date' オブジェクトは
真であるとみなされます。

以下にインスタンスメソッドを示します:

`replace(year, month, day)'
     キーワード引数で指定されたデータメンバが置き換えられることを
     除き、同じ値を持つ `date' オブジェクトを返します。 例えば、`d ==
     date(2002, 12, 31)' とすると、 `d.replace(day=26) == date(2002,
     12, 26)' となります。

`timetuple()'
     `time.localtime()' が返す形式の`time.struct_time' を返します。
     時間、分、および秒は 0 で、DST フラグは -1 になります。
     `D.timetuple()' は `time.struct_time((D.year, D.month, D.day, 0,
     0, 0,  D.weekday(),  D.toordinal() - date(D.year, 1,
     1).toordinal() + 1, -1))' と等価です。

`toordinal()'
     予測的グレゴリオ暦における日付序数を返します。 1 年の 1 月 1 日が
     序数 1 となります。任意の `date' オブジェクト D に ついて、
     `date.fromordinal(D.toordinal()) == D' となります。

`weekday()'
     月曜日を 0、日曜日を 6 として、曜日を整数で返します。 例えば、
     `date(2002, 12, 4).weekday() == 2' であり、水曜日を示します。
     `isoweekday()' も参照してください。

`isoweekday()'
     月曜日を 1、日曜日を 7 として、曜日を整数で返します。 例えば、
     `date(2002, 12, 4).weekday() == 3' であり、水曜日を示します。
     `weekday()'、`isocalendar()' も参照してください。

`isocalendar()'
     3 要素のタプル (ISO 年、ISO 週番号、ISO 曜日) を返します。

     ISO カレンダーはグレゴリオ暦の変種として広く用いられています。
     細かい説明については
     `http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm'
     を参照してください。

     ISO 年は完全な週が 52 または 53 週あり、週は月曜から始まって日曜に
     終わります。ISO
     年でのある年における最初の週は、その年の木曜日を含む 最初の
     (グレゴリオ暦での) 週となります。この週は週番号 1 と呼ばれ、
     この木曜日での ISO 年はグレゴリオ暦における年と等しくなります。

     例えば、2004 年は木曜日から始まるため、ISO 年の最初の週は 2003 年
     12 月 29 日、月曜日から始まり、2004 年 1 月 4 日、日曜日に
     終わります。従って、 `date(2003, 12, 29).isocalendar() == (2004,
     1, 1)' であり、かつ `date(2004, 1, 4).isocalendar() == (2004, 1,
     7)' となります。

`isoformat()'
     ISO 8601 形式、'YYYY-MM-DD' の日付を表す文字列を返します。 例えば、
     `date(2002, 12, 4).isoformat() == '2002-12-04'' となります。

`__str__()'
     `date' オブジェクト D において、 `str(D)' は `D.isoformat()'
     と等価です。

`ctime()'
     日付を表す文字列を、例えば date(2002, 12, 4).ctime() == 'Wed Dec
     4 00:00:00 2002' のようにして返します。 ネイティブの C 関数
     `ctime()' (`time.ctime()' はこの関数を呼び出しますが、
     `date.ctime()' は呼び出しません) が C 標準に準拠
     しているプラットフォームでは、 `D.ctime()' は
     `time.ctime(time.mktime(D.timetuple()))' と等価です。

`strftime(format)'
     明示的な書式化文字列で制御された、日付を表現する文字列を返します。
     時間、分、秒を表す書式化コードは値 0 になります。 `strftime()'
     のふるまいについてのセクション~*Note collections::を参照して
     ください。


File: python-lib-jp.info,  Node: datetime オブジェクト,  Next: time オブジェクト,  Prev: date オブジェクト,  Up: datetime

5.1.4 `datetime' オブジェクト
-----------------------------

`datetime' オブジェクトは `date' オブジェクトおよび `time'
オブジェクトの全ての情報が入っている単一のオブジェクト です。`date'
オブジェクトと同様に、`datetime' は
現在のグレゴリオ暦が両方向に延長されているものと仮定します;
また、`time' オブジェクトと同様に、`datetime' は 毎日が厳密に 3600*24
秒であると仮定します。

以下にコンストラクタを示します:

`datetime(year, month, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]])'
     年、月、および日の引数は必須です。TZINFO は `None' または `tzinfo'
     クラスのサブクラスのインスタンス
     にすることができます。残りの引数は整数または長整数で、
     以下のような範囲に入ります:

        * `MINYEAR <= YEAR <= MAXYEAR'

        * `1 <= MONTH <= 12'

        * `1 <= DAY <= 与えられた年と月における日数'

        * `0 <= HOUR < 24'

        * `0 <= MINUTE < 60'

        * `0 <= SECOND < 60'

        * `0 <= MICROSECOND < 1000000'

     引数がこれらの範囲外にある場合、 `ValueError' が送出されます。

その他のコンストラクタ、およびクラスメソッドを以下に示します:

`today()'
     現在のローカルな `datetime' を `tzinfo' が `None'
     であるものとして返します。 これは
     `datetime.fromtimestamp(time.time())' と等価です。 `now()'、
     `fromtimestamp()' も参照してください。

`now([tz])'
     現在のローカルな日付および時刻を返します。オプションの引数 TZ が
     `None' であるか指定されていない場合、この メソッドは `today()'
     と同様ですが、可能ならば `time.time()'
     タイムスタンプを通じて得ることができる
     より高い精度で時刻を提供します  (例えば、プラットフォームが C 関数
     `gettimeofday()' をサポートする場合には可能なことがあります)。

     そうでない場合、TZ はクラス `tzinfo' のサブクラスの
     インスタンスでなければならず、現在の日付および時刻は TZ
     のタイムゾーンに変換されます。この場合、結果は
     `TZ.fromutc(datetime.utcnow().replace(tzinfo=TZ))'
     と等価になります。 `today()', `utcnow()' も参照してください。

`utcnow()'
     現在の UTC における日付と時刻を、 `tzinfo' が `None' で
     あるものとして返します。このメソッドは `now()' に似ていますが、
     現在の UTC における日付と時刻を naive な `datetime' オブジェクト
     として返します。`now()' も参照してください。

`fromtimestamp(timestamp[, tz])'
     `time.time()' が返すような、POSIX タイムスタンプに
     対応するローカルな日付と時刻を返します。 オプションの引数 TZ が
     `None' であるか、指定されて
     いない場合、タイムスタンプはプラットフォームのローカルな日付および
     時刻に変換され、返される `datetime' オブジェクトは naive
     なものになります。

     そうでない場合、 TZ はクラス `tzinfo' のサブクラスの
     インスタンスでなければならず、現在の日付および時刻は TZ
     のタイムゾーンに変換されます。この場合、結果は
     `TZ.fromutc(datetime.utcfromtimestamp(TIMESTAMP).replace(tzinfo=TZ))'
     と等価になります。

     タイムスタンプがプラットフォームの C 関数 `localtime()' や
     `gmtime()' でサポートされている範囲を超えた場合、
     `fromtimestamp()' は `ValueError' を送出する
     ことがあります。この範囲はよく 1970 年から 2038 年に制限されて
     います。 うるう秒がタイムスタンプの概念に含まれている非 POSIX
     システム では、`fromtimestamp()' はうるう秒を無視します。
     このため、秒の異なる二つのタイムスタンプが同一の `datetime'
     オブジェクトとなることが起こり得ます。 `utcfromtimestamp()'
     も参照してください。

`utcfromtimestamp(timestamp)'
     `time.time()' が返すような POSIX タイムスタンプ に対応する、UTC
     での `datetime' オブジェクトを返します。
     タイムスタンプがプラットフォームにおける C 関数 `localtime()'
     でサポートされている範囲を超えている場合には `ValueError'
     を送出することがあります。 この値はよく 1970 年から 2038
     年に制限されていることがあります。 `fromtimestamp()'
     も参照してください。

`fromordinal(ordinal)'
     1 年 1 月 1 日を序数 1 とする予測的グレゴリオ暦序数に対応する
     `datetime' オブジェクトを返します。 `1 <= ordinal <=
     datetime.max.toordinal()' でないかぎり `ValueError'
     が送出されます。結果として返される
     オブジェクトの時間、分、秒、およびマイクロ秒はすべて 0 となり、
     `tzinfo' は `None' となります。

`combine(date, time)'
     与えられた `date' オブジェクトと同じデータメンバを持ち、 時刻と
     `tzinfo' メンバが与えられた `time' オブジェクト と等しい、新たな
     `datetime' オブジェクトを返します。 任意の `datetime' オブジェクト
     D について、 `D == datetime.combine(D.date(), D.timetz())'
     となります。DATE が `datetime' オブジェクトの場合、 その時刻と
     `tzinfo' は無視されます。

`strptime(date_string, format)'
     DATE_STRING に対応した`datetime' をかえします。
     FORMATにしたがって構文解析されます。これは、
     `datetime(*(time.strptime(date_string, format)[0:6]))' と等価です。
     date_stringとformatが`time.strptime()'で構文解析できない場合
     や、この関数が 時刻タプルを返してこない場合には`ValueError'
     がおこります。

     _Added in Python version 2.5_

以下にクラス属性を示します:

`min'
     表現できる最も古い `datetime' で、 `datetime(MINYEAR, 1, 1,
     tzinfo=None)' です。

`max'
     表現できる最も新しい `datetime' で、 `datetime(MAXYEAR, 12, 31,
     23, 59, 59, 999999, tzinfo=None)' です。

`resolution'
     等しくない `datetime' オブジェクト間の最小の差で、
     `timedelta(microseconds=1)' です。

以下に (読み出し専用の) インスタンス属性を示します:

`year'
     両端値を含む `MINYEAR' から `MAXYEAR' までの値です。

`month'
     両端値を含む 1 から 12 までの値です。

`day'
     1 から与えられた月と年における日数までの値です。

`hour'
     `range(24)' 内の値です。

`minute'
     `range(60)' 内の値です。

`second'
     `range(60)' 内の値です。

`microsecond'
     `range(1000000)' 内の値です。

`tzinfo'
     `datetime' コンストラクタに TZINFO 引数として
     与えられたオブジェクトになり、何も渡されなかった場合には `None'
     になります。

以下にサポートされている演算を示します:

演算                                 結果
------                               -----
DATETIME2 = DATETIME1 + TIMEDELTA    (1)
DATETIME2 = DATETIME1 - TIMEDELTA    (2)
TIMEDELTA = DATETIME1 - DATETIME2    (3)
DATETIME1 < DATETIME2                `datetime' を `datetime'
                                     と比較します。  (4)

`(1)'
     datetime2 は datetime1 から時間 timedelta 移動したもので、
     `TIMEDELTA.days > 0' の場合進む方向に、 `TIMEDELTA.days < 0'
     の場合戻る方向に移動します。 結果は入力の datetime と同じ `tzinfo'
     を持ち、 演算後には datetime2 - datetime1 == timedelta となります。
     datetime2.year が `MINYEAR' よりも小さいか、 `MAXYEAR'
     より大きい場合には `OverflowError' が送出されます。 入力が aware
     なオブジェクトの場合でもタイムゾーン修正は全く行われ ません。

`(2)'
     datetime2 + timedelta == datetime1 となるような datetime2 を
     計算します。ちなみに、結果は入力の datetime と同じ `tzinfo'
     メンバを持ち、入力が aware でもタイムゾーン修正は全く行われ
     ません。 この操作は date1 + (-timedelta)
     と等価ではありません。なぜならば、 date1 -
     timedeltaがオーバフローしない場合でも、-timedelta 単体が
     オーバフローする可能性があるからです。

`(3)'
     `datetime' から `datetime' の減算は両方の被演算子が naive
     であるか、両方とも aware である場合にのみ定義されています 片方が
     aware でもう一方が naive の場合、 `TypeError' が送出されます。

     両方とも naive か、両方とも aware で同じ `tzinfo' メンバ
     を持つ場合、`tzinfo' メンバは無視され、結果は `DATETIME2 + T ==
     DATETIME1' であるような `timedelta' オブジェクト T となります。
     この場合タイムゾーン修正は全く行われません。

     両方が aware で異なる `tzinfo' メンバを持つ場合、 `a-b' は A
     および B をまず naive な UTC datetime
     オブジェクトに変換したかのようにして行います。演算結果は
     決してオーバフローを起こさないことを除き、
     `(A.replace(tzinfo=None) - A.utcoffset()) -
     (B.replace(tzinfo=None) - B.utcoffset())' と同じになります。

`(4)'
     DATETIME1 が時刻として DATETIME2 よりも前を表す場合に、 DATETIME1
     はDATETIME2 よりも小さいと見なされます。

     被演算子の片方が naive でもう一方が aware の場合、 `TypeError'
     が送出されます。両方の被演算子が aware で、 同じ `tzinfo'
     メンバを持つ場合、共通の `tzinfo' メンバは無視され、基本の
     datetime 間の比較が行われます。 両方の被演算子が aware で異なる
     `tzinfo' メンバを持つ 場合、被演算子はまず (`self.utcoffset()'
     で得られる) UTC オフセット で修正されます。 _Note:_
     型混合の比較がデフォルトのオブジェクトアドレス比較となってしまう
     のを抑止するために、被演算子のもう一方が `datatime' オブジェクトと
     異なる型のオブジェクトの場合には `TypeError' が送出されます。
     しかしながら、被比較演算子のもう一方が `timetuple' 属性を
     持つ場合には `NotImplemented' が返されます。
     このフックにより、他種の日付オブジェクトに型混合比較を実装する
     チャンスを与えています。 そうでない場合、`datetime'
     オブジェクトと異なる型の オブジェクトが比較されると、比較演算子が
     `==' または `!=' でないかぎり `TypeError' が送出されます。
     後者の場合、それぞれ `False' または `True' を返します。


`datetime' オブジェクトは辞書のキーとして用いることができます。
ブール演算コンテキストでは、全ての `datetime' オブジェクトは
真であるとみなされます。

インスタンスメソッドを以下に示します:

`date()'
     同じ年、月、日の `date' オブジェクトを返します。

`time()'
     同じ時、分、秒、マイクロ秒を持つ `time' オブジェクトを返します。
     `tzinfo' は `None' です。`timetz()' も参照 してください。

`timetz()'
     同じ時、分、秒、マイクロ秒、および tzinfo メンバを持つ `time'
     オブジェクトを返します。 `time()' メソッドも参照してください。

`replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])'
     キーワード引数で指定したメンバの値を除き、同じ値をもつ datetime
     オブジェクトを返します。 メンバに対する変換を行わずに aware な
     datetime オブジェクトから naive な datetime
     オブジェクトを生成するために、 `tzinfo=None'
     を指定することもできます。

`astimezone(tz)'
     `datetime' オブジェクトを返します。返されるオブジェクトは 新たな
     `tzinfo' メンバ TZ を持ちます。TZ
     は日付および時刻を調整して、オブジェクトが SELF と同じ UTC
     時刻を持つが、TZ におけるローカルな時刻を表すようにします。

     TZ は `tzinfo' のサブクラスのインスタンスでなければ
     ならず、インスタンスの `utcoffset()' および `dst()' メソッドは
     `None' を返してはなりません。SELF は aware でなくてはなりません
     (`SELF.tzinfo' が `None' であってはならず、かつ `SELF.utcoffset()'
     は `None' を返してはなりません)。

     `SELF.tzinfo' が TZ の場合、 `SELF.astimezone(TZ)' は SELF
     に等しくなります:
     日付および時刻データメンバに対する調整は行われません。
     そうでない場合、結果はタイムゾーン TZ におけるローカル時刻で、
     SELF と同じ UTC 時刻を表すようになります: `ASTZ =
     DT.astimezone(TZ)' とした後、 `ASTZ - ASTZ.utcoffset()' は通常 `DT
     - DT.utcoffset()' と同じ日付および時刻 データメンバを持ちます。
     `tzinfo' クラスに関する議論では、夏時間 (Daylight Saving time)
     の遷移境界では上の等価性が成り立たないことを説明しています (TZ
     が標準時と夏時間の両方をモデル化している場合のみの問題です)。

     単にタイムゾーンオブジェクト TZ を `datetime' オブジェクト DT
     に追加したいだけで、日付や時刻データメンバへの調整
     を行わないのなら、`DT.replace(tzinfo=TZ)' を使って ください。 単に
     aware な `datetime' オブジェクト DT からタイムゾーン
     オブジェクトを除去したいだけで、日付や時刻データメンバの変換を
     行わないのなら、`DT.replace(tzinfo=None)' を使ってください。

     デフォルトの `tzinfo.fromutc()' メソッドを `tzinfo'
     のサブクラスで上書きして、`astimezone()' が返す結果に
     影響を及ぼすことができます。エラーの場合を無視すると、
     `astimezone()' は以下のように動作します:

            def astimezone(self, tz):
                if self.tzinfo is tz:
                    return self
                # Convert self to UTC, and attach the new time zone object.
                utc = (self - self.utcoffset()).replace(tzinfo=tz)
                # Convert from UTC to tz's local time.
                return tz.fromutc(utc)


`utcoffset()'
     `tzinfo' が `None' の場合、`None' を返し、 そうでない場合には
     `SELF.tzinfo.utcoffset(SELF)' を返します。後者の式が `None' か、1
     日以下の大きさを持つ 経過時間を表す `timedelta'
     オブジェクトのいずれかを返さない 場合には例外を送出します。

`dst()'
     `tzinfo' が `None' の場合、`None' を返し、 そうでない場合には
     `SELF.tzinfo.dst(SELF)' を返します。後者の式が `None' か、1
     日以下の大きさを持つ 経過時間を表す `timedelta'
     オブジェクトのいずれかを返さない 場合には例外を送出します。

`tzname()'
     `tzinfo' が `None' の場合、`None' を返し、 そうでない場合には
     `SELF.tzinfo.tzname(SELF)' を返します。後者の式が `None'
     か文字列オブジェクトのいずれか を返さない場合には例外を送出します。

`timetuple()'
     `time.localtime()' が返す形式の `time.struct_time' を返します。
     `D.timetuple()' は `time.struct_time((D.year, D.month, D.day,
     D.hour, D.minute, D.second, D.weekday(), D.toordinal() -
     date(D.year, 1, 1).toordinal() + 1, dst))' と等価です。
     返されるタプルの `tm_isdst' フラグは `dst()' メソッドに
     従って設定されます:  `tzinfo' が `None' か `dst()' が `None'
     を返す場合、 `tm_isdst' は `-1' に設定されます; そうでない場合、
     `dst()' がゼロでない値を返すと、`tm_isdst' は `1' となります;
     それ以外の場合には `tm_isdst' は`0' に設定 されます。

`utctimetuple()'
     `datetime' インスタンス D が naive の場合、このメソッドは
     `D.timetuple()' と同じであり、`d.dst()' の返す内容に かかわらず
     `tm_isdst' が 0 に強制される点だけが異なります。 DST が UTC
     時刻に影響を及ぼすことは決してありません。

     D が aware の場合、D から `D.utcoffset()' が差し 引かれて UTC
     時刻に正規化され、正規化された時刻の `time.struct_time'
     を返します。`tm_isdst' は 0 に強制されます。 D.year が `MINYEAR'
     や `MAXUEAR' で、UTC への修正の結果
     表現可能な年の境界を越えた場合には、戻り値の `tm_year' メンバは
     `MINYEAR'-1 または `MAXYEAR'+1 になることがあります。

`toordinal()'
     予測的グレゴリオ暦における日付序数を返します。
     `self.date().toordinal()' と同じです。

`weekday()'
     月曜日を 0、日曜日を 6 として、曜日を整数で返します。
     `self.date().weekday()' と同じです。 `isoweekday()'
     も参照してください。

`isoweekday()'
     月曜日を 1、日曜日を 7 として、曜日を整数で返します。
     `self.date().isoweekday()' と等価です。 `weekday()'、
     `isocalendar()' も参照してください。

`isocalendar()'
     3 要素のタプル (ISO 年、ISO 週番号、ISO 曜日) を返します。
     `self.date().isocalendar()' と等価です。

`isoformat([sep])'
     日付と時刻を ISO 8601 形式、すなわち YYYY-MM-DDTHH:MM:SS.mmmmmm
     か、 `microsecond' が 0 の場合には YYYY-MM-DDTHH:MM:SS
     で表した文字列を返します。 `utcoffset()' が `None' を返さない場合、
     UTC からのオフセットを時間と分を表した (符号付きの) 6 文字からなる
     文字列が追加されます: すなわち、 YYYY-MM-DDTHH:MM:SS.mmmmmm+HH:MM
     となるか、 `microsecond' が ゼロの場合には
     YYYY-MM-DDTHH:MM:SS+HH:MM となります。 オプションの引数 SEP
     (デフォルトでは `'T'' です) は 1
     文字のセパレータで、結果の文字列の日付と時刻の間に置かれます。
     例えば、

          >>> from datetime import tzinfo, timedelta, datetime
          >>> class TZ(tzinfo):
          ...     def utcoffset(self, dt): return timedelta(minutes=-399)
          ...
          >>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')
          '2002-12-25 00:00:00-06:39'

     となります。

`__str__()'
     `datetime' オブジェクト D において、 `str(D)' は `D.isoformat('
     ')' と等価です。

`ctime()'
     日付を表す文字列を、例えば `datetime(2002, 12, 4, 20, 30,
     40).ctime() == 'Wed Dec  4 20:30:40 2002'' のようにして返します。
     ネイティブの C 関数 `ctime()' (`time.ctime()'
     はこの関数を呼び出しますが、 `datetime.ctime()' は呼び出しません)
     が C 標準に準拠 しているプラットフォームでは、 `D.ctime()' は
     `time.ctime(time.mktime(d.timetuple()))' と等価です。

`strftime(format)'
     明示的な書式化文字列で制御された、日付を表現する文字列を返します。
     `strftime()' のふるまいについてのセクション~*Note
     collections::を参照して ください。


File: python-lib-jp.info,  Node: time オブジェクト,  Next: tzinfo オブジェクト,  Prev: datetime オブジェクト,  Up: datetime

5.1.5 `time' オブジェクト
-------------------------

`time' オブジェクトは (ローカルの) 日中時刻を表現します。
この時刻表現は特定の日の影響を受けず、`tzinfo' オブジェクト
を介した修正の対象となります。

`time(hour[, minute[, second[, microsecond[, tzinfo]]]])'
     全ての引数はオプションです。TZINFO は `None' または `tzinfo'
     クラスのサブクラスのインスタンス
     にすることができます。残りの引数は整数または長整数で、
     以下のような範囲に入ります:

        * `0 <= HOUR < 24'

        * `0 <= MINUTE < 60'

        * `0 <= SECOND < 60'

        * `0 <= MICROSECOND < 1000000'.

     引数がこれらの範囲外にある場合、 `ValueError' が送出されます。
     TZINFOのデフォルト値が `None'である以外のデフォルト値は0です。

以下にクラス属性を示します:

`min'
     表現できる最も古い `datetime' で、 `time(0, 0, 0, 0)' です。 The
     earliest representable `time', `time(0, 0, 0, 0)'.

`max'
     表現できる最も新しい `datetime' で、 `time(23, 59, 59, 999999,
     tzinfo=None)' です。

`resolution'
     等しくない `datetime' オブジェクト間の最小の差で、
     `timedelta(microseconds=1)' ですが、`time'
     オブジェクト間の四則演算はサポートされて
     いないので注意してください。

以下に (読み出し専用の) インスタンス属性を示します:

`hour'
     `range(24)' 内の値です。

`minute'
     `range(60)' 内の値です。

`second'
     `range(60)' 内の値です。

`microsecond'
     `range(1000000)' 内の値です。

`tzinfo'
     `time' コンストラクタに TZINFO 引数として
     与えられたオブジェクトになり、何も渡されなかった場合には `None'
     になります。

以下にサポートされている操作を示します:

   * `time' と `time' の比較では、A が時刻として B よりも前を表す場合に
     A は B よりも小さいと見なされます。 被演算子の片方が naive
     でもう一方が aware の場合、 `TypeError'
     が送出されます。両方の被演算子が aware で、 同じ `tzinfo'
     メンバを持つ場合、共通の `tzinfo' メンバは無視され、基本の
     datetime 間の比較が行われます。 両方の被演算子が aware で異なる
     `tzinfo' メンバを持つ 場合、被演算子はまず (`self.utcoffset()'
     で得られる) UTC オフセット で修正されます。
     型混合の比較がデフォルトのオブジェクトアドレス比較となってしまう
     のを抑止するために、`time' オブジェクトが他の型のオブジェクトと
     比較された場合、比較演算子が `==' または `!=' でないかぎり
     `TypeError' が送出されます。 後者の場合、それぞれ `False' または
     `True' を返します。

   * ハッシュ化、辞書のキーとしての利用

   * 効率的な pickle 化

   * ブール演算コンテキストでは、`time' オブジェクトは、
     分に変換し、`utfoffset()' (`None' を返した場合には `0')
     を差し引いて変換した後の結果がゼロでない場合、かつその
     ときに限って真とみなされます。

以下にインスタンスメソッドを示します:

`replace([hour[, minute[, second[, microsecond[, tzinfo]]]]])'
     キーワード引数で指定したメンバの値を除き、同じ値をもつ `time'
     オブジェクトを返します。 メンバに対する変換を行わずに aware な
     datetime オブジェクトから naive な `time'
     オブジェクトを生成するために、 `tzinfo=None'
     を指定することもできます。

`isoformat()'
     日付と時刻を ISO 8601 形式、すなわち HH:MM:SS.mmmmmm か、
     `microsecond' が 0 の場合には HH:MM:SS で表した文字列を返します。
     `utcoffset()' が `None' を返さない場合、 UTC
     からのオフセットを時間と分を表した (符号付きの) 6 文字からなる
     文字列が追加されます: すなわち、 HH:MM:SS.mmmmmm+HH:MM となるか、
     `microsecond' が 0 の場合には HH:MM:SS+HH:MM となります。

`__str__()'
     `time' オブジェクト T において、 `str(T)' は `T.isoformat()'
     と等価です。

`strftime(format)'
     明示的な書式化文字列で制御された、日付を表現する文字列を返します。
     `strftime()' のふるまいについてのセクション~*Note
     collections::を参照して ください。

`utcoffset()'
     `tzinfo' が `None' の場合、`None' を返し、 そうでない場合には
     `SELF.tzinfo.utcoffset(None)' を返します。後者の式が `None' か、1
     日以下の大きさを持つ 経過時間を表す `timedelta'
     オブジェクトのいずれかを返さない 場合には例外を送出します。

`dst()'
     `tzinfo' が `None' の場合、`None' を返し、 そうでない場合には
     `SELF.tzinfo.dst(None)' を返します。後者の式が `None' か、1
     日以下の大きさを持つ 経過時間を表す `timedelta'
     オブジェクトのいずれかを返さない 場合には例外を送出します。

`tzname()'
     `tzinfo' が `None' の場合、`None' を返し、 そうでない場合には
     `SELF.tzinfo.tzname(None)' を返します。後者の式が `None'
     か文字列オブジェクトのいずれか を返さない場合には例外を送出します。


File: python-lib-jp.info,  Node: tzinfo オブジェクト,  Next: strftime の振る舞い,  Prev: time オブジェクト,  Up: datetime

5.1.6 `tzinfo' オブジェクト
---------------------------

`tzinfo' は抽象基底クラスです。つまり、このクラスは直接
インスタンス化して利用しません。具体的なサブクラスを導出し、
(少なくとも) 利用したい `datetime' のメソッドが必要と する `tzinfo'
の標準メソッドを実装してやる必要があります。 `datetime'
モジュールでは、`tzinfo' の具体的な サブクラスは何ら提供していません。

`tzinfo' (の具体的なサブクラス) のインスタンスは `datetime' および
`time' オブジェクトのコンストラクタに 渡すことができます。
後者のオブジェクトでは、データメンバをローカル時刻におけるものとして
見ており、`tzinfo' オブジェクトはローカル時刻の UTC からの
オフセット、タイムゾーンの名前、DST オフセットを、渡された
日付および時刻オブジェクトからの相対で示すためのメソッドを 提供します。

pickle 化についての特殊な要求事項: `tzinfo' のサブクラスは
引数なしで呼び出すことのできる `__init__' メソッドを持たねば
なりません。そうでなければ、pickle 化することはできますがおそらく
unpickle 化することはできないでしょう。これは技術的な側面からの
要求であり、将来緩和されるかもしれません。

`tzinfo' の具体的なサブクラスでは、以下のメソッドを
実装する必要があります。厳密にどのメソッドが必要なのかは、 aware な
`datetime' オブジェクトがこのサブクラスの
インスタンスをどのように使うかに依存します。不確かならば、
単に全てを実装してください。

`utcoffset(self, dt)'
     ローカル時間の UTC からのオフセットを、UTC から東向きを正とした分で
     返します。ローカル時間が UTC
     の西側にある場合、この値は負になります。 このメソッドは UTC
     からのオフセットの総計を返すように意図されている
     ので注意してください; 例えば、 `tzinfo' オブジェクトが
     タイムゾーンと DST 修正の両方を表現する場合、`utcoffset()'
     はそれらの合計を返さなければなりません。UTC オフセットが未知である
     場合、`None' を返してください。そうでない場合には、 返される値は
     -1439 から 1439 の両端を含む値 (1440 = 24*60 ;
     つまり、オフセットの大きさは 1 日より短くなくてはなりません)
     が分で指定された `timedelta' オブジェクトでなければなりません。
     ほとんどの `utcoffset()' 実装は、おそらく以下の二つのうちの一つに
     似たものになるでしょう:

              return CONSTANT                 # fixed-offset class
              return CONSTANT + self.dst(dt)  # daylight-aware class

     `utcoffset()' が `None' を返さない場合、 `dst()' も `None'
     を返してはなりません。

     `utcoffset()' のデフォルトの実装は `NotImplementedError'
     を送出します。

`dst(self, dt)'
     夏時間 (DST) 修正を、UTC から東向きを正とした分で 返します。DST
     情報が未知の場合、`None' が返されます。 DST が有効でない場合には
     `timedelta(0)' を返します。 DST が有効の場合、オフセットは
     `timedelta' オブジェクト で返します (詳細は`utcoffset()'
     を参照してください)。 DST オフセットが利用可能な場合、この値は
     `utcoffset()' が返すUTC
     からのオフセットには既に加算されているため、 DST
     を個別に取得する必要がない限り `dst()' を使って
     問い合わせる必要はないので注意してください。
     例えば、`datetime.timetuple()' は `tzinfo' メンバ の `dst()'
     メソッドを呼んで `tm_isdst' フラグが
     セットされているかどうか判断し、`tzinfo.fromutc()' は `dst()'
     タイムゾーンを移動する際に DST による変更
     があるかどうかを調べます。

     標準および夏時間の両方をモデル化している `tzinfo' サブクラスの
     インスタンス TZ は以下の式:

     `TZ.utcoffset(DT) - TZ.dst(DT)'

     が、`DT.tzinfo == TZ' 全ての `datetime' オブジェクト DT
     について常に同じ結果を返さなければならないという点で、
     一貫性を持っていなければなりません。 正常に実装された `tzinfo'
     のサブクラスでは、この式は タイムゾーンにおける "標準オフセット
     (standard offset)" を表し、
     特定の日や時刻の事情ではなく地理的な位置にのみ依存していなくては
     なりません。`datetime.astimezone()' の実装はこの事実に
     依存していますが、違反を検出することができません;
     正しく実装するのはプログラマの責任です。`tzinfo' の
     サブクラスでこれを保証することができない場合、`tzinfo.fromutc()'
     の実装をオーバライドして、`astimezone()' に関わらず
     正しく動作するようにしてもかまいません。

     ほとんどの `dst()' 実装は、おそらく以下の二つのうちの一つに
     似たものになるでしょう:

              def dst(self):
                  # a fixed-offset class:  doesn't account for DST
                  return timedelta(0)

     or

              def dst(self):
                  # Code to set dston and dstoff to the time zone's DST
                  # transition times based on the input dt.year, and expressed
                  # in standard local time.  Then

                  if dston <= dt.replace(tzinfo=None) < dstoff:
                      return timedelta(hours=1)
                  else:
                      return timedelta(0)

     デフォルトの `dst()' 実装は `NotImplementedError' を送出します。

`tzname(self, dt)'
     `datetime' オブジェクト DT に対応するタイムゾーン名
     を文字列で返します。 `datetime'
     モジュールでは文字列名について何も定義しておらず、
     特に何かを意味するといった要求仕様もまったくありません。
     例えば、"GMT"、"UTC"、 "-500"、 "-5:00"、  "EDT"、 "US/Eastern"、
     "America/New York" は全て有効な応答となります。
     文字列名が未知の場合には `None' を返してください。 `tzinfo'
     のサブクラスでは、 特に、`tzinfo'
     クラスが夏時間について記述している場合のように、 渡された DT
     の特定の値によって異なった名前を返したい
     場合があるため、文字列値ではなくメソッドとなっていることに注意してください。

     デフォルトの `tzname()' 実装は `NotImplementedError' を送出します。

以下のメソッドは `datetime' や `time' オブジェクトにおいて、
同名のメソッドが呼び出された際に応じて呼び出されます。`datetime'
オブジェクトは自身を引数としてメソッドに渡し、`time' オブジェクトは
引数として `None' をメソッドに渡します。従って、`tzinfo' の
サブクラスにおけるメソッドは引数 DT が `None' の場合と、 `datetime'
の場合を受理するように用意しなければなりません。

`None' が渡された場合、最良の応答方法を決めるのはクラス設計者次第
です。例えば、このクラスが `tzinfo' プロトコルと関係をもたない
ということを表明させたければ、`None' が適切です。
標準時のオフセットを見つける他の手段がない場合には、 標準 UTC
オフセットを返すために `utcoffset(None)'
を使うともっと便利かもしれません。

`datetime' オブジェクトが `datetime' メソッド
の応答として返された場合、`dt.tzinfo' は SELF
と同じオブジェクトになります。ユーザが直接 `tzinfo' メソッド
を呼び出さないかぎり、`tzinfo' メソッドは `dt.tzinfo' と SELF
が同じであることに依存します。 その結果 `tzinfo' メソッドは DT
がローカル時間であると
解釈するので、他のタイムゾーンでのオブジェクトの振る舞いについて
心配する必要がありません。

`fromutc(self, dt)'
     デフォルトの `datetime.astimezone()' 実装で呼び出されます。
     `datetime.astimezone()' から呼ばれた場合、`DT.tzinfo' は SELF
     であり、 DT の日付および時刻データメンバは UTC
     時刻を表しているものとして見えます。`fromutc()' の目的は、SELF
     のローカル時刻に等しい `datetime' オブジェクト
     を返すことにより日付と時刻データメンバを修正することにあります。

     ほとんどの `tzinfo' サブクラスではデフォルトの `fromutc()'
     実装を問題なく継承できます。デフォルトの実装は、固定オフセットのタイムゾーン
     や、標準時と夏時間の両方について記述しているタイムゾーン、そして
     DST
     移行時刻が年によって異なる場合でさえ、扱えるくらい強力なものです。
     デフォルトの `fromutc()' 実装が全ての場合に対して正しく
     扱うことができないような例は、標準時の (UTCからの) オフセットが
     引数として渡された特定の日や時刻に依存するもので、これは政治的な理由に
     よって起きることがあります。 デフォルトの `astimezone()' や
     `fromutc()' の実装は、
     結果が標準時オフセットの変化にまたがる何時間かの中にある場合、
     期待通りの結果を生成しないかもしれません。

     エラーの場合のためのコードを除き、デフォルトの `fromutc()' の
     実装は以下のように動作します:

            def fromutc(self, dt):
                # raise ValueError error if dt.tzinfo is not self
                dtoff = dt.utcoffset()
                dtdst = dt.dst()
                # raise ValueError if dtoff is None or dtdst is None
                delta = dtoff - dtdst  # this is self's standard offset
                if delta:
                    dt += delta   # convert to standard local time
                    dtdst = dt.dst()
                    # raise ValueError if dtdst is None
                if dtdst:
                    return dt + dtdst
                else:
                    return dt


以下に `tzinfo' クラスの使用例を示します:

`tzinfo-examples.py'

標準時間 (standard time) および夏時間 (daylight time) の両方を
記述している `tzinfo' のサブクラスでは、回避不能の難解な問題が年に 2
度あるので注意してください。具体的な例として、東部アメリカ時刻 (US
Eastern, UTC -5000)  を考えます。EDT は 4 月の最初の日曜日 の 1:59
(EST) 以後に開始し、10 月の最後の日曜日の 1:59 (EDT) に 終了します:

         UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM
         EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM
         EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM

       start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM

         end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM

DST の開始の際 ("start" の並び) ローカルの壁時計は 1:59 から 3:00
に飛びます。この日は 2:MM の形式をとる時刻は実際には無意味と
なります。従って、`astimezone(Eastern)' は DST が開始する 日には `hour
== 2' となる結果を返すことはありません。 `astimezone()'
がこのことを保証するようにするには、 `tzinfo.dst()' メソッドは
"失われた時間" (東部時刻における 2:MM)
が夏時間に存在することを考えなければなりません。

DST が終了する際 ("end" の並び) では、問題はさらに悪化します: 1
時間の間、ローカルの壁時計ではっきりと時刻をいえなくなります:
それは夏時間の最後の 1 時間です。東部時刻では、その日の UTC での 5:MM
に夏時間は終了します。ローカルの壁時計は 1:59 (夏時間) から 1:00
(標準時) に再び巻き戻されます。ローカルの時刻に おける 1:MM
はあいまいになります。`astimezone()' は二つの UTC
時刻を同じローカルの時刻に対応付けることで
ローカルの時計の振る舞いをまねます。 東部時刻の例では、5:MM および 6:MM
の形式をとる UTC 時刻は 両方とも、東部時刻に変換された際に 1:MM
に対応づけられます。 `astimezone()' がこのことを保証するようにするには、
`tzinfo.dst()' は "繰り返された時間" が標準時に存在する
ことを考慮しなければなりません。このことは、例えばタイムゾーンの標準の
ローカルな時刻に DST への切り替え時刻を表現することで簡単に設定する
ことができます。

このようなあいまいさを許容できないアプリケーションは、 ハイブリッドな
`tzinfo' サブクラスを使って問題を回避しなければ なりません; UTC
や、他のオフセットが固定された `tzinfo' の サブクラス (EST (-5
時間の固定オフセット) のみを表すクラスや、 EDT (-4
時間の固定オフセット) のみを表すクラス) を使う限り、あいまいさは
発生しません。


File: python-lib-jp.info,  Node: strftime の振る舞い,  Next: 使用例,  Prev: tzinfo オブジェクト,  Up: datetime

5.1.7 `strftime()' の振る舞い
-----------------------------

`date'、 `datetime'、および `time'
オブジェクトは全て、明示的な書式化文字列でコントロールして
時刻表現文字列を生成するための `strftime(FORMAT)' メソッドを
サポートしています。大雑把にいうと、`d.strftime(fmt)' は `time'
モジュールの `time.strftime(fmt, d.timetuple())'
のように動作します。ただし全てのオブジェクトが `timetuple()'
メソッドをサポートしているわけではありません。

`time' オブジェクトでは、年、月、日の値がないため、それらの
書式化コードを使うことができません。無理矢理使った場合、 年は `1900'
に置き換えられ、月と日は `0' に置き換え られます。

`date' オブジェクトでは、時、分、秒の値がないため、
それらの書式化コードを使うことができません。無理矢理使った場合、
これらの値は `0' に置き換えられます。

naive オブジェクトでは、書式化コード `%z' および `%Z'
は空文字列に置き換えられます。

aware オブジェクトでは以下のようになります:

   * `%z' `utcoffset()' は +HHMM あるいは -HHMM の形式をもった 5
     文字の文字列に変換されます。HH は UTC オフセット時間を与える 2
     桁の文字列で、MM は UTC オフセット分を与える 2 桁の文字列です。
     例えば、`utcoffset()' が `timedelta(hours=-3, minutes=-30)'
     を返した場合、`%z' は文字列 `'-0330'' に置き換わります。

   * `%Z' `tzname()' が `None' を返した場合、`%Z' は
     空文字列に置き換わります。そうでない場合、`%Z' は返された
     値に置き換わりますが、これは文字列でなければなりません。

Python はプラットフォームの C ライブラリから `strftime()'
関数を呼び出し、プラットフォーム間のバリエーションはよくあることなので、
サポートされている書式化コードの全セットはプラットフォーム間で異なります。
Python の `time' モジュールのドキュメントでは、C 標準 (1989 年版)
が要求する書式化コードをリストしており、これらのコードは 標準 C
準拠の実装がなされたプラットフォームでは全て動作します。 1999 年版の C
標準では書式化コードが追加されているので注意してください。

`strftime()' が正しく動作する年の厳密な範囲はプラットフォーム
間で異なります。プラットフォームに関わらず、1900 年以前の年は
使うことができません。


File: python-lib-jp.info,  Node: 使用例,  Prev: strftime の振る舞い,  Up: datetime

5.1.8 使用例
------------

* Menu:

* Datetime オブジェクトをフォーマットされた文字列から生成する::


File: python-lib-jp.info,  Node: Datetime オブジェクトをフォーマットされた文字列から生成する,  Prev: 使用例,  Up: 使用例

5.1.8.1 Datetime オブジェクトをフォーマットされた文字列から生成する
...................................................................

`datetime'クラスは直接フォーマットされた時刻文字列の構文解析をサ
ポートしていません。`time.strptime' を使うことによって構文解
析をし、返されるタプルから`datetime'オブジェクトを生成することができます。

     >>> s = "2005-12-06T12:13:14"
     >>> from datetime import datetime
     >>> from time import strptime
     >>> datetime(*strptime(s, "%Y-%m-%dT%H:%M:%S")[0:6])
     datetime.datetime(2005, 12, 6, 12, 13, 14)


File: python-lib-jp.info,  Node: calendar,  Next: collections,  Prev: datetime,  Up: データ型

5.2 一般的なカレンダーに関する関数群
====================================

UNIX の `cal' プログラム相当の機能を含んだカレン ダーに関する関数群

このモジュールはUNIXの`cal'プログラムのようなカレンダー出力を
行い、それに加えてカレンダーに関する有益な関数群を提供します。標準ではこ
れらのカレンダーは（ヨーロッパの慣例に従って）月曜日を週の始まりとし、日
曜日を最後の日としています。
`setfirstweekday()'を用いることで、日曜日(6)や他の曜日を週の始
まりに設定することができます。日付を表す引数は整数値で与えます。

このモジュールで提供する関数とクラスのほとんどは `datetime'
に依存しており、
過去も未来も現代のグレゴリオ暦を利用します。この方式はDershowitzとReingold
の書籍「Calendrical Calculations」にある proleptic Gregorian
暦に一致しており、 同書では全ての計算の基礎となる暦としています。\
(訳注: proleptic Gregorian 暦とはグレゴリオ暦制定(1582年)以前についても
グレゴリオ暦で言い表す暦の方式のことで ISO 8601
などでも採用されています)

`Calendar([firstweekday])'
     `Calendar' オブジェクトを作ります。FIRSTWEEKDAY は整数で
     週の始まりの曜日を指定するものです。`0' が月曜(デフォルト)、 `6'
     なら日曜です。

     `Calendar'
     オブジェクトは整形されるカレンダーのデータを準備するために使える
     いくつかのメソッドを提供しています。しかし整形機能そのものは提供していません。
     それはサブクラスの仕事なのです。 _Added in Python version 2.5_

`Calendar' インスタンスには以下のメソッドがあります。

`iterweekdays(weekday)'
     曜日の数字を一週間分生成するイテレータを返します。
     イテレータから得られる最初の数字は `firstweekday()'
     が返す数字と同じになります。

`itermonthdates(year, month)'
     YEAR 年 MONTH 月に対するイテレータを返します。
     このイテレータはその月の全ての日(`datetime.date'
     オブジェクトとして)
     およびその前後の日で週に欠けが無いようにするのに必要な日を返します。

`itermonthdays2(year, month)'
     YEAR 年 MONTH 月に対する `itermonthdates()' と同じような
     イテレータを返します。生成されるのは日付の数字と曜日を表す数字のタプルです。

`itermonthdays(year, month)'
     YEAR 年 MONTH 月に対する `itermonthdates()' と同じような
     イテレータを返します。生成されるのは日付の数字だけです。

`monthdatescalendar(year, month)'
     YEAR 年 MONTH 月の週のリストを返します。 週は全て七つの
     `datetime.date' オブジェクトからなるリストです。

`monthdays2calendar(year, month)'
     YEAR 年 MONTH 月の週のリストを返します。
     週は全て七つの日付の数字と曜日を表す数字のタプルからなるリストです。

`monthdayscalendar(year, month)'
     YEAR 年 MONTH 月の週のリストを返します。
     週は全て七つの日付の数字からなるリストです。

`yeardatescalendar(year[, width])'
     指定された年のデータを整形に向く形で返します。返される値は月の並びのリストです。
     月の並びは最大で WIDTH ヶ月(デフォルトは3ヶ月)分です。
     各月は4ないし6週からなり、各週は1ないし7日からなります。 各日は
     `datetime.date' オブジェクトです。

`yeardays2calendar(year[, width])'
     指定された年のデータを整形に向く形で返します (`yeardatescalendar()'
     と同様です)。週のリストの中が日付の数字と曜日の数字のタプルになります。
     月の範囲外の部分の日付はゼロです。

`yeardayscalendar(year[, width])'
     指定された年のデータを整形に向く形で返します (`yeardatescalendar()'
     と同様です)。週のリストの中が日付の数字になります。
     月の範囲外の日付はゼロです。

`TextCalendar([firstweekday])'
     このクラスはプレインテキストのカレンダーを生成するのに使えます。

     _Added in Python version 2.5_

`TextCalendar' インスタンスには以下のメソッドがあります。

`formatmonth(theyear, themonth[, w[, l]])'
     ひと月分のカレンダーを複数行の文字列で返します。Wにより日の列幅を変える
     ことができ、それらはセンタリングされます。Lにより各週の表示される
     行数を変えることができます。 `setfirstweekday()'
     メソッドでセットされた週の最初の曜日に依存します。

`prmonth(theyear, themonth[, w[, l]])'
     `formatmonth()' で返されるひと月分のカレンダーを出力します。

`formatyear(theyear[, w[, l[, c[, m]]]])'
     M列からなる一年間のカレンダーを複数行の文字列で返します。
     任意の引数 W, L, C はそれぞれ、日付列の表示幅、各週の行数及び
     月と月の間のスペースの数を変更するためのものです。
     `setfirstweekday()'
     メソッドでセットされた週の最初の曜日に依存します。
     カレンダーを出力できる最初の年はプラットフォームに依存します。

`pryear(theyear[, w[, l[, c[, m]]]])'
     `formatyear()' で返される一年間のカレンダーを出力します。

`HTMLCalendar([firstweekday])'
     このクラスは HTML のカレンダーを生成するのに使えます。

     _Added in Python version 2.5_

`HTMLCalendar' インスタンスには以下のメソッドがあります。

`formatmonth(theyear, themonth[, withyear])'
     ひと月分のカレンダーを HTML のテーブルとして返します。WITHYEAR が
     真であればヘッダには年も含まれます。そうでなければ月の名前だけが使われます。

`formatyear(theyear[, width])'
     一年分のカレンダーを HTML のテーブルとして返します。WIDTH の値
     (デフォルトでは 3 です) は何ヶ月分を一行に収めるかを指定します。

`formatyearpage(theyear[, width[, css[, encoding]]])'
     一年分のカレンダーを一つの完全な HTML ページとして返します。 WIDTH
     の値(デフォルトでは 3 です) は何ヶ月分を一行
     に収めるかを指定します。CSS は使われるカスケーディング
     スタイルシートの名前です。スタイルシートを使わないようにするために
     `None' を渡すこともできます。ENCODING には
     出力に使うエンコーディングを指定します
     (デフォルトではシステムデフォルトのエンコーディングです)。

`LocaleTextCalendar([firstweekday[, locale]])'
     この `TextCalendar'
     のサブクラスではコンストラクタにロケール名を渡す
     ことができ、メソッドの返り値で月や曜日が指定されたロケールのものになります。
     このロケールがエンコーディングを含む場合には、月や曜日の入った文字列は
     ユニコードとして返されます。 _Added in Python version 2.5_

`LocaleHTMLCalendar([firstweekday[, locale]])'
     この `HTMLCalendar'
     のサブクラスではコンストラクタにロケール名を渡す
     ことができ、メソッドの返り値で月や曜日が指定されたロケールのものになります。
     このロケールがエンコーディングを含む場合には、月や曜日の入った文字列は
     ユニコードとして返されます。 _Added in Python version 2.5_

単純なテキストのカレンダーに関して、このモジュールには以下のような関数が提供されています。

`setfirstweekday(weekday)'
     週の最初の曜日(`0'は月曜日, `6'は日曜日)を設定します。定数
     `MONDAY', `TUESDAY', `WEDNESDAY',`THURSDAY', `FRIDAY',
     `SATURDAY'及び`SUNDAY' は便宜上提供されています。
     例えば、日曜日を週の開始日に設定するとき:

          import calendar
          calendar.setfirstweekday(calendar.SUNDAY)

     _Added in Python version 2.0_

`firstweekday()'
     現在設定されている週の最初の曜日を返します。 _Added in Python
     version 2.0_

`isleap(year)'
     YEARが閏年なら`True'を、そうでなければ`False'を返します。

`leapdays(y1, y2)'
     範囲(Y1...Y2)指定された期間の閏年の回数を返します。
     ここでY1やY2は年を表します。 _Changed in Python version 2.0_

`weekday(year, month, day)'
     YEAR(`1970'-...), MONTH (`1'-`12'),
     DAY(`1'-`31')で与えられた日の曜日(`0'は月曜日)を 返します。

`weekheader(n)'
     短縮された曜日名を含むヘッダを返します。N
     は各曜日を何文字で表すかを 指定します。

`monthrange(year, month)'
     YEARとMONTHで指定された月の一日の曜日と日数を返します。

`monthcalendar(year, month)'
     月のカレンダーを行列で返します。各行が週を表し、月の範囲外の日は0になり
     ます。
     それぞれの週は`setfirstweekday()'で設定をしていない限り月曜日か
     ら始まります。

`prmonth(theyear, themonth[, w[, l]])'
     `month()'関数によって返される月のカレンダーを出力します。

`month(theyear, themonth[, w[, l]])'
     `TextCalendar' の `formatmonth' メソッドを利用して、
     ひと月分のカレンダーを複数行の文字列で返します。 _Added in Python
     version 2.0_

`prcal(year[, w[, l[c]]])'
     `calendar()'関数で返される一年間のカレンダーを出力します。

`calendar(year[, w[, l[c]]])'
     `TextCalendar' の `formatyear' メソッドを利用して、
     3列からなる一年間のカレンダーを複数行の文字列で返します。 _Added
     in Python version 2.0_

`timegm(tuple)'
     関連はありませんが便利な関数で、`time'モジュールの
     `gmtime()'関数の戻値のような時間のタプルを受け取り、 1970年を
     起点とし、POSIX規格のエンコードによるUNIXのタイムスタンプに相当する
     値を返します。実際、`time.gmtime()'と`timegm()'は反対
     の動作をします。 _Added in Python version 2.0_

`calendar' モジュールの以下のデータ属性を利用することができます:

`day_name'
     現在のロケールでの曜日を表す配列です。

`day_abbr'
     現在のロケールでの短縮された曜日を表す配列です。

`month_name'
     現在のロケールでの月の名を表す配列です。この配列は通常の約束事に従って、
     1月を数字の 1 で表しますので、長さが 13 ある代わりに
     `month_name[0]' が空文字列になります。

`month_abbr'
     現在のロケールでの短縮された月の名を表す配列です。この配列は通常の約束事に従って、
     1月を数字の 1 で表しますので、長さが 13 ある代わりに
     `month_name[0]' が空文字列になります。

See also:
     *Note datetime:: `time' モジュールと似た機能を持った
     日付と時間用のオブジェクト指向インタフェース。 *Note time::
     低レベルの時間に関連した関数群。


File: python-lib-jp.info,  Node: collections,  Next: heapq,  Prev: calendar,  Up: データ型

5.3 高性能なコンテナ・データ型
==============================

High-performance container datatypes

_Added in Python version 2.4_

このモジュールでは高性能なコンテナ・データ型を実装しています。
現在のところ、実装されている型は deque と defaultdict です。 将来的に
B-tree と ordere dictionary がふくまれるかもしれません。 _Changed in
Python version 2.5_

* Menu:

* deque オブジェクト::
* レシピ::
* defaultdict オブジェクト::


File: python-lib-jp.info,  Node: deque オブジェクト,  Next: レシピ,  Prev: collections,  Up: collections

5.3.1 `deque' オブジェクト
--------------------------

`deque([iterable])'
     ITERABLE で与えられるデータから、新しい deque オブジェクトを
     (`append()' をつかって) 左→右に初期化し、返します。 ITERABLE
     が指定されない場合、新しい deque オブジェクトは空になります。

     Deque とは、スタックとキューを一般化したものです
     (この名前は「デック」と 発音され、これは「double-ended
     queue」の省略形です)。Deque はどちらの側からも append と pop
     が可能で、スレッドセーフでメモリ効率がよく、どちらの方向からも
     およそ `O(1)' のパフォーマンスで実行できます。

     `list' オブジェクトでも同様の操作を実現できますが、これは高速な
     固定長の操作に特化されており、内部のデータ表現形式のサイズと位置を
     両方変えるような `pop(0)' and `insert(0, v)' などの操作では
     メモリ移動のために `O(n)' のコストを必要とします。 _Added in
     Python version 2.4_

Deque オブジェクトは以下のようなメソッドをサポートしています:

`append(x)'
     X を deque の右側につけ加えます。

`appendleft(x)'
     X を deque の左側につけ加えます。

`clear()'
     Deque からすべての要素を削除し、長さを 0 にします。

`extend(iterable)'
     イテレータ化可能な引数 iterable から得られる要素を deque の右側に
     追加し拡張します。

`extendleft(iterable)'
     イテレータ化可能な引数 iterable から得られる要素を deque の左側に
     追加し拡張します。注意: 左から追加した結果は、イテレータ引数の
     順序とは逆になります。

`pop()'
     Deque の右側から要素をひとつ削除し、その要素を返します。
     要素がひとつも存在しない場合は `IndexError' を発生させます。

`popleft()'
     Deque の左側から要素をひとつ削除し、その要素を返します。
     要素がひとつも存在しない場合は `IndexError' を発生させます。

`remove(value)'
     最初に現れる value を削除します。 要素がみつからないない場合は
     `ValueError' を発生させます。 _Added in Python version 2.5_

`rotate(n)'
     Deque の要素を全体で Nステップだけ右にローテートします。 N
     が負の値の場合は、左にローテートします。Deque を
     ひとつ右にローテートすることは `d.appendleft(d.pop())' と同じです。

上記の操作のほかにも、deque は次のような操作をサポートしています:
イテレータ化、pickle、`len(d)'、`reversed(d)'、 `copy.copy(d)'、
`copy.deepcopy(d)'、 `in' 演算子による 包含検査、そして `d[-1]'
などの添え字による参照。

例:

     >>> from collections import deque
     >>> d = deque('ghi')                 # 3つの要素からなる新しい deque をつくる。
     >>> for elem in d:                   # deque の要素をひとつずつたどる。
     ...     print elem.upper()
     G
     H
     I

     >>> d.append('j')                    # 新しい要素を右側につけたす。
     >>> d.appendleft('f')                # 新しい要素を左側につけたす。
     >>> d                                # deque の表現形式。
     deque(['f', 'g', 'h', 'i', 'j'])

     >>> d.pop()                          # いちばん右側の要素を削除し返す。
     'j'
     >>> d.popleft()                      # いちばん左側の要素を削除し返す。
     'f'
     >>> list(d)                          # deque の内容をリストにする。
     ['g', 'h', 'i']
     >>> d[0]                             # いちばん左側の要素をのぞく。
     'g'
     >>> d[-1]                            # いちばん右側の要素をのぞく。
     'i'

     >>> list(reversed(d))                # deque の内容を逆順でリストにする。
     ['i', 'h', 'g']
     >>> 'h' in d                         # deque を検索。
     True
     >>> d.extend('jkl')                  # 複数の要素を一度に追加する。
     >>> d
     deque(['g', 'h', 'i', 'j', 'k', 'l'])
     >>> d.rotate(1)                      # 右ローテート
     >>> d
     deque(['l', 'g', 'h', 'i', 'j', 'k'])
     >>> d.rotate(-1)                     # 左ローテート
     >>> d
     deque(['g', 'h', 'i', 'j', 'k', 'l'])

     >>> deque(reversed(d))               # 新しい deque を逆順でつくる。
     deque(['l', 'k', 'j', 'i', 'h', 'g'])
     >>> d.clear()                        # deque を空にする。
     >>> d.pop()                          # 空の deque からは pop できない。
     Traceback (most recent call last):
       File "<pyshell#6>", line 1, in -toplevel-
         d.pop()
     IndexError: pop from an empty deque

     >>> d.extendleft('abc')              # extendleft() は入力を逆順にする。
     >>> d
     deque(['c', 'b', 'a'])


File: python-lib-jp.info,  Node: レシピ,  Next: defaultdict オブジェクト,  Prev: deque オブジェクト,  Up: collections

5.3.2 レシピ
------------

この節では deque をつかったさまざまなアプローチを紹介します。

`rotate()' メソッドのおかげで、 `deque' の一部を切り出したり
削除したりできることになります。たとえば `del d[n]' の純粋な Python
実装では pop したい要素まで `rotate()' します :

     def delete_nth(d, n):
         d.rotate(-n)
         d.popleft()
         d.rotate(n)

`deque' の切り出しを実装するのにも、同様のアプローチを使います。
まず対象となる要素を `rotate()' によって deque の左端まで
もってきてから、`popleft()' をつかって古い要素を消します。
そして、`extend()' で新しい要素を追加したのち、逆のローテートで
もとに戻せばよいのです。

このアプローチをやや変えたものとして、Forth スタイルのスタック操作、
つまり `dup', `drop', `swap', `over', `pick', `rot', および `roll'
を実装するのも簡単です。

ラウンドロビンのタスクサーバは `deque' をつかって、 `popleft()'
で現在のタスクを選択し、 入力ストリームが使い果たされなければ
`append()' で タスクリストの戻してやることができます:

     def roundrobin(*iterables):
         pending = deque(iter(i) for i in iterables)
         while pending:
             task = pending.popleft()
             try:
                 yield task.next()
             except StopIteration:
                 continue
             pending.append(task)

     >>> for value in roundrobin('abc', 'd', 'efgh'):
     ...     print value

     a
     d
     e
     b
     f
     c
     g
     h

複数パスのデータ・リダクション アルゴリズムは、`popleft()' を
複数回呼んで要素をとりだし、リダクション用の関数を適用してから
`append()' で deque に戻してやることにより、簡潔かつ効率的に
表現することができます。

たとえば入れ子状になったリストでバランスされた二進木をつくりたい場合、
2つの隣接するノードをひとつのリストにグループ化することになります:

     def maketree(iterable):
         d = deque(iterable)
         while len(d) > 1:
             pair = [d.popleft(), d.popleft()]
             d.append(pair)
         return list(d)

     >>> print maketree('abcdefgh')
     [[[['a', 'b'], ['c', 'd']], [['e', 'f'], ['g', 'h']]]]


File: python-lib-jp.info,  Node: defaultdict オブジェクト,  Prev: レシピ,  Up: collections

5.3.3 `defaultdict' オブジェクト
--------------------------------

`defaultdict([default_factory[, ...]])'
     新しいディクショナリ状のオブジェクトを返します。`defaultdict'は
     組込みの `dict'のサブクラスです。メソッドをオーバーライドし、書
     き込み可能なインスタンス変数を1つ追加している以外は
     `dict'クラスと同じです。
     同じ部分については以下では省略されています。

     1つめの引数は`default_factory'属性の初期値です。デフォルトは
     `None'です。残りの引数はキーワード引数もふくめ、`dict'のコ
     ンストラクタにあたえられた場合と同様に扱われます。

     _Added in Python version 2.5_

`defaultdict' オブジェクトは標準の`dict'に加えて、以下のメ
ソッドを実装しています:

`__missing__(key)'
     もし`default_factory'属性が`None'であれば、このメソッドは
     `KeyError'例外を、KEYを引数として発生させます。

     もし`default_factory'属性が`None'でなければ、このメソッドは
     `default_factory'を引数なしで呼び出し、あたえられたKEYに
     対応するデフォルト値を作ります。そしてこの値を KEY に対応する値
     を辞書に登録して返ります。

     もし `default_factory' の呼出が例外を発生させた場合には、
     変更せずそのまま例外を投げます。

     このメソッドは`dict'クラスの `__getitem__' メソッドで、キー
     が存在しなかった場合によびだされます。値を返すか例外を発生させるのどち
     らにしても、`__getitem__'からもそのまま値が返るか例外が発生します。

`defaultdict' オブジェクトは以下のインスタンス変数をサポートして います:

`default_factory'
     この属性は `__missing__' メソッドによって使われます。これは
     存在すればコンストラクタの第1引数によって初期化され、そうでなければ
     `None'になります。

* Menu:

* defaultdict の使用例::


File: python-lib-jp.info,  Node: defaultdict の使用例,  Prev: defaultdict オブジェクト,  Up: defaultdict オブジェクト

5.3.3.1 `defaultdict' の使用例
..............................

`list'を`default_factory'とすることで、キー=値ペアのシー
ケンスをリストの辞書へ簡単にグループ化できます。

     >>> s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
     >>> d = defaultdict(list)
     >>> for k, v in s:
             d[k].append(v)

     >>> d.items()
     [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]

それぞれのキーが最初に登場したとき、マッピングにはまだ存在しません。
そのためエントリは`default_factory'関数が返す空の`list'
を使って自動的に作成されます。
`list.append()'操作は新しいリストに紐付けられます。
キーが再度出現下場合には、通常の参照動作が行われます(そのキーに対応す
るリストが返ります)。そして `list.append()'操作で別の値をリスト
に追加します。このテクニックは`dict.setdefault()'を使った等価な
ものよりシンプルで速いです:

     >>> d = {}
     >>> for k, v in s:
     	d.setdefault(k, []).append(v)

     >>> d.items()
     [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]

`default_factory' を `int' にすると、`defaultdict' を(他の言語の bag や
multisetのように)要素の数え上げに便利に使うことができます:

     >>> s = 'mississippi'
     >>> d = defaultdict(int)
     >>> for k in s:
             d[k] += 1

     >>> d.items()
     [('i', 4), ('p', 2), ('s', 4), ('m', 1)]

最初に文字が出現したときは、マッピングが存在しないので
`default_factory' 関数が `int()'を呼んでデフォルトのカ ウント0
を生成します。インクリメント操作が各文字を数え上げます。
このテクニックは以下の `dict.get()'を使った等価なものよりシンプ
ルで速いです:

     >>> d = {}
     >>> for k in s:
     	d[k] = d.get(k, 0) + 1

     >>> d.items()
     [('i', 4), ('p', 2), ('s', 4), ('m', 1)]

`default_factory' を `set' に設定することで、
`defaultdict'をセットの辞書を作るために利用することができます:

     >>> s = [('red', 1), ('blue', 2), ('red', 3), ('blue', 4), ('red', 1), ('blue', 4)]
     >>> d = defaultdict(set)
     >>> for k, v in s:
             d[k].add(v)

     >>> d.items()
     [('blue', set([2, 4])), ('red', set([1, 3]))]


File: python-lib-jp.info,  Node: heapq,  Next: bisect,  Prev: collections,  Up: データ型

5.4 ヒープキューアルゴリズム
============================

ヒープキュー (別名優先度キュー) アルゴリズム。

_Added in Python version 2.3_

このモジュールではヒープキューアルゴリズムの一実装を提供しています。
優先度キューアルゴリズムとしても知られています。

ヒープとは、全ての K に対して、ゼロから要素を数えて いった際に、
`HEAP[K] <= HEAP[2*K+1]' かつ `HEAP[K] <= HEAP[2*K+2]'
となる配列です。比較のために、存在しない要素は無限大として扱われます。
ヒープの興味深い属性は `HEAP[0]' が常に最小の要素に なることです。

以下の API は教科書におけるヒープアルゴリズムとは 2 つの側面で異なって
います: (a) ゼロベースのインデクス化を行っています。これにより、
ノードに対するインデクスとその子ノードのインデクスの関係がやや明瞭で
なくなりますが、Python はゼロベースのインデクス化を使っているので
よりしっくりきます。(b) われわれの pop メソッドは最大の要素ではなく
最小の要素 (教科書では "min heap:最小ヒープ" と呼ばれています;
教科書では並べ替えをインプレースで行うのに適した "max heap:最大ヒープ"
が一般的です)。

これらの 2 点によって、ユーザに戸惑いを与えることなく、ヒープを通常の
Python リストとして見ることができます: `HEAP[0]' が最小の 要素となり、
`HEAP.sort()' はヒープを不変なままに保ちます!

ヒープを作成するには、`[]' に初期化されたリストを使うか、 `heapify()'
を用いて要素の入ったリストを変換します。

以下の関数が提供されています:

`heappush(heap, item)'
     ITEM を HEAP に push します。ヒープを不変に保ちます。

`heappop(heap)'
     pop を行い、HEAP から最初の要素を返します。ヒープは不変に
     保たれます。ヒープが空の場合、`IndexError' が送出されます。

`heapify(x)'
     リスト X をインプレース処理し、線形時間でヒープに変換します。

`heapreplace(heap, item)'
     HEAP から最小の要素を pop して返し、新たに ITEM を push
     します。ヒープのサイズは変更されません。 ヒープが空の場合、
     `IndexError' が送出されます。 この関数は `heappop()' に次いで
     `heappush()'
     を送出するよりも効率的で、固定サイズのヒープを用いている場合には
     より適しています。返される値は ITEM よりも大きくなるかも
     しれないので気をつけてください! これにより、このルーチンの合理的な
     利用法は条件つき置換の一部として使われることに制限されています。
                  if item > heap[0]:
                      item = heapreplace(heap, item)


使用例を以下に示します:

     >>> from heapq import heappush, heappop
     >>> heap = []
     >>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
     >>> for item in data:
     ...     heappush(heap, item)
     ...
     >>> sorted = []
     >>> while heap:
     ...     sorted.append(heappop(heap))
     ...
     >>> print sorted
     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     >>> data.sort()
     >>> print data == sorted
     True
     >>>

このモジュールではさらに2つのヒープに基く汎用関数を提供します。

`nlargest(n, iterable[, key])'
     ITERABLEで定義されるデータセットのうち、最大値から降順にN
     個の値のリストを返します。
     (あたえられた場合)KEYは、引数を一つとる、ITERABLEのそれぞ
     れの要素から比較キーを生成する関数を指定します: `KEY=`str.lower''
     以下のコードと同等です: `sorted(iterable, key=key,
     reverse=True)[:n]' _Added in Python version 2.4_ _Changed in
     Python version 2.5_

`nsmallest(n, iterable[, key])'
     ITERABLEで定義されるデータセットのうち、最小値から昇順にN
     個の値のリストを返します。
     (あたえられた場合)KEYは、引数を一つとる、ITERABLEのそれぞ
     れの要素から比較キーを生成する関数を指定します: `KEY=`str.lower''
     以下のコードと同等です: `sorted(iterable, key=key)[:n]' _Added in
     Python version 2.4_ _Changed in Python version 2.5_

どちらの関数もNの値が小さな場合に最適な動作をします。
大きな値の時には`sorted()'関数の方が効率的です。
さらに、`n==1'の時には`min()'および`max()' 関数 の方が効率的です。

* Menu:

* 理論::


File: python-lib-jp.info,  Node: 理論,  Prev: heapq,  Up: heapq

5.4.1 理論
----------

(説明は Franc,ois Pinard によるものです。このモジュールの Python コード
は Kevin O'Connor の貢献によるものです。)

ヒープとは、全ての K について、要素を 0 から数えたときに、 `a[K] <=
a[2*K+1]' かつ `a[K] <= a[2*K+2]' となる配列です。
比較のために、存在しない要素を無限大と考えます。 ヒープの興味深い属性は
`HEAP[0]' が常に最小の要素に なることです。

上記の奇妙な不変式は、勝ち抜き戦判定の際に効率的なメモリ表現を行う
ためのものです。 以下の番号は `a[K]' ではなく K とします:

                                        0

                       1                                 2

               3               4                5               6

           7       8       9       10      11      12      13      14

         15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30

上の木構造では、各セル K は `2*K+1' および `2*K+2'
を最大値としています。 スポーツに見られるような通常の 2
つ組勝ち抜き戦では、各セルはその
下にある二つのセルに対する勝者となっていて、個々のセルの勝者を
追跡していくことにより、そのセルに対する全ての相手を見ることが
できます。しかしながら、このような勝ち抜き戦を使う計算機
アプリケーションの多くでは、勝歴を追跡する必要はりません。
メモリ効率をより高めるために、勝者が上位に進級した際、
下のレベルから持ってきて置き換えることにすると、あるセルと
その下位にある二つのセルは異なる三つの要素を含み、かつ
上位のセルは二つの下位のセルに対して "勝者と" なります。

このヒープ不変式が常に守られれば、インデクス 0 は明らかに
最勝者となります。最勝者の要素を除去し、"次の" 勝者を見つける
ための最も単純なアルゴリズム的手法は、ある敗者要素 (ここでは上図の セル
30 とします) を 0 の場所に持っていき、この新しい 0 を
濾過するようにしてツリーを下らせて値を交換してゆきます。不変関係が
再構築されるまでこれを続けます。この操作は明らかに、ツリー内の
全ての要素数に対して対数的な計算量となります。全ての要素について
繰り返すと、 O(n log n) のソート(並べ替え)になります。

このソートの良い点は、新たに挿入する要素が、その最に取り出す 0 番目の
要素よりも "良い値" でない限り、ソートを行っている最中に新たな要素を
効率的に追加できるというところです。

この性質は、シミュレーション的な状況で、ツリーで全ての入力
イベントを保持し、"勝者となる状況" を最小のスケジュール時刻にする
ような場合に特に便利です。あるイベントが他のイベント群の実行を
スケジュールする際、それらは未来にスケジュールされることになるので、
それらのイベント群を容易にヒープに積むことができます。
すなわち、ヒープはスケジューラを実装する上で良いデータ構造で
あるといえます (私は MIDI シーケンサで使っているものです :-).

これまでスケジューラを実装するための様々なデータ構造が広範に
研究されています。ヒープは十分高速で、速度もおおむね一定であり、
最悪の場合でも平均的な速度とさほど変わらないため良いデータ構造と
いえます。しかし、最悪の場合がひどい速度になることを除き、
たいていでより効率の高い他のデータ構造表現も存在します。

ヒープはまた、巨大なディスクのソートでも非常に有用です。
おそらくご存知のように、巨大なソートを行うと、複数の "ラン (run)"
(予めソートされた配列で、そのサイズは通常 CPU メモリの量に関係
しています) が生成され、続いて統合処理 (merging) がこれらのランを
判定します。この統合処理はしばしば非常に巧妙に組織されています (1)。
重要なのは、最初のソートが可能な限り長いランを生成することです。
勝ち抜き戦はこれを行うための良い方法です。もし利用可能な全ての
メモリを使って勝ち抜き戦を行い、要素を置換および濾過処理して
現在のランに収めれば、ランダムな入力に対してメモリの二倍の
サイズのランを生成することになり、大体順序づけがなされている入力に
対してはもっと高い効率になります。

さらに、ディスク上の 0 番目の要素を出力して、現在の勝ち抜き戦に
(最後に出力した値に "勝って" しまうために) 収められない入力を得た
なら、ヒープには収まらないため、ヒープのサイズは減少します。
解放されたメモリは二つ目のヒープを段階的に構築するために巧妙に再利用
することができ、この二つ目のヒープは最初のヒープが崩壊していく
のと同じ速度で成長します。最初のヒープが完全に消滅したら、
ヒープを切り替えて新たなランを開始します。なんと巧妙で
効率的なのでしょう！

一言で言うと、ヒープは知って得するメモリ構造です。
私はいくつかのアプリケーションでヒープを使っていて、 `ヒープ'
モジュールを常備するのはいい事だと考えています。 :-)

---------- Footnotes ----------

(1) 現在使われているディスクバランス化アルゴリズムは、最近は
もはや巧妙というよりも目障りであり、このためにディスクに対するシーク
機能が重要になっています。巨大な容量を持つテープのようにシーク不能な
デバイスでは、事情は全く異なり、個々のテープ上の移動が可能な限り
効率的に行われるように非常に巧妙な処理を (相当前もって) 行わねば
なりません (すなわち、もっとも統合処理の "進行" に関係があります)。
テープによっては逆方向に読むことさえでき、巻き戻しに時間を取られる
のを避けるために使うこともできます。正直、本当に良いテープソート
は見ていて素晴らしく驚異的なものです！ソートというのは常に偉大な
芸術なのです！:-)


File: python-lib-jp.info,  Node: bisect,  Next: array,  Prev: heapq,  Up: データ型

5.5 配列二分法アルゴリズム
==========================

バイナリサーチ用の配列二分法アルゴリズム。

このモジュールは、挿入の度にリストをソートすることなく、リストをソートされた
順序に保つことをサポートします。
大量の比較操作を伴うような、アイテムがたくさんあるリストでは、より一般的な
アプローチに比べて、パフォーマンスが向上します。

動作に基本的な二分法アルゴリズムを使っているので、`bisect'
と呼ばれています。
ソースコードはこのアルゴリズムの実例として一番役に立つかもしれません
(境界条件はすでに正しいです!)。

次の関数が用意されています。

`bisect_left(list, item[, lo[, hi]])'
     ソートされた順序を保ったまま ITEM を LIST に挿入するのに適した
     挿入点を探し当てます。
     リストの中から検索する部分集合を指定するには、パラメーターの LO と
     HI を使います。 デフォルトでは、リスト全体が使われます。 ITEM
     がすでに LIST に含まれている場合、挿入点はどのエントリー
     よりも前(左)になります。 戻り値は、`LIST.insert()'
     の第一引数として使うのに適しています。 LIST
     はすでにソートされているものとします。 _Added in Python version
     2.1_

`bisect_right(list, item[, lo[, hi]])'
     `bisect_left()' と似ていますが、LIST に含まれる ITEM
     のうち、どのエントリーよりも後ろ(右)にくるような挿入点を返します。
     _Added in Python version 2.1_。

`bisect(...)'
     `bisect_right()' のエイリアス。

`insort_left(list, item[, lo[, hi]])'
     ITEM を LIST にソートされた順序で(ソートされたまま)挿入します。
     これは、 `LIST.insert(bisect.bisect_left(LIST, ITEM, LO, HI),
     ITEM)' と同等です。 LIST はすでにソートされているものとします。
     _Added in Python version 2.1_

`insort_right(list, item[, lo[, hi]])'
     `insort_left()' と似ていますが、LIST に含まれる ITEM
     のうち、どのエントリーよりも後ろに ITEM を挿入します。 _Added in
     Python version 2.1_

`insort(...)'
     `insort_right()' のエイリアス。

* Menu:

* bisect-example::


File: python-lib-jp.info,  Node: bisect-example,  Prev: bisect,  Up: bisect

5.5.1 使用例
------------

一般には、`bisect()' 関数は数値データを分類するのに役に立ちます。
この例では、`bisect()' を使って、(たとえば)順序のついた数値の区切り点
の集合に基づいて、試験全体の成績の文字を調べます。 区切り点は 85 以上は
`A'、 75..84 は `B'、などです。

     >>> grades = "FEDCBA"
     >>> breakpoints = [30, 44, 66, 75, 85]
     >>> from bisect import bisect
     >>> def grade(total):
     ...           return grades[bisect(breakpoints, total)]
     ...
     >>> grade(66)
     'C'
     >>> map(grade, [33, 99, 77, 44, 12, 88])
     ['E', 'A', 'B', 'D', 'F', 'A']


File: python-lib-jp.info,  Node: array,  Next: sets,  Prev: bisect,  Up: データ型

5.6 効率のよい数値アレイ
========================

一様な型を持つ数値からなる効率のよいアレイ。

このモジュールでは、基本的な値 (文字、整数、浮動小数点数) のアレイ
(array、配列) を効率よく表現できるオブジェクト型を定義しています。
アレイ はシーケンス (sequence) 型であり、中に入れる
オブジェクトの型に制限があることを除けば、リストとまったく同じように振
る舞います。オブジェクト生成時に一文字の"型コード" を用いて型を指
定します。次の型コードが定義されています:

型コード           C の型             Python の型        最小サイズ
                                                         (バイト単位)
------             ------             ------             ------
'c'                char               文字(str型)        1
'b'                signed char        int型              1
'B'                unsigned char      int型              1
'u'                Py_UNICODE         Unicode文字(unicode型)2
'h'                signed short       int型              2
'H'                unsigned short     int型              2
'i'                signed int         int型              2
'I'                unsigned int       long型             2
'l'                signed long        int型              4
'L'                unsigned long      long型             4
'f'                float              float型            4
'd'                double             float型            8

値の実際の表現はマシンアーキテクチャ (厳密に言うとCの実装) によって決
まります。値の実際のサイズは`itemsize' 属性から得られます。 Python
の通常の整数型では C の unsigned (long) 整数の最大範囲を表せな
いため、`'L''と`'I'' で表現されている要素に入る値は Python
では長整数として表されます。

このモジュールでは次の型を定義しています:

`array(typecode[, initializer])'
     要素のデータ型がTYPECODEに限定される新しいアレイを返します。
     オプションの値INITIALIZERをわたすと初期値になりますが、
     リスト、文字列または適当な型のイテレーション可能オブジェクトでなければ
     なりません。

     _Changed in Python version 2.4_
     リストか文字列を渡した場合、新たに作成されたアレイの`fromlist()'、
     `fromstring()'あるいは`fromunicode()'メソッド (以下を参照
     して下さい)
     に渡され、初期値としてアレイに追加されます。それ以外の場合
     には、イテレーション可能オブジェクト INITIALIZER は新たに作成
     されたオブジェクトの`extend()'メソッドに渡されます。

`ArrayType'
     `array'の別名です。撤廃されました。

アレイオブジェクトでは、インデクス指定、スライス、連結および反復といっ
た、通常のシーケンスの演算をサポートしています。スライス代入を使うときは、
代入値は同じ型コードのアレイオブジェクトでなければなりません。
それ以外のオブジェクトを指定すると`TypeError' を送出します。
アレイオブジェクトはバッファインタフェースを実装しており、
バッファオブジェクトをサポートしている場所ならどこでも利用できます。

次のデータ要素やメソッドもサポートされています:

`typecode'
     アレイを作るときに使う型コード文字です。

`itemsize'
     アレイの要素 1 つの内部表現に使われるバイト長です。

`append(x)'
     値X の新たな要素をアレイの末尾に追加します。

`buffer_info()'
     アレイの内容を記憶するために使っているバッファの、現在のメモリアドレス
     と要素数の入ったタプル`(ADDRESS, LENGTH)' を返します。
     バイト単位で表したメモリバッファの大きさは `ARRAY.buffer_info()[1]
     * ARRAY.itemsize'で計算できま す。例えば`ioctl()'
     操作のような、メモリアドレスを必要とする 低レベルな
     (そして、本質的に危険な) I/Oインタフェースを使って作業する
     場合に、ときどき便利です。アレイ自体が存在し、長さを変えるような演算を
     適用しない限り、有効な値を返します。

     _Note:_ C やC++ で書いたコードからアレイオブジェクトを使う場合
     (`buffer_info' の情報を使う意味のある唯一の方法です) は、
     アレイオブジェクトでサポートしているバッファインタフェースを使う方が
     より理にかなっています。このメソッドは後方互換性のために保守されており、
     新しいコードでの使用は避けるべきです。バッファインタフェースの説明は
     にあります。


`byteswap()'
     アレイのすべての要素に対して「バイトスワップ」(リトルエンディアンとビッ
     グエンディアンの変換) を行います。このメソッドは大きさが 1、2、4
     およ び 8 バイトの値にのみをサポートしています。他の型の値に使うと
     `RuntimeError' を送出します。異なるバイトオーダをもつ計算機
     で書かれたファイルからデータを読み込むときに役に立ちます。

`count(x)'
     シーケンス中のX の出現回数を返します。

`extend(iterable)'
     ITERABLE から要素を取り出し、アレイの末尾に要素を追加します。
     ITERABLE が別のアレイ型である場合、二つのアレイは_全く_同
     じ型コードをでなければなりません。それ以外の場合には `TypeError'
     を送出します。 ITERABLE
     がアレイでない場合、アレイに値を追加できるような正しい
     型の要素からなるイテレーション可能オブジェクトでなければなりません。
     _Changed in Python version 2.4_

`fromfile(f, n)'
     ファイルオブジェクトF から (マシン依存のデータ形式そのままで) N
     個の要素を読み出し、アレイの末尾に要素を追加します。 N
     個の要素を読めなかったときは`EOFError' を送出します
     が、それまでに読み出せた値はアレイに追加されています。 F
     は本当の組み込みファイルオブジェクトでなければなりません。
     `read()'メソッドをもつ他の型では動作しません。

`fromlist(list)'
     リストから要素を追加します。型に関するエラーが発生した場合にアレイが変
     更されないことを除き、`for x in LIST: a.append(x)'と同じです。

`fromstring(s)'
     文字列から要素を追加します。文字列は、 (ファイルから `fromfile()'
     メソッドを使って値を読み込んだときのように)
     マシン依存のデータ形式で表された値の配列として解釈されます。

`fromunicode(s)'
     指定した Unicode 文字列のデータを使ってアレイを拡張します。アレイの
     型コードは `'u'' でなければなりません。それ以外の場合には、
     `ValueError' を送出します。他の型のアレイに Unicode 型のデータ
     を追加するには、`array.fromstring(ustr.decode(enc))' を使ってくだ
     さい。

`index(x)'
     アレイ中でX が出現するインデクスのうち最小の値 I を返しま す。

`insert(i, x)'
     アレイ中の位置I の前に値X をもつ新しい要素を挿入します。 I
     の値が負の場合、アレイの末尾からの相対位置として扱います。

`pop([i])'
     アレイからインデクスがI の要素を取り除いて返します。
     オプションの引数はデフォルトで`-1' になっていて、最後の要素を取り
     除いて返すようになっています。

`read(f, n)'
     _This is deprecated in Python 1.5.1.
     `fromfile()'メソッドを使ってください。_

     ファイルオブジェクトF から (マシン依存のデータ形式そのままで) N
     個の要素を読み出し、アレイの末尾に要素を追加します。 N
     個の要素を読めなかったときは`EOFError' を送出します
     が、それまでに読み出せた値はアレイに追加されています。 F
     は本当の組み込みファイルオブジェクトでなければなりません。
     `read()'メソッドをもつ他の型では動作しません。

`remove(x)'
     アレイ中のX のうち、最初に現れたものを取り除きます。

`reverse()'
     アレイの要素の順番を逆にします。

`tofile(f)'
     アレイのすべての要素をファイルオブジェクトFに
     (マシン依存のデータ形式そのままで)書き込みます。

`tolist()'
     アレイを同じ要素を持つ普通のリストに変換します。

`tostring()'
     アレイをマシン依存のデータアレイに変換し、文字列表現 (`tofile()'
     メソッドによってファイルに書き込まれるものと同じ バイト列)
     を返します。

`tounicode()'
     アレイを Unicode 文字列に変換します。アレイの型コードは `'u''
     でなければ なりません。それ以外の場合には `ValueError'
     を送出します。 他の型のアレイから Unicode 文字列を得るには、
     `array.tostring().decode(enc)' を使ってください。

`write(f)'
     _This is deprecated in Python 1.5.1.
     `tofile()'メソッドを使ってください。_

     ファイルオブジェクトFに、全ての要素を(マシン依存のデータ形式その
     ままで)書き込みます。

アレイオブジェクトを表示したり文字列に変換したりすると、
`array(TYPECODE, INITIALIZER)' という形式で表現されま
す。アレイが空の場合、INITIALIZER の表示を省略します。アレイが
空でなければ、TYPECODE が `'c'' の場合には文字列に、
それ以外の場合には数値のリストになります。 関数`array()' を`from array
import array' で import して
いる限り、変換後の文字列に逆クォーテーション(```')を用いると
元のアレイオブジェクトと同じデータ型と値を持つアレイに逆変換できること
が保証されています。文字列表現の例を以下に示します:

     array('l')
     array('c', 'hello world')
     array('u', u'hello \textbackslash u2641')
     array('l', [1, 2, 3, 4, 5])
     array('d', [1.0, 2.0, 3.14])

See also:
     *Note struct:: 異なる種類のバイナリデータのパックおよびアンパック。
     *Note xdrlib::
     遠隔手続き呼び出しシステムで使われる外部データ表現仕様 (External
     Data Representation, XDR) のデータのパックおよびアンパック。 `The
     Numerical Python Manual' {Numeric Python 拡張モジュール (NumPy)
     では、別の方法でシーケンス型を定義 しています。Numerical Python
     に関する詳しい情報は
     `http://numpy.sourceforge.net/'を参照してください。 (NumPy
     マニュアルの PDF バージョンは
     `http://numpy.sourceforge.net/numdoc/numdoc.pdf'で手に入ります。}



File: python-lib-jp.info,  Node: sets,  Next: sched,  Prev: array,  Up: データ型

5.7 ユニークな要素の順序なしコレクション
========================================

ユニークな要素の集合の実装

_Added in Python version 2.3_

`sets'モジュールは、ユニークな要素の順序なしコレクションを構築し、
操作するためのクラスを提供します。
帰属関係のテストやシーケンスから重複を取り除いたり、
積集合・和集合・差集合・対称差集合のような標準的な数学操作などを含みます。

他のコレクションのように、`X in SET', `len(SET)', `for X in
SET'をサポートします。
順序なしコレクションは、挿入の順序や要素位置を記録しません。
従って、インデックス・スライス・他のシーケンス的な振舞いをサポートしません。

ほとんどの集合のアプリケーションは、`__hash__()'を除いて
すべての集合のメソッドを提供する`Set'クラスを使用します。
ハッシュを要求する高度なアプリケーションについては、
`ImmutableSet'クラスが`__hash__()'メソッドを加えているが、
集合の内容を変更するメソッドは省略されます。 `Set'と`ImmutableSet'は、
何が集合(`isinstance(OBJ, BaseSet)')であるか決めるのに役立つ
抽象クラス`BaseSet'から派生します。

集合クラスは辞書を使用して実装されます。
このことから、集合の要素にするには辞書のキーと同様の要件を満たさなけれ
ばなりません。具体的には、要素になるものには `__eq__' と `__hash__'
が定義されているという条件です。
その結果、集合はリストや辞書のような変更可能な要素を含むことができません。
しかしそれらは、タプルや`ImmutableSet'のインスタンスのような
不変コレクションを含むことができます。
集合の集合の実装中の便宜については、内部集合が自動的に変更不可能な形式に
変換されます。
例えば、`Set([Set(['dog'])])'は`Set([ImmutableSet(['dog'])])'へ
変換されます。

`Set([iterable])'
     新しい空の`Set'オブジェクトを構築します。
     もしオプションITERABLEが与えられたら、イタレータから得られた
     要素を備えた集合として更新します。
     ITERABLE中の全ての要素は、変更不可能であるか、 または*Note
     不変に自動変換するためのプロトコル::で記述されたプロトコルを使って
     変更不可能なものに変換可能であるべきです。

`ImmutableSet([iterable])'
     新しい空の`ImmutableSet'オブジェクトを構築します。
     もしオプションITERABLEが与えられたら、イタレータから得られた
     要素を備えた集合として更新します。
     ITERABLE中の全ての要素は、変更不可能であるか、 または*Note
     不変に自動変換するためのプロトコル::で記述されたプロトコルを使って
     変更不可能なものに変換可能であるべきです。

     `ImmutableSet'オブジェクトは`__hash__()'メソッドを備えているので、
     集合要素または辞書キーとして使用することができます。
     `ImmutableSet'オブジェクトは要素を加えたり取り除いたりするメソッドを
     持っていません。したがって、コンストラクタが呼ばれたとき要素はすべて
     知られていなければなりません。

* Menu:

* Set オブジェクト::
* 使用例 2::
* 不変に自動変換するためのプロトコル::
* 組み込み set 型との比較::


File: python-lib-jp.info,  Node: Set オブジェクト,  Next: 使用例 2,  Prev: sets,  Up: sets

5.7.1 Set オブジェクト
----------------------

`Set'と`ImmutableSet'のインスタンスはともに、 以下の操作を備えています:

演算                     等価な演算               結果
------                   -----                    -----
len(S)                                            集合Sの濃度
                                                  (cardinality)
X in S                                            XがSに帰属していれば真を返す
X not in S                                        XがSに帰属していなければ真を返す
S.issubset(T)            `S <= T'                 Sのすべての要素がTに帰属していれば真を返す
S.issuperset(T)          `S >= T'                 Tのすべての要素がSに帰属していれば真を返す
S.union(T)               S | T                    SとTの両方の要素からなる新しい集合
S.intersection(T)        S & T                    SとTで共通する要素からなる新しい集合
S.difference(T)          S - T                    SにあるがTにない要素からなる新しい集合
S.symmetric_difference(T)S ^ T                    SとTのどちらか一方に属する要素からなる集合
S.copy()                                          Sの浅いコピーからなる集合

演算子を使わない書き方である `union()'、 `intersection()'、
`difference()'、および`symmetric_difference()' は任意の
イテレート可能オブジェクトを引数として受け取るのに対し、演算子を使った
書き方の方では引数は集合型でなければならないので注意してください。
これはエラーの元となる`Set('abc') & 'cbs'' のような書き方を
排除し、より可読性のある`Set('abc').intersection('cbs')'
を選ばせるための仕様です。 _Changed in Python version 2.3.1_

加えて、`Set'と`ImmutableSet' は集合間の比較をサポートしています。
二つの集合は、各々の集合のすべての要素が他方に含まれて (各々が他方の
部分集合) いる場合、かつその場合に限り等価になります。
ある集合は、他方の集合の真の部分集合 (proper subset、部分集合で
あるが非等価)
である場合、かつその場合に限り、他方の集合より小さくなります。
ある集合は、他方の集合の真の上位集合 (proper superset、上位集合で
あるが非等価)
である場合、かつその場合に限り、他方の集合より大きくなります。

部分集合比較やと等値比較では、完全な順序決定関数を一般化できません。
たとえば、互いに素な 2 つの集合は等しくありませんし、互いの部
分集合でもないので、`A<B'、 `A==B'、 `A>B' は_すべて_ `False'
を返します。 したがって集合は `__cmp__' メソッドを実装しません。

集合は一部の順序（部分集合の関係）を定義するだけなので、集合のリストにおいて
`list.sort()' メソッドの出力は未定義です。

以下は`ImmutableSet'で利用可能であるが`Set'にはない操作です:

演算                                 結果
------                               -----
hash(S)                              S のハッシュ値を返す

以下は`Set'で利用可能であるが`ImmutableSet'にはない操作です:

演算                     等価な演算               結果
------                   -----                    -----
S.update(T)              S |= T                   Tを加えた要素からなる集合Sを返します
S.intersection_update(T) S &= T                   Tでも見つかった要素だけを持つ集合Sを返します
S.difference_update(T)   S -= T                   Tにあった要素を取り除いた後の集合Sを返します
S.symmetric_difference_update(T)S ^= T                   SとTのどちらか一方に属する要素からなる集合
                                                  Sを返します
S.add(X)                                          要素Xを集合Sに加えます
S.remove(X)                                       要素Xを集合Sから取り除きます;
                                                  X がなければ
                                                  `KeyError' を送出します
S.discard(X)                                      要素Xが存在すれば、集合Sから取り除きます
S.pop()                                           Sから要素を取り除き、それを返します;
                                                  集合が空なら `KeyError'
                                                  を送出します
S.clear()                                         集合Sからすべての要素を取り除きます

演算子を使わない書き方である `update()'、
`intersection_update()'、`difference_update()'、
および`symmetric_difference_update()' は任意の
イテレート可能オブジェクトを引数として受け取るので注意してください。
_Changed in Python version 2.3.1_

もう一つ注意を述べますが、このモジュールでは `union_update()' が
`update()' の別名として含まれています。
このメソッドは後方互換性のために残されているものです。
プログラマは組み込みの `set()' および `frozenset()' で
サポートされている `update()' を選ぶべきです。


File: python-lib-jp.info,  Node: 使用例 2,  Next: 不変に自動変換するためのプロトコル,  Prev: Set オブジェクト,  Up: sets

5.7.2 使用例
------------

     >>> from sets import Set
     >>> engineers = Set(['John', 'Jane', 'Jack', 'Janice'])
     >>> programmers = Set(['Jack', 'Sam', 'Susan', 'Janice'])
     >>> managers = Set(['Jane', 'Jack', 'Susan', 'Zack'])
     >>> employees = engineers | programmers | managers           # union
     >>> engineering_management = engineers & managers            # intersection
     >>> fulltime_management = managers - engineers - programmers # difference
     >>> engineers.add('Marvin')                                  # add element
     >>> print engineers
     Set(['Jane', 'Marvin', 'Janice', 'John', 'Jack'])
     >>> employees.issuperset(engineers)           # superset test
     False
     >>> employees.union_update(engineers)         # update from another set
     >>> employees.issuperset(engineers)
     True
     >>> for group in [engineers, programmers, managers, employees]:
     ...     group.discard('Susan')                # unconditionally remove element
     ...     print group
     ...
     Set(['Jane', 'Marvin', 'Janice', 'John', 'Jack'])
     Set(['Janice', 'Jack', 'Sam'])
     Set(['Jane', 'Zack', 'Jack'])
     Set(['Jack', 'Sam', 'Jane', 'Marvin', 'Janice', 'John', 'Zack'])


File: python-lib-jp.info,  Node: 不変に自動変換するためのプロトコル,  Next: 組み込み set 型との比較,  Prev: 使用例 2,  Up: sets

5.7.3 不変に自動変換するためのプロトコル
----------------------------------------

集合は変更不可能な要素だけを含むことできます。
都合上、変更可能な`Set'オブジェクトは、集合要素として加えられる前に、
自動的に`ImmutableSet'へコピーします。
そのメカニズムはハッシュ可能な要素を常に加えることですが、
もしハッシュ不可能な場合は、その要素は変更不可能な等価物を返す
`__as_immutable__()'メソッドを持っているかどうかチェックされます。

`Set'オブジェクトは、`ImmutableSet'のインスタンスを返す
`__as_immutable__()'メソッドを持っているので、集合の集合を構築
することが可能です。

集合内のメンバーであることをチェックするために、
要素をハッシュする必要がある`__contains__()'メソッドと
`remove()'メソッドが、同様のメカニズムを必要としています。
これらのメソッドは要素がハッシュできるかチェックします。
もし出来なければ-`__hash__()',`__eq__()',`__ne__()'
のための一時的なメソッドを備えたクラスによってラップされた要素を返すメソッド-
`__as_temporarily_immutable__()'メソッドをチェックします。

代理メカニズムは、オリジナルの可変オブジェクトから分かれたコピーを
組み上げる手間を助けてくれます。

`Set'オブジェクトは、新しいクラス`_TemporarilyImmutableSet'
によってラップされた`Set'オブジェクトを返す、
`__as_temporarily_immutable__()'メソッドを実装します。

ハッシュ可能を与えるための2つのメカニズムは通常ユーザーに見えません。
しかしながら、マルチスレッド環境下においては、
`_TemporarilyImmutableSet'によって一時的にラップされたものを
持っているスレッドがあるときに、もう一つのスレッドが集合を更新することで、
衝突を発生させることができます。
言いかえれば、変更可能な集合の集合はスレッドセーフではありません。


File: python-lib-jp.info,  Node: 組み込み set 型との比較,  Prev: 不変に自動変換するためのプロトコル,  Up: sets

5.7.4 組み込み `set' 型との比較
-------------------------------

組み込みの `set' および `frozenset' 型はこの `sets' で
学んだことを生かして設計されています。主な違いは次の通りです。

   * `Set' と `ImmutableSet' は `set' と `frozenset' に改名されました。

   * `BaseSet' に相当するものはありません。代わりに `isinstance(x,
     (set, frozenset))' を使って下さい。

   * 組み込みのものに使われているハッシュアルゴリズムは、
     多くのデータ集合に対してずっと良い性能(少ない衝突)を実現します。

   * 組み込みのものはより空間効率良く pickle 化できます。

   * 組み込みのものには `union_update()' メソッドがありません。
     代わりに同じ機能の `update()' メソッドを使って下さい。

   * 組み込みのものには `_repr(sorted=True)' メソッドがありません。
     代わりに組み込み関数の `repr()' と `sorted()' を使って
     `repr(sorted(s))' として下さい。

   *
     組み込みのものは変更不可能なものに自動で変換するプロトコルがありません。
     この機能は多くの人が困惑を覚えるわりに、コミュニティの誰からも実際的な
     使用例の報告がありませんでした。


File: python-lib-jp.info,  Node: sched,  Next: mutex,  Prev: sets,  Up: データ型

5.8 イベントスケジューラ
========================

一般的な目的のためのイベントスケジューラ

`sched'モジュールは一般的な目的のためのイベントスケジューラを
実装するクラスを定義します: 

`scheduler(timefunc, delayfunc)'
     `scheduler'クラスはイベントをスケジュールするための一般的な
     インターフェースを定義します。それは"外部世界"を実際に扱うための
     2つの関数を必要とします -- TIMEFUNCは引数なしで呼出し可能で
     あるべきで、そして数(それは"time"です, どんな単位でもかまいません)
     を返すようにします。DELAYFUNCは1つの引数(TIMEFUNCの出力
     と互換)で呼出し可能であり、その時間だけ遅延しなければいけません。
     各々のイベントが、マルチスレッドアプリケーションの中で他のスレッドが
     実行する機会の許可を実行した後に、DELAYFUNCは引数`0'で呼
     ばれるでしょう。

例:

     >>> import sched, time
     >>> s=sched.scheduler(time.time, time.sleep)
     >>> def print_time(): print "From print_time", time.time()
     ...
     >>> def print_some_times():
     ...     print time.time()
     ...     s.enter(5, 1, print_time, ())
     ...     s.enter(10, 1, print_time, ())
     ...     s.run()
     ...     print time.time()
     ...
     >>> print_some_times()
     930343690.257
     From print_time 930343695.274
     From print_time 930343700.273
     930343700.276

* Menu:

* スケジューラオブジェクト::


File: python-lib-jp.info,  Node: スケジューラオブジェクト,  Prev: sched,  Up: sched

5.8.1 スケジューラオブジェクト
------------------------------

`scheduler'インスタンスは以下のメソッドを持っています:

`enterabs(time, priority, action, argument)'
     新しいイベントをスケジュールします。引数TIMEは、
     コンストラクタへ渡されたTIMEFUNCの戻り値と互換な数値型で
     なければいけません。 同じTIMEによってスケジュールされたイベントは、
     それらのPRIORITYによって実行されるでしょう。

     イベントを実行することは、`ACTION(*ARGUMENT)'を
     実行することを意味します。
     ARGUMENTはACTIONのためのパラメータを保持するシーケンスで
     なければいけません。

     戻り値は、イベントのキャンセル後に使われるかもしれないイベントです
     (`cancel()'を見よ)。

`enter(delay, priority, action, argument)'
     時間単位以上のDELAYでイベントをスケジュールします。
     そのとき、その他の関連時間、その他の引数、効果、戻り値は、
     `enterabs()'に対するものと同じです。

`cancel(event)'
     キューからイベントを消去します。
     もしEVENTがキューにある現在のイベントでないならば、
     このメソッドは`RuntimeError'を送出します。

`empty()'
     もしイベントキューが空ならば、Trueを返します。

`run()'
     すべてのスケジュールされたイベントを実行します。
     この関数は次のイベントを(コンストラクタへ渡された関数
     `delayfunc'を使うことで)待ち、そしてそれを実行し、
     イベントがスケジュールされなくなるまで同じことを繰り返します。

     ACTIONあるいはDELAYFUNCは例外を投げることができます。
     いずれの場合も、スケジューラは一貫した状態を維持し、例外を伝播するでしょう。
     例外がACTIONによって投げられる場合、イベントは`run()'への
     呼出しを未来に行なわないでしょう。

     イベントのシーケンスが、次イベントの前に、利用可能時間より実行時間が長いと、
     スケジューラは単に遅れることになるでしょう。
     イベントが落ちることはありません;
     呼出しコードはもはや適切でないキャンセルイベントに対して責任があります。


File: python-lib-jp.info,  Node: mutex,  Next: Queue,  Prev: sched,  Up: データ型

5.9 排他制御
============

排他制御のためのロックとキュー

`mutex' モジュールでは、ロック (lock) の獲得と解除によって
排他制御を可能にするクラスを定義しています。
排他制御はスレッドやマルチタスクを使う上で便利かもしれませんが、
このクラスがそうした機能を必要として (いたり、想定して) いるわけでは
ありません。

`mutex'モジュールでは以下のクラスを定義しています:

`mutex()'
     新しい (ロックされてない) mutex を作ります。

     mutex には 2 つの状態変数 -- "ロック" ビット (locked bit) と
     キュー (queue) があります。 mutex
     がロックされていなければ、キューは空です。
     それ以外の場合、キューは空になっているか、 `(FUNCTION, ARGUMENT)'
     のペアが一つ以上入っています。
     このペアはロックを獲得しようと待機している関数 (またはメソッド)
     を表しています。 キューが空でないときに mutex
     をロック解除すると、キューの先頭の
     エントリをキューから除去し、そのエントリのペアに基づいて
     `FUNCTION(ARGUMENT)' を呼び出します。
     これによって、先頭にあったエントリが新たなロックを獲得します。

     当然のことながらマルチスレッドの制御には利用できません -
     というのも、 `lock()' が、ロックを獲得したら関数を呼び出すという
     変なインタフェースだからです。

* Menu:

* mutex オブジェクト::


File: python-lib-jp.info,  Node: mutex オブジェクト,  Prev: mutex,  Up: mutex

5.9.1 mutex オブジェクト
------------------------

`mutex' には以下のメソッドがあります:

`test()'
     mutex がロックされているかどうか調べます。

`testandset()'
     「原子的 (Atomic)」な Test-and-Set 操作です。
     ロックがセットされていなければ獲得して `True' を返します。
     それ以外の場合には`False'を返します。

`lock(function, argument)'
     mutex がロックされていなければ `FUNCTION(ARGUMENT)' を実行します。
     mutex がロックされている場合、関数とその引数をキューに置きます。
     キューに置かれた `FUNCTION(ARGUMENT)' がいつ実行
     されるかについては`unlock'を参照してください。

`unlock()'
     キューが空ならば mutex をロック解除します。
     そうでなければ、キューの最初の要素を実行します。


File: python-lib-jp.info,  Node: Queue,  Next: weakref,  Prev: mutex,  Up: データ型

5.10 同期キュークラス
=====================

同期キュークラス

`Queue'モジュールは、多生産者-多消費者FIFOキューを実装します。
これは、複数のスレッドの間で情報を安全に交換しなければならないときの
スレッドプログラミングで特に有益です。 このモジュールの`Queue'クラスは、
必要なすべてのロックセマンティクスを実装しています。
これはPythonのスレッドサポートの状況に依存します。

`Queue'モジュールは以下のクラスと例外を定義します:

`Queue(maxsize)'
     クラスのコンストラクタです。
     MAXSIZEはキューに置くことのできる要素数の上限を設定する整数です。
     いったんこの大きさに達したら、挿入はキューの要素が消費されるまでブロック
     されます。
     もしMAXSIZEが0以下であるならば、キューの大きさは無限です。

`Empty'
     空な`Queue'オブジェクトで、
     非ブロックメソッドとして`get()'(または`get_nowait()')
     が呼ばれたとき、送出される例外です。

`Full'
     満杯な`Queue'オブジェクトで、
     非ブロックメソッドとして`put()'(または`put_nowait()')
     が呼ばれたとき、送出される例外です。

* Menu:

* キューオブジェクト::


File: python-lib-jp.info,  Node: キューオブジェクト,  Prev: Queue,  Up: Queue

5.10.1 キューオブジェクト
-------------------------

クラス`Queue'はキューオブジェクトを実装しており、
以下のメソッドを持っています。
このクラスは、他のキュー構造(例えばスタック)を実装するために
派生させられるますが、継承可能なインタフェースはここでは説明しません。
詳しいことはソースコードを見てください。 公開メソッドは次のものです:

`qsize()'
     キューの大まかなサイズを返します。
     マルチスレッドセマンティクスにおいて、この値は信頼できません。

`empty()'
     キューが空なら`True'を返し、そうでないなら`False'を返します。
     マルチスレッドセマンティクスにおいて、この値は信頼できません。

`full()'
     キューが満杯なら`True'を返し、そうでないなら`False'を返します。
     マルチスレッドセマンティクスにおいて、この値は信頼できません。

`put(item[, block[, timeout]])'
     ITEMをキューに入れます。
     もしオプション引数BLOCKがTrueでTIMEOUTがNone(デフォルト)ならば、
     フリースロットが利用可能になるまでブロックします。
     TIMEOUTが正の値の場合、最大でTIMEOUT秒間ブロックし、
     その時間内に空きスロットが利用可能にならなければ、
     例外`Full'を送出します。
     他方(BLOCKがFalse)、直ちにフリースロットが利用できるならば、
     キューにアイテムを置きます。できないならば、例外`Full'を送出します
     (この場合TIMEOUTは無視されます)。

     _Added in Python version 2.3_


`put_nowait(item)'
     `put(ITEM, False)'と同じ意味です。

`get([block[, timeout]])'
     キューからアイテムを取り除き、それを返します。
     もしオプション引数BLOCKがTrueでTIMEOUTがNone(デフォルト)ならば、
     アイテムが利用可能になるまでブロックします。
     もしTIMEOUTが正の値の場合、最大でTIMEOUT秒間ブロックし、
     その時間内でアイテムが利用可能にならなければ、
     例外`Empty'を送出します。
     他方(BLOCKがFalse)、直ちにアイテムが利用できるならば、
     それを返します。できないならば、例外`Empty'を送出します
     (この場合TIMEOUTは無視されます)。

     _Added in Python version 2.3_


`get_nowait()'
     `get(False)'と同じ意味です。

キューに入れられたタスクが全て消費者スレッドに処理されたかどうかを追跡するために
2つのメソッドが提供されます。

`task_done()'
     過去にキューに入れられたタスクが完了した事を示します。
     キューの消費者スレッドに利用されます。
     タスクの取り出しに使われた、各 `get()' に対して、それに続く
     `task_done()' の
     呼び出しは、取り出したタスクに対する処理が完了した事をキューに教えます。

     `join()' がブロックされていた場合、全itemが処理された
     (キューに`put()'された全てのitemに対して `task_done()'
     が呼び出されたことを 意味します) 時に復帰します。

     キューにあるよりitemの個数よりも多く呼び出された場合、
     `ValueError' が送出されます。 _Added in Python version 2.5_

`join()'
     キューの中の全アイテムが処理される間でブロックします。

     キューにitemが追加される度に、未完了タスクカウントが増やされます。
     消費者スレッドが `task_done()' を呼び出して、itemを受け取ってそれに
     対する処理が完了した事を知らせる度に、未完了タスクカウントが減らされます。
     未完了タスクカウントが0になったときに、join()
     のブロックが解除されます。 _Added in Python version 2.5_

キューに入れたタスクが完了するのを待つ例:

         def worker():
             while True:
                 item = q.get()
                 do_work(item)
                 q.task_done()

         q = Queue()
         for i in range(num_worker_threads):
              t = Thread(target=worker)
              t.setDaemon(True)
              t.start()

         for item in source():
             q.put(item)

         q.join()       # 全タスクが完了するまでブロック


File: python-lib-jp.info,  Node: weakref,  Next: UserDict,  Prev: Queue,  Up: データ型

5.11 弱参照
===========

弱参照と弱辞書のサポート。

_Added in Python version 2.1_

`weakref'モジュールは、Pythonプログラマがオブジェクトへの
"弱参照"を作成できるようにします。

以下では、用語"リファレント (referent)" は弱参照が参照するオブジェクトを
意味します。

オブジェクトに対する弱参照は、そのオブジェクトを生かしておくのに
十分な条件にはなりません: あるリファレントに対する参照が弱参照しか
残っていない場合、ガベージコレクション機構は自由にリファレントを破壊し、
そのメモリを別の用途に再利用できます。弱参照の主な用途は、
巨大なオブジェクトを保持するキャッシュやマップ型の実装において、
キャッシュやマップ型にあるという理由だけオブジェクトを存続させたくない
場合です。 例えば、巨大なバイナリ画像のオブジェクトがたくさんあり、
それぞれに名前を関連付けたいとします。 Python の辞書型を使って
名前を画像に対応付けたり画像を名前に対応付けたりすると、
画像オブジェクトは辞書内のキーや値に使われているため存続しつづける
ことになります。`weakref' モジュールが提供している `WeakKeyDictionary'
や `WeakValueDictionary' クラスは
その代用で、対応付けを構築するのに弱参照を使い、キャッシュや
マップ型に存在するという理由だけでオブジェクトを存続させないように
します。 例えば、もしある画像オブジェクトが `WeakValueDictionary' の
値になっていた場合、最後に残った画像オブジェクトへの参照を
弱参照マップ型が保持していれば、ガーベジコレクションはこのオブジェクトを
再利用でき、画像オブジェクトに対する弱参照内の対応付けはそのまま
削除されます。

`WeakKeyDictionary' や `WeakValueDictionary' は
弱参照を使って実装されていて、キーや値がガーベジコレクションによって回収された
ことを弱参照辞書に知らせるような弱参照オブジェクトのコールバック関数を
設定しています。

ほとんどのプログラムが、いずれかの弱参照辞書型を使うだけで必要を満たせるはずです
-- 自作の弱参照辞書を直接作成する必要は普通はありません。とはいえ、
弱参照辞書の実装に使われている低水準の機構は、高度な利用を行う際に恩恵を
うけられるよう `weakref' モジュールで公開されています。

すべてのオブジェクトを弱参照できるわけではありません。
弱参照できるオブジェクトは、クラスインスタンス、(Cではなく)
Pythonで書かれた関数、 (束縛および非束縛の両方の)メソッド、`set' および
`frozenset' 型、ファイルオブジェクト、ジェネレータ、型オブジェクト、
`bsddb' モジュールの `DBcursor' 型、ソケット型、
`array'型、`deque'型、および正規表現パターンオブジェクト です。
_Changed in Python version 2.4_

`list' や`dict' など、いくつかの組み込み型は弱参照を
直接サポートしませんが、以下のようにサブクラス化を行えばサポートを
追加できます:

     class Dict(dict):
         pass

     obj = Dict(red=1, green=2, blue=3)   # this object is weak referencable

弱参照をサポートするために拡張型を簡単に作れます。
詳細については、*Note repr::節 "拡張型における弱参照"を読んでください。

`ref(object[, callback])'
     OBJECTへの弱参照を返します。リファレントがまだ生きているならば、
     元のオブジェクトは参照オブジェクトの呼び出しで取り出せす。
     リファレントがもはや生きていないならば、参照オブジェクトを呼び出したときに
     `None' を返します。 CALLBACK に `None'
     以外の値を与えた場合、オブジェクトをまさに後始末処理しようとするときに
     呼び出します。このとき弱参照オブジェクトはCALLBACK
     の唯一のパラメタとして
     渡されます。リファレントはもはや利用できません。

     同じオブジェクトに対してたくさんの弱参照を作れます。
     それぞれの弱参照に対して登録されたコールバックは、
     もっとも新しく登録されたコールバックからもっとも古いものへと呼び出されます。

     コールバックが発生させた例外は標準エラー出力に書き込まれますが、伝搬させられません。
     それらはオブジェクトの`__del__()'メソッドが発生させる例外とまったく同様の
     方法で処理されます。

     OBJECTがハッシュ可能ならば、弱参照はハッシュ可能です。それらはOBJECTが
     削除された後でもそれらのハッシュ値を保持します。OBJECTが削除されてから初めて
     `hash()'が呼び出された場合に、その呼び出しは`TypeError'を発生させます。

     弱参照は等価性のテストをサポートしていますが、順序をサポートしていません。
     参照がまだ生きているならば、CALLBACKに関係なく二つの参照はそれらの
     リファレントと同じ等価関係を持ちます。リファレントのどちらか一方が削除された場合、
     参照オブジェクトが同じオブジェクトである場合に限り、その参照は等価です。

     _Changed in Python version 2.4_


`proxy(object[, callback])'
     弱参照を使うOBJECTへのプロキシを返します。弱参照オブジェクトとともに
     用いられる明示的な参照外しを要求する代わりに、これはほとんどのコンテキストに
     おけるプロキシの利用をサポートします。OBJECTが呼び出し可能かどうかに依存して、
     返されるオブジェクトは`ProxyType'または`CallableProxyType'のどちらか一方の
     型を持ちます。プロキシオブジェクトはリファレントに関係なくハッシュ可能ではありません。
     これによって、それらの基本的な変更可能という性質に関係する多くの問題を避けています。
     そして、辞書のキーとしてそれらの利用を妨げます。CALLBACKは`ref()'関数の
     同じ名前のパラメータと同じものです。

`getweakrefcount(object)'
     OBJECTを参照する弱参照とプロキシの数を返します。

`getweakrefs(object)'
     OBJECTを参照するすべての弱参照とプロキシオブジェクトのリストを返します。

`WeakKeyDictionary([dict])'
     キーを弱く参照するマッピングクラス。もはやキーへの強い参照がなくなったときに、
     辞書のエントリは捨てられます。アプリケーションの他の部分が所有するオブジェクトへ
     属性を追加することもなく、それらのオブジェクトに追加データを関連づけるために
     これを使うことができます。これは属性へのアクセスをオーバーライドするオブジェクトに
     特に便利です。

     _Note:_ 注意:  `WeakKeyDictionary' は Python
     辞書型の上に作られているので、
     反復処理を行うときにはサイズ変更してはなりません。`WeakKeyDictionary'
     の場合、反復処理の最中にプログラムが行った操作が、(ガベージコレクションの副作用として)
     「魔法のように」辞書内の要素を消し去ってしまうため、確実なサイズ変更は困難なのです。

`WeakValueDictionary([dict])'
     値を弱く参照するマッピングクラス。値への強い参照がもはや存在しなくなったときに、辞書のエントリは捨てられます。

`ReferenceType'
     弱参照オブジェクトのための型オブジェクト。

`ProxyType'
     呼び出し可能でないオブジェクトのプロキシのための型オブジェクト。

`CallableProxyType'
     呼び出し可能なオブジェクトのプロキシのための型オブジェクト。

`ProxyTypes'
     プロキシのためのすべての型オブジェクトを含むシーケンス。これは両方のプロキシ型の名前付けに依存しないで、オブジェクトがプロキシかどうかのテストをより簡単にできます。

`ReferenceError'
     プロキシオブジェクトが使われても、元のオブジェクトがガーベジコレクションされてしまっているときに発生する例外。これは標準の`ReferenceError'例外と同じです。

See also:
    *PEP0205 Weak References*
          この機能の提案と理論的根拠。初期の実装と他の言語における類似の機能についての情報へのリンクを含んでいます。


* Menu:

* 弱参照オブジェクト::
* 例 2::
* 拡張型における弱参照::


File: python-lib-jp.info,  Node: 弱参照オブジェクト,  Next: 例 2,  Prev: weakref,  Up: weakref

5.11.1 弱参照オブジェクト
-------------------------

弱参照オブジェクトは属性あるいはメソッドを持ちません。しかし、リファレントがまだ存在するならば、呼び出すことでそのリファレントを取得できるようにします:

     >>> import weakref
     >>> class Object:
     ...     pass
     ...
     >>> o = Object()
     >>> r = weakref.ref(o)
     >>> o2 = r()
     >>> o is o2
     True

リファレントがもはや存在しないならば、参照オブジェクトの呼び出しは`None'を返します:

     >>> del o, o2
     >>> print r()
     None

弱参照オブジェクトがまだ生きているかどうかのテストは、式`REF() is not
None'を用いて行われます。通常、参照オブジェクトを使う必要があるアプリケーションコードはこのパターンに従います:

     # rは弱参照オブジェクト
     o = r()
     if o is None:
         # リファレントがガーベジコレクトされた
         print "Object has been allocated; can't frobnicate."
     else:
         print "Object is still live!"
         o.do_something_useful()

"生存性(liveness)"のテストを個々に行うと、スレッド化されたアプリケーションにおいて競合状態を作り出します。弱参照が呼び出される前に、他のスレッドは弱参照が無効になる原因となり得ます。上で示したイディオムは、シングルスレッド化されたアプリケーションと同じくスレッド化されたアプリケーションにおいて安全です。

サブクラス化を行えば、`ref' オブジェクトの特殊なバージョンを
作成できます。これは`WeakValueDictionary' の実装で使われており、
マップ内の各エントリによるメモリのオーバヘッドを減らしています。
こうした実装は、ある参照に追加情報を関連付けたい場合に便利ですし、
リファレントを取り出すための呼び出し時に何らかの追加処理を行いたい
場合にも使えます。

以下の例では、`ref' のサブクラスを使って、あるオブジェクトに
追加情報を保存し、リファレントがアクセスされたときにその値に作用
をできるようにするための方法を示しています:

     import weakref

     class ExtendedRef(weakref.ref):
         def __new__(cls, ob, callback=None, **annotations):
             weakref.ref.__new__(cls, ob, callback)
             self.__counter = 0

         def __init__(self, ob, callback=None, **annotations):
             super(ExtendedRef, self).__init__(ob, callback)
             for k, v in annotations:
                 setattr(self, k, v)

         def __call__(self):
             """Return a pair containing the referent and the number of
             times the reference has been called.
             """
             ob = super(ExtendedRef, self)()
             if ob is not None:
                 self.__counter += 1
                 ob = (ob, self.__counter)
             return ob


File: python-lib-jp.info,  Node: 例 2,  Next: 拡張型における弱参照,  Prev: 弱参照オブジェクト,  Up: weakref

5.11.2 例
---------

この簡単な例では、アプリケーションが以前に参照したオブジェクトを取り出すためにオブジェクトIDを利用する方法を示します。オブジェクトに生きたままであることを強制することなく、オブジェクトのIDは他のデータ構造の中で使えます。しかし、そうする場合は、オブジェクトはまだIDによって取り出せます。

     import weakref

     _id2obj_dict = weakref.WeakValueDictionary()

     def remember(obj):
         oid = id(obj)
         _id2obj_dict[oid] = obj
         return oid

     def id2obj(oid):
         return _id2obj_dict[oid]


File: python-lib-jp.info,  Node: 拡張型における弱参照,  Prev: 例 2,  Up: weakref

5.11.3 拡張型における弱参照
---------------------------

実装の目的の一つは、弱参照によって恩恵を受けない数のような型のオブジェクトにオーバーヘッドを負わせることなく、どんな型でも弱参照メカニズムに加わることができるようにすることです。

弱く参照可能なオブジェクトに対して、弱参照メカニズムを使うために、拡張は`PyObject*'フィールドをインスタンス構造に含んでいなければなりません。オブジェクトのコンストラクタによって、それは`NULL'
に初期化しなければなりません。対応する型オブジェクトの`tp_weaklistoffset'フィールドをフィールドのオフセットに設定することもしなければなりません。また、`Py_TPFLAGS_HAVE_WEAKREFS'をtp_flagsスロットへ追加する必要もあります。例えば、インスタンス型は次のような構造に定義されます:

     typedef struct {
         PyObject_HEAD
         PyClassObject *in_class;       /* クラスオブジェクト */
         PyObject      *in_dict;        /* 辞書 */
         PyObject      *in_weakreflist; /* 弱参照のリスト */
     } PyInstanceObject;

インスタンスに対して静的に宣言される型オブジェクトはこのように定義されます:

     PyTypeObject PyInstance_Type = {
         PyObject_HEAD_INIT(&PyType_Type)
         0,
         "module.instance",

         /* 簡単のためにたくさんのものを省略... */

         Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_WEAKREFS   /* tp_flags */
         0,                                          /* tp_doc */
         0,                                          /* tp_traverse */
         0,                                          /* tp_clear */
         0,                                          /* tp_richcompare */
         offsetof(PyInstanceObject, in_weakreflist), /* tp_weaklistoffset */
     };

型コンストラクタは弱参照リストを`NULL'に初期化する責任があります:

     static PyObject *
     instance_new() {
         /* 簡単のために他の初期化を省略 */

         self->in_weakreflist = NULL;

         return (PyObject *) self;
     }

さらに一つだけ追加すると、どんな弱参照でも取り除くためには、デストラクタは弱参照マネージャを呼び出す必要があります。オブジェクトの破壊のどんな他の部分が起きる前にこれを行うべきですが、弱参照リストが非`NULL'である場合はこれが要求されるだけです:

     static void
     instance_dealloc(PyInstanceObject *inst)
     {
         /* 必要なら一時オブジェクトを割り当ててください。
            しかし、まだ破壊しないでください。
          */

         if (inst->in_weakreflist != NULL)
             PyObject_ClearWeakRefs((PyObject *) inst);

         /* 普通にオブジェクトの破壊を進めてください。 */
     }


File: python-lib-jp.info,  Node: UserDict,  Next: UserList,  Prev: weakref,  Up: データ型

5.12 辞書オブジェクトのためのクラスラッパー
===========================================

辞書オブジェクトのためのクラスラッパー。

このモジュールは
最小限のマッピングインターフェイスをすでに持っているクラスのために、
すべての辞書メソッドを定義しているmixin、`DictMixin'を定義しています。これによって、shelveモジュールのような辞書の代わりをする必要があるクラスを書くことが非常に簡単になります。

このモジュールでは`UserDict'クラスを定義しています。これは辞書オブジェクトのラッパーとして
動作します。これは`dict'(Python
2.2から利用可能な機能です)によって置き換えられています。
`dict'の導入以前に、`UserDict'クラスは辞書風のサブクラスをオーバライドや新メソッドの
定義によって作成するために使われていました。

`UserDict'モジュールは`UserDict'クラスと`DictMixin'を定義しています:

`UserDict([initialdata])'
     辞書をシミュレートするクラス。インスタンスの内容は通常の辞書に保存され、`UserDict'インスタンスの`data'属性を通してアクセスできます。INITIALDATAが与えられれば、`data'はその内容で初期化されます。他の目的のために使えるように、INITIALDATAへの参照が保存されないことがあるということに注意してください。
     _Note:_
     後方互換性のために、`UserDict'のインスタンスはイテレート可能ではありません。

`IterableUserDict([initialdata])'
     `UserDict'のイテレーションをサポートするサブクラス (使用例: `for
     key in myDict').

マッピングのメソッドと演算(節*Note
マップ型::を参照)に加えて、`UserDict'、`IterableUserDict'インスタンスは次の属性を提供します:

`data'
     `UserDict'クラスの内容を保存するために使われる実際の辞書。

`DictMixin()'
     `__getitem__'、`__setitem__'、`__delitem__'および`keys'
     といった最小の辞書インタフェースを既に持っているクラスのために、全ての辞書メソッドを定義する
     mixin です。

     このmixinはスーパークラスとして使われるべきです。上のそれぞれのメソッドを
     追加することで、より多くの機能がだんだん追加されます。
     例えば、`__delitem__'
     以外の全てのメソッドを定義すると、使えないのは `pop'と`popitem'
     だけになります。

     4 つの基底メソッドに加えて、`__contains__'、`__iter__'
     および`iteritems'を定義すれば、順次効率化を果たすことができます。

     mixin はサブクラスのコンストラクタについて何も知らないので、
     `__init__()' や `copy()' は定義していません。



File: python-lib-jp.info,  Node: UserList,  Next: UserString,  Prev: UserDict,  Up: データ型

5.13 リストオブジェクトのためのクラスラッパー
=============================================

リストオブジェクトのためのクラスラッパー。

_Note:_ このモジュールは後方互換性のためだけに残されています。Python
2.2より前のバージョンのPythonで動作する必要のないコードを書いているのならば、組み込み`list'型から直接サブクラス化することを検討してください。

このモジュールはリストオブジェクトのラッパーとして働くクラスを定義します。独自のリストに似たクラスのために役に立つ基底クラスで、これを継承し既存のメソッドをオーバーライドしたり、あるいは、新しいものを追加したりすることができます。このような方法で、リストに新しい振る舞いを追加できます。

`UserList'モジュールは`UserList'クラスを定義しています:

`UserList([list])'
     リストをシミュレートするクラス。インスタンスの内容は通常のリストに保存され、`UserList'インスタンスの`data'属性を通してアクセスできます。インスタンスの内容は最初にLISTのコピーに設定されますが、デフォルトでは空リスト`[]'です。LISTは通常のPythonリストか、`UserList'(またはサブクラス)のインスタンスのどちらかです。

変更可能シーケンスのメソッドと演算(節*Note シーケンス型
str::を参照)に加えて、`UserList'インスタンスは次の属性を提供します:

`data'
     `UserList'クラスの内容を保存するために使われる実際のPythonリストオブジェクト。

*サブクラス化の要件:*
`UserList'のサブクラスは引数なしか、あるいは一つの引数のどちらかとともに呼び出せるコンストラクタを提供することが期待されます。新しいシーケンスを返すリスト演算は現在の実装クラスのインスタンスを作成しようとします。そのために、データ元として使われるシーケンスオブジェクトである一つのパラメータとともにコンストラクタを呼び出せると想定しています。

導出クラスがこの要求に従いたくないならば、このクラスがサポートしているすべての特殊メソッドはオーバーライドされる必要があります。その場合に提供される必要のあるメソッドについての情報は、ソースを参考にしてください。

_Changed in Python version 2.0_


File: python-lib-jp.info,  Node: UserString,  Next: types,  Prev: UserList,  Up: データ型

5.14 文字列オブジェクトのためのクラスラッパー
=============================================

文字列オブジェクトのためのクラスラッパー。

_Note:_
このモジュールの`UserString'クラスは後方互換性のためだけに残されています。Python
2.2より前のバージョンのPythonで動作する必要のないコードを書いているのならば、`UserString'を使う代わりに組み込み`str'型から直接サブクラス化することを検討してください(組み込みの`MutableString'と等価なものはありません)。

このモジュールは文字列オブジェクトのラッパーとして働くクラスを定義します。独自の文字列に似たクラスのために役に立つ基底クラスで、これを継承し既存のメソッドをオーバーライドしたり、あるいは、新しいものを追加したりすることができます。このような方法で、文字列に新しい振る舞いを追加できます。

これらのクラスは実際のクラスやユニコードオブジェクトに比べてとても効率が悪いということに注意した方がよいでしょう。これは特に`MutableString'に対して当てはまります。

`UserString'モジュールは次のクラスを定義しています:

`UserString([sequence])'
     文字列またはユニコード文字列オブジェクトをシミュレートするクラス。インスタンスの内容は通常の文字列またはユニコード文字列オブジェクトに保存され、`UserString'インスタンスの`data'属性を通してアクセスできます。インスタンスの内容は最初にSEQUENCEのコピーに設定されます。SEQUENCEは通常のPython文字列またはユニコード文字列、`UserString'(またはサブクラス)のインスタンス、あるいは組み込み`str()'関数を使って文字列に変換できる任意のシーケンスのいずれかです。

`MutableString([sequence])'
     このクラスは上の`UserString'から導出され、_変更可能に_なるように文字列を再定義します。変更可能な文字列は辞書のキーとして使うことができません。なぜなら、辞書はキーとして_変更不能な_オブジェクトを要求するからです。このクラスの主な目的は、辞書のキーとして変更可能なオブジェクトを使うという試みを捕捉するために、継承と`__hash__()'メソッドを取り除く(オーバーライドする)必要があることを示す教育的な例を提供することです。そうしなければ、非常にエラーになりやすく、突き止めることが困難でしょう。

文字列とユニコードオブジェクトのメソッドと演算(節*Note
文字列メソッド::、"文字列メソッド"を参照)に加えて、`UserString'インスタンスは次の属性を提供します:

`data'
     `UserString'クラスの内容を保存するために使われる実際のPython文字列またはユニコードオブジェクト。


File: python-lib-jp.info,  Node: types,  Next: new,  Prev: UserString,  Up: データ型

5.15 組み込み型の名前
=====================

組み込み型の名前

このモジュールは標準のPythonインタプリタで使われているオブジェクト
の型について、名前を定義しています(拡張モジュールで定義されている型を除
く)。このモジュールは`listiterator'型のようなプロセス中に例外
をふくまないので、`from types import
*'のように使っても安全です。このモジュールの
将来のバージョンで追加される名前は、`Type'で終わる予定です。

関数での典型的な利用方法は、以下のように引数の型によって異なる動作をする
場合です:

     from types import *
     def delete(mylist, item):
         if type(item) is IntType:
            del mylist[item]
         else:
            mylist.remove(item)

Python 2.2以降では、`int()' や `str()'のような
ファクトリ関数は、型の名前となりましたので、`types'を使用する
必要はなくなりました。上記のサンプルは、以下のように記述する事が
推奨されています。

     def delete(mylist, item):
         if isinstance(item, int):
            del mylist[item]
         else:
            mylist.remove(item)

このモジュールは以下の名前を定義しています。

`NoneType'
     `None'の型です。

`TypeType'
     typeオブジェクトの型です (`type()' などによって返 されます)。

`BooleanType'
     `bool'の`True'と`False'の型です。これは組み込み関数の
     `bool()'のエイリアスです。

`IntType'
     整数の型です(e.g. `1')。

`LongType'
     長整数の型です(e.g. `1L')。

`FloatType'
     浮動小数点数の型です(e.g. `1.0')。

`ComplexType'
     複素数の型です(e.g. `1.0j')。
     Pythonが複素数のサポートなしでコンパイルされていた場合には
     定義されません。

`StringType'
     文字列の型です(e.g. `'Spam'')。

`UnicodeType'
     Unicode文字列の型です(e.g. `u'Spam'')。
     Pythonがユニコードのサポートなしでコンパイルされていた場合には
     定義されません。

`TupleType'
     タプルの型です(e.g. `(1, 2, 3, 'Spam')')。

`ListType'
     リストの型です(e.g. `[0, 1, 2, 3]')。

`DictType'
     辞書の型です(e.g. `{'Bacon': 1, 'Ham': 0}')。

`DictionaryType'
     `DictType'の別名です。

`FunctionType'
     ユーザー定義の関数またはlambdaの型です。

`LambdaType'
     `FunctionType'の別名です。

`GeneratorType'
     ジェネレータ関数の呼び出しによって生成されたイテレータオブジェクトの型で
     す。 _Added in Python version 2.2_

`CodeType'
     `compile()' 関数などによって返されるコード オブジェクトの型です。

`ClassType'
     ユーザー定義のクラスの型です。

`InstanceType'
     ユーザー定義のクラスのインスタンスの型です。

`MethodType'
     ユーザー定義のクラスのインスタンスのメソッドの型です。

`UnboundMethodType'
     `MethodType'の別名です。

`BuiltinFunctionType'
     `len()' や `sys.exit()'のような組み込み関数の型です。

`BuiltinMethodType'
     `BuiltinFunction'の別名です。

`ModuleType'
     モジュールの型です。

`FileType'
     `sys.stdout'のようなopenされたファイルオブジェクトの型です。

`XRangeType'
     `xrange()' 関数によって返されるrangeオブジェ クトの型です。

`SliceType'
     `slice()' 関数によって返されるオブジェクトの 型です。

`EllipsisType'
     `Ellipsis'の型です。

`TracebackType'
     `sys.exc_traceback'に含まれるようなトレースバックオブジェクトの型です。

`FrameType'
     フレームオブジェクトの型です。
     トレースバックオブジェクト`tb'の`tb.tb_frame'などです。

`BufferType'
     `buffer()' 関数によって作られるバッファオブ ジェクトの型です。

`DictProxyType'
     `TypeType.__dict__' のような dictへのプロキシ型です。


`NotImplementedType'
     `NotImplemented'の型です。

`GetSetDescriptorType'
     `FrameType.f_locals' や `array.array.typecode' のような
     `PyGetSetDef' のある
     拡張モジュールで定義されたオブジェクトの型です。
     この定数は上のような拡張型がないPythonでは定義されません。
     ポータブルなコードでは`hasattr(types, 'GetSetDescriptorType')'を
     使用してください。 _Added in Python version 2.5_

`MemberDescriptorType'
     `datetime.timedelta.days' のような `PyMemberDef'のある
     拡張モジュールで定義されたオブジェクトの型です。
     この定数は上のような拡張型がないPythonでは定義されません。
     ポータブルなコードでは`hasattr(types, 'MemberDescriptorType')'を
     使用してください。 _Added in Python version 2.5_

`StringTypes'
     文字列型のチェックを簡単にするための`StringType'と
     `UnicodeType'を含むシーケンスです。
     `UnicodeType'は実行中の版のPythonに含まれている場合にだけ含まれるの
     で、2つの文字列型のシーケンスを使うよりこれを使う方が移植性が高くなります。
     例: `isinstance(s, types.StringTypes)'.  _Added in Python version
     2.2_


File: python-lib-jp.info,  Node: new,  Next: copy,  Prev: types,  Up: データ型

5.16 ランタイム内部オブジェクトの作成
=====================================

ランタイム実装オブジェクトの作成のインターフェイス。

`new'モジュールはインタプリタオブジェクト作成関数へのインターフェイスを与えます。新しいオブジェクトを"魔法を使ったように"作り出す必要がある、通常の作成関数が使えないときに、これは主にマーシャル型関数で使われます。このモジュールはインタプリタへの低レベルインターフェイスを提供します。したがって、このモジュールを使うときには注意しなければなりません。
オブジェクトが利用される時にインタプリタをクラッシュさせるような引数を
与えることもできてしまいます。

`new'モジュールは次の関数を定義しています:

`instance(class[, dict])'
     この関数は`__init__()'コンストラクタを呼び出さずに辞書DICTをもつCLASSのインスタンスを作り出します。DICTが省略されるか、`None'である場合は、新しいインスタンスのために新しい空の辞書が作られます。オブジェクトがいつもと同じ状態であるという保証はないことに注意してください。

`instancemethod(function, instance, class)'
     この関数はINSTANCEに束縛されたメソッドオブジェクトか、あるいはINSTANCEが`None'の場合に束縛されていないメソッドオブジェクトを返します。FUNCTIONは呼び出し可能でなければなりません。

`function(code, globals[, name[, argdefs[, closure]]])'
     与えられたコードとグローバル変数をもつ(Python)関数を返します。NAMEを与えるならば、文字列か`None'でなければならない。文字列の場合は、関数は与えられた名前をもつ。そうでなければ、関数名は`CODE.co_name'から取られる。ARGDEFSを与える場合はタプルでなければならず、パラメータのデフォルト値を決めるために使われます。
     CLOSURE
     を与える場合は`None'または名前を`CODE.co_freevars'に束縛するセルオブジェクトのタプルである必要があります。

     )が与えられていると、

`code(argcount, nlocals, stacksize, flags, codestring, constants, names, varnames, filename, name, firstlineno, lnotab)'
     この関数は`PyCode_New()'というC関数へのインターフェイスです。

`module(name[, doc])'
     この関数はNAMEという名前の新しいモジュールオブジェクトを返します。NAMEは文字列でなければならない。
     省略可能な DOC 引数はどんな型でもよい。

`classobj(name, baseclasses, dict)'
     この関数は新しいクラスオブジェクトを返します。そのクラスオブジェクトは(クラスのタプルであるべき)BASECLASSESから派生し、名前空間DICTを持ち、NAMEという名前です。


File: python-lib-jp.info,  Node: copy,  Next: pprint,  Prev: new,  Up: データ型

5.17 浅いコピーおよび深いコピー操作
===================================

浅いコピーおよび深いコピー操作。

このモジュールでは汎用の (浅い／深い) コピー操作を提供しています。 

以下にインタフェースをまとめます:

     import copy

     x = copy.copy(y)        # make a shallow copy of y
     x = copy.deepcopy(y)    # make a deep copy of y

このモジュール固有のエラーに対しては、`copy.error' が送出されます。

浅い (shallow) コピーと深い (deep) コピーの違いが関係するのは、
複合オブジェクト (リストやクラスインスタンスのような他のオブジェクトを
含むオブジェクト) だけです:

   * _浅いコピー (shallow copy)_ は新たな複合オブジェクトを作成し、
     その後 (可能な限り)
     元のオブジェクト中に見つかったオブジェクトに対する _参照_
     を挿入します。

   * _深いコピー (deep copy)_ は新たな複合オブジェクトを作成し、
     その後元のオブジェクト中に見つかったオブジェクトの _コピー_
     を挿入します。


深いコピー操作には、しばしば浅いコピー操作の時には存在しない 2 つの
問題がついてまわります:

   * 再帰的なオブジェクト (直接、間接に関わらず、自分自身に対する参照
     を持つ複合オブジェクト) は再帰ループを引き起こします。

   * 深いコピーでは、_何もかも_ をコピーするため、例えば複数の
     コピー間で共有されるべき管理データ構造までも、余分にコピー
     してしまいます。


`deepcopy()' 関数では、これらの問題を以下のようにして 回避しています:

   * 現在のコピー過程ですでにコピーされたオブジェクトからなる、 "メモ"
     辞書を 保持します; かつ

   *
     ユーザ定義のクラスでコピー操作やコピーされる内容の集合を上書きできる
     ようにします。


このモジュールでは、モジュール、メソッド、スタックトレース、
スタックフレーム、ファイル、ソケット、ウィンドウ、アレイ、その他これらに
類似の型をコピーしません。
このモジュールでは元のオブジェクトを変更せずに返すことで関数とクラスを
(浅く または 深く)「コピー」します。これは `pickle'モジュールでの
扱われかたと同じです。 _Changed in Python version 2.5_

クラスでは、pickle
化を制御するためのインタフェースと同じインタフェースを
コピーの制御に使うことができます。これらのメソッドに関する情報は
`pickle'  モジュールの記述を 参照してください。`copy' モジュールは
pickle 用関数登録モジュール `copy_reg' を使いません。

クラス独自のコピー実装を定義するために、特殊メソッド `__copy__()'
および `__deepcopy__()' を定義することができます。前者は
浅いコピー操作を実装するために使われます; 追加の引数はありません。
後者は深いコピー操作を実現するために呼び出されます; この関数には
単一の引数としてメモ辞書が渡されます。`__deepcopy__()'
の実装で、内容のオブジェクトに対して深いコピーを生成する必要がある場合、
`deepcopy()' を呼び出し、最初の引数にそのオブジェクトを、
メモ辞書を二つ目の引数に与えなければなりません。 

See also:
     *Note pickle:: オブジェクト状態の取得と復元をサポートするために
     使われる特殊メソッドについて議論されています。


File: python-lib-jp.info,  Node: pprint,  Next: repr,  Prev: copy,  Up: データ型

5.18 データ出力の整然化
=======================

Data pretty printer.

`pprint'モジュールを使うと、Pythonの任意のデータ構造をインタープ
リタへの入力で使われる形式にして"pretty-print"できます。
フォーマット化された構造の中にPythonの基本的なタイプではないオブジェクト
があるなら、表示できないかもしれません。
Pythonの定数として表現できない多くの組み込みオブジェクトと同様、ファイ
ル、ソケット、クラスあるいはインスタンスのようなオブジェクトが含まれてい
た場合は出力できません。

可能であればオブジェクトをフォーマット化して1行に出力しますが、与えられ
た幅に合わないなら複数行に分けて出力します。
無理に幅を設定したいなら、`PrettyPrinter'オブジェクトを作成して明
示してください。

_Changed in Python version 2.5_

`pprint'モジュールには1つのクラスが定義されています：

`PrettyPrinter(...)'
     `PrettyPrinter'インスタンスを作ります。
     このコンストラクタにはいくつかのキーワードパラメータを設定できます。

     STREAMキーワードで出力ストリームを設定できます；このストリームに対
     して呼び出されるメソッドはファイルプロトコルの`write()'メソッドだ
     けです。
     もし設定されなければ、`PrettyPrinter'は`sys.stdout'を使用しま す。
     さらに3つのパラメータで出力フォーマットをコントロールできます。
     そのキーワードはINDENT、DEPTHとWIDTHです。

     再帰的なレベルごとに加えるインデントの量はINDENTで設定できます；デ
     フォルト値は1です。
     他の値にすると出力が少しおかしく見えますが、ネスト化されたところが見分け
     易くなります。

     出力されるレベルはDEPTHで設定できます；
     出力されるデータ構造が深いなら、指定以上の深いレベルのものは`...'で
     置き換えられて表示されます。
     デフォルトでは、オブジェクトの深さを制限しません。

     WIDTHパラメータを使うと、出力する幅を望みの文字数に設定できます；
     デフォルトでは80文字です。
     もし指定した幅にフォーマットできない場合は、できるだけ近づけます。

          >>> import pprint, sys
          >>> stuff = sys.path[:]
          >>> stuff.insert(0, stuff[:])
          >>> pp = pprint.PrettyPrinter(indent=4)
          >>> pp.pprint(stuff)
          [   [   '',
                  '/usr/local/lib/python1.5',
                  '/usr/local/lib/python1.5/test',
                  '/usr/local/lib/python1.5/sunos5',
                  '/usr/local/lib/python1.5/sharedmodules',
                  '/usr/local/lib/python1.5/tkinter'],
              '',
              '/usr/local/lib/python1.5',
              '/usr/local/lib/python1.5/test',
              '/usr/local/lib/python1.5/sunos5',
              '/usr/local/lib/python1.5/sharedmodules',
              '/usr/local/lib/python1.5/tkinter']
          >>>
          >>> import parser
          >>> tup = parser.ast2tuple(
          ...     parser.suite(open('pprint.py').read()))[1][1][1]
          >>> pp = pprint.PrettyPrinter(depth=6)
          >>> pp.pprint(tup)
          (266, (267, (307, (287, (288, (...))))))


`PrettyPrinter'クラスにはいくつかの派生する関数が提供されていま す：

`pformat(object[, indent[, width[, depth]]])'
     OBJECTをフォーマット化して文字列として返します。
     INDENT、WIDTHと、DEPTHは`PrettyPrinter'コンス
     トラクタにフォーマット指定引数として渡されます。 _Changed in
     Python version 2.4_

`pprint(object[, stream[, indent[, width[, depth]]]])'
     OBJECTをフォーマット化してSTREAMに出力し、最後に改行します。
     STREAMが省略されたら、`sys.stdout'に出力します。
     これは対話型のインタープリタ上で、求める値を`print'する代わりに
     使用できます。 INDENT、WIDTHと、DEPTHは`PrettyPrinter'コンス
     トラクタにフォーマット指定引数として渡されます。

          >>> stuff = sys.path[:]
          >>> stuff.insert(0, stuff)
          >>> pprint.pprint(stuff)
          [<Recursion on list with id=869440>,
           '',
           '/usr/local/lib/python1.5',
           '/usr/local/lib/python1.5/test',
           '/usr/local/lib/python1.5/sunos5',
           '/usr/local/lib/python1.5/sharedmodules',
           '/usr/local/lib/python1.5/tkinter']

     _Changed in Python version 2.4_

`isreadable(object)'
     OBJECTをフォーマット化して出力できる（"readable"）か、あるいは
     `eval()' を使って値を再構成できるかを返しま す。
     再帰的なオブジェクトに対しては常にfalseを返します。

          >>> pprint.isreadable(stuff)
          False


`isrecursive(object)'
     OBJECTが再帰的な表現かどうかを返します。

さらにもう1つ、関数が定義されています：

`saferepr(object)'
     OBJECTの文字列表現を、再帰的なデータ構造から保護した形式で返しま
     す。
     もしOBJECTの文字列表現が再帰的な要素を持っているなら、再帰的な参照
     は`<Recursion on TYPENAME with id=NUMBER>'で表示されま す。
     出力は他と違ってフォーマット化されません。


     >>> pprint.saferepr(stuff)
     "[<Recursion on list with id=682968>, '', '/usr/local/lib/python1.5', '/usr/loca
     l/lib/python1.5/test', '/usr/local/lib/python1.5/sunos5', '/usr/local/lib/python
     1.5/sharedmodules', '/usr/local/lib/python1.5/tkinter']"

* Menu:

* PrettyPrinter オブジェクト::


File: python-lib-jp.info,  Node: PrettyPrinter オブジェクト,  Prev: pprint,  Up: pprint

5.18.1 PrettyPrinter オブジェクト
---------------------------------

`PrettyPrinter'インスタンスには以下のメソッドがあります：

`pformat(object)'
     OBJECTのフォーマット化した表現を返します。
     これは`PrettyPrinter'のコンストラクタに渡されたオプションを考慮し
     てフォーマット化されます。

`pprint(object)'
     OBJECTのフォーマット化した表現を指定したストリームに出力し、最後に
     改行します。

以下のメソッドは、対応する同じ名前の関数と同じ機能を持っています。
以下のメソッドをインスタンスに対して使うと、新たに`PrettyPrinter'
オブジェクトを作る必要がないのでちょっぴり効果的です。

`isreadable(object)'
     OBJECTをフォーマット化して出力できる（"readable"）か、あるいは
     `eval()' を使って値を再構成できるかを返しま す。
     これは再帰的なオブジェクトに対してfalseを返すことに注意して下さい。
     もし`PrettyPrinter'のDEPTHパラメータが設定されていて、オブ
     ジェクトのレベルが設定よりも深かったら、falseを返します。

`isrecursive(object)'
     オブジェクトが再帰的な表現かどうかを返します。

このメソッドをフックとして、サブクラスがオブジェクトを文字列に変換する方
法を修正するのが可能になっています。
デフォルトの実装では、内部で`saferepr()'を呼び出しています。

`format(object, context, maxlevels, level)'
     3つの値を返します：OBJECTをフォーマット化して文字列にしたもの、そ
     の結果が読み込み可能かどうかを示すフラグ、再帰が含まれているかどうかを示
     すフラグ。

     最初の引数は表示するオブジェクトです。
     2つめの引数はオブジェクトの`id()'をキーとして含むディクショナリ
     で、オブジェクトを含んでいる現在の（直接、間接にOBJECTのコンテナと
     して表示に影響を与える）環境です。
     ディクショナリCONTEXTの中でどのオブジェクトが表示されたか表示する
     必要があるなら、3つめの返り値はtrueになります。
     `format()'メソッドの再帰呼び出しではこのディクショナリのコンテナ
     に対してさらにエントリを加えます。
     3つめの引数MAXLEVELSで再帰呼び出しのレベルを設定します；
     もし制限しないなら、`0'にします。
     この引数は再帰呼び出しでそのまま渡されます。
     4つめの引数LEVELで現在のレベルを設定します；
     再帰呼び出しでは、現在の呼び出しより小さい値が渡されます。 _Added
     in Python version 2.3_


File: python-lib-jp.info,  Node: repr,  Prev: pprint,  Up: データ型

5.19 もう一つの`repr()'の実装
=============================

大きさに制限のある別の`repr()'の実装。

`repr'モジュールは結果の文字列の大きさを制限したオブジェクト表現を作り出すための方法を提供します。これはPythonデバッガで使われていますが、他の状況でも同じように役に立つかもしれません。

このモジュールはクラスとインスタンス、それに関数を提供します:

`Repr()'
     組み込みクラス`repr()'によく似た関数を実装するために役に立つ書式化サービスを提供します。過度に長い表現を作り出さないように、異なるオブジェクト型に対する大きさの制限が追加されます。

`aRepr'
     これは下で説明される`repr()'関数を提供するために使われる`Repr'のインスタンスです。このオブジェクトの属性を変更すると、`repr()'とPythonデバッガが使うサイズ制限に影響します。

`repr(obj)'
     これは`aRepr'の`repr()'メソッドです。同じ名前の組み込み関数が返す文字列と似ていますが、最大サイズに制限のある文字列を返します。

* Menu:

* Reprオブジェクト::
* Reprオブジェクトをサブクラス化する::


File: python-lib-jp.info,  Node: Reprオブジェクト,  Next: Reprオブジェクトをサブクラス化する,  Prev: repr,  Up: repr

5.19.1 Reprオブジェクト
-----------------------

`Repr'インスタンスは様々なオブジェクト型の表現にサイズ制限を与えるために使えるいくつかのメンバーと、特定のオブジェクト型を書式化するメソッドを提供します。

`maxlevel'
     再帰的な表現を作る場合の深さ制限。デフォルトは`6'です。

`maxdict'

`maxlist'

`maxtuple'

`maxset'

`maxfrozenset'

`maxdeque'

`maxarray'
     指定されたオブジェクト型に対するエントリ表現の数についての制限。
     `maxdict'に対するデフォルトは`4'で、`maxarray'
     は`5'、その他に対しては`6'です。 _Added in Python version 2.4_.

`maxlong'
     長整数の表現のおける文字数の最大値。中央の数字が抜け落ちます。デフォルトは`40'です。

`maxstring'
     文字列の表現における文字数の制限。文字列の"通常の"表現は文字の材料だということに注意してください:
     表現にエスケープシーケンスが必要とされる場合は、表現が短縮されたときにこれらはマングルされます。デフォルトは`30'です。

`maxother'
     この制限は`Repr'オブジェクトに利用できる特定の書式化メソッドがないオブジェクト型のサイズをコントロールするために使われます。`maxstring'と同じようなやり方で適用されます。デフォルトは`20'です。

`repr(obj)'
     インスタンスが強制する書式化を使う組み込み`repr()'と等価なもの。

`repr1(obj, level)'
     `repr()'が使う再帰的な実装。これはどの書式化メソッドを呼び出すかを決定するためにOBJの型を使い、それをOBJとLEVELに渡します。再帰呼び出しにおいてLEVELの値に対して`LEVEL
     -
     1'を与える再帰的な書式化を実行するために、型に固有のメソッドは`repr1()'を呼び出します。

`repr_TYPE(obj, level)'
     型名に基づく名前をもつメソッドとして、特定の型に対する書式化メソッドは実装されます。メソッド名では、TYPEは`string.join(string.split(type(OBJ).__name__,
     '_'))'に置き換えられます。これらのメソッドへのディスパッチは`repr1()'によって処理されます。再帰的に値の書式を整える必要がある型固有のメソッドは、`self.repr1(SUBOBJ,
     LEVEL - 1)'を呼び出します。


File: python-lib-jp.info,  Node: Reprオブジェクトをサブクラス化する,  Prev: Reprオブジェクト,  Up: repr

5.19.2 Reprオブジェクトをサブクラス化する
-----------------------------------------

更なる組み込みオブジェクト型へのサポートを追加するためや、すでにサポートされている型の扱いを変更するために、`Repr.repr1()'による動的なディスパッチを使って`Repr'をサブクラス化することができます。この例はファイルオブジェクトのための特別なサポートを追加する方法を示しています:

     import repr
     import sys

     class MyRepr(repr.Repr):
         def repr_file(self, obj, level):
             if obj.name in ['<stdin>', '<stdout>', '<stderr>']:
                 return obj.name
             else:
                 return `obj`

     aRepr = MyRepr()
     print aRepr.repr(sys.stdin)          # prints '<stdin>'


File: python-lib-jp.info,  Node: 数値と数学モジュール,  Next: インターネット上のデータの操作,  Prev: データ型,  Up: Top

6 数値と数学モジュール
**********************

この章で解説されるモジュールは数値と数学関連の関数とデータ型を提供する。
`math'と`cmath'はさまざまな浮動小数点数および複素数向け
数学関数を含みます。
速度より10進法での正確さに興味があるユーザには、`decimal'モジュー
ルが真の10進表現をサポートしています。

この章で解説されるモジュールの一覧は:

* Menu:

* math::
* cmath::
* decimal::
* random::
* itertools::
* functools::
* operator::


File: python-lib-jp.info,  Node: math,  Next: cmath,  Prev: 数値と数学モジュール,  Up: 数値と数学モジュール

6.1 数学関数
============

数学関数(`sin()' など)。

このモジュールはいつでも利用できます。標準 C で定義されている数学関数に
アクセスすることができます。

これらの関数で複素数を使うことはできません。複素数に対応する必要がある
ならば、 `cmath' モジュールにある同じ名前の関数を使ってくだ
さい。ほとんどのユーザーは複素数を理解するのに必要なだけの数学を勉強し
たくないので、複素数に対応した関数と対応していない関数の区別がされてい
ます。これらの関数では複素数が利用できないため、引数に複素数を渡される
と、複素数の結果が返えるのではなく例外が発生します。その結果、プログラ
マは、そもそもどういった理由で例外がスローされたのかに早い段階で気づく
事ができます。(1)

このモジュールでは次の関数を提供しています。
明示的な注記のない限り、戻り値は全て浮動小数点数になります。

以下は整数論および数表現にまつわる関数です:

`ceil(x)'
     X の天井値 (ceil)、すなわちX 以上の最も小さい整数を
     float型で返します。

`fabs(x)'
     X の絶対値を返します。

`floor(x)'
     X の床値 (floor)、すなわちX 以下の最も大きい整数を
     float型で返します。

`fmod(x, y)'
     プラットフォームの C ライブラリで定義されている `fmod(X, Y)'
     を返します。 Python の `X % Y' という式は必ずしも同じ結果を
     返さないということに注意してください。 C 標準の要求では、`fmod'
     は除算の結果が X と同じ符号に なり、大きさが`abs(Y)'
     より小さくなるような整数 N に ついては`fmod(X, Y)' が厳密に
     (数学的に、つまり限りなく高い精度で) `X - N*Y'
     と等価であるよう求めています。 Python の `X % Y' は、Y
     と同じ符号の結果を
     返し、浮動小数点の引数に対して厳密な解を出せないことがあります。
     例えば、 `fmod(-1e-100, 1e100)' は `-1e-100' ですが、 Python
     の`-1e-100 % 1e100' は `1e100-1e-100' になり、
     浮動小数点型で厳密に表現できず、ややこしいことに`1e100' に
     丸められます。このため、一般には浮動小数点の場合には関数 `fmod()'、
     整数の場合には`X % Y' を使う方がよいでしょう。

`frexp(x)'
     X の仮数と指数を `(M, E)'のペアとして返します。
     Mはfloat型で、Eは厳密に`X == M * 2**E' であるような整数型です。 X
     がゼロの場合は、 `(0.0, 0)'を返し、それ以外の場合は、 `0.5 <=
     abs(M) < 1' を返します。これは浮動小数点型の内部表現
     を可搬性を保ったまま "分解する (pick apart)" するためです。

`ldexp(x, i)'
     `X * (2**I)' を返します。

`modf(x)'
     Xの小数部分と整数部分を返します。 両方の結果は
     Xの符号を受け継ぎます。 整数部はfloat型で返されます。

`frexp()'と `modf()' は C のものとは異なった呼び出し/返し
パターンを持っていることに注意してください。引数を1つだけ受け取り、1組のペアに
なった値を返すので、2つ目の戻り値を `出力用の引数'
経由で返したりはしません (Python には出力用の引数はありません)。

`ceil()'、`floor()'、および`modf()' 関数に
ついては、非常に大きな浮動小数点数が_全て_ 整数そのものになるという
ことに注意してください。通常、Python の浮動小数点型は 53 ビット以上の
精度をもたない (プラットフォームにおける C double 型と同じ) ので、
結果的に`abs(X) >= 2**52' であるような浮動小数点型X は
小数部分を持たなくなるのです。

以下は指数および対数関数です:

`exp(x)'
     `e**X' を返します。

`log(x[, base])'
     X の自然対数を返します。 BASE を底とした X の対数を返します。BASE
     を省略した場合 X の自然対数を返します。 _Changed in Python version
     2.3_

`log10(x)'
     X の10を底とした対数を返します。

`pow(x, y)'
     `X**Y'を返します。

`sqrt(x)'
     X の平方根を返します。

以下は三角関数です:

`acos(x)'
     X の逆余弦を返します。

`asin(x)'
     X の逆正弦を返します。

`atan(x)'
     X 逆正接を返します。

`atan2(y, x)'
     `atan(Y / X)' の逆正接をラジアンで返します。 戻り値は `-pi' から
     `pi' の間になります。この角度は、 極座標平面において原点から `(X,
     Y)' へのベクトル が X 軸の正の方向となす角です。`atan2()'
     のポイントは、 入力 X, Y の両方の符号が既知であるために、位相角の
     正しい象限を計算できることにあります。例えば、`atan(1)' と
     `atan2(1,1)' はいずれも `pi/4' ですが、`atan2(-1, -1)' は
     `-3*pi/4' になります。

`cos(x)'
     X の余弦を返します。

`hypot(x, y)'
     ユークリッド距離(`sqrt(X*X + Y*Y)')を返します。

`sin(x)'
     Xの正弦を返します。

`tan(x)'
     X の正接を返します。

以下は角度に関する関数です:

`degrees(x)'
     角 X をラジアンから度数に変換します。

`radians(x)'
     角 X を度数からラジアンに変換します。

以下は双曲線関数です:

`cosh(x)'
     X の双曲線余弦を返します。

`sinh(x)'
     Xの双曲線正弦を返します。

`tanh(x)'
     X の双曲線正接を返します。

このモジュールでは以下の 2つの数学定数も定義しています:

`pi'
     数学定数 _pi_。

`e'
     数学定数 _e_。

_Notice:_ `math' モジュールは、ほとんどが実行プラットフォームにおける C
言語の数学ライブラリ関数に対する薄いラッパでできています。
例外的な場合での挙動は、 C
言語標準ではおおさっぱにしか定義されておらず、 さらに Python
は数学関数におけるエラー報告機能の挙動をプラットフォームの C
実装から受け継いでいます。その結果として、エラーの際 (およびなんらか
の引数がとにかく例外的であると考えられる場合) に送出される特定の例外に
ついては、プラットフォーム間やリリースバージョン間を通じて有意なものと
なっていません。例えば、 `math.log(0)' が `-Inf' を返すか `ValueError'
または  `OverflowError' を送出するかは不定であり、 `math.log(0)' が
`OverflowError' を送出する場合において `math.log(0L)' が `ValueError'
を送出するときもあります。

See also:
     *Note cmath:: これらの多くの関数の複素数版。

---------- Footnotes ----------

(1) 訳注：例外が発生しないで、計算結果が返えってし
まうと、計算結果がおかしい事から、原因が複素数を渡したせいである事に
プログラマが気づくのがおくれる可能性があります。


File: python-lib-jp.info,  Node: cmath,  Next: decimal,  Prev: math,  Up: 数値と数学モジュール

6.2 複素数のための数学関数
==========================

複素数のための数学関数です。

このモジュールは常に利用できます。このモジュールでは、
複素数を扱う数学関数へのアクセス手段を提供しています。

提供している関数を以下に示します:

`acos(x)'
     X の逆余弦 (arc cosine) を返します。 この関数には二つの branch cut
     があります: 一つは 1 から右側に実数軸に沿って
     _infinity_へと延びていて、 下から連続しています。 もう一つは -1
     から左側に実数軸に沿って -_infinity_へと延びていて、
     上から連続しています。

`acosh(x)'
     X の逆双曲線余弦を返します。 branch cut が一つあり、1
     の左側に実数軸に沿って -_infinity_へと
     延びていて、上から連続しています。

`asin(x)'
     X の逆正弦を返します。 `acos()' と同じ branch cut を持ちます。

`asinh(x)'
     X の双曲線正弦を返します。 2 つの brnch cut があり、+-`1j' の左から
     +-_infinity_`j' に延びており、両方とも上で連続しています。
     これらの branch cut
     は将来のリリースで修正されるべきバグとみなされて います。 正しい
     branch cut は虚数軸に沿って延びており、一つは `1j' から
     _infinity_`j' までで右から連続、もう一方は -`1j' から下って
     -_infinity_`j' までで、左から連続です。

`atan(x)'
     X の逆正接を返します。 2 つの branch cut があります: 一つは `1j'
     から虚数軸に沿って _infinity_`j' へと延びており、
     左で連続です。もう一方は -`1j' から虚数軸に沿って -_infinity_`j'
     までで、左で連続です。 (この仕様は上の branch cut
     が反対側から連続になるように変更されるかも しれません)。

`atanh(x)'
     X の逆双曲線正接を返します。 2 つの branch cut があります: 一つは
     1 から実数軸に沿って _infinity_までで、上で連続です。 もう一方は
     -1 から実数軸に沿って -_infinity_までで、 上で連続です。
     (この仕様は左側の branch cut
     が反対側から連続になるように変更されるかも しれません)。

`cos(x)'
     X の余弦を返します。

`cosh(x)'
     X の双曲線余弦を返します。

`exp(x)'
     指数値 `e**X' を返します。

`log(x[, base])'
     BASEを底とするX の対数を返します。
     もしBASEが指定されていない場合には、Xの自然対数を返しま す。
     branch cut を一つもち、0 から負の実数軸に沿って -_infinity_に
     延びており、上で連続しています。 _Changed in Python version 2.4_

`log10(x)'
     X の底 10 対数を返します。 `log()' と同じbranch cut を持ちます。

`sin(x)'
     X の正弦を返します。

`sinh(x)'
     X の双曲線正弦を返します。

`sqrt(x)'
     X の平方根を返します。 `log()' と同じ branch cut を持ちます。

`tan(x)'
     X の正接を返します。

`tanh(x)'
     X の双曲線正接を返します。

このモジュールではまた、以下の数学定数も定義しています:

`pi'
     数学上の定数 _pi_ で、実数です。

`e'
     数学上の定数 _e_ で、実数です。

`math'  と同じような関数が選ばれて
いますが、全く同じではないので注意してください。機能を二つの
モジュールに分けているのは、複素数に興味がなかったり、もしかすると
複素数とは何かすら知らないようなユーザがいるからです。
そういった人たちはむしろ、`math.sqrt(-1)' が複素数を返すよりも
例外を送出してほしいと考えます。また、`cmath' で定義されている
関数は、たとえ結果が実数で表現可能な場合 (虚数部分がゼロの複素数) でも、
常に複素数を返すので注意してください。

branch cut に関する注釈: branch cut をもつ曲線上では、与えられた関数は
連続でありえなくなります。これらは多くの複素関数における必然的な
特性です。複素関数を計算する必要がある場合、これらの branch cut に
関して理解しているものと仮定しています。悟りに至るために何らかの
(到底基礎的とはいえない) 複素数に関する書をひもといてください。
数値計算を目的とした branch cut の正しい選択方法についての情報としては、
以下がよい参考文献となります:

See also:
     Kahan, W:  Branch cuts for complex elementary functions; or, Much
     ado about nothings's sign bit.  In Iserles, A., and Powell, M.
     (eds.), . Clarendon Press (1987) pp165-211.


File: python-lib-jp.info,  Node: decimal,  Next: random,  Prev: cmath,  Up: 数値と数学モジュール

6.3 10進浮動小数点数の算術演算
==============================

汎用 10 進数算術仕様 (General Decimal Arithmetic Specification) の実装。

_Added in Python version 2.4_

`decimal' モジュールは10 進の浮動小数点算術をサポートします。 `decimal'
には、 `float()' データ型に比べて、以下のような 利点があります:

   * 10 進数を正確に表現できます。`1.1' のような数は、2 進数の
     浮動小数点型では正しく表現できません。エンドユーザは普通、 2
     進数における`1.1' の近似値が`1.1000000000000001'
     だからといって、そのように表示してほしいとは考えないものです。

   * 値の正確さは算術にも及びます。10 進の浮動小数点による計算では、
     `0.1 + 0.1 + 0.1 - 0.3' は厳密にゼロに等しくなります。 2
     進浮動小数点では`5.5511151231257827e-017' になってしまいます。
     ゼロに近い値とはいえ、この誤差は数値間の等価性テストの信頼性を阻害します。
     また、誤差が蓄積されることもあります。こうした理由から、数値間の等価性を
     厳しく保たねばならないようなアプリケーションを考えるなら、10
     進数による 数値表現が望ましいということになります。

   * `decimal' モジュールでは、有効桁数の表記が取り入れられており、
     例えば `1.30 + 1.20' は `2.50' になります。すなわち、
     末尾のゼロは有効数字を示すために残されます。こうした仕様は通貨計算を行う
     アプリケーションでは慣例です。乗算の場合、「教科書的な」アプローチでは、
     乗算の被演算子すべての桁数を使います。 例えば、`1.3 * 1.2' は
     `1.56' になり、 `1.30 * 1.20' は `1.5600' になります。

   * ハードウェアによる 2 進浮動小数点表現と違い、`decimal'
     モジュールでは計算精度をユーザが指定できます(デフォルトでは 28
     桁です)。 この桁数はほとんどの問題解決に十分な大きさです:

          >>> getcontext().prec = 6
          >>> Decimal(1) / Decimal(7)
          Decimal("0.142857")
          >>> getcontext().prec = 28
          >>> Decimal(1) / Decimal(7)
          Decimal("0.1428571428571428571428571429")

   * 2 進と 10 進の浮動小数点は、いずれも広く公開されている標準仕様の
     もとに実装されています。組み込みの浮動小数点型では、標準仕様で提唱されている
     機能のほんのささやかな部分を利用できるにすぎませんが、 `decimal'
     では標準仕様が要求している全ての機能を利用できます。必要に応じて、
     プログラマは値の丸めやシグナル処理を完全に制御できます。


このモジュールは、 10 進数型、算術コンテキスト (context for
arithmetic)、 そしてシグナル (signal)
という三つの概念を中心に設計されています、

10 進数型は変更不可能な型です。この型には符号部、仮数部、そして指数部
があります。有効桁数を残すために、仮数部の末尾にあるゼロの切り詰めは
行われません。 `decimal' では、 `Infinity', `-Infinity', および `NaN'
といった特殊な値も定義されています。 標準仕様では `-0' と `+0'
も区別しています。

算術コンテキストとは、精度や値丸めの規則、指数部の制限を決めている
環境です。この環境では、演算結果を表すためのフラグや、演算上発生した
特定のシグナルを例外として扱うかどうかを決めるトラップイネーブラも
定義しています。丸め規則には`ROUND_CEILING', `ROUND_DOWN',
`ROUND_FLOOR', `ROUND_HALF_DOWN', `ROUND_HALF_EVEN', `ROUND_HALF_UP',
および `ROUND_UP' があります。

シグナルとは、演算の過程で生じる例外的条件です。個々のシグナルは、
アプリケーションそれぞれの要求に従って、無視されたり、単なる情報と
みなされたり、例外として扱われたりします。`decimal' モジュール
には、`Clamped', `InvalidOperation', `DivisionByZero', `Inexact',
`Rounded', `Subnormal', `Overflow', および `Underflow'
といったシグナルがあります。

各シグナルには、フラグとトラップイネーブラがあります。演算上
何らかのシグナルに遭遇すると、フラグはゼロからインクリメントされて
ゆきます。このとき、もしトラップイネーブラが 1 にセットされて
いれば、例外を送出します。フラグの値は膠着型 (sticky) なので、
演算によるフラグの変化をモニタしたければ、予めフラグをリセット
しておかねばなりません。

See also:
     IBM による汎用 10 進演算仕様、 。

     IEEE 標準化仕様 854-1987, 。

* Menu:

* Quick-start Tutorial::
* Decimal オブジェクト::
* Context オブジェクト::
* シグナル::
* 浮動小数点数に関する注意::
* スレッドを使った処理::
* レシピ 2::
* Decimal FAQ::


File: python-lib-jp.info,  Node: Quick-start Tutorial,  Next: Decimal オブジェクト,  Prev: decimal,  Up: decimal

6.3.1 Quick-start Tutorial
--------------------------

普通、`decimal' を使うときには、モジュールを import し、現在の
演算コンテキストを `getcontext()' で調べ、必要に応じて
精度や丸めを設定し、演算エラーのトラップを有効にします:

     >>> from decimal import *
     >>> getcontext()
     Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999,
             capitals=1, flags=[], traps=[Overflow, InvalidOperation,
             DivisionByZero])

     >>> getcontext().prec = 7       # 新たな精度を設定

`Decimal' のインスタンスは、整数、文字列またはタプルから生成
できます。`Decimal' を `float' から生成したければ、まず
文字列型に変換せねばなりません。そうすることで、変換方法の詳細を
(representation error も含めて) 明示的に残せます。 `Decimal' は
"数値ではない (Not a Number)" を表す `NaN' や正負の `Infinity'
(無限大)、 `-0' といった特殊な値も表現できます。

     >>> Decimal(10)
     Decimal("10")
     >>> Decimal("3.14")
     Decimal("3.14")
     >>> Decimal((0, (3, 1, 4), -2))
     Decimal("3.14")
     >>> Decimal(str(2.0 ** 0.5))
     Decimal("1.41421356237")
     >>> Decimal("NaN")
     Decimal("NaN")
     >>> Decimal("-Infinity")
     Decimal("-Infinity")

新たな `Decimal' 型数値の有効桁数は入力した数の桁数だけで決まります。
演算コンテキストにおける精度や値丸めの設定が影響するのは算術操作の
中だけです。

     >>> getcontext().prec = 6
     >>> Decimal('3.0')
     Decimal("3.0")
     >>> Decimal('3.1415926535')
     Decimal("3.1415926535")
     >>> Decimal('3.1415926535') + Decimal('2.7182818285')
     Decimal("5.85987")
     >>> getcontext().rounding = ROUND_UP
     >>> Decimal('3.1415926535') + Decimal('2.7182818285')
     Decimal("5.85988")

`Decimal' 型数値はほとんどの場面で Python の他の機能とうまく
やりとりできます。 `Decimal' 浮動小数点小劇場 (flying circus)
を示しましょう:

     >>> data = map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 9.25'.split())
     >>> max(data)
     Decimal("9.25")
     >>> min(data)
     Decimal("0.03")
     >>> sorted(data)
     [Decimal("0.03"), Decimal("1.00"), Decimal("1.34"), Decimal("1.87"),
      Decimal("2.35"), Decimal("3.45"), Decimal("9.25")]
     >>> sum(data)
     Decimal("19.29")
     >>> a,b,c = data[:3]
     >>> str(a)
     '1.34'
     >>> float(a)
     1.3400000000000001
     >>> round(a, 1)     # round() は値をまず二進の浮動小数点数に変換します
     1.3
     >>> int(a)
     1
     >>> a * 5
     Decimal("6.70")
     >>> a * b
     Decimal("2.5058")
     >>> c % a
     Decimal("0.77")

`quantize()' メソッドは位を固定して数値を丸めます。このメソッドは、
計算結果を固定の桁数で丸めることがよくある、通貨を扱うアプリケーションで
便利です:

     >>> Decimal('7.325').quantize(Decimal('.01'), rounding=ROUND_DOWN)
     Decimal("7.32")
     >>> Decimal('7.325').quantize(Decimal('1.'), rounding=ROUND_UP)
     Decimal("8")

前述のように、`getcontext()' 関数を使うと現在の演算コンテキスト
にアクセスでき、設定を変更できます。ほとんどのアプリケーションはこの
アプローチで十分です。

より高度な作業を行う場合、`Context()' コンストラクタを使って
別の演算コンテキストを作っておくと便利なことがあります。
別の演算コンテキストをアクティブにしたければ、`setcontext()'
を使います。

`Decimal' モジュールでは、標準仕様に従って、すぐ利用できる
二つの標準コンテキスト、`BasicContext' および `ExtendedContext'
を提供しています。後者はほとんどのトラップが
有効になっており、とりわけデバッグの際に便利です:

     >>> myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)
     >>> setcontext(myothercontext)
     >>> Decimal(1) / Decimal(7)
     Decimal("0.142857142857142857142857142857142857142857142857142857142857")

     >>> ExtendedContext
     Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999,
             capitals=1, flags=[], traps=[])
     >>> setcontext(ExtendedContext)
     >>> Decimal(1) / Decimal(7)
     Decimal("0.142857143")
     >>> Decimal(42) / Decimal(0)
     Decimal("Infinity")

     >>> setcontext(BasicContext)
     >>> Decimal(42) / Decimal(0)
     Traceback (most recent call last):
       File "<pyshell#143>", line 1, in -toplevel-
         Decimal(42) / Decimal(0)
     DivisionByZero: x / 0

演算コンテキストには、演算中に遭遇した例外的状況をモニタするための
シグナルフラグがあります。フラグが一度セットされると、明示的に
クリアするまで残り続けます。そのため、フラグのモニタを行いたいような
演算の前には`clear_flags()' メソッドでフラグをクリアして
おくのがベストです。

     >>> setcontext(ExtendedContext)
     >>> getcontext().clear_flags()
     >>> Decimal(355) / Decimal(113)
     Decimal("3.14159292")
     >>> getcontext()
     Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999999, Emax=999999999,
             capitals=1, flags=[Inexact, Rounded], traps=[])

FLAGS エントリから、`Pi' の有理数による近似値が丸められた
(コンテキスト内で決められた精度を超えた桁数が捨てられた) ことと、
計算結果が厳密でない (無視された桁の値に非ゼロのものがあった) ことが
わかります。

コンテキストの `traps' フィールドに入っている辞書を使うと、
個々のトラップをセットできます:

     >>> Decimal(1) / Decimal(0)
     Decimal("Infinity")
     >>> getcontext().traps[DivisionByZero] = 1
     >>> Decimal(1) / Decimal(0)
     Traceback (most recent call last):
       File "<pyshell#112>", line 1, in -toplevel-
         Decimal(1) / Decimal(0)
     DivisionByZero: x / 0

ほとんどのプログラムでは、開始時に一度だけ現在の演算コンテキストを
修正します。また、多くのアプリケーションでは、データから `Decimal'
への変換はループ内で一度だけキャストして行います。コンテキストを設定し、
`Decimal' オブジェクトを生成できたら、ほとんどのプログラムは 他の
Python 数値型と全く変わらないかのように`Decimal' を操作できます。


File: python-lib-jp.info,  Node: Decimal オブジェクト,  Next: Context オブジェクト,  Prev: Quick-start Tutorial,  Up: decimal

6.3.2 Decimal オブジェクト
--------------------------

`Decimal([value [, context]])'
     VALUE に基づいて新たな `Decimal' オブジェクトを構築 します。

     VALUE は整数、文字列、タプル、および他の `Decimal'
     オブジェクトにできます。VALUE を指定しない場合、 `Decimal("0")'
     を返します。 VALUE が文字列の場合、 以下の 10
     進数文字列の文法に従わねばなりません:

              sign           ::=  '+' | '-'
              digit          ::=  '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
              indicator      ::=  'e' | 'E'
              digits         ::=  digit [digit]...
              decimal-part   ::=  digits '.' [digits] | ['.'] digits
              exponent-part  ::=  indicator [sign] digits
              infinity       ::=  'Infinity' | 'Inf'
              nan            ::=  'NaN' [digits] | 'sNaN' [digits]
              numeric-value  ::=  decimal-part [exponent-part] | infinity
              numeric-string ::=  [sign] numeric-value | [sign] nan

     VALUE を `tuple' にする場合、タプルは三つの要素を持ち、
     それぞれ符号 (正なら`0'、負なら `1')、仮数部を
     表す数字のタプル、そして指数を表す整数でなければなりません。
     例えば、`Decimal((0, (1, 4, 1, 4), -3))' は `Decimal("1.414")'
     を返します。

     CONTEXT に指定した精度 (precision) は、オブジェクトが記憶する
     桁数には影響しません。桁数は VALUE に指定した桁数だけから
     決定されます。例えば、演算コンテキストに指定された精度が 3
     桁しかなくても、 `Decimal("3.00000")' は 5
     つのゼロを全て記憶します。

     CONTEXT 引数の目的は、VALUE が正しくない形式の文字列
     であった場合に行う処理を決めることにあります;
     演算コンテキストが`InvalidOperation' をトラップするように
     なっていれば、例外を送出します。それ以外の場合には、コンストラクタは
     値が`NaN' の`Decimal' を返します。

     一度生成すると、`Decimal' オブジェクトは変更不能 (immutable)
     になります。

10 進浮動小数点オブジェクトは、`float' や`int' のような
他の組み込み型と多くの点で似ています。通常の数学演算や特殊メソッドを
適用できます。また、`Decimal' オブジェクトは コピーでき、pickle
化でき、print で出力でき、辞書のキーにでき、
集合の要素にでき、比較、保存、他の型 (`float' や`long')
への型強制を行えます。

こうした標準的な数値型の特性の他に、10進浮動小数点オブジェクトには
様々な特殊メソッドがあります:

`adjusted()'
     仮数部の先頭の一桁だけが残るように桁シフトを行い、そのときの指数部を
     返します: `Decimal("321e+5").adjusted()' なら 7 です。
     最上桁の小数点からの相対位置を調べる際に使います。

`as_tuple()'
     数値を表現するためのタプル: `(sign, digittuple, exponent)'
     を返します。

`compare(other[, context])'
     `__cmp__()' に似ていますが、`Decimal' インスタンスを 返します。
                  a or b is a NaN ==> Decimal("NaN")
                  a < b           ==> Decimal("-1")
                  a == b          ==> Decimal("0")
                  a > b           ==> Decimal("1")


`max(other[, context])'
     `max(self, other)' と同じですが、値を返す前に現在のコンテキストに
     即した丸め規則を適用します。また、 `NaN'
     に対して、(コンテキストでシグナルまたは黙認のどちらが
     設定されているかに応じて) シグナルを発行するか無視します。

`min(other[, context])'
     `min(self, other)' と同じですが、値を返す前に現在のコンテキストに
     即した丸め規則を適用します。また、 `NaN'
     に対して、(コンテキストでシグナルまたは黙認のどちらが
     設定されているかに応じて) シグナルを発行するか無視します。

`normalize([context])'
     数値を正規化 (normalize) して、右端に連続しているゼロを除去し、
     `Decimal("0")' と同じ結果はすべて `Decimal("0e0")' に変換します。
     同じクラスの値から基準表現を生成する際に用います。 たとえば、
     `Decimal("32.100")' と `Decimal("0.321000e+2")'
     の正規化は、いずれも同じ値 `Decimal("32.1")' になります。

`quantize(exp [, rounding[, context[, watchexp]]])'
     指数部をEXP と同じにします。値丸めの際、まずROUNDING が
     あるか調べ、次にCONTEXT を調べ、最後に現在のコンテキストの
     設定を用います。

     WATCHEXP が (default) に設定されている場合、処理結果の指数 が
     `Emax' よりも大きい場合や `Etiny' よりも小さい
     場合にエラーを返します。

`remainder_near(other[, context])'
     モジュロを計算し、正負のモジュロのうちゼロに近い値を返します。
     たとえば、 `Decimal(10).remainder_near(6)' は `Decimal("4")'
     よりもゼロに近い値 `Decimal("-2")' を返します。

     ゼロからの差が同じ場合には、 SELF と同じ符号を持った方を 返します。

`same_quantum(other[, context])'
     SELF と OTHER が同じ指数を持っているか、あるいは 双方とも `NaN'
     である場合に真を返します。

`sqrt([context])'
     平方根を精度いっぱいまで求めます。

`to_eng_string([context])'
     数値を工学で用いられる形式 (工学表記; enginnering notation)
     の文字列に変換します。

     工学表記では指数は 3 の倍数になります。従って、 最大で 3
     桁までの数字が基数の小数部に現れます。たとえば、
     `Decimal('123E+1')' は `Decimal("1.23E+3")' に変換されます。

`to_integral([rounding[, context]])'
     `Inexact' や `Rounded' といったシグナルを出さずに
     最近傍の整数に値を丸めます。ROUNDING が指定されていれば適用
     されます; それ以外の場合、値丸めの方法はCONTEXT の設定か現在の
     コンテキストの設定になります。


File: python-lib-jp.info,  Node: Context オブジェクト,  Next: シグナル,  Prev: Decimal オブジェクト,  Up: decimal

6.3.3 Context オブジェクト
--------------------------

コンテキスト (context) とは、算術演算における環境設定です。
コンテキストは計算精度を決定し、値丸めの方法を設定し、
シグナルのどれが例外になるかを決め、指数の範囲を制限しています。

多重スレッドで処理を行う場合には各スレッドごとに現在のコンテキストが
あり、`getcontext()' や `setcontext()' といった関数で
アクセスしたり設定変更できます:

`getcontext()'
     アクティブなスレッドの現在のコンテキストを返します。

`setcontext(c)'
     アクティブなスレッドのコンテキストを C に設定します。

Python 2.5 から、`with' 文と `localcontext()' 関数を使っ
て実行するコンテキストを一時的に変更することもできるようになりました。

`localcontext([c])'
     with 文の入口でアクティブなスレッドのコンテキストを C のコピー
     に設定し、with
     文を抜ける時に元のコンテキストに復旧する、コンテキスト
     マネージャを返します。コンテキストが指定されなければ、現在のコンテキ
     ストのコピーが使われます。 _Added in Python version 2.5_

     たとえば、以下のコードでは精度を42桁に設定し、計算を実行し、そして
     元のコンテキストに復帰します。
              from __future__ import with_statement
              from decimal import localcontext

              with localcontext() as ctx:
                  ctx.prec = 42   # 高精度の計算を実行
                  s = calculate_something()
              s = +s  # 最終的な結果をデフォルトの精度に丸める


新たなコンテキストは、以下で説明する`Context' コンストラクタを
使って生成できます。その他にも、`decimal' モジュールでは
作成済みのコンテキストを提供しています:

`BasicContext'
     General Decimal Arithmetic Specification
     で定義されている標準コンテキスト の一つです。精度は 9
     桁に設定されています。丸め規則は `ROUND_HALF_UP'
     です。すべての演算結果フラグはクリアされています。`Inexact'、
     `Rounded'、`Subnormal' を除く全ての演算エラートラップが 有効
     (例外として扱う) になっています。

     多くのトラップが有効になっているので、デバッグの際に便利なコンテキスト
     です。

`ExtendedContext'
     General Decimal Arithmetic Specification
     で定義されている標準コンテキスト の一つです。精度は 9
     桁に設定されています。丸め規則は `ROUND_HALF_EVEN'
     です。すべての演算結果フラグはクリアされています。
     トラップは全て無効 (演算中に一切例外を送出しない) になっています。

     トラップが無効になっているので、エラーの伴う演算結果を `NaN' や
     `Infinity' にし、例外を送出しないようにしたいアプリケーションに
     向いたコンテキストです。このコンテキストを使うと、他の場合にはプログラム
     が停止してしまうような状況があっても実行を完了させられます。

`DefaultContext'
     `Context' コンストラクタが新たなコンテキストを作成するさいに
     雛形にするコンテキストです。このコンテキストのフィールド
     (精度の設定など) を変更すると、`Context'
     コンストラクタが生成する新たなコンテキストに 影響を及ぼします。

     このコンテキストは、主に多重スレッド環境で便利です。スレッドを開始する
     前に何らかのフィールドを変更しておくと、システム全体のデフォルト設定
     に効果を及ぼせます。スレッドを開始した後にフィールドを変更すると
     競合条件を抑制するためにスレッドを同期化せねばならないので推奨しません。

     単一スレッドの環境では、このコンテキストを使わないよう薦めます。
     下で述べるように明示的にコンテキストを作成してください。

     デフォルトの値は精度 28 桁、丸め規則 `ROUND_HALF_EVEN' で、
     トラップ `Overflow'、`InvalidOperation'、および `DivisionByZero'
     が有効になっています。

上に挙げた三つのコンテキストに加え、`Context' コンストラクタを
使って新たなコンテキストを生成できます。

`Context(prec=None, rounding=None, traps=None, flags=None, Emin=None, Emax=None, capitals=1)'
     新たなコンテキストを生成します。あるフィールドが定義されていないか
     `None' であれば、 `DefaultContext' からデフォルト値を
     コピーします。 FLAGS フィールドが設定されていいか `None'
     の場合には、全てのフラグがクリアされます。

     PREC フィールドは正の整数で、コンテキストにおける算術演算の
     計算精度を設定します。

     ROUNDING は、
        * `ROUND_CEILING' (`Infinity' 寄りの値にする),

        * `ROUND_DOWN' (ゼロ寄りの値にする),

        * `ROUND_FLOOR' (`-Infinity' 寄りの値にする),

        * `ROUND_HALF_DOWN' (最近値のうちゼロ寄りの値にする),

        * `ROUND_HALF_EVEN' (最近値のうち偶数値を優先する),

        * `ROUND_HALF_UP' (最近値のうちゼロから遠い値にする), または

        * `ROUND_UP' (ゼロから遠い値にする)

     のいずれかです。

     TRAPS および FLAGS フィールドには、セットしたい
     シグナルを列挙します。一般的に、新たなコンテキストを作成するときには
     トラップだけを設定し、フラグはクリアしておきます。

     EMIN および EMAX フィールドには、指数範囲の外側値を整数で
     指定します。

     CAPITALS フィールドは `0' または `1' (デフォルト) にします。`1'
     に設定すると、指数記号を大文字 `E' で
     出力します。それ以外の場合には `Decimal('6.02e+23')' のように`e'
     を使います。

`Context' クラスでは、いくつかの汎用のメソッドの他、現在の
コンテキストで算術演算を直接行うためのメソッドを数多く定義しています。

`clear_flags()'
     フラグを全て `0' にリセットします。

`copy()'
     コンテキストの複製を返します。

`create_decimal(num)'
     SELF をコンテキストとする新たな Decimal インスタンスを NUM
     から生成します。`Decimal' コンストラクタと違い、
     数値を変換する際にコンテキストの精度、値丸め方法、フラグ、トラップ
     を適用します。

     定数値はしばしばアプリケーションの要求よりも高い精度を持っているため、
     このメソッドが役に立ちます。また、値丸めを即座に行うため、
     例えば以下のように、入力値に値丸めを行わないために合計値にゼロの加算を
     追加するだけで結果が変わってしまうといった、現在の精度
     よりも細かい値の影響が紛れ込む問題を防げるという恩恵もあります。

              >>> getcontext().prec = 3
              >>> Decimal("3.4445") + Decimal("1.0023")
              Decimal("4.45")
              >>> Decimal("3.4445") + Decimal(0) + Decimal("1.0023")
              Decimal("4.44")


`Etiny()'
     `Emmin - prec + 1' に等しい値を返します。
     演算結果の劣化が起こる桁の最小値です。アンダーフローが起きた場合、
     指数は `Etiny' に設定されます。


`Etop()'
     `Emax - prec + 1' に等しい値を返します。

`Decimal' を使った処理を行う場合、通常は `Decimal'
インスタンスを生成して、算術演算を適用するというアプローチを
とります。演算はアクティブなスレッドにおける現在のコンテキストの
下で行われます。もう一つのアプローチは、コンテキストのメソッドを
使った特定のコンテキスト下での計算です。 コンテキストのメソッドは
`Decimal' クラスのメソッドに似ているので、
ここでは簡単な説明にとどめます。

`abs(x)'
     X の絶対値を返します。

`add(x, y)'
     X と Y の加算を返します。

`compare(x, y)'
     二つの値を数値として比較します。

     `__cmp__()' に似ていますが、 以下のように`Decimal'
     インスタンスを返します:
                  a or b is a NaN ==> Decimal("NaN")
                  a < b           ==> Decimal("-1")
                  a == b          ==> Decimal("0")
                  a > b           ==> Decimal("1")


`divide(x, y)'
     X を Y で除算した値を返します。

`divmod(x, y)'
     二つの数値間の除算を行い、結果の整数部を返します。

`max(x, y)'
     二つの値を数値として比較し、大きいほうを返します。

     数値上二つの値が等しい場合には、左側値を結果として返します。

`min(x, y)'
     二つの値を数値として比較し、小さいほうを返します。

     数値上二つの値が等しい場合には、左側値を結果として返します。

`minus(x)'
     Python における単項の符号反転前置演算子 (unary prefix minus
     operator) に対応する演算です。

`multiply(x, y)'
     X とY の積を返します。

`normalize(x)'
     被演算子をもっとも単純な表記にします。

     本質的には、`plus' 演算の結果から末尾のゼロを全て取り除いた
     ものと同じです。

`plus(x)'
     Python における単項の符号非反転前置演算子 (unary prefix plus
     operator)
     に対応する演算です。コンテキストにおける精度や値丸めを適用する
     ので、等値 (identity) 演算とは _違います_。

`power(x, y[, modulo])'
     `x ** y' を計算します。MODULO が指定されていれば使います。

     右被演算子は整数部が 9 桁以下で、小数部 (のある場合) は値丸め前に
     全てゼロになっていなければなりません。被演算子は正でも負でもゼロでも
     かまいません。右被演算子が負の場合には、左被演算子の逆数 (1
     を左被演算子で割った値) を右被演算子の逆数でべき乗します。

     中間演算でより高い計算精度が必要になり、その精度が実装の提供している
     精度を超えた場合、`InvalidOperation' エラーをシグナルします。

     負のべき乗を行う際に 1 への除算でアンダーフローが起きても、
     その時点では演算を停止せず継続します。

`quantize(x, y)'
     X に値丸めを適用し、指数を Y にした値を返します。

     他の演算と違い、量子化後の係数の長さが精度よりも大きい場合には
     `InvalidOperation' をシグナルします。
     このため、エラーが生じないかぎり、量子化後の指数は右側の被演算子
     の指数と等しくなることが保証されます。

     また、結果が劣化していたり不正確な値であっても、`Underflow'
     をシグナルしないという点も他の演算と異なります。

`remainder(x, y)'
     整数除算の剰余を返します。

     剰余がゼロでない場合、符号は割られる数の符号と同じになります。

`remainder_near(x, y)'
     モジュロを計算し、正負のモジュロのうちゼロに近い値を返します。
     たとえば、 `Decimal(10).remainder_near(6)' は `Decimal("4")'
     よりもゼロに近い値 `Decimal("-2")' を返します。

     ゼロからの差が同じ場合には、 SELF と同じ符号を持った方を 返します。

`same_quantum(x, y)'
     SELF と OTHER が同じ指数を持っているか、あるいは 双方とも `NaN'
     である場合に真を返します。

`sqrt(x)'
     X の平方根を精度いっぱいまで求めます。

`subtract(x, y)'
     X とY の間の差を返します。

`to_eng_string()'
     工学表記で文字列に変換します。

     工学表記では指数は 3 の倍数になります。従って、 最大で 3
     桁までの数字が基数の小数部に現れます。たとえば、
     `Decimal('123E+1')' は `Decimal("1.23E+3")' に変換されます。

`to_integral(x)'
     `Inexact' や `Rounded' といったシグナルを出さずに
     最近傍の整数に値を丸めます。

`to_sci_string(x)'
     数値を科学表記で文字列に変換します。


File: python-lib-jp.info,  Node: シグナル,  Next: 浮動小数点数に関する注意,  Prev: Context オブジェクト,  Up: decimal

6.3.4 シグナル
--------------

シグナルは、計算中に生じた様々なエラー条件を表現します。
各々のシグナルは一つのコンテキストフラグと一つのトラップイネーブラに
対応しています。

コンテキストフラグは、該当するエラー条件に遭遇するたびに加算されて
ゆきます。演算後にフラグを調べれば、演算に関する情報
(例えば計算が厳密だったかどうか) がわかります。
フラグを調べたら、次の計算を始める前にフラグを全てクリアするように
してください。

あるコンテキストのトラップイネーブラがあるシグナルに対してセット
されている場合、該当するエラー条件が生じると Python の例外を送出
します。例えば、`DivisionByZero' が設定されていると、
エラー条件が生じた際に `DivisionByZero' 例外を送出します。

`Clamped'
     値の表現上の制限に沿わせるために指数部が変更されたことを通知します。

     通常、クランプ (clamp)
     は、指数部がコンテキストにおける指数桁の制限値 `Emin' および`Emax'
     を越えたなった場合に発生します。
     可能な場合には、係数部にゼロを加えた表現に合わせて指数部を減らします。

`DecimalException'
     他のシグナルの基底クラスで、`ArithmeticError' の サブクラスです。

`DivisionByZero'
     有限値をゼロで除算したときのシグナルです。

     除算やモジュロ除算、数を負の値で累乗した場合に起きることがあります。
     このシグナルをトラップしない場合、演算結果は `Infinity' または
     `-Infinity'
     になり、その符号は演算に使った入力に基づいて決まります。

`Inexact'
     値の丸めによって演算結果から厳密さが失われたことを通知します。

     このシグナルは値丸め操作中にゼロでない桁を無視した際に生じます。
     演算結果は値丸め後の値です。シグナルのフラグやトラップは、
     演算結果の厳密さが失われたことを検出するために使えるだけです。

`InvalidOperation'
     無効な演算が実行されたことを通知します。

     ユーザが有意な演算結果にならないような操作を要求したことを示します。
     このシグナルをトラップしない場合、`NaN' を返します。
     このシグナルの発生原因として考えられるのは、以下のような状況です:

                  Infinity - Infinity
                  0 * Infinity
                  Infinity / Infinity
                  x % 0
                  Infinity % x
                  x._rescale( non-integer )
                  sqrt(-x) and x > 0
                  0 ** 0
                  x ** (non-integer)
                  x ** Infinity


`Overflow'
     数値オーバフローを示すシグナルです。

     このシグナルは、値丸めを行った後の指数部が `Emax' より大きいことを
     示します。シグナルをトラップしない場合、演算結果は値丸めのモードにより、
     表現可能な最大の数値になるように内側へ引き込んで丸めを行った値か、
     `Infinity' になるように外側に丸めた値のいずれかになります。
     いずれの場合も、`Inexact' および `Rounded' が同時に
     シグナルされます。

`Rounded'
     情報が全く失われていない場合も含み、値丸めが起きたときのシグナルです。

     このシグナルは、値丸めによって桁がなくなると常に発生します。
     なくなった桁がゼロ (例えば`5.00' を丸めて `5.0' になった場合)
     であってもです。このシグナルをトラップしなければ、
     演算結果をそのまま返します。このシグナルは有効桁数の減少を検出
     する際に使います。

`Subnormal'
     値丸めを行う前に指数部が `Emin' より小さかったことを示す
     シグナルです。

     演算結果が微小である場合 (指数が小さすぎる場合) に発生します。
     このシグナルをトラップしなければ、演算結果をそのまま返します。

`Underflow'
     演算結果が値丸めによってゼロになった場合に生じる数値アンダフローです。

     演算結果が微小なため、値丸めによってゼロになった場合に発生します。
     `Inexact' および `Subnormal' シグナルも同時に発生します。

これらのシグナルの階層構造をまとめると、以下の表のようになります:

         exceptions.ArithmeticError(exceptions.StandardError)
             DecimalException
                 Clamped
                 DivisionByZero(DecimalException, exceptions.ZeroDivisionError)
                 Inexact
                     Overflow(Inexact, Rounded)
                     Underflow(Inexact, Rounded, Subnormal)
                 InvalidOperation
                 Rounded
                 Subnormal


File: python-lib-jp.info,  Node: 浮動小数点数に関する注意,  Next: スレッドを使った処理,  Prev: シグナル,  Up: decimal

6.3.5 浮動小数点数に関する注意
------------------------------

* Menu:

* 精度を上げて丸め誤差を抑制する::
* 特殊値::


File: python-lib-jp.info,  Node: 精度を上げて丸め誤差を抑制する,  Next: 特殊値,  Prev: 浮動小数点数に関する注意,  Up: 浮動小数点数に関する注意

6.3.5.1 精度を上げて丸め誤差を抑制する
......................................

10 進浮動小数点数を使うと、 10 進数表現による誤差を抑制できます (`0.1'
を正確に表現できるようになります); しかし、ゼロでない
桁が一定の精度を越えている場合には、演算によっては依然として値丸めによる
誤差を引き起こします。 Knuth は、十分でない計算精度の下で値丸めを伴う
浮動小数点演算を行った結果、加算の結合則や分配則における恒等性が崩れて
しまう例を二つ示しています:

     # Examples from Seminumerical Algorithms, Section 4.2.2.
     >>> from decimal import Decimal, getcontext
     >>> getcontext().prec = 8

     >>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')
     >>> (u + v) + w
     Decimal("9.5111111")
     >>> u + (v + w)
     Decimal("10")

     >>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')
     >>> (u*v) + (u*w)
     Decimal("0.01")
     >>> u * (v+w)
     Decimal("0.0060000")

`decimal' モジュールでは、最下桁を失わないように十分に計算精度を
広げることで、上で問題にしたような恒等性をとりもどせます:

     >>> getcontext().prec = 20
     >>> u, v, w = Decimal(11111113), Decimal(-11111111), Decimal('7.51111111')
     >>> (u + v) + w
     Decimal("9.51111111")
     >>> u + (v + w)
     Decimal("9.51111111")
     >>>
     >>> u, v, w = Decimal(20000), Decimal(-6), Decimal('6.0000003')
     >>> (u*v) + (u*w)
     Decimal("0.0060000")
     >>> u * (v+w)
     Decimal("0.0060000")


File: python-lib-jp.info,  Node: 特殊値,  Prev: 精度を上げて丸め誤差を抑制する,  Up: 浮動小数点数に関する注意

6.3.5.2 特殊値
..............

`decimal' モジュールの数体系では、`NaN', `sNaN', `-Infinity' ,
`Infinity' , および二つのゼロ、 `+0' と `-0'
といった特殊な値を提供しています。

無限大 (Infinity) は `Decimal('Infinity')' で直接構築できます。
また、`DivisionByZero' をトラップせずにゼロで除算を行った
場合にも出てきます。同様に、 `Overflow' シグナルをトラップ
しなければ、表現可能な最大の数値の制限を越えた値を丸めたときに出てきます。

無限大には符号があり (アフィン: affine であり)、算術演算に使用でき、
非常に巨大で不確定の(indeterminate)値として扱われます。例えば、無限大に
何らかの定数を加算すると、演算結果は別の無限大になります。

演算によっては結果が不確定になるものがあり、`NaN' を返します。
ただし、`InvalidOperation' シグナルをトラップするように
なっていれば例外を送出します。

例えば、`0/0' は `NaN' を返します。`NaN' は 「非数値 (not a
number)」を表します。このような `NaN' は
暗黙のうちに生成され、一度生成されるとそれを他の計算にも流れてゆき、
関係する個々の演算全てが個別の `NaN' を返すようになります。
この挙動は、たまに入力値が欠けるような状況で一連の計算を行う際に
便利です -- 特定の計算に対しては無効な結果を示すフラグを立てつつ
計算を進められるからです。

一方、`NaN' の変種である`sNaN' は関係する全ての演算
で演算後にシグナルを送出します。`sNaN' は、無効な演算結果
に対して特別な処理を行うために計算を停止する必要がある場合に便利です。

アンダフローの起きた計算は、符号付きのゼロ (signed zero) を返す
ことがあります。符号は、より高い精度で計算を行った結果の
符号と同じになります。
符号付きゼロの大きさはやはりゼロなので、正のゼロと負のゼロは
等しいとみなされ、符号は単なる参考にすぎません。

二つの符号付きゼロが区別されているのに等価であることに加えて、
異なる精度におけるゼロの表現はまちまちなのに、値は等価と
みなされるということがあります。これに慣れるには多少時間がかかります。
正規化浮動小数点表現に目が慣れてしまうと、以下の計算でゼロに
等しい値が返っているとは即座に分かりません:

     >>> 1 / Decimal('Infinity')
     Decimal("0E-1000000026")


File: python-lib-jp.info,  Node: スレッドを使った処理,  Next: レシピ 2,  Prev: 浮動小数点数に関する注意,  Up: decimal

6.3.6 スレッドを使った処理
--------------------------

関数`getcontext()' は、スレッド毎に別々の`Context'
オブジェクトにアクセスします。別のスレッドコンテキストを持つということは、
複数のスレッドが互いに影響を及ぼさずに (`getcontext.prec=10' のような)
変更を適用できるということです。

同様に、`setcontext()' 関数は自動的に引数のコンテキスト
を現在のスレッドのコンテキストに設定します。

`getcontext()' を呼び出す前に`setcontext()' が
呼び出されていなければ、現在のスレッドで使うための新たなコンテキスト
を生成するために`getcontext()' が自動的に呼び出されます。

新たなコンテキストは、DEFAULTCONTEXT と呼ばれる雛形から
コピーされます。アプリケーションを通じて全てのスレッドに同じ
値を使うようにデフォルトを設定したければ、DEFAULTCONTEXT
オブジェクトを直接変更します。`getcontext()' を呼び出す
スレッド間で競合条件が生じないようにするため、DEFAULTCONTEXT
への変更はいかなるスレッドを開始するよりも_前に_ 行わねば
なりません。以下に例を示します:

     # スレッドを立ち上げる前にアプリケーションにわたるデフォルトを設定
     DefaultContext.prec = 12
     DefaultContext.rounding = ROUND_DOWN
     DefaultContext.traps = ExtendedContext.traps.copy()
     DefaultContext.traps[InvalidOperation] = 1
     setcontext(DefaultContext)

     # その後でスレッドを開始
     t1.start()
     t2.start()
     t3.start()
      . . .


File: python-lib-jp.info,  Node: レシピ 2,  Next: Decimal FAQ,  Prev: スレッドを使った処理,  Up: decimal

6.3.7 レシピ
------------

`Decimal' クラスの利用を実演している例をいくつか示します。
これらはユーティリティ関数としても利用できます:

     def moneyfmt(value, places=2, curr='', sep=',', dp='.',
                  pos='', neg='-', trailneg=''):
         """Decimal を通貨表現の文字列に変換します。

         places:  小数点以下の値を表すのに必要な桁数
         curr:    符号の前に置く通貨記号 (オプションで、空でもかまいません)
         sep:     桁のグループ化に使う記号、オプションです (コンマ、ピリオド、
                  スペース、または空)
         dp:      小数点 (コンマまたはピリオド)
                  小数部がゼロの場合には空にできます。
         pos:     正数の符号オプション: '+', 空白または空文字列
         neg:     負数の符号オプション: '-', '(', 空白または空文字列
         trailneg:後置マイナス符号オプション:  '-', ')', 空白または空文字列

         >>> d = Decimal('-1234567.8901')
         >>> moneyfmt(d, curr='$')
         '-$1,234,567.89'
         >>> moneyfmt(d, places=0, sep='.', dp='', neg='', trailneg='-')
         '1.234.568-'
         >>> moneyfmt(d, curr='$', neg='(', trailneg=')')
         '($1,234,567.89)'
         >>> moneyfmt(Decimal(123456789), sep=' ')
         '123 456 789.00'
         >>> moneyfmt(Decimal('-0.02'), neg='<', trailneg='>')
         '<.02>'

         """
         q = Decimal((0, (1,), -places))    # 小数点以下2桁 --> '0.01'
         sign, digits, exp = value.quantize(q).as_tuple()
         assert exp == -places
         result = []
         digits = map(str, digits)
         build, next = result.append, digits.pop
         if sign:
             build(trailneg)
         for i in range(places):
             if digits:
                 build(next())
             else:
                 build('0')
         build(dp)
         i = 0
         while digits:
             build(next())
             i += 1
             if i == 3 and digits:
                 i = 0
                 build(sep)
         build(curr)
         if sign:
             build(neg)
         else:
             build(pos)
         result.reverse()
         return ''.join(result)

     def pi():
         """現在の精度まで円周率を計算します。

         >>> print pi()
         3.141592653589793238462643383

         """
         getcontext().prec += 2  # 中間ステップのための余分の数字
         three = Decimal(3)      # 普通の float に対する "three=3.0" の代わり
         lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24
         while s != lasts:
             lasts = s
             n, na = n+na, na+8
             d, da = d+da, da+32
             t = (t * n) / d
             s += t
         getcontext().prec -= 2
         return +s               # 単項のプラスで新しい精度に変換します

     def exp(x):
         """e の x 乗を返します。結果の型は入力の型と同じです。

         >>> print exp(Decimal(1))
         2.718281828459045235360287471
         >>> print exp(Decimal(2))
         7.389056098930650227230427461
         >>> print exp(2.0)
         7.38905609893
         >>> print exp(2+0j)
         (7.38905609893+0j)

         """
         getcontext().prec += 2
         i, lasts, s, fact, num = 0, 0, 1, 1, 1
         while s != lasts:
             lasts = s
             i += 1
             fact *= i
             num *= x
             s += num / fact
         getcontext().prec -= 2
         return +s

     def cos(x):
         """x ラジアンの余弦を返します。

         >>> print cos(Decimal('0.5'))
         0.8775825618903727161162815826
         >>> print cos(0.5)
         0.87758256189
         >>> print cos(0.5+0j)
         (0.87758256189+0j)

         """
         getcontext().prec += 2
         i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1
         while s != lasts:
             lasts = s
             i += 2
             fact *= i * (i-1)
             num *= x * x
             sign *= -1
             s += num / fact * sign
         getcontext().prec -= 2
         return +s

     def sin(x):
         """x ラジアンの正弦を返します。

         >>> print sin(Decimal('0.5'))
         0.4794255386042030002732879352
         >>> print sin(0.5)
         0.479425538604
         >>> print sin(0.5+0j)
         (0.479425538604+0j)

         """
         getcontext().prec += 2
         i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1
         while s != lasts:
             lasts = s
             i += 2
             fact *= i * (i-1)
             num *= x * x
             sign *= -1
             s += num / fact * sign
         getcontext().prec -= 2
         return +s


File: python-lib-jp.info,  Node: Decimal FAQ,  Prev: レシピ 2,  Up: decimal

6.3.8 Decimal FAQ
-----------------

Q.  `decimal.Decimal('1234.5')' などと打ち込むのは煩わしいのですが、
対話式インタプリタを使う際にタイプ量を少なくする方法はありませんか?

A.  コンストラクタを1文字に縮める人もいるようです。

     >>> D = decimal.Decimal
     >>> D('1.23') + D('3.45')
     Decimal("4.68")

Q.  小数点以下2桁の固定小数点数のアプリケーションの中で、いくつかの
入力が余計な桁を保持しているのでこれを丸めなければなりません。その他の
ものに余計な桁はなくそのまま使えます。どのメソッドを使うのがいいでしょうか?

A.  `quantize()' メソッドで固定した桁に丸められます。 `Inexact'
トラップを設定しておけば、確認にも有用です。

     >>> TWOPLACES = Decimal(10) ** -2       # Decimal('0.01') と同じ

     >>> # 小数点以下2桁に丸める
     >>> Decimal("3.214").quantize(TWOPLACES)
     Decimal("3.21")

     >>> # 小数点以下2桁を越える桁を保持していないことの確認
     >>> Decimal("3.21").quantize(TWOPLACES, context=Context(traps=[Inexact]))
     Decimal("3.21")

     >>> Decimal("3.214").quantize(TWOPLACES, context=Context(traps=[Inexact]))
     Traceback (most recent call last):
        ...
     Inexact: Changed in rounding

Q.
正当な2桁の入力が得られたとして、その正当性をアプリケーション実行中も
変わらず保ち続けるにはどうすればいいでしょうか?

A.
加減算のような演算は自動的に固定小数点を守ります。その他の乗除算などは
小数点以下の桁を変えてしまいますので実行後は  `quantize()' ステップ
が必要です。

Q.  一つの値に対して多くの表現方法があります。 `200' と`200.000' と
`2E2' と `.02E+4' は全て同じ値で違った精度の数です。これらをただ一つの
正規化された値に変換することはできますか?

A.  `normalize()' メソッドは全ての等しい値をただ一つの表現に直します。

     >>> values = map(Decimal, '200 200.000 2E2 .02E+4'.split())
     >>> [v.normalize() for v in values]
     [Decimal("2E+2"), Decimal("2E+2"), Decimal("2E+2"), Decimal("2E+2")]

Q.  ある種の10進数値はいつも指数表記で表示されます。
指数表記以外の表示にする方法はありますか?

A.  値によっては、指数表記だけが有効桁数を表せる表記法なのです。
たとえば、 `5.0E+3' を `5000' と表してしまうと、
値は変わりませんが元々の2桁という有効数字が反映されません。

Q.  普通の float を `Decimal' に変換できますか?

A.  はい。どんな2進浮動小数点数も Decimal として正確に表現できます。
正確な変換は直感的に考えたよりも多い桁になることもありますので、
`Inexact' をトラップしたとすればそれはもっと精度を上げる
必要性があることを示しています。

     def floatToDecimal(f):
         "浮動小数点数を情報の欠落無く Decimal に変換します"

         # float で表された数を仮数 (0.5 <= abs(m) < 1.0) と指数に(正確に)転
         # 換します。仮数を整数になるまで2倍し続けます。整数化した仮数と指数
         # を使って等価な Decimal を求めます。この手続きが正確に行なえなかっ
         # たら、精度を上げて再度同じことをします。

         mantissa, exponent = math.frexp(f)
         while mantissa != int(mantissa):
             mantissa *= 2.0
             exponent -= 1
         mantissa = int(mantissa)

         oldcontext = getcontext()
         setcontext(Context(traps=[Inexact]))
         try:
             while True:
                 try:
                    return mantissa * Decimal(2) ** exponent
                 except Inexact:
                     getcontext().prec += 1
         finally:
             setcontext(oldcontext)

Q.  上の `floatToDecimal()' はなぜモジュールに入っていないのですか?

A.
2進と10進の浮動小数点数を混ぜるようにアドバイスするべきかどうか疑問が
あります。また、これを使うときには2進浮動小数点数の表示の問題を避けるように
注意しなければなりません。

     >>> floatToDecimal(1.1)
     Decimal("1.100000000000000088817841970012523233890533447265625")

Q.  複雑な計算の中で、精度不足や丸めの異常で間違った結果になっていない
ことをどうやって保証すれば良いでしょうか?

A.  decimal モジュールでは検算は容易です。一番良い方法は、大きめの精度や
様々な丸めモードで再計算してみることです。大きく異なった結果が出てきたら、
精度不足や丸めの問題や悪条件の入力、または数値計算的に不安定なアルゴリズム
を示唆しています。

Q.  コンテキストの精度は計算結果には適用されていますが入力には適用されて
いないようです。様々に異なる精度の入力値を混ぜて計算する時に注意すべき
ことはありますか?

A.  はい。原則として入力値は正確であると見做しておりそれらの値を使った
計算も同様です。結果だけが丸められます。入力の強みは "what you type is
what you get" (打ち込んだ値が得られる値)という点にあります。
入力が丸められないということを忘れていると結果が奇妙に見えるというのは
弱点です。

     >>> getcontext().prec = 3
     >>> Decimal('3.104') + D('2.104')
     Decimal("5.21")
     >>> Decimal('3.104') + D('0.000') + D('2.104')
     Decimal("5.20")

解決策は精度を上げるかまたは単項のプラス演算子を使って入力の丸めを強制する
ことです。

     >>> getcontext().prec = 3
     >>> +Decimal('1.23456789')      # 単項のプラスで丸めを引き起こします
     Decimal("1.23")

もしくは、入力を `Context.create_decimal()' を使って生成時に丸め
てしまうこともできます。

     >>> Context(prec=5, rounding=ROUND_DOWN).create_decimal('1.2345678')
     Decimal("1.2345")


File: python-lib-jp.info,  Node: random,  Next: itertools,  Prev: decimal,  Up: 数値と数学モジュール

6.4 擬似乱数を生成する
======================

よく知られている様々な分布をもつ擬似乱数を生成する。

このモジュールでは様々な分布をもつ擬似乱数生成器を実装しています。
整数用では、ある値域内の数の選択を一様にします。
シーケンス用には、シーケンスからのランダムな要素の一様な選択、
リストの要素の順列をランダムに置き換える関数、
順列を入れ替えずにランダムに取り出す関数があります。

実数用としては、一様分布、正規分布 (ガウス分布)、
対数正規分布、負の指数分布、ガンマおよびベータ分布を計算する
関数があります。 角度分布の生成用には、von Mises 分布が利用可能です。

ほとんど全てのモジュール関数は基礎となる関数 `random()' に依存
します。この関数は半開区間 [0.0, 1.0) の値域を持つ一様な浮動小数点数を生
成します。Python は中心となる乱数生成器として Mersenne Twister を使いま
す。これは 53 ビットの浮動小数点を生成し、周期が  2**19937-1、本体は C
で実装されていて、高速でスレッドセーフです。Mersenne Twister は、現存す
る中で、最も大規模にテストされた乱数生成器のひとつです。しかし、完全に決
定論的であるため、この乱数生成器は全ての目的に合致しているわけではなく、
暗号化の目的には全く向いていません。

このモジュールで提供されている関数は、実際には `random.Random'
クラスの隠蔽されたインスタンスのメソッドにバインドされています。
内部状態を共有しない生成器を取得するため、自分で `Random'
のインスタンスを生成することができます。異なる `Random'
のインスタンスを各スレッド毎に生成し、`jumpahead()'
メソッドを使うことで各々のスレッドにおいて生成された乱数列が
できるだけ重複しないようにすれば、マルチスレッドプログラムを作成する上で
特に便利になります。

自分で考案した基本乱数生成器を使いたいなら、クラス `Random' を
サブクラス化することもできます: この場合、メソッド `random()'、
`send()'、`getstate()'、`setstate()'、および `jumpahead()'
をオーバライドしてください。 オプションとして、新しいジェネレータは
`getrandombits()' メソッドを提供できます -- これにより `randrange()'
メソッドが 任意の、大きな範囲を超える集合を作成できるようになります。
_Added in Python version 2.4_

サブクラス化の例として、`random' モジュールは `WichmannHill'
クラスを提供します。このクラスは Python だけで書かれた代替生成器を実装し
ています。このクラスは、乱数生成器に Wichmann-Hill 法を使っていた古いバ
ージョンの Python から得られた結果を再現するための、後方互換の手段になり
ます。ただし、この Wichmann-Hill 生成器はもはや推奨することができない
ということに注意してください。現在の水準では生成される周期が短すぎ、また
厳密な乱数性試験に合格しないことが知られています。こうした欠点を修正した
最近の改良についてはページの最後に挙げた参考文献を参照してください。
_Changed in Python version 2.3_

保守関数:

`seed([x])'
     基本乱数生成器を初期化します。 オプション引数 X
     はハッシュ可能な任意のオブジェクトを とり得ます。X が省略されるか
     `None' の場合、現在のシステム 時間が使われます;
     現在のシステム時間はモジュールが最初にインポート
     された時に乱数生成器を初期化するためにも使われます。

     乱数の発生源をオペレーティングシステムが提供している場合、システム時刻の
     代わりにその発生源が使われます（詳細については `os.urandom()'
     関数を参照）。_Changed in Python version 2.4_

     X が `None' でも、整数でも長整数でもない場合、 `hash(X)'
     が代わりに使われます。 X が整数または長整数の場合、X
     が直接使われます。

`getstate()'
     乱数生成器の現在の内部状態を記憶したオブジェクトを返します。
     このオブジェクトを `setstate()' に渡して内部状態を
     復帰することができます。 _Added in Python version 2.1_

`setstate(state)'
     STATE は予め `getstate()' を呼び出して得ておかなくては
     なりません。`setstate()' は `setstate()' が呼び出
     された時の乱数生成器の内部状態を復帰します。 _Added in Python
     version 2.1_

`jumpahead(n)'
     内部状態を、現在の状態から、非常に離れているであろう状態に変更します。
     N は非負の整数です。 これはマルチスレッドのプログラムが複数の
     `Random' クラス のインスタンスと結合されている場合に非常に便利です:
     `setstate()' や `seed()'
     は全てのインスタンスを同じ内部状態にするのに
     使うことができ、その後 `jumpahead()' を使って各インスタンスの
     内部状態を引き離すことができます。 _Added in Python version 2.1_
     _Changed in Python version 2.3_

`getrandbits(k)'
     乱数ビットK とともにPyhonの`long' intを返します。
     このメソッドはMersenneTwister生成器で提供されており、その他の
     乱数生成器でもオプションのAPIとして提供されているかもしれません。
     このメソッドが使えるとき、`randrange()'メソッドは大きな
     範囲を扱えるようになります。 _Added in Python version 2.4_

整数用の関数:

`randrange([start,] stop[, step])'
     `range(START、STOP、STEP)' の要素から
     ランダムに選ばれた要素を返します。この関数は `choice(range(START,
     STOP, STEP))' と等価ですが、実際には range
     オブジェクトを生成しません。 _Added in Python version 1.5.2_

`randint(a, b)'
     `A <= N <= B' であるような ランダムな整数 N を返します。

シーケンス用の関数:

`choice(seq)'
     空でないシーケンス SEQ からランダムに要素を返します。 SEQ
     が空のときは、 `IndexError' が送出されます。

`shuffle(x[, random])'
     シーケンス X を直接変更によって混ぜます。 オプションの引数 RANDOM
     は、値域が [0.0, 1.0) のランダムな
     浮動小数点数を返すような引数を持たない関数です; 標準では、
     この関数は `random()' です。

     かなり小さい `len(X)' であっても、X の順列は
     ほとんどの乱数生成器の周期よりも大きくなるので注意してください;
     このことは長いシーケンスに対してはほとんどの順列は生成されないことを
     意味します。

`sample(population, k)'
     母集団のシーケンスから選ばれた長さ K の一意な要素からなるリスト
     を返します。値の置換を行わないランダムサンプリングに用いられます。
     _Added in Python version 2.3_

     母集団自体を変更せずに、母集団内の要素を含む新たなリストを返します。返さ
     れたリストは選択された順に並んでいるので、このリストの部分スライスもラン
     ダムなサンプルになります。これにより、くじの当選者を1等賞と2等賞（の部分
     スライス）に分けるといったことも可能です。母集団の要素はハッシュ可能でな
     くても、ユニークでなくても、かまいません。母集団が繰り返しを含む場合、返
     されたリストの各要素はサンプルから選択可能な要素になります。整数の並びか
     らサンプルを選ぶには、引数に `xrange()'
     オブジェクトを使いましょう。
     特に、巨大な母集団からサンプルを取るとき、速度と空間効率が上がります。
     `sample(xrange(10000000), 60)'

以下の関数は特殊な実数値分布を生成します。関数パラメタは
対応する分布の公式において、数学的な慣行に従って使われている
変数から取られた名前がつけられています; これらの公式のほとんどは
多くの統計学のテキストに載っています。

`random()'
     値域 [0.0, 1.0) の次のランダムな浮動小数点数を返します。

`uniform(a, b)'
     `A <= N <= B' であるような ランダムな実数 N を返します。

`betavariate(alpha, beta)'
     ベータ分布です。引数の満たすべき条件は `ALPHA > -1' および `BETA >
     -1' です。 0 から 1 の値を返します。

`expovariate(lambd)'
     指数分布です。LAMBD は平均にしたい値で 1.0 を割ったものです。
     (このパラメタは "lambda" と呼ぶべきなのですが、Python の予約語
     なので使えません。) 返される値の範囲は 0 から正の無限大です。

`gammavariate(alpha, beta)'
     ガンマ分布です。 (ガンマ関数 _ではありません_ ！)
     引数の満たすべき条件は  `ALPHA > 0' および `BETA > 0' です。

`gauss(mu, sigma)'
     ガウス分布です。MU は平均であり、 SIGMA は
     標準偏差です。この関数は後で定義する関数 `normalvariate()'
     より少しだけ高速です。

`lognormvariate(mu, sigma)'
     対数正規分布です。この分布を自然対数を用いた分布にした場合、 平均
     MU で標準偏差 SIGMA の正規分布になるでしょう。 MU
     は任意の値を取ることができ、 SIGMA はゼロより
     大きくなければなりません。

`normalvariate(mu, sigma)'
     正規分布です、MU は平均で、SIGMA は標準偏差です。

`vonmisesvariate(mu, kappa)'
     MU は平均の角度で、0 から 2*_pi_ までのラジアンで
     表されます。KAPPA は濃度パラメタで、ゼロまたはそれ以上
     でなければなりません。KAPPA がゼロに等しい場合、 この分布は範囲 0
     から 2*_pi_ の一様でランダムな角度の 分布に退化します。

`paretovariate(alpha)'
     パレート分布です。ALPHA は形状パラメタです。

`weibullvariate(alpha, beta)'
     ワイブル分布です。ALPHA はスケールパラメタで、 BETA
     は形状パラメタです。

代替の乱数生成器:

`WichmannHill([seed])'
     乱数生成器として Wichmann-Hill アルゴリズムを実装するクラスです。
     `Random' クラスと同じメソッド全てと、下で説明する `whseed()'
     メソッドを持ちます。このクラスは、Python
     だけで実装されているので、スレ
     ッドセーフではなく、呼び出しと呼び出しの間にロックが必要です。また、周期
     が 6,953,607,871,644
     と短く、独立した2つの乱数列が重複しないように注意が 必要です。

`whseed([x])'
     これは obsolete で、バージョン 2.1 以前の Python
     と、ビット・レベルの互 換性のために提供されてます。詳細は `seed()'
     を参照してください。 `whseed()'
     は、引数に与えた整数が異なっても、内部状態が異なること
     を保障しません。取り得る内部状態の個数が 2**24
     以下になる場合もあります。

`SystemRandom([seed])'
     オペレーティングシステムの提供する発生源によって乱数を生成する
     `os.urandom()'関数を使うクラスです。
     すべてのシステムで使えるメソッドではありません。
     ソフトウェアの状態に依存してはいけませんし、一連の操作は再現
     不能です。それに応じて、`seed()' と `jumpahead()'
     メソッドは何の影響も及ぼさず、無視されます。 `getstate()' と
     `setstate()' メソッドが呼び出されると、例外
     `NotImplementedError'が送出されます。 _Added in Python version 2.4_

基本使用例:

     >>> random.random()        # Random float x, 0.0 <= x < 1.0
     0.37444887175646646
     >>> random.uniform(1, 10)  # Random float x, 1.0 <= x < 10.0
     1.1800146073117523
     >>> random.randint(1, 10)  # Integer from 1 to 10, endpoints included
     7
     >>> random.randrange(0, 101, 2)  # Even integer from 0 to 100
     26
     >>> random.choice('abcdefghij')  # Choose a random element
     'c'

     >>> items = [1, 2, 3, 4, 5, 6, 7]
     >>> random.shuffle(items)
     >>> items
     [7, 3, 2, 5, 6, 4, 1]

     >>> random.sample([1, 2, 3, 4, 5],  3)  # Choose 3 elements
     [4, 1, 5]

See also:
     M. Matsumoto and T. Nishimura, "Mersenne Twister: A
     623-dimensionally equidistributed uniform pseudorandom number
     generator",  Vol. 8, No. 1, January pp.3-30 1998.

     Wichmann, B. A. & Hill, I. D., "Algorithm AS 183: An efficient and
     portable pseudo-random number generator",  31 (1982) 188-190.

    `http://www.npl.co.uk/ssfm/download/abstracts.html#196'
          A modern variation of the Wichmann-Hill generator that
          greatly increases the period, and passes now-standard
          statistical tests that the original generator failed.



File: python-lib-jp.info,  Node: itertools,  Next: functools,  Prev: random,  Up: 数値と数学モジュール

6.5 効率的なループ実行のためのイテレータ生成関数
================================================

効率的なループ実行のためのイテレータ生成関数。

_Added in Python version 2.3_

このモジュールではイテレータを構築する部品を実装しています。プログラム言
語HaskellとSMLからアイデアを得ていますが、Pythonに適した形に修正されてい
ます。

このモジュールは、高速でメモリ効率に優れ、単独でも組み合わせても使用する
ことのできるツールを標準化したものです。標準化により、多数の個人が、それ
ぞれの好みと命名規約で、それぞれ少しだけ異なる実装を行う為に発生する可読
性と信頼性の問題を軽減する事ができます。

ここで定義したツールは簡単に組み合わせて使用することができるようになって
おり、アプリケーション固有のツールを簡潔かつ効率的に作成する事ができます。

例えば、SMLの作表ツール`tabulate(f)'は`f(0), f(1), ...'のシー
ケンスを作成します。このツールボックスでは`imap()'と
`count()'を用意しており、この二つを組み合わせて `imap(f,
count())'とすれば同じ結果を得る事ができます。

同様に、`operator'モジュールの高速な関数とも一緒に使用すること
ができるようになっています。

他にこのモジュールに追加したい基本的な構築部品があれば、開発者に提案して
ください。

イテレータを使用すると、Python で書いてもコンパイル言語で書いても
リストを使用した同じ処理よりメモリ効率がよく、高速になります。
これはデータをメモリ上に "在庫"しておくのではなく、
必要に応じて作成する注文生産方式を採用しているためです。

イテレータによるパフォーマンス上のメリットは、要素の数が増えるにつれてよ
り明確になります。一定以上の要素を持つリストでは、メモリキャッシュのパフ
ォーマンスに対する影響が大きく、実行速度が低下します。

See also:
     The Standard ML Basis Library, .

     Haskell, A Purely Functional Language, .

* Menu:

* Itertool関数::
* 例 3::
* レシピ 3::


File: python-lib-jp.info,  Node: Itertool関数,  Next: 例 3,  Prev: itertools,  Up: itertools

6.5.1 Itertool関数
------------------

以下の関数は全て、イテレータを作成して返します。無限長のストリームのイテ
レータを返す関数もあり、この場合にはストリームを中断するような関数かルー
プ処理から使用しなければなりません。

`chain(*iterables)'
     先頭のiterableの全要素を返し、次に2番目のiterableの全要素…と全
     iterableの要素を返すイテレータを作成します。連続したシーケンスを、一つ
     のシーケンスとして扱う場合に使用します。この関数は以下のスクリプトと同
     等です：

               def chain(*iterables):
                   for it in iterables:
                       for element in it:
                           yield element


`count([n])'
     Nで始まる、連続した整数を返すイテレータを作成します。N を
     指定しなかった場合、デフォルト値はゼロです。現在、
     Pythonの長整数はサポートしていません。`imap()'で連続したデー
     タを生成する場合や`izip()'でシーケンスに番号を追加する場合な
     どに引数として使用することができます。この関数は以下のスクリプトと同等
     です：

               def count(n=0):
                   while True:
                       yield n
                       n += 1

     `count()'はオーバーフローのチェックを行いません。このため、
     `sys.maxint'を超えると負の値を返します。この動作は将来変更されま
     す。

`cycle(iterable)'
     iterableから要素を取得し、同時にそのコピーを保存するイテレータを作成し
     ます。iterableの全要素を返すと、セーブされたコピーから要素を返し、これ
     を無限に繰り返します。この関数は以下のスクリプトと同等です：

               def cycle(iterable):
                   saved = []
                   for element in iterable:
                       yield element
                       saved.append(element)
                   while saved:
                       for element in saved:
                             yield element

     `cycle'は大きなメモリ領域を使用し
     ます。使用するメモリ量はiterableの大きさに依存します。

`dropwhile(predicate, iterable)'
     predicateが真である限りは要素を無視し、その後は全ての要素を返すイテ
     レータを作成します。このイテレータは、predicateが真の間は_全く_要
     素を返さないため、最初の要素を返すまでに長い時間がかかる場合がありま
     す。この関数は以下のスクリプトと同等です：

               def dropwhile(predicate, iterable):
                   iterable = iter(iterable)
                   for x in iterable:
                       if not predicate(x):
                           yield x
                           break
                   for x in iterable:
                       yield x


`groupby(iterable[, key])'
     同じキーをもつような要素からなるITERABLE 中のグループに対して、
     キーとグループを返すようなイテレータを作成します。 KEY
     は各要素に対するキー値を計算する関数です。キーを指定しない 場合や
     `None' にした場合、KEY 関数のデフォルトは恒等関数になり
     要素をそのまま返します。通常、ITERABLE は
     同じキー関数で並べ替え済みである必要があります。

     返されるグループはそれ自体がイテレータで、`groupby()' と ITERABLE
     を共有しています。もととなるITERABLE を
     共有しているため、`groupby' オブジェクトの要素取り出しを
     先に進めると、それ以前の要素であるグループは見えなくなってしまいます。
     従って、データが後で必要な場合にはリストの形で保存しておく必要があります:

              groups = []
              uniquekeys = []
              for k, g in groupby(data, keyfunc):
                  groups.append(list(g))      # Store group iterator as a list
                  uniquekeys.append(k)

     `groupby()' は以下のコードと等価です:

              class groupby(object):
                  def __init__(self, iterable, key=None):
                      if key is None:
                          key = lambda x: x
                      self.keyfunc = key
                      self.it = iter(iterable)
                      self.tgtkey = self.currkey = self.currvalue = xrange(0)
                  def __iter__(self):
                      return self
                  def next(self):
                      while self.currkey == self.tgtkey:
                          self.currvalue = self.it.next() # Exit on StopIteration
                          self.currkey = self.keyfunc(self.currvalue)
                      self.tgtkey = self.currkey
                      return (self.currkey, self._grouper(self.tgtkey))
                  def _grouper(self, tgtkey):
                      while self.currkey == tgtkey:
                          yield self.currvalue
                          self.currvalue = self.it.next() # Exit on StopIteration
                          self.currkey = self.keyfunc(self.currvalue)

     _Added in Python version 2.4_

`ifilter(predicate, iterable)'
     predicateが`True'となる要素だけを返すイテレータを作成します。
     PREDICATEが`None'の場合、値が真であるアイテムだけを返しま
     す。この関数は以下のスクリプトと同等です：

               def ifilter(predicate, iterable):
                   if predicate is None:
                       predicate = bool
                   for x in iterable:
                       if predicate(x):
                           yield x


`ifilterfalse(predicate, iterable)'
     predicateが`False'となる要素だけを返すイテレータを作成します。
     PREDICATEが`None'の場合、値が偽であるアイテムだけを返しま
     す。この関数は以下のスクリプトと同等です：

               def ifilterfalse(predicate, iterable):
                   if predicate is None:
                       predicate = bool
                   for x in iterable:
                       if not predicate(x):
                           yield x


`imap(function, *iterables)'
     iterablesの要素を引数としてfuntionを呼び出すイテレータを作成します。
     FUNCTIONが`None'の場合、引数のタプルを返します。
     `map()'と似ていますが、最短のiterableの末尾まで到達した後は
     `None'を補って処理を続行するのではなく、終了します。これは、
     `map()'に無限長のイテレータを指定するのは多くの場合誤りですが
     (全出力が評価されてしまうため)、`imap()'の場合には一般的で役
     に立つ方法であるためです。この関数は以下のスクリプトと同等です：

               def imap(function, *iterables):
                   iterables = map(iter, iterables)
                   while True:
                       args = [i.next() for i in iterables]
                       if function is None:
                           yield tuple(args)
                       else:
                           yield function(*args)


`islice(iterable, [start,] stop [, step])'
     iterableから要素を選択して返すイテレータを作成します。STARTが0以
     外であれば、iterableの先頭要素はstartに達するまでスキップします。以
     降、STEPが1以下なら連続した要素を返し、1以上なら指定された値分の
     要素をスキップします。STOPが`None'であれば、無限に、もしく
     はiterableの全要素を返すまで値を返します。`None'以外ならイテレー
     タは指定された要素位置で停止します。通常のスライスと異なり、
     START、STOP、STEPに負の値を指定する事はできません。
     シーケンス化されたデータから関連するデータを取得する場合（複数行からなるレ
     ポートで、三行ごとに名前が指定されている場合など）に使用します。この関
     数は以下のスクリプトと同等です：
               def islice(iterable, *args):
                   s = slice(*args)
                   it = iter(xrange(s.start or 0, s.stop or sys.maxint, s.step or 1))
                   nexti = it.next()
                   for i, element in enumerate(iterable):
                       if i == nexti:
                           yield element
                           nexti = it.next()

     STARTが`None'ならば、繰返しは0から始まります。
     STEPが`None'ならば、ステップは1となります。 _Changed in Python
     version 2.5_

`izip(*iterables)'
     各iterableの要素をまとめるイテレータを作成します。`zip()'に似
     ていますが、リストではなくイテレータを返します。複数のイテレート可能オ
     ブジェクトに対して、同じ繰り返し処理を同時に行う場合に使用します。この
     関数は以下のスクリプトと同等です：

               def izip(*iterables):
                   iterables = map(iter, iterables)
                   while iterables:
                       result = [it.next() for it in iterables]
                       yield tuple(result)

     _Changed in Python version 2.4_

     イテレート可能オブジェクトの左から右への評価順序は保証されることに注意
     して下さい。このことによって、データ列を長さnのグループにまとめる常套
     句 `izip(*[iter(s)]*n)' が実現可能になります。長さnのグループにま
     とめるのに中途半端なデータ列に対しては `izip(*[chain(s,
     [None]*(n-1))]*n)'
     のように、最後のタプルを埋める値をあらかじめ準備し
     ておくことができます。

     もう一つの注意は `izip()' が長さが不揃いの入力に対して呼ばれた
     時、`izip()' 終了の後引き続いて長い方のイテレート可能オブジェ
     クトを呼び出した結果は保証の限りではないということです。可能性として、
     残ったそれぞれのイテレート可能オブジェクトから値が一つ失われているかも
     しれないし失われていないかもしれません。これは次のようにして起こります。
     実行中にそれぞれのイテレート可能オブジェクトから一つずつ値を取り出しま
     すが、その処理がいずれかのイテレート可能オブジェクトが空になることによ
     り終了します。この時途中まで取り出された値たちは宙に浮きます(不完全なタ
     プルとして送り出されることもなく、また次の `it.next()' のためにイ
     テレート可能オブジェクトに押し戻すこともできません)。一般に、
     `izip()' を長さが不揃いな入力に使うのは、残され使われなかった
     長い方のイテレート可能オブジェクトの値を気にしない時だけにするべきです。

`repeat(object[, times])'
     繰り返しOBJECTを返すイテレータを作成します。TIMESを指定し
     ない場合、無限に値を返し続けます。`imap()'で常に同じオブジェク
     トを関数の引数として指定する場合に使用します。また、`izip()'
     で作成するタプルの全要素に常に同じオブジェクトを指定する場合にも使用す
     ることもできます。この関数は以下のスクリプトと同等です：

               def repeat(object, times=None):
                   if times is None:
                       while True:
                           yield object
                   else:
                       for i in xrange(times):
                           yield object


`starmap(function, iterable)'
     iterablesの要素を引数としてfuntionを呼び出すイテレータを作成します。
     functionの引数が単一のiterableにタプルとして格納されている場合("zip済
     み")、`imap()'の代わりに使用します。`imap()'と
     `starmap()'ではfunctionの呼び出し方法が異なり、
     `imap()'は`function(a,b)'、`starmap()'では
     `function(*c)'のように呼び出します。この関数は以下のスクリプトと
     同等です：

               def starmap(function, iterable):
                   iterable = iter(iterable)
                   while True:
                       yield function(*iterable.next())


`takewhile(predicate, iterable)'
     predicateが真である限りiterableから要素を返すイテレータを作成します。
     この関数は以下のスクリプトと同等です：

               def takewhile(predicate, iterable):
                   for x in iterable:
                       x = iterable.next()
                       if predicate(x):
                           yield x
                       else:
                           break


`tee(iterable[, n=2])'
     一つのITERABLE からN 個の独立したイテレータを生成して
     返します。`n==2' の場合は、以下のコードと等価になります:

               def tee(iterable):
                   def gen(next, data={}, cnt=[0]):
                       for i in count():
                           if i == cnt[0]:
                               item = data[i] = next()
                               cnt[0] += 1
                           else:
                               item = data.pop(i)
                           yield item
                   it = iter(iterable)
                   return (gen(it.next), gen(it.next))

     一度`tee()' でイテレータを分割すると、もとの ITERABLE
     を他で使ってはならなくなるので注意してください; さもなければ、
     `tee' オブジェクトの知らない間にITERABLE が先の要素に
     進んでしまうことになります。

     `tee'はかなり大きなメモリ領域を使用します
     (使用するメモリ量はiterableの大きさに依存します)。
     一般には、一つのイテレータが他のイテレータよりも先に
     ほとんどまたは全ての要素を消費するような場合には、`tee()'
     よりも`list()' を使った方が高速です。 _Added in Python version 2.4_


File: python-lib-jp.info,  Node: 例 3,  Next: レシピ 3,  Prev: Itertool関数,  Up: itertools

6.5.2 例
--------

以下に各ツールの一般的な使い方と、ツールの組み合わせの例を示します。


     >>> amounts = [120.15, 764.05, 823.14]
     >>> for checknum, amount in izip(count(1200), amounts):
     ...     print 'Check %d is for $%.2f' % (checknum, amount)
     ...
     Check 1200 is for $120.15
     Check 1201 is for $764.05
     Check 1202 is for $823.14

     >>> import operator
     >>> for cube in imap(operator.pow, xrange(1,5), repeat(3)):
     ...    print cube
     ...
     1
     8
     27
     64

     >>> reportlines = ['EuroPython', 'Roster', '', 'alex', '', 'laura',
                       '', 'martin', '', 'walter', '', 'mark']
     >>> for name in islice(reportlines, 3, None, 2):
     ...    print name.title()
     ...
     Alex
     Laura
     Martin
     Walter
     Mark

     # Show a dictionary sorted and grouped by value
     >>> from operator import itemgetter
     >>> d = dict(a=1, b=2, c=1, d=2, e=1, f=2, g=3)
     >>> di = sorted(d.iteritems(), key=itemgetter(1))
     >>> for k, g in groupby(di, key=itemgetter(1)):
     ...     print k, map(itemgetter(0), g)
     ...
     1 ['a', 'c', 'e']
     2 ['b', 'd', 'f']
     3 ['g']

     # Find runs of consecutive numbers using groupby.  The key to the solution
     # is differencing with a range so that consecutive numbers all appear in
     # same group.
     >>> data = [ 1,  4,5,6, 10, 15,16,17,18, 22, 25,26,27,28]
     >>> for k, g in groupby(enumerate(data), lambda (i,x):i-x):
     ...     print map(operator.itemgetter(1), g)
     ...
     [1]
     [4, 5, 6]
     [10]
     [15, 16, 17, 18]
     [22]
     [25, 26, 27, 28]


File: python-lib-jp.info,  Node: レシピ 3,  Prev: 例 3,  Up: itertools

6.5.3 レシピ
------------

この節では、既存の itertools をビルディングブロックとしてツールセットを
拡張するためのレシピを示します。

iterable 全体を一度にメモリ上に置くよりも、要素を一つづつ処理する方が
メモリ効率上の有利さを保てます。関数形式のままツールをリンクしてゆくと、
コードのサイズを減らし、一時変数を減らす助けになります。
インタプリタのオーバヘッドをもたらす for
ループやジェネレータを使わずに、 "ベクトル化された"
ビルディングブロックを使うと、高速な処理を実現 できます。

     def take(n, seq):
         return list(islice(seq, n))

     def enumerate(iterable):
         return izip(count(), iterable)

     def tabulate(function):
         "Return function(0), function(1), ..."
         return imap(function, count())

     def iteritems(mapping):
         return izip(mapping.iterkeys(), mapping.itervalues())

     def nth(iterable, n):
         "Returns the nth item"
         return list(islice(iterable, n, n+1))

     def all(seq, pred=None):
         "Returns True if pred(x) is true for every element in the iterable"
         for elem in ifilterfalse(pred, seq):
             return False
         return True

     def any(seq, pred=None):
         "Returns True if pred(x) is true for at least one element in the iterable"
         for elem in ifilter(pred, seq):
             return True
         return False

     def no(seq, pred=None):
         "Returns True if pred(x) is false for every element in the iterable"
         return True not in imap(pred, seq)

     def quantify(seq, pred=None):
         "Count how many times the predicate is true in the sequence"
         return sum(imap(pred, seq))

     def padnone(seq):
         """Returns the sequence elements and then returns None indefinitely.

         Useful for emulating the behavior of the built-in map() function.
         """
         return chain(seq, repeat(None))

     def ncycles(seq, n):
         "Returns the sequence elements n times"
         return chain(*repeat(seq, n))

     def dotproduct(vec1, vec2):
         return sum(imap(operator.mul, vec1, vec2))

     def flatten(listOfLists):
         return list(chain(*listOfLists))

     def repeatfunc(func, times=None, *args):
         """Repeat calls to func with specified arguments.

         Example:  repeatfunc(random.random)
         """
         if times is None:
             return starmap(func, repeat(args))
         else:
             return starmap(func, repeat(args, times))

     def pairwise(iterable):
         "s -> (s0,s1), (s1,s2), (s2, s3), ..."
         a, b = tee(iterable)
         try:
             b.next()
         except StopIteration:
             pass
         return izip(a, b)

     def grouper(n, iterable, padvalue=None):
         "grouper(3, 'abcdefg', 'x') --> ('a','b','c'), ('d','e','f'), ('g','x','x')"
         return izip(*[chain(iterable, repeat(padvalue, n-1))]*n)


File: python-lib-jp.info,  Node: functools,  Next: operator,  Prev: itertools,  Up: 数値と数学モジュール

6.6 高階関数と呼び出し可能オブジェクトの操作
============================================

高階関数と呼び出し可能オブジェクトの操作

_Added in Python version 2.5_

モジュール `functools' は高階関数、
つまり関数に対する関数、あるいは他の関数を返す関数、のためのものです。
一般に、どんな呼び出し可能オブジェクトでもこのモジュールの目的には関数として扱えます。

モジュール `functools' では以下の関数を定義します。

`partial(func[,*args][, **keywords])'
     新しい `partial' オブジェクトを返します。
     このオブジェクトは呼び出されると位置引数 ARGS とキーワード引数
     KEYWORDS 付きで呼び出された FUNC のように振る舞います。
     呼び出しに際してさらなる引数が渡された場合、それらは ARGS
     に付け加えられます。
     追加のキーワード引数が渡された場合には、それらで KEYWORDS
     を拡張または上書きします。 大雑把にいうと、次のコードと等価です。
                  def partial(func, *args, **keywords):
                      def newfunc(*fargs, **fkeywords):
                          newkeywords = keywords.copy()
                          newkeywords.update(fkeywords)
                          return func(*(args + fargs), **newkeywords)
                      newfunc.func = func
                      newfunc.args = args
                      newfunc.keywords = keywords
                      return newfunc

     関数 `partial' は、
     関数の引数と/かキーワードの一部を「凍結」した部分適用として使われ、
     簡素化された引数形式をもった新たなオブジェクトを作り出します。
     例えば、`partial' を使って BASE 引数のデフォルトが 2 である `int'
     関数のように振る舞う呼び出し可能オブジェクトを作ることができます。
                  >>> basetwo = partial(int, base=2)
                  >>> basetwo.__doc__ = 'Convert base 2 string to an int.'
                  >>> basetwo('10010')
                  18


`update_wrapper(wrapper, wrapped[, assigned][, updated])'
     wrapper 関数を wrapped 関数に見えるようにアップデートします。
     オプション引数はタプルで、 元の関数のどの属性が wrapper
     関数の一致する属性に直接書き込まれる(assigned)か、 また wrapper
     関数のどの属性が元の関数の対応する属性でアップデートされる(updated)か、
     を指定します。 これらの引数のデフォルト値はモジュール定数
     WRAPPER_ASSIGNMENTS (wrapper
     関数に名前、モジュールそしてドキュメンテーション文字列を書き込みます)
     と WRAPPER_UPDATES (wrapper
     関数のインスタンス辞書をアップデートします) です。

     この関数は主に関数を包んで wrapper
     を返すデコレータ関数の中で使われるよう意図されています。 もし
     wrapper 関数がアップデートされないとすると、
     返される関数のメタデータは元の関数の定義ではなく wrapper
     関数の定義を反映してしまい、 これは典型的に役立たずです。

`wraps(wrapped[, assigned][, updated])'
     これはラッパ関数を定義するときに `partial(update_wrapper,
     wrapped=wrapped, assigned=assigned, updated=updated)'
     を関数デコレータとして呼び出す便宜関数です。
                  >>> def my_decorator(f):
                  ...     @wraps(f)
                  ...     def wrapper(*args, **kwds):
                  ...         print 'Calling decorated function'
                  ...         return f(*args, **kwds)
                  ...     return wrapper
                  ...
                  >>> @my_decorator
                  ... def example():
                  ...     print 'Called example function'
                  ...
                  >>> example()
                  Calling decorated function
                  Called example function
                  >>> example.__name__
                  'example'

     このデコレータ・ファクトリーを使わなければ、
     上の例中の関数の名前は `'wrapper'' となっているところです。

* Menu:

* partial オブジェクト::


File: python-lib-jp.info,  Node: partial オブジェクト,  Prev: functools,  Up: functools

6.6.1 `partial' オブジェクト
----------------------------

`partial' オブジェクトは、 `partial()'
関数によって作られる呼び出し可能オブジェクトです。
オブジェクトには読み取り専用の属性が三つあります。

`func'
     {} 呼び出し可能オブジェクトまたは関数です。 `partial'
     の呼び出しは新しい引数とキーワードと共に `func' に転送されます。

`args'
     {} 最左の位置引数で、`partial'
     オブジェクトの呼び出し時にその呼び出しの際の位置引数の前に追加されます。

`keywords'
     {} `partial' オブジェクトの呼び出し時に渡されるキーワード引数です。

`partial' オブジェクトは `function' オブジェクトのように呼び出し可能で、
弱参照可能で、属性を持つことができます。 重要な相違点もあります。
例えば、`__name__' と `__doc__' 両属性は自動では作られません。
また、クラス中で定義された `partial'
オブジェクトはスタティックメソッドのように振る舞い、
インスタンスの属性問い合わせの中で束縛メソッドに変換されません。


File: python-lib-jp.info,  Node: operator,  Prev: functools,  Up: 数値と数学モジュール

6.7 関数形式の標準演算子
========================

組み込み関数形式になっている全ての Python の標準演算子。

`operator' モジュールは、Python 固有の各演算子に対応している C
言語で実装された関数セットを提供します。例えば、 `operator.add(x, y)'
は式 `x+y' と等価です。関数名は 特殊なクラスメソッドとして扱われます;
便宜上、先頭と末尾の `__' を取り除いたものも提供されています。

これらの関数はそれぞれ、オブジェクトの比較、論理演算、数学演算、
シーケンス操作、および抽象型テストに分類されます。

オブジェクト比較関数は全てのオブジェクトで有効で、関数の名前は
サポートする大小比較演算子からとられています:

`lt(a, b)'

`le a, b'

`eq a, b'

`ne a, b'

`ge a, b'

`gt a, b'

`__lt__ a, b'

`__le__ a, b'

`__eq__ a, b'

`__ne__ a, b'

`__ge__ a, b'

`__gt__ a, b'
     これらは  A および B の大小比較を行います。 特に、 `lt(A, B)' は
     `A < B'、 `le(A, B)' は `A <= B'、 `eq(A, B)' は `A == B'、 `ne(A,
     B)' は `A != B'、 `gt(A, B)' は `A > B'、 そして `ge(A, B)' は `A
     >= B' と等価です。

     組み込み関数 `cmp()' と違って、これらの関数はどのような
     値を返してもよく、ブール代数値として解釈できてもできなくても
     かまいません。大小比較の詳細については

     を参照してください。 _Added in Python version 2.2_

論理演算もまた全てのオブジェクトに対して適用することができ、
真値テスト、同一性テストおよびブール演算をサポートします:

`not_(o)'

`__not__ o'
     `not' O の結果を返します。(オブジェクトのインスタンス には
     `__not__()' メソッドは適用されないので注意してください;
     この操作を定義しているのはインタプリタコアだけです。結果は
     `__nonzero__()' および `__len__()' メソッドによって 影響されます。)

`truth(o)'
     O が真の場合 `True' を返し、そうでない場合 `False'
     を返します。この関数は`bool'のコンストラクタ呼び出しと同等です。

`is_(a, b)'
     `A is B' を返します。オブジェクトの同一性をテストします。

`is_not(a, b)'
     `A is not B' を返します。オブジェクトの同一性をテストします。

演算子で最も多いのは数学演算およびビット単位の演算です:

`abs(o)'

`__abs__ o'
     O の絶対値を返します。

`add(a, b)'

`__add__ a, b'
     数値 A および B について A `+' B を 返します。

`and_(a, b)'

`__and__ a, b'
     A と B の論理積を返します。

`div(a, b)'

`__div__ a, b'
     `__future__.division' が有効でない場合には A `/' B
     を返します。"古い(classic)" 除算としても知られています。

`floordiv(a, b)'

`__floordiv__ a, b'
     A `//' B を返します。 _Added in Python version 2.2_

`inv(o)'

`invert o'

`__inv__ o'

`__invert__ o'
     O のビット単位反転を返します。`~'O と 同じです。Python 2.0
     では名前 `invert()' および `__invert__()' が追加されました。

`lshift(a, b)'

`__lshift__ a, b'
     A の B ビット左シフトを返します。

`mod(a, b)'

`__mod__ a, b'
     A `%' B を返します。

`mul(a, b)'

`__mul__ a, b'
     数値 A および B について A `*' B を返します。

`neg(o)'

`__neg__ o'
     O の符号反転を返します。

`or_(a, b)'

`__or__ a, b'
     A と B の論理和を返します。

`pos(o)'

`__pos__ o'
     O の符号非反転を返します。

`pow(a, b)'

`__pow__ a, b'
     数値 A および B について A `**' B を返します。 _Added in Python
     version 2.3_

`rshift(a, b)'

`__rshift__ a, b'
     A の B ビット右シフトを返します。

`sub(a, b)'

`__sub__ a, b'
     A `-' B を返します。

`truediv(a, b)'

`__truediv__ a, b'
     `__future__.division' が有効な場合 A `/' B
     を返します。"真の"除算としても知られています。 _Added in Python
     version 2.2_

`xor(a, b)'

`__xor__ a, b'
     A および B の排他的論理和を返します。

`index(a)'

`__index__ a'
     整数に変換された A を返します。 A`.__index__()' と同等です。
     _Added in Python version 2.5_

シーケンスを扱う演算子には以下のようなものがあります:

`concat(a, b)'

`__concat__ a, b'
     シーケンス A および B について A `+' B を返します。

`contains(a, b)'

`__contains__ a, b'
     B `in' A を調べた結果を返します。
     演算対象が左右反転しているので注意してください。関数名
     `__contains__()' は Python 2.0 で追加されました。

`countOf(a, b)'
     A の中に B が出現する回数を返します。

`delitem(a, b)'

`__delitem__ a, b'
     A でインデクスが B の要素を削除します。

`delslice(a, b, c)'

`__delslice__ a, b, c'
     A でインデクスが B から C`-1' のスライス要素を 削除します。

`getitem(a, b)'

`__getitem__ a, b'
     A でインデクスが B の要素を返します。

`getslice(a, b, c)'

`__getslice__ a, b, c'
     A でインデクスが B から C`-1' のスライス要素を 返します。

`indexOf(a, b)'
     A で最初に B が出現する場所のインデクスを返します。

`repeat(a, b)'

`__repeat__ a, b'
     シーケンス A と整数 B について A `*' B を返します。

`sequenceIncludes(...)'
     _This is deprecated in Python 2.0.  `contains()'
     を使ってください。_

     `contains()' の別名です。

`setitem(a, b, c)'

`__setitem__ a, b, c'
     A でインデクスが B の要素の値を C に設定します。

`setslice(a, b, c, v)'

`__setslice__ a, b, c, v'
     A でインデクスが B から C`-1' のスライス要素の 値をシーケンス V
     に設定します。

多くの演算に「その場」バージョンがあります。
以下の関数はそうした演算子の通常の文法に比べてより素朴な呼び出し方を提供します。
たとえば、文 `x += y' は `x = operator.iadd(x, y)' と等価です。
別の言い方をすると、`z = operator.iadd(x, y)' は複合文 `z = x; z += y'
と等価です。

`iadd(a, b)'

`__iadd__ a, b'
     `a = iadd(a, b)' は `a += b' と等価です。 _Added in Python version
     2.5_

`iand(a, b)'

`__iand__ a, b'
     `a = iand(a, b)' は `a &= b' と等価です。 _Added in Python version
     2.5_

`iconcat(a, b)'

`__iconcat__ a, b'
     `a = iconcat(a, b)' は二つのシーケンス A と B に対し `a += b'
     と等価です。 _Added in Python version 2.5_

`idiv(a, b)'

`__idiv__ a, b'
     `a = idiv(a, b)' は `__future__.division' が有効でないときに `a /=
     b' と等価です。 _Added in Python version 2.5_

`ifloordiv(a, b)'

`__ifloordiv__ a, b'
     `a = ifloordiv(a, b)' は `a //= b' と等価です。 _Added in Python
     version 2.5_

`ilshift(a, b)'

`__ilshift__ a, b'
     `a = ilshift(a, b)' は `a <'`<= b' と等価です。 _Added in Python
     version 2.5_

`imod(a, b)'

`__imod__ a, b'
     `a = imod(a, b)' は `a %= b' と等価です。 _Added in Python version
     2.5_

`imul(a, b)'

`__imul__ a, b'
     `a = imul(a, b)' は `a *= b' と等価です。 _Added in Python version
     2.5_

`ior(a, b)'

`__ior__ a, b'
     `a = ior(a, b)' は `a |= b' と等価です。 _Added in Python version
     2.5_

`ipow(a, b)'

`__ipow__ a, b'
     `a = ipow(a, b)' は `a **= b' と等価です。 _Added in Python
     version 2.5_

`irepeat(a, b)'

`__irepeat__ a, b'
     `a = irepeat(a, b)' は A がシーケンスで B が整数であるとき `a *=
     b' と等価です。 _Added in Python version 2.5_

`irshift(a, b)'

`__irshift__ a, b'
     `a = irshift(a, b)' は `a >>= b' と等価です。 _Added in Python
     version 2.5_

`isub(a, b)'

`__isub__ a, b'
     `a = isub(a, b)' は `a -= b' と等価です。 _Added in Python version
     2.5_

`itruediv(a, b)'

`__itruediv__ a, b'
     `a = itruediv(a, b)' は `__future__.division' が有効なときに `a /=
     b' と等価です。 _Added in Python version 2.5_

`ixor(a, b)'

`__ixor__ a, b'
     `a = ixor(a, b)' は `a ^= b' と等価です。 _Added in Python version
     2.5_

`operator' モジュールでは、オブジェクトの型を調べるための
述語演算子も定義しています。_Note:_ これらの関数が返す結果について
誤って理解しないよう注意してください; インスタンスオブジェクトに
対して常に信頼できる値を返すのは `isCallable()'
だけです。例えば以下のようになります:

     >>> class C:
     ...     pass
     ...
     >>> import operator
     >>> o = C()
     >>> operator.isMappingType(o)
     True

`isCallable(o)'
     _This is deprecated in Python 2.0.  `callable()'
     を使ってください。_

     オブジェクト O を関数のように呼び出すことができる場合真を
     返し、それ以外の場合 false
     を返します。関数、バインドおよび非バインド
     メソッド、クラスオブジェクト、および `__call__()' メソッド
     をサポートするインスタンスオブジェクトは真を返します。

`isMappingType(o)'
     オブジェクト O
     がマップ型インタフェースをサポートする場合に真を返します。
     辞書および `__getitem__'
     メソッドが定義された全てのインスタンスオブジェクトに対しては、この値は真になります。
     _インタフェース自体が誤った定義になっているため、
     あるインスタンスが完全なマップ型プロトコルを備えているかを調べる信頼性のある方法は
     存在しません。このため、この関数によるテストはさほど便利ではありません。_

`isNumberType(o)'
     オブジェクト O が数値を表現している場合に真を返します。 C
     で実装された全ての数値型対して、この値は真になります。
     _インタフェース自体が誤った定義になっているため、
     あるインスタンスが完全な数値型のインタフェースをサポートしているかを調べる信頼性のある方法は存在
     しません。このため、この関数によるテストはさほど便利ではありません。_

`isSequenceType(o)'
     O がシーケンス型プロトコルをサポートする場合に真を返します。
     シーケンス型メソッドを C で定義している全てのオブジェクトおよび
     `__getitem__' メソッドが定義された全てのインスタンスオブジェクト
     に対して、この値は真になります。
     _インタフェース自体が誤った定義になっているため、
     あるインスタンスが完全なシーケンス型のインタフェースをサポートしているかを調べる信頼性のある方法は存在
     しません。このため、この関数によるテストはさほど便利ではありません。_

例: `0' から `255' までの序数を文字に対応付ける 辞書を構築します。

     >>> import operator
     >>> d = {}
     >>> keys = range(256)
     >>> vals = map(chr, keys)
     >>> map(operator.setitem, [d]*len(keys), keys, vals)

`operator' モジュールはアトリビュートとアイテムの汎用的な検索
のための道具も定義しています。 `map()', `sorted()',
`itertools.groupby()',
や関数を引数に取るその他の関数に対して高速にフィールドを抽出する際に
引数として使うと便利です。

`attrgetter(attr[, args...])'
     演算対象から ATTR を取得する呼び出し可能なオブジェクトを返します。
     二つ以上のアトリビュートを要求された場合には、アトリビュートのタプルを返します。
     `f=attrgetter('name')' とした後で、`f(b)' を呼び出すと `b.name'
     を返します。 `f=attrgetter('name', 'date')' とした後で、 `f(b)'
     を呼び出すと `(b.name, b.date)' を返します。 _Added in Python
     version 2.4_ _Changed in Python version 2.5_

`itemgetter(item[, args...])'
     演算対象から ITEM を取得する呼び出し可能なオブジェクトを返します。
     二つ以上のアイテムを要求された場合には、アイテムのタプルを返します。
     `f=itemgetter(2)' とした後で、 `f(b)' を呼び出すと `b[2]'
     を返します。 `f=itemgetter(2,5,3)' とした後で、 `f(b)' を呼び出すと
     `(b[2], b[5], b[3])' を返します。 _Added in Python version 2.4_
     _Changed in Python version 2.5_

例:

     >>> from operator import itemgetter
     >>> inventory = [('apple', 3), ('banana', 2), ('pear', 5), ('orange', 1)]
     >>> getcount = itemgetter(1)
     >>> map(getcount, inventory)
     [3, 2, 5, 1]
     >>> sorted(inventory, key=getcount)
     [('orange', 1), ('banana', 2), ('apple', 3), ('pear', 5)]

* Menu:

* 演算子から関数への対応表::


File: python-lib-jp.info,  Node: 演算子から関数への対応表,  Prev: operator,  Up: operator

6.7.1 演算子から関数への対応表
------------------------------

下のテーブルでは、個々の抽象的な操作が、どのように Python 構文上の
各演算子や `operator' モジュールの関数に対応しているか を示しています。

操作                     構文                     関数
------                   -----                    -----
加算                     `A + B'                  `add(A, B)'
結合                     `SEQ1 + SEQ2'            `concat(SEQ1, SEQ2)'
包含テスト               `O in SEQ'               `contains(SEQ, O)'
除算                     `A / B'                  `__future__.division'
                                                  が無効な場合の `div(A,
                                                  B) #'
除算                     `A / B'                  `__future__.division'
                                                  が有効な場合の
                                                  `truediv(A, B) #'
除算                     `A // B'                 `floordiv(A, B)'
論理積                   `A & B'                  `and_(A, B)'
排他的論理和             `A ^ B'                  `xor(A, B)'
ビット反転               `~{} A'                  `invert(A)'
論理和                   `A | B'                  `or_(A, B)'
べき乗                   `A ** B'                 `pow(A, B)'
インデクス指定の代入     `O[K] = V'               `setitem(O, K, V)'
インデクス指定の削除     `del O[K]'               `delitem(O, K)'
インデクス指定           `O[K]'                   `getitem(O, K)'
左シフト                 `A <`<' B'               `lshift(A, B)'
剰余                     `A % B'                  `mod(A, B)'
乗算                     `A * B'                  `mul(A, B)'
(算術)否                 `- A'                    `neg(A)'
(論理)否                 `not A'                  `not_(A)'
右シフト                 `A >> B'                 `rshift(A, B)'
シーケンスの反復         `SEQ * I'                `repeat(SEQ, I)'
スライス指定の代入       `SEQ[I:J]' = VALUES      `setslice(SEQ, I, J,
                                                  VALUES)'
スライス指定の削除       `del SEQ[I:J]'           `delslice(SEQ, I, J)'
スライス指定             `SEQ[I:J]'               `getslice(SEQ, I, J)'
文字列書式化             `S % O'                  `mod(S, O)'
減算                     `A - B'                  `sub(A, B)'
真値テスト               `O'                      `truth(O)'
順序付け                 `A < B'                  `lt(A, B)'
順序付け                 `A <= B'                 `le(A, B)'
等価性                   `A == B'                 `eq(A, B)'
不等性                   `A != B'                 `ne(A, B)'
順序付け                 `A >= B'                 `ge(A, B)'
順序付け                 `A > B'                  `gt(A, B)'


File: python-lib-jp.info,  Node: インターネット上のデータの操作,  Next: 構造化マークアップツール,  Prev: 数値と数学モジュール,  Up: Top

7 インターネット上のデータの操作
********************************

この章ではインターネット上で一般的に利用されているデータ形式の
操作をサポートするモジュール群について記述します．

* Menu:

* email::
* mailcap::
* mailbox::
* mhlib::
* mimetools::
* mimetypes::
* MimeWriter::
* mimify::
* multifile::
* rfc822::
* base64::
* binhex::
* binascii::
* quopri::
* uu::


File: python-lib-jp.info,  Node: email,  Next: mailcap,  Prev: インターネット上のデータの操作,  Up: インターネット上のデータの操作

7.1 電子メールと MIME 処理のためのパッケージ
============================================

電子メールのメッセージを解析、操作および生成を
支援するパッケージ。これには MIME 文書もふくまれる。

_Added in Python version 2.2_

`email' パッケージは電子メールのメッセージを管理するライブラリです。
これには MIME やそれ以外の RFC 2822 ベースのメッセージ文書もふくまれます。
このパッケージはいくつかの古い標準パッケージ、`rfc822'、
`mimetools'、`multifile' などにふくまれていた
機能のほとんどを持ち、くわえて標準ではなかった `mimecntl' などの
機能もふくんでいます。このパッケージは、とくに電子メールのメッセージを
SMTP (RFC 2821 )、 NNTP、
その他のサーバに送信するために作られているというわけでは
_ありません_。それは `smtplib'、`nntplib' モ ジュールなどの機能です。
`email' パッケージは RFC 2822 に加えて、RFC 2045 , RFC 2046 , RFC 2047 

および RFC 2231 など MIME 関連の RFC をサポートしており、できるかぎり
RFC に準拠することをめざしています。

`email' パッケージの一番の特徴は、電子メールの内部表現である
_オブジェクトモデル_ と、電子メールメッセージの解析および生成とを
分離していることです。`email' パッケージを使うアプリケーションは
基本的にはオブジェクトを処理することができます。メッセージに子オブジェクトを
追加したり、メッセージから子オブジェクトを削除したり、内容を完全に
並べかえたり、といったことができます。フラットなテキスト文書から
オブジェクトモデルへの変換、またそこからフラットな文書へと戻す変換は
それぞれ別々の解析器 (パーサ) と生成器 (ジェネレータ) が担当しています。
また、一般的な MIME オブジェクトタイプのいくつかについては手軽な
サブクラスが存在しており、メッセージフィールド値を抽出したり解析したり、
RFC 準拠の日付を生成したりなどのよくおこわれるタスクについては
いくつかの雑用ユーティリティもついています。

以下の節では `email' パッケージの機能を説明します。
説明の順序は多くのアプリケーションで一般的な使用順序にもとづいています。
まず、電子メールメッセージをファイルあるいはその他のソースから
フラットなテキスト文書として読み込み、つぎにそのテキストを解析して
電子メールのオブジェクト構造を作成し、その構造を操作して、
最後にオブジェクトツリーをフラットなテキストに戻す、という順序になっています。

このオブジェクト構造は、まったくのゼロから作りだしたものであっても
いっこうにかまいません。この場合も上と似たような作業順序になるでしょう。

またここには `email' パッケージが提供するすべての
クラスおよびモジュールに関する説明と、`email' パッケージを
使っていくうえで遭遇するかもしれない例外クラス、いくつかの補助ユーティリティ、
そして少々のサンプルも含まれています。古い `mimelib' や前バージョンの
`email' パッケージののユーザのために、現行バージョンとの違いと
移植についての節も設けてあります。

See also:
     *Note smtplib:: SMTP プロトコル クライアント *Note nntplib:: NNTP
     プロトコル クライアント

* Menu:

* 電子メールメッセージの表現::
* 電子メールメッセージを解析パースする::
* MIME 文書を生成する::
* 電子メールおよび MIME オブジェクトをゼロから作成する::
* 国際化されたヘッダ::
* 文字セットの表現::
* エンコーダ::
* 例外および障害クラス::
* 雑用ユーティリティ::
* イテレータ::
* パッケージの履歴::
* mimelib との違い::
* 使用例 3::

