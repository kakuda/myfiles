これは python-lib-jp.info、python-lib-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-lib-jp.info,  Node: Top,  Next: 序,  Prev: (dir),  Up: (dir)

Python ライブラリリファレンス
*****************************

* Menu:

* 序::
* はじめに::
* 組み込みオブジェクト::
* 組み込み型::
* 文字列処理::
* データ型::
* 数値と数学モジュール::
* インターネット上のデータの操作::
* 構造化マークアップツール::
* File Formats::
* 暗号関連のサービス::
* ファイルとディレクトリへのアクセス::
* データ圧縮とアーカイブ::
* データの永続化::
* 汎用オペレーティングシステムサービス::
* オプションのオペレーティングシステムサービス::
* Unix独特のサービス::
* プロセス間通信とネットワーク::
* インターネットプロトコルとその支援::
* マルチメディアサービス::
* Tkを用いたグラフィカルユーザインターフェイス::
* 国際化::
* プログラムのフレームワーク::
* 開発ツール::
* Pythonデバッガ::
* Python プロファイラ::
* Python ランタイム サービス::
* カスタム Python インタプリタ::
* 制限実行 restricted execution::
* モジュールのインポート::
* Python言語サービス::
* Python コンパイラパッケージ::
* 抽象構文木::
* 各種サービス::
* SGI IRIX 特有のサービス::
* SunOS 特有のサービス::
* MS Windows 特有のサービス::
* ドキュメント化されていないモジュール::
* バグ報告::
* 歴史とライセンス::
* 日本語訳について::
* Module Index::
* Class-Exception-Object Index::
* Function-Method-Variable Index::
* Miscellaneous Index::


File: python-lib-jp.info,  Node: 序,  Next: はじめに,  Prev: Top,  Up: Top

序
**

Copyright (C) 2001-2006 Python Software Foundation.  All rights
reserved.

Copyright (C) 2000 BeOpen.com.  All rights reserved.

Copyright (C) 1995-2000 Corporation for National Research Initiatives.
All rights reserved.

Copyright (C) 1991-1995 Stichting Mathematisch Centrum.  All rights
reserved.

Translation Copyright (C) 2003, 2004 Python Document Japanese
Translation Project. All rights reserved.

ライセンスおよび許諾に関する完全な情報は、このドキュメントの末尾を
参照してください。

     Pythonは拡張性のあるインタプリタ形式のオブジェクト指向言語です。簡単な
     テキスト処理スクリプトから対話型のWWWブラウザまで、幅広い用途に対応し
     ています。

     では、 プログラミング言語 Python
     の厳密な構文とセマンティクスについて説明して いますが、Python
     とともに配付され，Python をすぐに活用する上で大いに
     役立つ標準ライブラリについては説明していません。このライブラリには、
     例えばファイルI/O のように， Python
     プログラマが直接アクセスできない
     システム機能へのアクセス機能を提供する (Cで書かれた)
     組み込みモジュールや、
     日々のプログラミングで生じる多くの問題に標準的な解決策を提供する
     pure Python で書かれたモジュールが入っています。これら数多くの
     モジュールには、Pythonプログラムに移植性を持たせ、それを高めるという
     明確な意図があります。

     このライブラリリファレンスマニュアルでは、Pythonの標準ライブラリだけで
     なく、多くのオプションのライブラリモジュールについて説明しています
     (ライブラリモジュールの中には，プラットフォームでのサポートや
     コンパイル時の設定によって、使えたり使えなかったりするものがあります)．
     また、言語の標準の型、組み込みの関数と例外、Python リファレンス
     マニュアルで説明していなかったり，説明不足であるような多くの点に
     ついても説明しています。

     このマニュアルでは、読者が Python 言語について基礎的な知識を持って
     いると仮定しています。形式ばらずに Python を学んでみたければ、
     を参照してください。  は、
     高度な文法とセマンティクスについて疑問があるときに参照してください。
     最後に、
     と題されたマニュアルには、Pythonに新しい機能を追加する方法と、
     他のアプリケーションに Python を組み込む方法が書かれています。



File: python-lib-jp.info,  Node: はじめに,  Next: 組み込みオブジェクト,  Prev: 序,  Up: Top

1 はじめに
**********

この "Python ライブラリ" には様々な内容が収録されています。

このライブラリには、数値型やリスト型のような、通常は言語の"核"
をなす部分とみなされるデータ型が含まれています。Python 言語のコア
部分では、これらの型に対してリテラル表現形式を与え、意味づけ上の
いくつかの制約を与えていますが、完全にその意味づけを定義している
わけではありません。(一方で、言語のコア部分では演算子のスペルや
優先順位のような構文法的な属性を定義しています。) 　
このライブラリにはまた、組み込み関数と例外が納められています --
組み込み関数および例外は、全ての Python で書かれたコード上で、 `import'
文を使わずに使うことができるオブジェクトです。
これらの組み込み要素のうちいくつかは言語のコア部分で定義されて
いますが、大半は言語コアの意味づけ上不可欠なものではないので
ここでしか記述されていません。

とはいえ、このライブラリの大部分に収録されているのはモジュールの
コレクションです。このコレクションを細分化する方法はいろいろあります。
あるモジュールは C 言語で書かれ、Python インタプリタに組み
込まれています; 一方別のモジュールは Python で書かれ、ソースコードの
形式で取り込まれます。またあるモジュールは、例えば実行スタックの追跡
結果を出力するといった、Python に非常に特化したインタフェースを提供
し、一方他のモジュールでは、特定のハードウェアにアクセスするといった、
特定のオペレーティングシステムに特化したインタフェースを提供
し、さらに別のモジュールでは WWW (ワールドワイドウェブ)
のような特定のアプリケーション分野に特化したインタフェースを
提供しています。モジュールによっては全てのバージョン、全ての 移植版の
Python で利用することができたり、背後にあるシステムが
サポートしている場合にのみ使えたり、Python をコンパイルして
インストールする際に特定の設定オプションを選んだときにのみ
利用できたりします。

このマニュアルの構成は "内部から外部へ:" つまり、最初に
組み込みのデータ型を記述し、組み込みの関数および例外、
そして最後に各モジュールといった形になっています。モジュール
は関係のあるものでグループ化して一つの章にしています。
章の順番付けや各章内のモジュールの順番付けは、大まかに重要性の
高いものから低いものになっています。

つまり、このマニュアルを最初から読み始め、読み飽き始めた
ところで次の章に進めば、Python ライブラリで利用できるモジュールや
サポートしているアプリケーション領域の概要をそこそこ理解できる
ということです。
もちろん、このマニュアルを小説のように読む必要は_ありません_ --
(マニュアルの先頭部分にある) 目次にざっと目を通したり、 (最後尾にある)
索引でお目当ての関数やモジュール、用語を探す
ことだってできます。もしランダムな項目について勉強してみたいの
なら、ランダムにページを選び (`random' 参照)、そこから 1, 2
節読むこともできます。このマニュアルの各節をどんな順番で
読むかに関わらず、第 *Note 組み込みオブジェクト:: 章、
"組み込み型、例外、および 関数"
から始めるとよいでしょう。マニュアルの他の部分は、
この節の内容について知っているものとして書かれているからです。

それでは、ショーの始まりです！


File: python-lib-jp.info,  Node: 組み込みオブジェクト,  Next: 組み込み型,  Prev: はじめに,  Up: Top

2 組み込みオブジェクト
**********************

組み込み例外名、関数名、各種定数名は専用のシンボルテーブル中に存在しています。
シンボル名を参照するときこのシンボルテーブルは最後に参照されるので、
ユーザーが設定したローカルな名前やグローバルな名前によってオーバーライド
することができます。
組み込み型については参照しやすいようにここで説明されています。(1)

この章にある表では、オペレータの優先度を昇順に並べて表わしていて、
同じ優先度のオペレータは同じ箱に入れています。同じ優先度の二項演算子は左
から右への結合順序を持っています。(単項演算子は右から左へ結合しますが選択
の余地はないでしょう。) (2)
オペレータの優先順位についての詳細はの5章をごらんください。

* Menu:

* 組み込み関数::
* 非必須組み込み関数 Non-essential Built-in Functions::
* 組み込み例外::
* 組み込み定数::

---------- Footnotes ----------

(1)
ほとんどの説明ではそこで発生しうる例外については説明されていません。この
マニュアルの将来の版で訂正される予定です。

(2) 訳者註: HTML版では、変換の過程で
表の区切り情報が消えてしまっているので、PS版やPDF版をごらんください。


File: python-lib-jp.info,  Node: 組み込み関数,  Next: 非必須組み込み関数 Non-essential Built-in Functions,  Prev: 組み込みオブジェクト,  Up: 組み込みオブジェクト

2.1 組み込み関数
================

Python インタプリタは数多くの組み込み関数を持っていて、いつでも利用
することができます。それらの関数をアルファベット順に挙げます。

`__import__(name[, globals[, locals[, fromlist[, level]]]])'
     この関数は `import'  文によって呼び出され
     ます。この関数の主な意義は、同様のインタフェースを持つ関数で
     この関数を置き換え、`import' 文の意味を変更できるように
     することです。これを行う理由とやり方の例については、標準ライブラリ
     モジュール  `ihooks'  および `rexec'  を読んで下さい。また、
     組み込みモジュール `imp'  についても 読んでみて下さい。自分で関数
     `__import__' を構築する 際に便利な操作が定義されています。

     例えば、文 `import spam' は結果として以下の呼び出し:
     `__import__('spam',' `globals(),' `locals(), [], -1)' になります;
     文 `from spam.ham import eggs' は `__import__('spam.ham',
     globals(), locals(), ['eggs'], -1)' です。 `locals()' および
     `['eggs']' が引数で与えられますが、 関数 `__import__()' は `eggs'
     という名のローカル変数 を設定しないので注意してください;
     この操作はそれ以後の import 文の
     ために生成されたコードで行われます。(実際、標準の実装では LOCALS
     引数を全く使わず、`import' 文のパッケージ文脈を決定するため だけに
     GLOBALS を使います。)

     変数 NAME が `package.module' の形式であった場合、 通常、NAME
     という名のモジュール _ではなく_ トップレベルの パッケージ
     (最初のドットまでの名前) が返されます。しかし、 空でない FROMLIST
     引数が与えられていれば、NAME
     と名づけられたモジュールが返されます。これは異なる種類の import
     文に対して生成されたバイトコードと互換性をもたせるために行われます;
     `import spam.ham.eggs' とすると、トップレベルのパッケージ `spam'
     はインポートする名前空間に置かれなければなりませんが、 `from
     spam.ham import eggs' とすると、変数 `eggs' を 見つけるためには
     `spam.ham' サブパッケージを使わなくては
     なりません。この振る舞いを回避するために、`getattr()' を
     使って必要なコンポーネントを展開してください。例えば、
     以下のようなヘルパー関数:

          def my_import(name):
              mod = __import__(name)
              components = name.split('.')
              for comp in components[1:]:
                  mod = getattr(mod, comp)
              return mod

     LEVEL で絶対インポートを使うか相対インポートを使うかを指定します。
     デフォルトは `-1'
     で、この値は絶対と相対の両インポートを試すことを示します。 `0'
     を指定すると、絶対インポートだけ行なう、という意味になります。
     LEVEL が正の値ならば、`__import__' を呼び出すモジュールの
     ディレクトリから幾つ上の親ディレクトリまで探索するか、を意味します。
     _Changed in Python version 2.5_ _Changed in Python version 2.5_

`abs(x)'
     数値の絶対値を返します。引数として通常の整数、長整数、浮動小数点数を
     とることができます。引数が複素数の場合、その大きさ (magnitude) が
     返されます

`all(iterable)'
     ITERABLE の全ての要素が真ならば `True' を返します。
     以下のコードと等価です。
               def all(iterable):
                   for element in iterable:
                       if not element:
                           return False
                   return True

     _Added in Python version 2.5_

`any(iterable)'
     ITERABLE のいずれかの要素が真ならば `True' を返します。
     以下のコードと等価です。
               def any(iterable):
                   for element in iterable:
                       if element:
                           return True
                   return False

     _Added in Python version 2.5_

`basestring()'
     この抽象型は、 `str' および `unicode' のスーパクラスです。
     この型は呼び出したりインスタンス化したりはできませんが、オブジェクトが
     `str' や `unicode' のインスタンスであるかどうかを調べる際に
     利用できます。 `isinstance(obj, basestring)' は `isinstance(obj,
     (str, unicode))' と同じです。 _Added in Python version 2.3_

`bool([x])'
     標準の真値テストを使って、値をブール値に変換します。X
     が偽なら、`False' を返します; そうでなければ `True'
     を返します。`bool' はクラスでも あり、`int'
     のサブクラスになります。`bool' クラスは
     それ以上サブクラス化できません。このクラスのインスタンス は`False'
     および `True'　だけです。

     _Added in Python version 2.2.1_

     _Changed in Python version 2.3_

`callable(object)'
     OBJECT 引数が呼び出し可能なオブジェクトの場合、真を返します。
     そうでなければ偽を返します。この関数が真を返しても OBJECT
     の呼び出しは失敗する可能性がありますが、偽を返した場合は決して
     成功することはありません。クラスは呼び出し可能 (クラスを呼び出すと
     新しいインスタンスを返します) なことと、クラスのインスタンスが
     メソッド `__call__()' を持つ場合には呼び出しが可能なので
     注意してください。

`chr(i)'
     ASCII コードが整数 I となるような文字 1 字からなる文字列を
     返します。例えば、`chr(97)' は文字列 `'a'' を返します。 この関数は
     `ord()' の逆です。引数は [0..255] の両端を含む
     範囲内に収まらなければなりません; I が範囲外の値のときには
     `ValueError' が送出されます。

`classmethod(function)'
     FUNCTION のクラスメソッドを返します。

     クラスメソッドは、インスタンスメソッドが暗黙の第一引数として
     インスタンスをとるように、第一引数としてクラスをとります。
     クラスメソッドを宣言するには、以下の書きならわしを使います:

          class C:
              @classmethod
              def f(cls, arg1, arg2, ...): ...

     `@classmethod' は関数デコレータ形式です。詳しくは {Python
     リファレンスマニュアル} の 7
     章にある関数定義についての説明を参照してください。

     このメソッドはクラスで呼び出すこと (例えば C.f() ) も、
     インスタンスとして呼び出すこと (例えば C().f()) もできます。
     インスタンスはそのクラスが何であるかを除いて無視されます。
     クラスメソッドが導出クラスに対して呼び出された場合、
     導出されたクラスオブジェクトが暗黙の第一引数として渡されます。

     クラスメソッドは C++ や Java における静的メソッドとは異なります。
     そのような機能を求めているなら、`staticmethod()' を参照してくだ
     さい。

     もっとクラスメソッドについての情報が必要ならば、

     の3章にある標準型階層についてのドキュメントを繙いてください。
     _Added in Python version 2.2_ _Changed in Python version 2.4_

`cmp(x, y)'
     二つのオブジェクト X および Y を比較し、その結果に従って
     整数を返します。戻り値は `X' < `Y' のときには負、 `X == Y'
     の時にはゼロ、`X > Y' には 厳密に正の値になります。

`compile(string, filename, kind[, flags[, dont_inherit]])'
     STRING をコードオブジェクトにコンパイルします。コードオブジェク
     トは `exec' 文で実行したり、 `eval()' を呼び出して評
     価できます。FILENAME 引数にはコードの読み出し元のファイル名を指
     定します。コードをファイルから読み出したのでない場合には、それとわかる
     ような値を渡します (一般的には `'<string>'' を使います)。引数 KIND
     には、どの種類のコードをコンパイルするかを指定します。 STRING
     が命令文の列からなる場合には `'exec'' 、単一の式から なる場合には
     `'eval'' 、単一の対話的な命令文からなる場合には `'single''
     にします (最後のケースでは、式の評価結果が `None'
     以外の場合に値を出力します)。

     複数行の命令文をコンパイルする時には、2 つの注意点があります:
     行末は単 一の改行文字 (`'\n'')
     で表さねばなりません。また、入力行は少な くとも 1
     つの改行文字で終端せねばなりません。行末が `'\r\n''
     で表現されている場合、文字列に `replace()' メソッドを使って `'\n''
     に変換してください。

     オプションの引数 FLAGS および DONT_INHERIT (Python 2.2 で
     新たに追加) は、 STRING のコンパイル時にどの future 文 (PEP 236 参照)
     の影響を及ぼすかを制御します。どちらも省略した場合
     (または両方ともゼロの場合)、コンパイルを呼び出している側のコードで有効
     になっている future 文の内容を有効にして STRING をコンパイルしま
     す。FLAGS が指定されていて、かつ DONT_INHERIT が指定されて いない
     (またはゼロ) の場合、上の場合に加えて FLAGS に指定された future
     文をいます。DONT_INHERIT がゼロでない整数の場合、 FLAGS
     の値そのものを使い、この関数呼び出し周辺での future 文の効
     果は無視します。

     future
     文はビットで指定され、互いにビット単位の論理和を取って複数の文
     を指定できます。ある機能を指定するために必要なビットフィールドは、
     `__future__' モジュールの `_Feature' インスタンスにおける
     `compiler_flag' 属性で得られます。

`complex([real[, imag]])'
     値 REAL + IMAG*j の複素数型数を生成するか、文字列または
     数値を複素数型に変換します。最初の引数が文字列の場合、文字列を
     複素数として変換します。この場合関数は二つ目の引数無しで呼び出さ
     なければなりません。二つ目の引数は文字列であってはなりません。
     それぞれの引数は (複素数を含む) 任意の数値型をとることができます。
     IMAG が省略された場合、標準の値はゼロで、関数は `int' 、 `long()'
     および `float()' のような数値型への 変換関数として動作します。
     全ての引数が省略された場合、`0j' を返します。

`delattr(object, name)'
     `setattr()' の親戚となる関数です。引数はオブジェクトと
     文字列です。文字列はオブジェクトの属性のどれか一つの名前でなければ
     なりません。この関数は与えられた名前の属性を削除しますが、オブジェクト
     がそれを許す場合に限ります。例えば、 `delattr(X, 'FOOBAR')' は
     `del X.FOOBAR' と等価です。

`dict([mapping-or-sequence])'
     オプションの場所にある引数か、キーワード引数の集合から、
     新しく辞書オブジェクトを初期化して返します。
     引数が指定されていなければ、新しい空の辞書を返します。
     オプションの場所にある引数がマップ型のオブジェクトの場合、
     そのマップ型オブジェクトと同じキーと値を持つ辞書を返します。
     それ以外の場合、オプションの場所にある引数はシーケンス型か、
     反復をサポートするコンテナ型か、イテレータオブジェクトでなければなりません。
     この場合引数中の要素もまた、上に挙げた型のどれかでなくてはならず、
     加えて正確に 2 個のオブジェクトを持っていなくてはなりません。
     最初の要素は新たな辞書のキーとして、二つ目の要素は辞書の値として
     使われます。同じキーが一度以上与えられた場合、新たな辞書中には
     最後に与えた値だけが関連付けられます。

     キーワード引数が与えられた場合、キーワードとそれに関連付けられた
     値が辞書の要素として追加されます。オプションの場所にある
     オブジェクト内とキーワード引数の両方で同じキーが指定されていた場合、
     辞書中にはキーワード引数の設定値の方が残されます。

     例えば、以下のコードはどれも、`{"one": 2, "two": 3}'
     と同じ辞書を返します:

        * `dict({'one': 2, 'two': 3})'

        * `dict({'one': 2, 'two': 3}.items())'

        * `dict({'one': 2, 'two': 3}.iteritems())'

        * `dict(zip(('one', 2), ('two', 3)))'

        * `dict([['two', 3], ['one', 2]])'

        * `dict(one=2, two=3)'

        * `dict([(['one', 'two'][i-2], i) for i in (2, 3)])'

     _Added in Python version 2.2_ _Changed in Python version 2.3_

`dir([object])'
     引数がない場合、現在のローカルシンボルテーブルにある名前のリストを
     返します。引数がある場合、そのオブジェクトの有効な属性からなるリスト
     を返そうと試みます。この情報はオブジェクトの `__dict__'
     属性が定義されている場合、そこから収集されます。また、
     クラスまたは型オブジェクトからも集められます。リストは完全なものに
     なるとは限りません。
     オブジェクトがモジュールオブジェクトの場合、リストにはモジュール属性
     の名前も含まれます。
     オブジェクトが型オブジェクトやクラスオブジェクトの場合、
     リストにはそれらの属性が含まれ、かつそれらの基底クラスの属性も
     再帰的にたどられて含まれます。
     それ以外の場合には、リストにはオブジェクトの属性名、クラス属性名、
     再帰的にたどった基底クラスの属性名が含まれます。
     返されるリストはアルファベット順に並べられています。 例えば:

          >>> import struct
          >>> dir()
          ['__builtins__', '__doc__', '__name__', 'struct']
          >>> dir(struct)
          ['__doc__', '__name__', 'calcsize', 'error', 'pack', 'unpack']

     _Note:_ `dir()' は第一に対話プロンプトのために提供されているので、
     厳密さや一貫性をもって定義された名前のセットよりも、むしろ興味深い名前
     のセットを与えようとします。また、この関数の細かい動作はリリース間で
     変わる可能性があります。

`divmod(a, b)'
     2 つの (複素数でない) 数値を引数として取り、長除法を行って
     その商と剰余からなるペアを返します。被演算子が型混合である場合、 2
     進算術演算子での規則が適用されます。通常の整数と長整数の場合、
     結果は  `(A // B, A %{} B)' と同じ
     です。浮動小数点数の場合、結果は `(Q, A %{} B)' であり、 Q は通常
     `math.floor(A / B)' ですが、 そうではなく 1 になることもあります。
     いずれにせよ、`Q * B + A %{} B' は A に非常に近い値になり、 `A %{}
     B' がゼロでない値の場合、その符号は B と同じで、 `0 <= abs(A %{}
     B) < abs(B)' になります。

     _Changed in Python version 2.3_

`enumerate(iterable)'
     列挙オブジェクトを返します。ITERABLE はシーケンス型、イテレータ型、
     あるいは反復をサポートする他のオブジェクト型でなければなりません。
     `enumerate()' が返すイテレータの `next()' メソッドは、
     (ゼロから始まる) カウント値と、値だけ ITERABLE を反復操作して
     得られる、対応するオブジェクトを含むタプルを返します。
     `enumerate()' はインデクス付けされた値の列: `(0, seq[0])', `(1,
     seq[1])', `(2, seq[2])', ...  を得るのに便利です。 _Added in
     Python version 2.3_

`eval(expression[, globals[, locals]])'
     文字列とオプションの引数 GLOBALS、LOCALS をとります。 GLOBALS
     を指定する場合には辞書でなくてはなりません。 LOCALS
     は任意のマップ型にできます。 _Changed in Python version 2.4_

     引数 EXPRESSIONは Python の表現式
     (技術的にいうと、条件のリストです) として構文解釈され、
     評価されます。このとき辞書 GLOBALS および LOCALS はそれぞれ
     グローバルおよびローカルな名前空間として使われます。 LOCALS
     辞書が存在するが、'__builtins__' が欠けている場合、 EXPRESSION
     を解析する前に現在のグローバル変数を GLOBALS
     にコピーします。このことから、EXPRESSION は通常 標準の
     `__builtin__' モジュールへの完全なアクセス
     を有し、制限された環境が伝播するようになっています。 LOCALS
     辞書が省略された場合、標準の値として GLOBALS に
     設定されます。辞書が両方とも省略された場合、表現式は `eval' が
     呼び出されている環境の下で実行されます。構文エラーは例外として報告されます。

     以下に例を示します:

          >>> x = 1
          >>> print eval('x+1')
          2

     この関数は (`compile()' で生成されるような) 任意の
     コードオブジェクトを実行するために利用することもできます。
     この場合、文字列の代わりにコードオブジェクトを渡します。
     このコードオブジェクトは引数 KIND を `'eval'' にして
     コンパイルされていなければなりません。

     ヒント: 文の動的な実行は `exec' 文でサポートされています。
     ファイルからの文の実行は関数 `execfile()' でサポートされて
     います。関数 `globals()' および `locals()' は
     それぞれ現在のグローバルおよびローカルな辞書を返すので、 `eval()'
     や `execfile()' で使うことができます。

`execfile(filename[, globals[, locals]])'
     この関数は `exec' 文に似ていますが、文字列の代わりにファイルに
     対して構文解釈を行います。`import' 文と違って、モジュール管理
     機構を使いません -- この関数はファイルを無条件に読み込み、
     新たなモジュールを生成しません。(1)

     引数は文字列とオプションの 2 つの辞書からなります。FILE
     は読み込まれ、(モジュールのように) Python
     文の列として評価されます。 このとき GLOBALS および LOCALS
     がそれぞれグローバル およびローカルな名前空間として使われます。
     LOCALS は任意のマップ型に指定できます。 _Changed in Python version
     2.4_ LOCALS 辞書が 省略された場合、標準の値として GLOBALS
     に設定されます。辞書が 両方とも省略された場合、表現式は
     `execfiles' が呼び出されている 環境の下で実行されます。戻り値は
     `None' です。

     _標準では LOCALS は後に述べる関数 `locals()'  のように動作します:
     標準の LOCALS 辞書に対する変更を試みては いけません。`execfile()'
     の呼び出しが返る時にコードが LOCALS
     に与える影響を知りたいなら、明示的に LOACALS 辞書を
     渡してください。`execfile()' は関数のローカルを変更するための
     信頼性のある方法として使うことはできません_

`file(filename[, mode[, bufsize]])'
     `file' 型のコンストラクタです。詳しくは *Note
     ファイルオブジェクト::節 "ファイルオブジェクト"
     を参照してください。 コンストラクタの引数は後述の `open()'
     組み込み関数と同じです。

     ファイルを開くときは、このコンストラクタを直接呼ばずに `open()' を
     呼び出すのが望ましい方法です。`file' は型テストにより適しています
     (たとえば `isinstance(f, file)' と書くような)。

     _Added in Python version 2.2_

`filter(function, list)'
     LIST のうち、FUNCTION が真を返すような要素からなる
     リストを構築します。LIST
     はシーケンスか、反復をサポートするコンテナか、
     イテレータです。LIST が文字列型かタプル型の場合、結果も同じ型に
     なります。FUNCTION が `None' の場合、恒等関数を仮定
     します。すなわち、LIST の偽となる要素 は除去されます。

     function が `None' ではない場合、`filter(function, LIST)' は
     `[item for item in LIST if function(item)]' と同等です。 function
     が `None' の場合 `[item for item in LIST if  item]' と同等です。

`float([x])'
     文字列または数値を浮動小数点数に変換します。引数が文字列の場合、
     十進の数または浮動小数点数を含んでいなければなりません。符号が
     付いていてもかまいません。また、空白文字中に埋め込まれていても
     かまいません。それ以外の場合、引数は通常整数、長整数、または浮動小数点
     数をとることができ、同じ値の浮動小数点数が (Python の浮動小数点
     精度で) 返されます。 引数が指定されなかった場合、`0.0' を返します。

     _Note:_ 文字列で値を渡す際、背後の C ライブラリによって NaN  および
     Infinity  が返されるかもしれません。これらの
     値を返すような特殊な文字列のセットは完全に C
     ライブラリに依存しており、
     バリエーションがあることが知られています。

`frozenset([iterable])'
     `frozenset' オブジェクトを返します。要素はITERABLE から
     取得します。`frozenset' 型は、update メソッドを持たない代わりに
     ハッシュ化でき、他の `set' 型の要素にしたり辞書型のキーに
     したりできます。`frozenset' の要素自体は変更不能でなければ
     なりません。集合 (set) 型の集合を表現するためには、内集合も
     `frozenset' オブジェクトでなければなりません。ITERABLE を
     指定しない場合には空の集合 `frozenset([])' を返します。 _Added in
     Python version 2.4_

`getattr(object, name[, default])'
     指定された OBJECT の属性を返します。NAME は文字列で
     なくてはなりません。文字列がオブジェクトの属性名の一つであった
     場合、戻り値はその属性の値になります。例えば、 `getattr(x,
     'foobar')' は `x.foobar' と等価です。
     指定された属性が存在しない場合、DEFAULT が与えられている
     場合にはしれが返されます。そうでない場合には `AttributeError'
     が送出されます。

`globals()'
     現在のグローバルシンボルテーブルを表す辞書を返します。
     常に現在のモジュールの辞書になります (関数またはメソッドの中では
     それらを定義しているモジュールを指し、この関数を呼び出したモジュール
     ではありません)。

`hasattr(object, name)'
     引数はオブジェクトと文字列です。文字列がオブジェクトの属性名の一つ
     であった場合 `True' を、そうでない場合 `False' を返します
     (この関数は `getattr(OBJECT, NAME)' を呼び出し、
     例外を送出するかどうかを調べることで実装しています)。

`hash(object)'
     オブジェクトのハッシュ値を (存在すれれば) 返します。ハッシュ値は
     整数です。これらは辞書を検索する際に辞書のキーを高速に比較するために
     使われます。等しい値となる数値は等しいハッシュ値を持ちます (1 と
     1.0 のように型が異なっていてもです)。

`help([object])'
     組み込みヘルプシステムを起動します (この関数は対話的な使用のための
     ものです)。引数が与えられていない場合、対話的ヘルプシステムは
     インタプリタコンソール上で起動します。引数が文字列の場合、文字列は
     モジュール、関数、クラス、メソッド、キーワード、またはドキュメント
     の項目名として検索され、ヘルプページがコンソール上に印字されます。
     引数が何らかのオブジェクトの場合、そのオブジェクトに関するヘルプ
     ページが生成されます。 _Added in Python version 2.2_

`hex(x)'
     (任意のサイズの) 整数 を16進の文字列に変換します。 結果は Python
     の式としても使える形式になります。 _Changed in Python version 2.4_

`id(object)'
     オブジェクトの "識別値" を返します。この値は整数 (または長整数)
     で、このオブジェクトの有効期間は一意かつ定数であることが保証されて
     います。 オブジェクトの有効期間が重ならない 2 つのオブジェクトは
     同じ `id()' 値を持つかもしれません。 (実装に関する注釈:
     この値はオブジェクトのアドレスです。)

`input([prompt])'
     `eval(raw_input(PROMPT))' と同じです。
     _この関数はユーザのエラーに対して安全ではありません! この関数
     では、入力は有効な Python の式であると期待しています; 入力が
     構文的に正しくない場合、`SyntaxError' が送出されます。
     式を評価する際にエラーが生じた場合、他の例外も送出されるかもしれません。
     (一方、この関数は時に、熟練者がすばやくスクリプトを書く際に必要なまさに
     そのものです)_

     `readline' モジュールが読み込まれていれば、`input()'
     は精緻な行編集およびヒストリ機能を提供します。

     一般的なユーザからの入力のための関数としては `raw_input()'
     を使うことを検討してください。

`int([x[, radix]])'
     文字列または数値を通常の整数に変換します。引数が文字列の場合、
     Python 整数として表現可能な十進の数でなければなりません。
     符号が付いていてもかまいません。また、空白文字中に埋め込まれていても
     かまいません。RADIX 引数は変換の基数を表し、範囲 [2, 36] の
     整数またはゼロをとることができます。RADIX がゼロの場合、文字列の
     内容から適切な基数を推測します; 変換は整数リテラルと同じです。
     RADIX が指定されており、X が文字列でない場合、 `TypeError'
     が送出されます。
     それ以外の場合、引数は通常整数、長整数、または浮動小数点
     数をとることができます。浮動小数点数から整数へ変換では (ゼロ方向に)
     値を丸めます。
     引数が通常整数の範囲を超えている場合、長整数が代わりに返されます。
     引数が与えられなかった場合、`0' を返します。

`isinstance(object, classinfo)'
     引数 OBJECT が引数 CLASSINFO のインスタンスであるか、
     (直接または間接的な) サブクラスのインスタンスの場合に真を返します。
     また、CLASSINFO が型オブジェクトであり、OBJECT がその
     型のオブジェクトである場合にも真を返します。OBJECT が
     クラスインスタンスや与えられた型のオブジェクトでない場合、
     この関数は常に偽を返します。CLASSINFO をクラスオブジェクト
     でも型オブジェクトにもせず、クラスや型オブジェクトからなる
     タプルや、そういったタプルを再帰的に含むタプル (他のシーケンス型は
     受理されません) でもかまいません。CLASSINFO がクラス、型、
     クラスや型からなるタプル、そういったタプルが再帰構造をとっている
     タプルのいじれでもない場合、例外 `TypeError' が送出 されます。
     _Changed in Python version 2.2_

`issubclass(class, classinfo)'
     CLASS が CLASSINFO の (直接または間接的な) サブクラスで
     ある場合に真を返します。クラスはそのクラス自体のサブクラスと
     CLASINFO はクラスオブジェクトからなるタプルでもよく、 この場合には
     CLASSINFO のすべてのエントリが調べ られます。その他の場合では、
     例外 `TypeError' が送出されます。 _Changed in Python version 2.3_

`iter(o[, sentinel])'
     イテレータオブジェクトを返します。2 つ目の引数があるかどうかで、
     最初の引数の解釈は非常に異なります。2 つ目の引数がない場合、 O
     は反復プロトコル (`__iter__()' メソッド) か、
     シーケンス型プロトコル (引数が `0' から開始する `__getitem__()'
     メソッド) をサポートする集合オブジェクト
     でなければなりません。これらのプロトコルが両方ともサポート
     されていない場合、 `TypeError' が送出されます。 2 つ目の引数
     SENTINEL が与えられていれば、O
     は呼び出し可能なオブジェクトでなければなりません。この場合に
     生成されるイテレータは、`next()' を呼ぶ毎に O を引数無し
     で呼び出します。返された値が SENTINEL と等しければ、
     `StopIteration' が送出されます。そうでない場合、
     戻り値がそのまま返されます。 _Added in Python version 2.2_

`len(s)'
     オブジェクトの長さ (要素の数) を返します。引数はシーケンス型
     (文字列、 タプル、またはリスト) か、マップ型 (辞書) です。

`list([sequence])'
     SEQUENCE の要素と同じ要素をもち、かつ順番も同じなリストを
     返します。SEQUENCE はシーケンス、反復処理をサポートするコンテナ、
     あるいはイテレータオブジェクトです。SEQUENCE がすでにリストの
     場合、`SEQUENCE[:]' と同様にコピーを作成して返します。
     例えば、`list('abc')' は `['a', 'b', 'c']' および `list((1, 2,
     3))' は `[1, 2, 3]' を返します。
     引数が与えられなかった場合、新しい空のリスト `[]' を返します。

`locals()'
     現在のローカルシンボルテーブルを表す辞書を更新して返します。
     _この辞書の内容は変更してはいけません; 値を変更しても、
     インタプリタが使うローカル変数の値には影響しません。_

`long([x[, radix]])'
     文字列または数値を長整数値に変換します。引数が文字列の場合、
     Python 整数として表現可能な十進の数でなければなりません。
     符号が付いていてもかまいません。また、空白文字中に埋め込まれていても
     かまいません。RADIX 引数は `int()' と同じように 解釈され、X
     が文字列の時だけ与えることができます。
     それ以外の場合、引数は通常整数、長整数、または浮動小数点
     数をとることができ、同じ値の長整数が返されます。浮動小数点数から
     整数へ変換では (ゼロ方向に) 値を丸めます。
     引数が与えられなかった場合、`0L' を返します。

`map(function, list, ...)'
     FUNCTION を LIST の全ての要素に適用し、返された
     値からなるリストを返します。追加の LIST 引数を与えた場合、
     FUNCTION はそれらを引数として取らなければならず、関数は
     そのリストの全ての要素について個別に適用されます; 他のリストより
     短いリストがある場合、要素 `None' で延長されます。FUNCTION が
     `None' の場合、恒等関数であると仮定されます; すなわち、
     複数のリスト引数が存在する場合、`map()' は全てのリスト引数に
     対し、対応する要素からなるタプルからなるリストを返します
     (転置操作の ようなものです)。LIST
     引数はどのようなシーケンス型でもかまいません;
     結果は常にリストになります。

`max(s[, args...][key])'
     単一の引数 S の場合、空でないシーケンス
     (文字列、タプルまたはリスト) の要素のうち最大のものを返します。1
     個よりも引数が多い場合、引数 間で最大のものを返します。

     オプションの KEY 引数には `list.sort()' で使われるのと同じ
     ような1引数の順序付け関数を指定します。KEY を指定する場合はキーワー
     ド形式でなければなりません (たとえば `max(a,b,c,key=func)')。
     _Changed in Python version 2.5_

`min(s[, args...][key])'
     単一の引数 S の場合、空でないシーケンス
     (文字列、タプルまたはリスト) の要素のうち最小のものを返します。1
     個よりも引数が多い場合、引数 間で最小のものを返します。

     オプションの KEY 引数には `list.sort()' で使われるのと同じ
     ような1引数の順序付け関数を指定します。KEY を指定する場合はキーワー
     ド形式でなければなりません (たとえば `min(a,b,c,key=func)')。
     _Changed in Python version 2.5_

`object()'
     ユーザ定義の属性やメソッドを持たない、新しいオブジェクトを返します。
     `object()' は新スタイルのクラスの、基底クラスです。これは、新ス
     タイルのクラスのインスタンスに共通のメソッド群を持ちます。 _Added
     in Python version 2.2_

     _Changed in Python version 2.3_

`oct(x)'
     (任意のサイズの) 整数を 8 進の文字列に変換します。 結果は Python
     の式としても使える形式になります。 _Changed in Python version 2.4_

`open(filename[, mode[, bufsize]])'
     ファイルを開いて、*Note ファイルオブジェクト::節
     "ファイルオブジェクト" に記述されている `file'
     型のオブジェクトを返します。ファイルが開けなければ、 `IOError'
     が送出されます。ファイルを開くときは `file'
     のコンストラクタを直接呼ばずに `open()' を
     使うのが望ましい方法です。

     最初の 2 つの引数は `studio' の `fopen()' と同じです: FILENAME
     は開きたいファイルの名前で、 MODE
     はファイルをどのようにして開くかを指定します。

     最もよく使われる MODE の値は、読み出しの `'r''、 書き込み
     (ファイルがすでに存在すれば切り詰め られます) の
     `'w''、追記書き込みの `'a'' です (_いくつかの_ UNIX
     システムでは、_全て_ の書き込みが
     現在のファイルシーク位置に関係なくファイルの末尾に追加されます) 。
     MODE が省略された場合、標準の値は `'r'' になります。
     移植性を高めるためには、バイナリファイルを開くときには、MODE
     の値に `'b'' を追加しなければなりません。(バイナリファイルと
     テキストファイルを区別なく扱うようなシステムでも、ドキュメンテーション
     の代わりになるので便利です。) 他に MODE
     に与えられる可能性のある値については後述します。

     オプションの BUFSIZE 引数は、ファイルのために必要とする
     バッファのサイズを指定します: 0 は非バッファリング、 1 は行単位
     バッファリング、その他の正の値は指定した値 (の近似値) のサイズを
     もつバッファを使用することを意味します。BUFSIZE の値が負の
     場合、システムの標準を使います。通常、端末は行単位のバッファリング
     であり、その他のファイルは完全なバッファリングです。省略された
     場合、システムの標準の値が使われます。 (2)

     `'r+''、`'w+''、および `'a+'' はファイルを更新 モードで開きます
     (`'w+'' はファイルがすでに存在すれば切り詰め
     るので注意してください) 。バイナリとテキストファイルを区別する
     システムでは、ファイルをバイナリモードで開くためには `'b''
     を追加してください (区別しないシステムでは `'b'' は無視されます)。

     標準の `fopen()' における MODE の値に加えて、 `'U'' または `'rU''
     を使うことができます。 Python が全改行文字サポートを行っている
     (標準ではしています)　場合,
     ファイルがテキストファイルで開かれますが、行末文字として Unix
     における 慣行である `'\n'' 、Macintosh における慣行である `'\r''、
     Windows における慣行である `'\r\n'' のいずれを使うことも
     できます。これらの改行文字の外部表現はどれも、Python
     プログラムからは `'\n'' に見えます。Python
     が全改行文字サポートなしで構築 されている場合、MODE `'U''
     は通常のテキストモードと
     同様になります。開かれたファイルオブジェクトはまた、`newlines'
     と呼ばれる属性を持っており、その値は `None' (改行が見つから
     なかった場合)、`'\n''、`'\r''、 `'\r\n''、
     または見つかった全ての改行タイプを含むタプルになります。

     `'U'' を取り除いた後のモードは `'r''、`'w''、`'a'' の
     いずれかで始まる、というのが Python における規則です。

     _Changed in Python version 2.5_

`ord(c)'
     長さ 1 の与えられた文字列に対し、その文字列が unicode
     オブジェクトならば Unicode
     コードポイントを表す整数を、8ビット文字列ならばそのバイトの値を返します。
     たとえば、`ord('a')' は整数 `97' を返し、 `ord(u'\u2020')' は
     `8224' を返します。この値は 8ビット文字列に対する `chr()'
     の逆であり、unicode オブジェクトに対する `unichr()'
     の逆です。引数が unicode で Python が UCS2 Unicode
     対応版ならば、その文字のコードポイントは両端を含めて [0..65535]
     の範囲に
     入っていなければなりません。この範囲から外れると文字列の長さが 2
     になり、 `TypeError' が送出されることになります。

`pow(x, y[, z])'
     X の Y 乗を返します; Z があれば、 X の Y 乗に対する Z
     のモジュロを返します (`pow(X, Y)% Z' より効率よく計算
     されます)。引数二つの `pow(X, Y)' という形式は、
     冪乗演算子を使った `X**Y' と等価です。

     引数は数値型でなくてはなりません。型混合の場合、 2
     進算術演算における型強制規則が適用されます。通常整数
     および長整数の被演算子に対しては、二つ目の引数が負の数でない
     限り、結果は (型強制後の)被演算子と同じ型になります;
     負の場合、全ての引数は浮動小数点型に変換され、浮動小数点
     型の結果が返されます。例えば、 `10**2' は `100' を返しますが、
     `100**-2' は `0.01' を返します。 (最後に述べた機能は Python 2.2
     で追加されたものです。 Python 2.1
     以前では、双方の引数が整数で二つ目の値が負の
     場合、例外が送出されます。) 二つ目の引数が負の場合、
     三つめの引数は無視されます。Z がある場合、X および Y
     は整数型でなければならず、Y は非負
     の値でなくてはなりません。(この制限は Python 2.2 で追加
     されました。 Python 2.1 以前では、3 つの浮動小数点引数を 持つ
     `pow()' は浮動小数点の丸めに関する偶発誤差
     により、プラットフォーム依存の結果を返します。)

`property([fget[, fset[, fdel[, doc]]]])'
     新しい形式のクラス (`object' から導出されたクラス) における
     プロパティ属性を返します。

     FGET は属性値を取得するための関数で、同様に FSET は
     属性値を設定するための関数です。また、FDEL は属性を
     削除するための関数です。以下に属性 x
     を扱う典型的な利用法を示します:

          class C(object):
              def __init__(self): self._x = None
              def getx(self): return self._x
              def setx(self, value): self._x = value
              def delx(self): del self._x
              x = property(getx, setx, delx, "I'm the 'x' property.")

     DOC
     がもし与えられたならばそれがプロパティ属性のドキュメント文字列になります。
     与えられない場合、プロパティは FGET
     のドキュメント文字列(がもしあれば)を
     コピーします。これにより、読み取り専用プロパティを `property()' を
     デコレータとして使って容易に作れるようになります。

          class Parrot(object):
              def __init__(self):
                  self._voltage = 100000

              @property
              def voltage(self):
                  """Get the current voltage."""
                  return self._voltage

     のようにすると、`voltage()' が同じ名前の読み取り専用属性 の
     "getter" になります。

     _Added in Python version 2.2_ _Changed in Python version 2.5_

`range([start,] stop[, step])'
     数列を含むリストを生成するための多機能関数です。`for'
     ループでよく使われます。引数は通常の整数でなければなりません。
     STEP 引数が無視された場合、標準の値 `1' になります。 START
     引数が蒸しされた場合標準の値 `0' になります。
     完全な形式では、通常の整数列 `[START, START + STEP, START + 2 *
     STEP, ...]' を返します。 STEP が正の値の場合、最後の要素は STOP
     よりも小さい `START + I * STEP' の最大値になります; STEP
     が負の値の場合、最後の要素は STOP よりも大きい `START + I * STEP'
     の最小値になります。 STEP はゼロであってはなりません (さもなければ
     `ValueError' が送出されます)。以下に例を示します:

          >>> range(10)
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
          >>> range(1, 11)
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
          >>> range(0, 30, 5)
          [0, 5, 10, 15, 20, 25]
          >>> range(0, 10, 3)
          [0, 3, 6, 9]
          >>> range(0, -10, -1)
          [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
          >>> range(0)
          []
          >>> range(1, 0)
          []


`raw_input([prompt])'
     引数 PROOMPT が存在する場合、末尾の改行を除いて標準出力に出力
     されます。次に、この関数は入力から 1 行を読み込んで文字列に変換して
     (末尾の改行を除いて) 返します。`EOF' が読み込まれると `EOFError'
     が送出されます。以下に例を示します:

          >>> s = raw_input('--> ')
          --> Monty Python's Flying Circus
          >>> s
          "Monty Python's Flying Circus"

     `readline' モジュールが読み込まれていれば、`input()'
     は精緻な行編集およびヒストリ機能を提供します。

`reduce(function, sequence[, initializer])'
     SEQUENCE の要素に対して、シーケンスを単一の値に短縮するような形で
     2 つの引数をもつ FUNCTION を左から右に累積的に適用します。
     例えば、`reduce(labmda x, y: x+y, [1, 2, 3, 4, 5])' は
     `((((1+2)+3)+4)+5)' を計算します。左引数X は累計の値になり、右引数
     Y は`sequence' から取り出した 更新値になります。オプションの
     INITIALIZER
     が存在する場合、計算の際にシーケンスの先頭に置かれます。また、
     シーケンスが空の場合には標準の値になります。INITIALIZER
     が与えられて おらず、SEQUENCE が単一の要素しか持っていない場合、
     最初の要素が返されます。

`reload(module)'
     すでにインポートされた MODULE を再解釈し、再初期化します。
     引数はモジュールオブジェクトでなければならないので、予めインポート
     に成功していなければなりません。この関数はモジュールのソースコード
     ファイルを外部エディタで編集して、Python インタプリタから
     離れることなく新しいバージョンを試したい際に有効です。 戻り値は
     (MODULE 引数と同じ) モジュールオブジェクトです。

     `reload(module)' を実行すると、以下の処理が行われます:

        * Python モジュールのコードは再コンパイルされ、
          モジュールレベルのコードは再度実行されます。モジュールの辞書中に
          ある、何らかの名前に結び付けられたオブジェクトを新たに定義します。
          拡張モジュール中の`init'
          関数が二度呼び出されることはありません。

        * Python における他のオブジェクトと同様、以前のオブジェクトの
          メモリ領域は、参照カウントがゼロにならないかぎり再利用されません。

        * モジュール名前空間内の名前は新しいオブジェクト
          (または更新された オブジェクト) を指すよう更新されます。

        * 以前のオブジェクトが (外部の他のモジュールなどからの) 参照を
          受けている場合、それらを新たなオブジェクトにバインドし直すことは
          ないので、必要なら自分で名前空間を更新せねばなりません。


     いくつか補足説明があります:

     モジュールは文法的に正しいが、その初期化には失敗した場合、
     そのモジュールの最初の `import' 文はモジュール名を
     ローカルにはバインドしませんが、(部分的に初期化された) モジュール
     オブジェクトを `sys.modules' に記憶します。従って、モジュールを
     ロードしなおすには、`reload()' する前にまず `import'
     (モジュールの名前を部分的に初期化されたオブジェクトにバインドします)
     を再度行わなければなりません。

     モジュールが再ロードされた再、その辞書
     (モジュールのグローバル変数を 含みます)
     はそのまま残ります。名前の再定義を行うと、以前の定義を
     上書きするので、一般的には問題はありません。新たなバージョンのモジュール
     が古いバージョンで定義された名前を定義していない場合、古い定義が
     そのまま残ります。
     辞書がグローバルテーブルやオブジェクトのキャッシュを維持していれば、
     この機能をモジュールを有効性を引き出すために使うことができます --
     つまり、 `try'
     文を使えば、必要に応じてテーブルがあるかどうかをテストし、
     その初期化を飛ばすことができます:

          try:
              cache
          except NameError:
              cache = {}

     組み込みモジュールや動的にロードされるモジュールを再ロードする
     ことは、不正なやり方ではありませんが、一般的にそれほど便利では
     ありません。例外は `sys'、`__main__' および `__builtin__' です。
     しかしながら、多くの場合、拡張モジュールは 1 度以上初期化される
     ようには設計されておらず、再ロードされた場合には何らかの理由で
     失敗するかもしれません。

     一方のモジュールが `from' ... `import' ...
     を使って、オブジェクトを他方のモジュールからインポートしているなら、
     他方のモジュールを `reload()' で呼び出しても、その
     モジュールからインポートされたオブジェクトを再定義することは
     できません -- この問題を回避する一つの方法は、`from' 文を
     再度実行することで、もう一つの方法は `from' 文の代わりに `import'
     と限定的な名前 (MODULE.NAME) を使うことです。

     あるモジュールがクラスのインスタンスを生成している場合、その
     クラスを定義しているモジュールの再ロードはそれらインスタンスの
     メソッド定義に影響しません -- それらは古いクラス定義を使いつづけ
     ます。これは導出クラスの場合でも同じです。

`repr(object)'
     オブジェクトの印字可能な表現を含む文字列を返します。これは
     型変換で得られる (逆クオートの) 値と同じです。通常の関数として
     この操作にアクセスできるとたまに便利です。この関数は多くの型について、
     `eval()' に渡されたときに同じ値を持つようなオブジェクトを
     表す文字列を生成しようとします。

`reversed(seq)'
     要素を逆順に取り出すイテレータ (reverse iterator) を返します。 SEQ
     はシーケンス型プロトコル (`__len__()' メソッド、および `0'
     から始まる整数を引数にとる`__getitem__()' メソッド)
     をサポートしていなければなりません。 _Added in Python version 2.4_

`round(x[, n])'
     X を小数点以下 N 桁で丸めた浮動小数点数の値を返します。 N
     が省略されると、標準の値はゼロになります。結果は浮動小数点
     数です。値は最も近い 10 のマイナス N の倍数に丸められます。
     二つの倍数との距離が等しい場合、ゼロから離れる方向に丸められます
     (従って、例えば `round(0.5)' は `1.0' になり、 `round(-0.5)' は
     `-1.0' になります)。

`set([iterable])'
     集合を表現する`set' 型オブジェクトを返します。要素は ITERABLE
     から取得します。要素は変更不能でなければなりません。
     集合の集合を表現するには、内集合は `frozenset' オブジェクト
     でなければなりません。ITERABLE を指定しない場合、 新たな空の `set'
     型オブジェクト、`set([])' を返します。 _Added in Python version
     2.4_

`setattr(object, name, value)'
     `getattr()' と対をなす関数です。引数はそれぞれオブジェクト、
     文字列、そして任意の値です。文字列はすでに存在する属性の名前でも、
     新たな属性の名前でもかまいません。この関数は指定した値を指定した属性に
     関連付けますが、指定したオブジェクトにおいて可能な場合に限ります。
     例えば、`setattr(X, 'FOOBAR', 123)' は `X.FOOBAR = 123'
     と等価です。

`sorted(iterable[, cmp[, key[, reverse]]])'
     ITERABLE の要素をもとに、並べ替え済みの新たなリストを
     生成して返します。 オプション引数CMP、KEY、および REVERSE の意味は
     `list.sort()' メソッドと同じです。 (*Note
     set（集合）型::節に説明があります。)

     CMP は2つの引数(iterable
     の要素)からなるカスタムの比較関数を指定します。
     これは始めの引数が2つ目の引数に比べて小さい、等しい、大きいかに応じて
     負数、ゼロ、正数を返します。 `CMP=`lambda' X,Y: `cmp'(x.lower(),
     y.lower())'

     KEY
     は1つの引数からなる関数を指定します。これは個々のリストの要素から
     比較のキーを取り出すのに使われます。 `KEY=`str.lower''

     REVERSE は真偽値です。 `True' がセットされた場合、リストの要素は
     個々の比較が反転したものとして並び替えられます。

     一般的に、 KEY および REVERSE の変換プロセスは同等の CMP 関数を
     指定するより早く動作します。これは KEY および REVERSE
     がそれぞれの要素に 一度だけ触れる間に、CMP
     はリストのそれぞれの要素に対して複数回呼ばれることに よるものです。

     _Added in Python version 2.4_

`slice([start,] stop[, step])'
     `range(START, STOP, STEP)' で指定される
     インデクスの集合を表すスライスオブジェクトを返します。
     `range(START)'スライスオブジェクトを返します。 引数 START および
     STEP は標準では `None' です。
     スライスオブジェクトは読み出し専用の属性 `start'、`stop' および
     `step' を持ち、これらは単に引数で使われた値 (または 標準の値)
     を返します。これらの値には、その他のはっきりとした機能は
     ありません; しかしながら、これらの値は Numerical Python  およびその他のサードパーティによる拡張
     で利用されています。スライスオブジェクトは拡張されたインデクス指定
     構文が使われる際にも生成されます。例えば: `a[start:stop:step]' や
     `a[start:stop, i]' です。

`staticmethod(function)'
     FUNCTION の静的メソッドを返します。

     静的メソッドは暗黙の第一引数を受け取りません。
     静的メソッドの宣言は、以下のように書き慣わされます:

          class C:
              @staticmethod
              def f(arg1, arg2, ...): ...

     `@staticmethod' は関数デコレータ形式です。詳しくは {Python
     リファレンスマニュアル} の 7
     章にある関数定義についての説明を参照してください。

     このメソッドはクラスで呼び出すこと (例えば C.f() ) も、
     インスタンスとして呼び出すこと (例えば C().f()) もできます。
     インスタンスはそのクラスが何であるかを除いて無視されます。

     Python における静的メソッドは Java や C++ における静的メソッドと
     類似しています。より進んだ概念については、 `classmethod()'
     を参照してください。

     もっと静的メソッドについての情報が必要ならば、

     の3章にある標準型階層についてのドキュメントを繙いてください。
     _Added in Python version 2.2_ _Changed in Python version 2.4_

`str([object])'
     オブジェクトをうまく印字可能な形に表現したものを含む文字列を返します。
     文字列に対してはその文字列自体を返します。`repr(OBJECT)'
     との違いは、`str(OBJECT)' は常に `eval()' が
     受理できるような文字列を返そうと試みるわけではないという点です;
     この関数の目的は印字可能な文字列を返すところにあります。
     引数が与えられなかった場合、空の文字列 `''' を返します。

`sum(sequence[, start])'
     START と SEQUENCE の要素を左から右へ加算してゆき、
     総和を返します。START はデフォルトで `0' です。 SEQUENCE
     の要素は通常は数値で、文字列であってはなりません。
     文字列からなるシーケンスを結合する高速かつ正しい方法は
     `''.join(SEQUENCE)' です。 `sum(range(N), M)' は
     `reduce(operator.add, range(N), M)' と同等です。 _Added in Python
     version 2.3_

`super(type[, object-or-type])'
     TYPE の上位クラスを返します。返された上位クラスオブジェクトが非バ
     インドの場合、二つめの引数は省略されます。二つめの引数がオブジェクトの場
     合、`isinstance(OBJ, TYPE)' は真でなくてはなりません。
     二つ目の引数が型オブジェクトの場合、`issubclass(TYPE2,  TYPE)'
     は真でなくてはなりません。 `super()'
     は新スタイルのクラスにのみ機能します。

     協調する上位クラスのメソッドを呼び出す典型的な利用法を以下に示します:
          class C(B):
              def meth(self, arg):
                  super(C, self).meth(arg)

     `super' は`super(C, self).__getitem__(name)' のような
     明示的なドット表記の属性参照の一部として使われているので注意してください。
     これに伴って、`super' は`super(C, self)[name]' のような
     文や演算子を使った非明示的な属性参照向けには定義されていないので
     注意してください。

     _Added in Python version 2.2_

`tuple([sequence])'
     SEQUENCE の要素と要素が同じで、かつ順番も同じになるタプルを
     返します。SEQUENCE はシーケンス、反復をサポートするコンテナ、
     およびイテレータオブジェクトをとることができます。 SEQUENCE
     がすでにタプルの場合、そのタプルを変更せずに返します。
     例えば、`tuple('abc')' は `('a', 'b', 'c')' を返し、 `tuple([1, 2,
     3])' は `(1, 2, 3)' を返します。

`type(object)'
     OBJECT の型を返します。オブジェクトの型の検査には `isinstance()'
     組み込み関数を使うことが推奨されます。

     3 引数で呼び出された場合には `type' 関数は後述するように
     コンストラクタとして働きます。

`type(name, bases, dict)'
     新しい型オブジェクトを返します。本質的には `class'
     文の動的な形です。 NAME 文字列はクラス名で、`__name__'
     属性になります。 BASES タプルは基底クラスの羅列で、`__bases__'
     属性になります。 DICT
     辞書はクラス本体の定義を含む名前空間で、`__dict__' 属性になります。
     たとえば、以下の二つの文は同じ `type' オブジェクトを作ります:

            >>> class X(object):
            ...     a = 1
            ...
            >>> X = type('X', (object,), dict(a=1))

     _Added in Python version 2.2_

`unichr(i)'
     Unicode におけるコードが整数 I になるような文字 1 文字からなる
     Unicode 文字列を返します。例えば、`unichr(97)' は文字列 `u'a''
     を返します。この関数は Unicode 文字列に対する `ord()' の逆
     です。引数の正当な範囲は Python
     がどのように構成されているかに依存しています -- UCS2 ならば
     [0..0xFFFF] であり UCS4 ならば [0..0x10FFFF] であり、
     このどちらかです。 それ以外の値に対しては  `ValueError'
     が送出されます。 _Added in Python version 2.0_

`unicode([object[, encoding [, errors]]])'
     以下のモードのうち一つを使って、OBJECT のUnicode 文字列
     バージョンを返します:

     もし ENCODING かつ/または ERRORS が与えられていれば、 `unicode()'
     は 8 ビットの文字列または文字列バッファになっている オブジェクトを
     ENCODING の codec を使ってデコードします。 ENCODING
     パラメタはエンコーディング名を与える文字列です;
     未知のエンコーディングの場合、`LookupError' が送出されます。
     エラー処理は ERRORS に従って行われます; このパラメタは
     入力エンコーディング中で無効な文字の扱い方を指定します。ERRORS が
     `'strict'' (標準の設定です) の場合、エラー発生時には `ValueError'
     が送出されます。一方、`'ignore'' では、
     エラーは暗黙のうちに無視されるようになり、`'replace'' では
     公式の置換文字、`U+FFFD' を使って、デコードできなかった
     文字を置き換えます。`codecs' モジュールについても参照して
     ください。

     オプションのパラメタが与えられていない場合、 `unicode()' は
     `str()' の動作をまねます。ただし、8 ビット文字列ではなく、 Unicode
     文字列を返します。もっと詳しくいえば、 OBJECT が Unicode
     文字列かそのサブクラスなら、デコード処理を一切介する ことなく
     Unicode 文字列を返すということです。

     `__unicode__()' メソッドを提供しているオブジェクトの場合、
     `unicode()' はこのメソッドを引数なしで呼び出して Unicode
     文字列を生成します。それ以外のオブジェクトの場合、 8
     ビットの文字列か、オブジェクトのデータ表現 (representation)
     を呼び出し、その後デフォルトエンコーディングで `'strict'' モードの
     codec を使って Unicode 文字列に変換します。

     _Added in Python version 2.0_ _Changed in Python version 2.2_

`vars([object])'
     引数無しでは、現在のローカルシンボルテーブルに対応する辞書を
     返します。モジュール、クラス、またはクラスインスタンスオブジェクト
     (またはその他 `__dict__' 属性を持つもの) を引数として与えた場合、
     そのオブジェクトのシンボルテーブルに対応する辞書を返します。
     返される辞書は変更すべきではありません:
     変更が対応するシンボルテーブル にもたらす影響は未定義です。(3)

`xrange([start,] stop[, step])'
     この関数は `range()' に非常によく似ていますが、リストの代わり に
     "xrange オブジェクト" を返します。このオブジェクトは不透明な
     シーケンス型で、対応するリストと同じ値を持ちますが、それらの値全てを
     同時に記憶しません。`ragne()' に対する `xrange()'
     の利点は微々たるものです (`xrange()' は要求に応じて
     値を生成するからです) ただし、メモリ量の厳しい計算機で
     巨大な範囲の値を使う時や、(ループがよく `break' で中断
     されるといったように) 範囲中の全ての値を使うとは限らない場合は
     その限りではありません。

     _Note:_ `xrange()' はシンプルさと速度のために定義されている
     関数であり、その実現のために実装上の制限を課している場合があります。
     Python の C 実装では、全ての引数をネイティブの C long 型 (Python
     の "short" 整数型) に制限しており、要素数がネイティブの C long
     型の 範囲内に収まるよう要求しています。


`zip([iterable, ...])'
     この関数はタプルのリストを返します。このリストの I 番目のタプルは
     各引数のシーケンスまたはイテレート可能オブジェクト中の I
     番目の要素を含みます。
     返されるリストは引数のシーケンスのうち長さが最小のものの
     長さに切り詰められます。引数が全て同じ長さの際には、 `zip()'
     は初期値引数が `None' の `map()'
     と似ています。引数が単一のシーケンスの場合、1 要素のタプルからなる
     リストを返します。引数を指定しない場合、空のリストを返します。
     _Added in Python version 2.0_

     _Changed in Python version 2.4_


---------- Footnotes ----------

(1) この関数は比較利用されない
方なので、将来構文にするかどうかは保証できません。

(2)  現状では、`setvbuf()' を持っていないシステムでは、
バッファサイズを指定しても効果はありません。バッファサイズを指定
するためのインタフェースは `setvbuf()' を使っては 行われていません。
何らかの I/O が実行された後で呼び出されるとコアダンプすることが
あり、どのような場合にそうなるかを決定する信頼性のある方法が
ないからです。

(3) 現在の実装では、ローカルな値
のバインディングは通常は影響を受けませんが、(モジュールのような)
他のスコープから取り出した値は影響を受けるかもしれません。また
この実装は変更されるかもしれません。


File: python-lib-jp.info,  Node: 非必須組み込み関数 Non-essential Built-in Functions,  Next: 組み込み例外,  Prev: 組み込み関数,  Up: 組み込みオブジェクト

2.2 非必須組み込み関数 (Non-essential Built-in Functions)
=========================================================

いくつかの組み込み関数は、現代的な Python プログラミングを行う場合には、
必ずしも学習したり、知っていたり、使ったりする必要がなくなりました。
こうした関数は古いバージョンの Python 向け書かれたプログラムとの互換性を
維持するだけの目的で残されています。

Python
のプログラマ、教官、学生、そして本の著者は、こうした関数を飛ばしても
かまわず、その際に何か重要なことを忘れていると思う必要もありません。

`apply(function, args[, keywords])'
     引数 FUNCTION は呼び出しができるオブジェクト (ユーザ定義
     および組み込みの関数またはメソッド、またはクラスオブジェクト)
     でなければなりません。ARGS はシーケンス型でなくてはなりません。
     FUNCTION は引数リスト ARGS を使って呼び出されます;
     引数の数はタプルの長さになります。オプションの引数 KEYWORDS
     を与える場合、 KEYWORDS は文字列のキーを持つ辞書で
     なければなりません。これは引数リストの最後に追加されるキーワード
     引数です。 `apply()' の呼び出しは、単なる `FUNCTION(ARGS)'
     の呼び出しとは異なります。 というのは、`apply()'
     の場合、引数は常に一つだから です。`apply()' は `FUNCTION(*ARGS,
     **KEYWORDS)' を 使うのと等価です。 上のような
     "拡張された関数呼び出し構文" は `apply()'
     と全く等価なので、必ずしも `apply()' を使う必要はありません。
     _This is deprecated in Python 2.3.
     上で述べられたような拡張呼び出し構文を使って ください。_


`buffer(object[, offset[, size]])'
     引数 OBJECT を参照する新たなバッファオブジェクトが生成されます。
     引数 OBJECT は (文字列、アレイ、バッファといった) バッファ
     呼び出しインタフェースをサポートするオブジェクトでなければなりません。
     返されるバッファオブジェクトは OBJECT の先頭 (または OFFSET)
     からのスライスになります。スライスの末端は OBJECT の末端まで
     (または引数 SIZE で与えられた長さになるまで) です。

`coerce(x, y)'
     二つの数値型の引数を共通の型に変換して、変換後の値からなるタプルを
     返します。変換に使われる規則は算術演算における規則と同じです。
     型変換が不可能である場合、`TypeError' を送出します。

`intern(string)'
     STRING を "隔離" された文字列のテーブルに入力し、隔離された
     文字列を返します - この文字列は STRING 自体かコピーです。
     隔離された文字列は辞書検索のパフォーマンスを少しだけ向上させるのに
     有効です - 辞書中のキーが隔離されており、検索するキーが隔離されて
     いる場合、(ハッシュ化後の) キーの比較は文字列の比較ではなくポインタ
     の比較で行うことができるからです。通常、Python プログラム内で
     利用されている名前は自動的に隔離され、モジュール、クラス、
     またはインスタンス属性を保持するための辞書は隔離されたキーを持って
     います。 _Changed in Python version 2.3_


File: python-lib-jp.info,  Node: 組み込み例外,  Next: 組み込み定数,  Prev: 非必須組み込み関数 Non-essential Built-in Functions,  Up: 組み込みオブジェクト

2.3 組み込み例外
================

標準の例外クラス群

例外はクラスオブジェクトです。 例外はモジュール `exceptions'
で定義されています。
このモジュールを明示的にインポートする必要はありません: 例外は
`exceptions' モジュールと同様に組み込み名前空間で 与えられます。

_Note:_  過去の Python
のバージョンでは、文字列の例外がサポートされていました。 Python 1.5
よりも新しいバージョンでは、全ての標準的な例外は
クラスオブジェクトに変換され、ユーザにも同様にするよう奨励しています。
文字列による例外は Python 2.5 以降は `DeprecationWarning' を
送出するようになります。
将来のバージョンでは、文字列による例外のサポートは削除されます。
同じ値を持つ別々の文字列オブジェクトは異なる例外と見なされます。
これはプログラマに対して、例外処理を指定する際に、
文字列ではなく例外名を使わせるための変更です。組み込み例外の文字列値は
全てその名前となりますが、ユーザ定義の例外やライブラリモジュールで定義される
例外についてもそうするように要求しているわけではありません。

`try'  文の中で、`except' 

節を使って特定の例外クラスについて記述した場合、その節は
指定した例外クラスから導出されたクラスも扱います (指定した例外
クラスを導出した元のクラスは含みません)
サブクラス化の関係にない例外クラスが二つあった場合、それらに同じ
名前を付けたとしても、等しくなることはありません。

以下に列挙した組み込み例外はインタプリタや組み込み関数によって生成
されます。特に注記しないかぎり、これらの例外は エラーの詳しい原因を
示している、 "関連値 (associated value)" を持ちます。
この値は文字列または複数の情報 (例えばエラーコードや、エラーコード
を説明する文字列) を含むタプルです。この関連値は `raise'  文の二つ目の引数です。
文字列の例外の場合、関連値自体は `except' 節 (あった場合)
の二つ目の引数として与えた名前を持つ変数に記憶されます。
クラス例外の場合、この値は例外クラスのインスタンスです。
例外が標準のルートクラスである `BaseException' から
導出された場合、関連値は例外インスタンスの `args' 属性中
に置かれます。もし引数が一つならば(このようにすることが望まれますが)、
その引数の値は `message' 属性に収められます。

ユーザによるコードも組み込み例外を送出することができます。
これは例外処理をテストしたり、インタプリタがある例外を送出する 状況と
"ちょうど同じような" エラー条件であることを報告させるために
使うことができます。しかし、ユーザが適切でないエラーを送出するよう
コードするのを妨げる方法はないので注意してください。

組み込み例外クラスは新たな例外を定義するためにサブクラス化する
ことができます; プログラマには、新しい例外を少なくとも `Exception'
クラスから導出するよう勧めます。 `BaseException'
からは導出しないで下さい。 例外を定義する上での詳しい情報は、  の
"ユーザ定義の例外" の項目にあります。

以下の例外クラスは他の例外クラスの基底クラスとしてのみ使われます。

`BaseException'
     全ての組み込み例外のルートクラスです。ユーザ定義例外を直接このクラス
     から導出することは意図していません(そういう場合は `Exception'
     を使ってください)。このクラスに対して `str()' や `unicode()'
     が呼ばれた場合、引数の文字列表現かまたは引数が無
     い時には空文字列が返されます。一つだけの引数が渡された場合、それが
     `message' 属性に格納されます。二つ以上の引数が渡された場合、
     `message' 属性は空文字列になります。こうした振舞いは `message'
     がなぜ例外が送出されたかを説明するメッセージを格納す
     る場所だという事実を反映することを意図しています。例外に対してより多く
     のデータを紐付けたい場合は、インスタンスの任意の属性が利用できます。
     全ての引数は `args' にもタプルとして格納されるようになっていま
     すが、この属性は廃止の方向に向かっていますのでできるだけ使わないように
     する方がいいでしょう。 _Added in Python version 2.5_

`Exception'
     全ての組み込み例外のうち、システム終了でないものはこのクラスから導出
     されています。全てのユーザ定義例外はこのクラスから導出される
     べきです。 _Changed in Python version 2.5_

`StandardError'
     `StopIteration'、`SystemExit'、 `KeyboardInterrupt' および
     `SystemExit' 以外の、全ての組み込み例外の基底クラスです。
     `StandardError' 自体は `Exception' から導出されています。

`ArithmeticError'
     算術上の様々なエラーにおいて送出される組み込み例外:
     `OverflowError'、`ZeroDivisionError'、 `FloatingPointError'
     の基底クラスです。

`LookupError'
     マップ型またはシーケンス型に使ったキーやインデクスが無効な値の場合に
     送出される例外:`IndexError'、`KeyError'
     の基底クラスです。`sys.setdefaultencoding()'
     によって直接送出されることもあります。

`EnvironmentError'
     Python システムの外部で起こっているはずの例外: `IOError'、
     `OSError' の基底クラスです。この型の例外が 2 つの要素を
     もつタプルで生成された場合、最初の要素はインスタンスの `errno'
     属性で得ることができます
     (この値はエラー番号と見なされます)。二つめの 要素は `strerror'
     属性です (この値は通常、エラーに関連する
     メッセージです)。タプル自体は `args' 属性から得ることもできます。
     _Added in Python version 1.5.2_

     `EnvironmentError' 例外が 3 要素のタプルで生成された場合、 最初の
     2 つの要素は上と同様に得ることができる一方、3 つ目の要素は
     `filename' 属性で得ることができます。しかしながら、以前の
     バージョンとの互換性のために、`args' 属性にはコンストラクタに渡した
     最初の 2 つの引数からなる 2 要素のタプルしか含みません。

     この例外が 3 つ以外の引数で生成された場合、`filename' 属性は
     `None' になります。この例外が 2 または 3 つ以外の引数で生成
     された場合、`errno' および `strerror' 属性も `None'
     になります。後者のケースでは、`args' が
     コンストラクタに与えた引数をそのままタプルの形で含んでいます。

以下の例外は実際に送出される例外です。

`AssertionError'
     `assert' 文が失敗した場合に送出されます。

`AttributeError'
     属性の参照や代入が失敗した場合に送出されます。(オブジェクトが
     属性の参照や属性の代入をまったくサポートしていない場合には
     `TypeError' が送出されます。)

`EOFError'
     組み込み関数 (`input()' または  `raw_input()')
     のいずれかで、データを全く読まないうちにファイルの終端 (`EOF') に
     到達した場合に送出されます。 (注意: ファイルオブジェクトの
     `read()' および `readline()'
     メソッドの場合、データを読まないうちに
     `EOF'にたどり着くと空の文字列 を返します。)

`FloatingPointError'
     浮動小数点演算が失敗した場合に送出されます。この例外はどの Python
     のバージョンでも常に定義されていますが、Python が `--with-fpectl'
     オプションをつけた状態に設定されて いるか、`pyconfig.h'
     ファイルにシンボル `WANT_SIGFPE_HANDLER' が定義されている場合にのみ
     送出されます。

`GeneratorExit'
     ジェネレータの `close()' メソッドが呼び出されたときに送出されま
     す。この例外は技術的にはエラーでないので `StandardError' ではなく
     `Exception' から導出されています。 _Added in Python version 2.5_

`IOError'
     (`print' 文、組み込みの `open()' またはファイル
     オブジェクトに対するメソッドといった) I/O 操作が、例えば
     "ファイルが存在しません" や "ディスクの空き領域がありません"
     といった I/O に関連した理由で失敗した場合に送出されます。

     このクラスは `EnvironmentError' から導出されています。
     この例外クラスのインスタンス属性に関する情報は上記の
     `EnvironmentError' に関する議論を参照してください。

`ImportError'
     `import' 文でモジュール定義を見つけられなかった場合や、 `from
     ...import' 文で指定した名前をインポート
     することができなかった場合に送出されます。

`IndexError'
     シーケンスのインデクス指定がシーケンスの範囲を超えている場合に送出
     されます。(スライスのインデクスはシーケンスの範囲に収まるように暗黙のうちに
     調整されます; インデクスが通常の整数でない場合、`TypeError'
     が送出されます。)

`KeyError'
     マップ型 (辞書型) オブジェクトのキーが、オブジェクトのキー集合内に
     見つからなかった場合に送出されます。

`KeyboardInterrupt'
     ユーザが割り込みキー (通常は <Control-C> または <Delete> キー
     です)
     を押した場合に送出されます。割り込みが起きたかどうかはインタプリタ
     の実行中に定期的に調べられます。 組み込み関数 `input()' や
     `raw_input()' がユーザの
     入力を待っている間に割り込みキーを押しても、この例外が送出されます。
     この例外は `Exception' を捕まえるコードに間違って捕まってイ
     ンタプリタが終了するのを阻止されないように  `BaseException'
     から導出されています。 _Changed in Python version 2.5_

`MemoryError'
     ある操作中にメモリが不足したが、その状況は (オブジェクトをいくつか
     消去することで) まだ復旧可能かもしれない場合に送出されます。
     例外に関連づけられた値は、どの種の (内部)
     操作がメモリ不足になっている
     かを示す文字列です。背後にあるメモリ管理アーキテクチャ (C の
     `malloc()' 関数) によっては、インタプリタが常にその状況
     を完璧に復旧できるとはかぎらないので注意してください; プログラムの
     暴走が原因の場合にも、やはり実行スタックの追跡結果を出力
     できるようにするために例外が送出されます。

`NameError'
     ローカルまたはグローバルの名前が見つからなかった場合に送出されます。
     これは非限定の名前のみに適用されます。関連付けられた値は見つからなかった
     名前を含むエラーメッセージです。

`NotImplementedError'
     この例外は `RuntimeError' から導出されています。ユーザ定義の
     基底クラスにおいて、そのクラスの導出クラスにおいてオーバライドする
     ことが必要な抽象化メソッドはこの例外を送出しなくてはなりません。
     _Added in Python version 1.5.2_

`OSError'
     このクラスは `EnvironmentError' から導出されており、 主に `os'
     モジュールの `os.error' 例外で使われて
     います。例外に関連付けられる可能性のある値については、上記の
     `EnvironmentError' を参照してください。 _Added in Python version
     1.5.2_

`OverflowError'
     算術演算の結果、表現するには大きすぎる値になった場合に送出されます。
     これは長整数の演算では起こりません (長整数の演算ではむしろ
     `MemoryError' が送出されることになるでしょう)。 C
     では浮動小数点演算における例外処理の標準化が行われていないので、
     ほとんどの浮動小数点演算もチェックされていません。通常の整数では、
     オーバフローを起こす全ての演算がチェックされます。例外は左シフトで、
     典型的なアプリケーションでは左シフトのオーバフローでは例外を送出する
     よりもむしろ、オーバフローしたビットを捨てるようにしています。

`ReferenceError'
     ``weakref'.proxy()' によって生成された弱参照 (weak reference)
     プロキシを使って、ガーベジコレクションによって処理
     された後の参照対象オブジェクトの属性にアクセスした場合に送出されます。
     弱参照については `weakref' モジュールを参照してください。 _Added
     in Python version 2.2_

`RuntimeError'
     他のカテゴリに分類できないエラーが検出された場合に送出されます。
     関連付けられた値は何が問題だったのかをより詳細に示す文字列です。
     (この例外はほとんど過去のバージョンのインタプリタにおける遺物です;
     この例外はもはやあまり使われることはありません)

`StopIteration'
     イテレータの `next()' メソッドにより、それ以上要素がないことを
     知らせるために送出されます。
     この例外は、通常のアプリケーションではエラーとはみなされないので、
     `StandardError' ではなく `Exception' から導出 されています。
     _Added in Python version 2.2_

`SyntaxError'
     パーザが構文エラーに遭遇した場合に送出されます。この例外は
     `import' 文、`exec' 文、組み込み関数 `evel()' や
     `input()'、初期化スクリプトの 読み込みや標準入力で
     (対話的な実行時にも) 起こる可能性があります。

     このクラスのインスタンスは、例外の詳細に簡単にアクセスできるように
     するために、属性 `filename'、`lineno'、 `offset' および `text'
     を持ちます。 例外インスタンスに対する `str()'
     はメッセージのみを返します。

`SystemError'
     インタプリタが内部エラーを発見したが、その状況は全ての望みを
     棄てさせるほど深刻ではないように思われる場合に送出されます。
     関連づけられた値は (控えめな言い方で)
     何がまずいのかを示す文字列です。

     Python の作者か、あなたの Python インタプリタを保守している人に
     このエラーを報告してください。このとき、 Python インタプリタの
     バージョン (`sys.version'; Python の対話的セッションを開始した
     際にも出力されます)、正確なエラーメッセージ
     (例外に関連付けられた値) を忘れずに報告してください。
     そしてもし可能ならエラーを引き起こしたプログラムのソースコードを
     報告してください。

`SystemExit'
     この例外は `sys.exit()' 関数によって送出されます。この例外が
     処理されなかった場合、Python インタプリタは終了します; スタックの
     トレースバックは全く印字されません。関連付けられた値が通常の整数
     である場合、システム終了状態を指定しています (`exit()' 関数に
     渡されます); 値が `None'の場合、終了状態はゼロです;
     (文字列のような)
     他の型の場合、そのオブジェクトの値が印字され、終了状態は 1
     になります。

     この例外のインスタンスは属性 `code' を持ちます。この値は
     終了状態またはエラーメッセージ (標準では `None' です) に
     設定されます。また、この例外は技術的にはエラーではないため、
     `StandardError' からではなく、`BaseException' から
     導出されています。

     `sys.exit()' は、後始末のための処理 (`try' 文の `finally' 節)
     が実行されるようにするため、またデバッガが
     制御不能になるリスクを冒さずにスクリプトを実行できるようにするために
     例外に翻訳されます。即座に終了することが真に強く必要であるとき
     (例えば、`fork()' を呼んだ後の子プロセス内) には `os._exit()'
     関数を使うことができます。

     この例外は `Exception' を捕まえるコードに間違って捕まえられ
     ないように、`StandardError' や `Exception' からで はなく
     `BaseException' から導出されています。これにより、
     この例外は着実に呼出し元の方に伝わっていってインタプリタを終了させます。
     _Changed in Python version 2.5_

`TypeError'
     組み込み演算または関数が適切でない型のオブジェクトに対して適用
     された際に送出されます。関連付けられる値は型の不整合に関して
     詳細を述べた文字列です。

`UnboundLocalError'
     関数やメソッド内のローカルな変数に対して参照を行ったが、その変数には
     値がバインドされていなかった際に送出されます。`NameError'
     のサブクラスです。 _Added in Python version 2.0_

`UnicodeError'
     Unicode に関するエンコードまたはデコードのエラーが発生した際に送出
     されます。`ValueError' のサブクラスです。 _Added in Python version
     2.0_

`UnicodeEncodeError'
     Unicode 関連のエラーがエンコード中に発生した際に送出されます。
     `UnicodeError' のサブクラスです。 _Added in Python version 2.3_

`UnicodeDecodeError'
     Unicode 関連のエラーがデコード中に発生した際に送出されます。
     `UnicodeError' のサブクラスです。 _Added in Python version 2.3_

`UnicodeTranslateError'
     Unicode 関連のエラーがコード翻訳に発生した際に送出されます。
     `UnicodeError' のサブクラスです。 _Added in Python version 2.3_

`ValueError'
     組み込み演算や関数が、正しい型だが適切でない値を受け取った場合、
     および `IndexError' のように、より詳細な説明のできない
     状況で送出されます。

`WindowsError'
     Windows 特有のエラーか、エラー番号が `errno' 値に対応しない
     場合に送出されます。`winerrno' および `strerror' 値は Windows
     プラットフォーム API の関数、 `GetLastError()' と
     `FormatMessage()' の戻り値から生成されます。 `errno' の値は
     `winerror' 値を対応する `errno.h' の値に対応付けたものです。

     `OSError' のサブクラスです。 _Added in Python version 2.0_
     _Changed in Python version 2.5_

`ZeroDivisionError'
     除算またモジュロ演算における二つ目の引数がゼロであった場合に
     送出されます。関連付けられている値は文字列で、その演算における
     被演算子の型を示します。

以下の例外は警告カテゴリとして使われます; 詳細については `warnings'
モジュールを参照してください。

`Warning'
     警告カテゴリの基底クラスです。

`UserWarning'
     ユーザコードによって生成される警告の基底クラスです。

`DeprecationWarning'
     廃用された機能に対する警告の基底クラスです。

`PendingDeprecationWarning'
     将来廃用されることになっている機能に対する警告の基底クラスです。

`SyntaxWarning'
     曖昧な構文に対する警告の基底クラスです。

`RuntimeWarning'
     あいまいなランタイム挙動に対する警告の基底クラスです。

`FutureWarning'
     将来意味構成が変わることになっている文の構成に対する警告の基底クラスです。

`ImportWarning'
     モジュールインポートの誤りと思われるものに対する警告の基底クラスです。
     _Added in Python version 2.5_

`UnicodeWarning'
     ユニコードに関連した警告の基底クラスです。 _Added in Python
     version 2.5_

組み込み例外のクラス階層は以下のようになっています:

`exception_hierarchy.txt'


File: python-lib-jp.info,  Node: 組み込み定数,  Prev: 組み込み例外,  Up: 組み込みオブジェクト

2.4 組み込み定数
================

組み込み空間には少しだけ定数があります。以下にそれらの定数を示します:

`False'
     `bool' 型における、偽を表す値です。 _Added in Python version 2.3_

`True'
     `bool' 型における、真を表す値です。 _Added in Python version 2.3_

`None'
     ``types'.NoneType' の唯一の値です。 `None'
     は、例えば関数にデフォルトの値が渡されないときのように、
     値がないことを表すためにしばしば用いられます。

`NotImplemented'
     "特殊な比較 (rich comparison)" を行う特殊メソッド
     (`__eq__()'、`__lt__()'、およびその仲間) に対して、
     他の型に対しては比較が実装されていないことを示すために返される値です。

`Ellipsis'
     拡張スライス文と同時に用いられる特殊な値です。


File: python-lib-jp.info,  Node: 組み込み型,  Next: 文字列処理,  Prev: 組み込みオブジェクト,  Up: Top

3 組み込み型
************

以下のセクションでは、インタプリタに組み込まれている標準の型に
ついて記述します。 _Note:_ これまでの(リリース 2.2 までの) Python
の歴史では、組み込み型は
オブジェクト指向における継承を行う際に雛型にできないという点で、
ユーザ定義型とは異なっていました。いまではこのような制限はなくなっています。

主要な組み込み型は数値型、シーケンス型、マッピング型、ファイル、クラス、
インスタンス型、および例外です。 

演算によっては、複数の型でサポートされているものがあります;
特に、ほぼ全てのオブジェクトについて、比較、真値テスト、 (`repr()'
関数や、わずかに異なる `str()' 関数 による) 文字列への
変換を行うことができます。オブジェクトが`print' 

によって書かれていると、後の方の文字列への変換が暗黙に行われます
(Information on `print' 文 やその他の文に関する情報は  および

で見つけることができます。)

* Menu:

* 真値テスト::
* ブール演算::
* 比較::
* 数値型 int::
* イテレータ型::
* シーケンス型 str::
* set（集合）型::
* マップ型::
* ファイルオブジェクト::
* コンテキストマネージャ型::
* 他の組み込み型::
* 特殊な属性::


File: python-lib-jp.info,  Node: 真値テスト,  Next: ブール演算,  Prev: 組み込み型,  Up: 組み込み型

3.1 真値テスト
==============

どのオブジェクトも `if' または `while' 条件文の中や、
以下のブール演算における被演算子として真値テストを行うことができます。
以下の値は偽であると見なされます: 

   * `None' 

   * `False' 

   * 数値型におけるゼロ。例えば `0' 、 `0L' 、 `0.0' 、 `0j' 。

   * 空のシーケンス型。例えば `''' 、 `()' 、 `[]' 。

   * 空のマッピング型。例えば `@' 。

   * `__nonzero__()' または `__len__()' メソッドが
     定義されているようなユーザ定義クラスのインスタンスで、それらのメソッド
     が整数値ゼロまたは `bool' 値の `False' を返すとき。 (1)


それ以外の値は全て真であると見なされます -- 従って、ほとんどの型
のオブジェクトは常に真です。 

ブール値の結果を返す演算および組み込み関数は、特に注釈のない限り常に
偽値として `0' または`False' を返し、真値として `1' または `True'
を返します (重要な例外: ブール演算 `or'  および `and'  は常に被演算子
の中の一つを返します)。 

---------- Footnotes ----------

(1) これらの特殊なメソッドに関する追加情報は に記載されています。


File: python-lib-jp.info,  Node: ブール演算,  Next: 比較,  Prev: 真値テスト,  Up: 組み込み型

3.2 `and', `or', `not'
======================

以下にブール演算子を示します。優先度の低いものから順に並んでいます。: 

演算                     結果                     注釈
------                   -----                    -----
X or Y                   X が偽なら Y             (1)
                         、そうでなければ X       
X and Y                  X が偽なら X             (1)
                         、そうでなければ Y       
not X                    X が偽なら `True'        (2)
                         、そうでなければ         
                         `False'                  

注釈:

`(1)'
     これらの演算子は、演算を行う上で必要がない限り、二つ目の引数を評価しません。

`(2)'
     `not' は非ブール演算子よりも低い演算優先度なので、 `not A == B' は
     `not (A == B)' と評価され、 `A == not B' は構文エラーとなります。


File: python-lib-jp.info,  Node: 比較,  Next: 数値型 int,  Prev: ブール演算,  Up: 組み込み型

3.3 比較
========

比較演算は全てのオブジェクトでサポートされています。比較演算子は
全て同じ演算優先度を持っています (ブール演算より高い演算優先度です)。
比較は任意の形で連鎖させることができます; 例えば、`X < Y <= Z' は `X <
Y および  Y <= Z' と等価で、違うのは Y が一度だけしか評価
されないということです (どちらの場合でも、 `X < Y' が偽となった場合には
Z は評価されません) 。 

以下のテーブルに比較演算をまとめます:

演算                     意味                     注釈
------                   -----                    -----
<                        より小さい               
<=                       以下                     
>                        より大きい               
>=                       以上                     
==                       等しい                   
!=                       等しくない               (1)
<>                       等しくない               (1)
is                       同一のオブジェクトである 
is not                   同一のオブジェクトでない 

注釈:

`(1)'
     `<>' および `!=' は同じ演算子を別の書き方にしたものです。 `!='
     のほうが望ましい書き方です; `<>' は廃止すべき書き方です。


数値型間の比較か文字列間の比較でないかぎり、異なる型のオブジェクトを
比較しても等価になることはありません; これらのオブジェクトの順番付けは
一貫してはいますが任意のものです (従って要素の型が一様でないシーケンスを
ソートした結果は一貫したものになります)。
さらに、(例えばファイルオブジェクトのように) 型によっては、 その型の 2
つのオブジェクトの不等性だけの、縮退した比較の概念
しかサポートしないものもあります。繰り返しますが、
そのようなオブジェクトも任意の順番付けをされていますが、
それは一貫したものです。被演算子が複素数の場合、演算子 `<' 、 `<=' 、
`>' および `>=' は 例外 `TypeError' を送出します。 

あるクラスのインスタンス間の比較は、そのクラスで `__cmp__()'
メソッドが定義されていない限り等しくなりません。 このメソッドを使ってオブジェクトの比較方法に影響を及ぼすための
情報については

を参照してください。

*実装に関する注釈:* 数値型を除き、異なる型のオブジェクトは
型の名前で順番付けされます; 適当な比較をサポートしていないある型の
オブジェクトはアドレスによって順番付けされます。

同じ優先度を持つ演算子としてさらに 2 つ、シーケンス型でのみ `in'  および
`not in'  が サポートされています (以下を参照)。


File: python-lib-jp.info,  Node: 数値型 int,  Next: イテレータ型,  Prev: 比較,  Up: 組み込み型

3.4 数値型 `int', `float', `long', `complex'
============================================

4 つの異なる数値型があります: "通常の整数型" 、 "長整数型"
、"浮動小数点型" 、および "複素数型" です。

さらに、ブール方は通常の整数型のサブタイプです。通常の整数 (単に
"整数型" とも呼ばれます) は C では `long' を
使って実装されており、少なくとも 32 ビットの精度があります
(`sys.maxint' は常に通常の整数の各プラットフォームにおける
最大値にセットされており、最小値は `-sys.maxint - 1' になります)。
長整数型には精度の制限がありません。浮動小数点型は C では `double'
を使って実装されています。しかし使っている計算機
が何であるか分からないなら、これらの数値型の精度に関して断言はできません。 

複素数型は実数部と虚数部を持ち、それぞれの C では `double' を
使って実装されています。複素数 Z から実数および虚数部を取り出す
には、`Z.real' および `Z.imag' を使います。

数値は、数値リテラルや組み込み関数や演算子の戻り値として生成されます。
修飾のない整数リテラル (16 進表現や 8 進表現の値も含みます) は、
通常の整数値を表します。値が通常の整数で表すには大きすぎる場合、 `L'
または `l' が末尾につく整数リテラル は長整数型を表します (`L'
が望ましいです。というのは `1l' は 11 と非常に紛らわしいからです！)
小数点または 指数表記のある数値リテラルは浮動小数点数を表します。
数値リテラルに `j' または `J' をつけると
実数部がゼロの複素数を表します。複素数の数値リテラルは実数部と
虚数部を足したものです。

Python は型混合の演算を完全にサポートします: ある 2 項演算子が
互いに異なる数値型の被演算子を持つ場合、より "制限された" 型の
被演算子は他方の型に合わせて広げられます。ここで通常の整数は
長整数より制限されており、長整数は浮動小数点数より制限されており、
浮動小数点は複素数より制限されています。
型混合の数値間での比較も同じ規則に従います。 (1) コンストラクタ `int()'
、`long()' 、`float()'、 および `complex()'
を使って、特定の型の数を生成することが できます。 

全ての数値型（complex
は例外）は以下の演算をサポートします。これらの演算は
優先度の低いものから順に並べられています (同じボックスにある演算は
同じ優先度を持っています; 全ての数値演算は比較演算よりも
高い優先度を持っています):

演算                     結果                     注釈
------                   -----                    -----
X + Y                    X と Y の和              
X - Y                    X と Y の差              
X * Y                    X と Y の積              
X / Y                    X と Y の商              (1)
X // Y                   X と Y                   (5)
                         の商(を切り下げたもの)   
X %{} Y                  `X / Y' の剰余           (4)
-X                       X の符号反転             
+X                       X の符号不変             
abs(X)                   X の絶対値または大きさ   
int(X)                   X の通常整数への変換     (2)
long(X)                  X の長整数への変換       (2)
float(X)                 X                        
                         の浮動小数点数への変換   
complex(RE,IM)           実数部 RE 、虚数部 IM    
                         の複素数。 IM            
                         のデフォルト値はゼロ。   
C.conjugate()            複素数 C の共役複素数    
divmod(X, Y)             `(X // Y, X %{} Y)'      (3)
                         からなるペア             
pow(X, Y)                X の Y 乗                
X ** Y                   X の Y 乗                

注釈:
`(1)'
     (通常および長) 整数の割り算では、結果は整数になります。
     この場合値は常にマイナス無限大の方向に丸められます: つまり、1/2 は
     0、 (-1)/2 は -1、1/(-1) は -1、そして (-1)/(-2) は 0 になります。
     被演算子の両方が長整数の場合、計算値に関わらず結果は長整数で返される
     ので注意してください。 

`(2)'
     浮動小数点数から (通常または長) 整数への変換では、C
     におけるのと同様の 値の丸めまたは切り詰めが行われるかもしれません;
     きちんと定義された 変換については、`math'  モジュールの `floor()'
     および `ceil()' を参照してください。 

`(3)'
     完全な記述については、*Note 組み込み関数::、"組み込み関数"
     を参照してください。

`(4)'
     複素数の切り詰め除算演算子、モジュロ演算子、および `divmod()'。

     _This is deprecated in Python 2.3.  適切であれば、`abs()'
     を使って浮動小数点に変換してください。_

`(5)'
     整数の除算とも呼ばれます。結果の値は整数ですが、整数型(int)とは限りません。

* Menu:

* Bit-string Operations::

---------- Footnotes ----------

(1) この結果として、リスト `[1, 2]' は `[1.0, 2.0]'
と等しいと見なされます。タプルの場合も同様です


File: python-lib-jp.info,  Node: Bit-string Operations,  Prev: 数値型 int,  Up: 数値型 int

3.4.1 整数型におけるビット列演算
--------------------------------

通常および長整数型ではさらに、ビット列に対してのみ意味のある
演算をサポートしています。負の数はその値の 2 の補数の値として扱われます
(長整数の場合、演算操作中にオーバフローが起こらないように十分なビット数
があるものと仮定します) 。

2 進のビット単位演算は全て、数値演算よりも低く、比較演算子よりも高い
優先度です; 単項演算 `~' は他の単項数値演算 (`+' および `-')
と同じ優先度です。

以下のテーブルでは、ビット列演算を優先度の低いものから順に並べています
(同じボックス内の演算は同じ優先度です):

演算                     結果                     注釈
------                   -----                    -----
X | Y                    ビット単位の X と Y の   
                         "論理和"                 
X ^{} Y                  ビット単位の X と Y の   
                         "排他的論理和"           
X &{} Y                  ビット単位の X と Y の   
                         "論理積"                 
X <{}< N                 X の N ビット左シフト    (1), (2)
X >{}> N                 X の N ビット右シフト    (1), (3)
~X                       X のビット反転           

注釈:
`(1)'
     負値のシフト数は不正であり、`ValueError' が送出 されます。

`(2)'
     N ビットの左シフトは、オーバフローチェックを行わない `pow(2, N)'
     による乗算と等価です。

`(3)'
     N ビットの右シフトは、オーバフローチェックを行わない `pow(2, N)'
     による除算と等価です。


File: python-lib-jp.info,  Node: イテレータ型,  Next: シーケンス型 str,  Prev: 数値型 int,  Up: 組み込み型

3.5 イテレータ型
================

_Added in Python version 2.2_ 

Python はコンテナの内容にわたって反復処理を行う概念をサポートして
います。この概念は 2 つの別々のメソッドを使って実装されています;
これらのメソッドはユーザ定義のクラスで反復を行えるようにするために
使われます。後に詳しく述べるシーケンス型はすべて反復処理メソッドを
サポートしています。

以下はコンテナオブジェクトに反復処理をサポートさせるために定義しなければ
ならないメソッドです:

`__iter__()'
     イテレータオブジェクトを返します。イテレータオブジェクトは以下で述べる
     イテレータプロトコルをサポートする必要があります。あるコンテナが
     異なる形式の反復処理をサポートする場合、それらの反復処理形式
     のイテレータを特定的に要求するようなメソッドを追加することができます
     (複数の形式での反復処理をサポートするようなオブジェクトとして
     木構造の例があります。木構造は幅優先走査と深さ優先走査の両方を
     サポートします)。 このメソッドは Python/C API において Python
     オブジェクトを表す 型構造体の `tp_iter' スロットに対応します。

イテレータオブジェクト自体は以下の 2 のメソッドをサポートする必要
があります。これらのメソッドは 2 つ合わせて "イテレータプロトコル"
を成します:

`__iter__()'
     イテレータオブジェクト自体を返します。このメソッドはコンテナとイテレータの
     両方を`for' および `in' 文で使えるようにするために
     必要です。このメソッドは Python/C API において Python
     オブジェクトを表す 型構造体の `tp_iter' スロットに対応します。

`next()'
     コンテナ内の次の要素を返します。もう要素が残っていない場合、 例外
     `StopIteration' を送出します。このメソッドは Python/C API において
     Python オブジェクトを表す型構造体の `tp_iternext'
     スロットに対応します。

Python では、いくつかのイテレータオブジェクトを定義しています。これらは
一般的および特殊化されたシーケンス型、辞書型、そして他のさらに特殊化
された形式をサポートします。特殊型であることはイテレータプロトコル
の実装が特殊になること以外は重要なことではありません。

このプロトコルの趣旨は、 一度イテレータの `next()' メソッドが
`StopIteration'
例外を送出した場合、以降の呼び出しでもずっと例外を送出しつづける
ところにあります。この特性に従わないような実装は変則であると
みなされます (この制限は Python 2.3 で追加されました; Python 2.2
では、この規則に従うと多くのイテレータが変則となります)。

Python におけるジェネレータ (generator) は、イテレータプロトコル
を実装する簡便な方法を提供します。コンテナオブジェクトの `__iter__()'
メソッドがジェネレータとして実装されて いれば、メソッドは `__iter__()'
および `next()' メソッドを提供するイテレータオブジェクト
(技術的にはジェネレータ オブジェクト) を自動的に返します。


File: python-lib-jp.info,  Node: シーケンス型 str,  Next: set（集合）型,  Prev: イテレータ型,  Up: 組み込み型

3.6 シーケンス型 `str', `unicode', `list', `tuple', `buffer', `xrange'
======================================================================

組み込み型には 6 つのシーケンス型があります: 文字列、ユニコード文字列、
リスト、タプル、バッファ、そして xrange オブジェクトです。

文字列リテラルは `'xyzzy''、`"frobozz"' といったように、
単引用符または二重引用符の中に書かれます。
文字列リテラルについての詳細はは、

の第 2 章を読んで下さい。 Unicode
文字列はほとんど文字列と同じですが、`u'abc'' 、 `u"def"'
といったように先頭に文字 `u' を付けて 指定します。 リストは `[a, b, c]'
のように要素をコンマで区切り角括弧で 囲って生成します。タプルは `a, b,
c' のようにコンマ演算子で 区切って生成します
(角括弧の中には入れません)。
丸括弧で囲っても囲わなくてもかまいませんが、空のタプルは `()'
のように丸括弧で囲わなければなりません。 要素が一つのタプルでは、例えば
`(d,)' のように、要素の後ろに コンマをつけなければなりません。 

バッファオブジェクトは Python の構文上では直接サポートされていませんが、
組み込み関数 `buffer()' 

で生成することができます。バッファオブジェクトは結合や反復をサポート
していません。 

xrange オブジェクトは、オブジェクトを生成するための特殊な構文がない
点でバッファに似ていて、関数 `xrange()' で生成します。 xrange
オブジェクトはスライス、結合、反復をサポートせず、 `in' 、 `not in'
、`min()' または `max()' は効率的ではありません。 

ほとんどのシーケンス型は以下の演算操作をサポートします。`in' および
`not in' は比較演算とおなじ優先度を持っています。 `+' および `*'
は対応する数値演算とおなじ優先度です。 (1)

以下のテーブルはシーケンス型の演算を優先度の低いものから順に挙げたものです
(同じボックス内の演算は同じ優先度です)。テーブル内の S および T
は同じ型のシーケンスです; N、I および J は整数です:

演算                     結果                     注釈
------                   -----                    -----
X in S                   S のある要素 X           (1)
                         と等しい場合 `True'      
                         、そうでない場合         
                         `False'                  
X not in S               S のある要素が X         (1)
                         と等しい場合 `False'     
                         、そうでない場合 `True'  
S + T                    S および T の結合        (6)
S * N, N * S             S の浅いコピー N         (2)
                         個からなる結合           
S[I]                     S の 0 から数えて I      (3)
                         番目の要素               
S[I:J]                   S の I 番目から J        (3), (4)
                         番目までのスライス       
S[I:J:K]                 S の I 番目から J        (3), (5)
                         番目まで、K              
                         毎のスライス             
len(S)                   S の長さ                 
min(S)                   S の最小の要素           
max(S)                   S の最大の要素           

注釈:

`(1)'
     S が文字列または Unicode 文字列の場合、 演算操作 `in' および `not
     in' は部分文字列の一致テスト と同じように動作します。バージョン
     2.3 以前の Python では、 X は長さ 1 の文字列でした。Python 2.3
     以降では、X はどの長さでもかまいません。

`(2)'
     N が `0' 以下の値の場合、`0' として 扱われます (これは S
     と同じ型の空のシーケンスを表します)。
     コピーは浅いコピーなので注意してください; 入れ子になったデータ
     構造はコピーされません。これは Python に慣れていないプログラマを
     よく悩ませます。例えば以下のコードを考えます:

          >>> lists = [[]] * 3
          >>> lists
          [[], [], []]
          >>> lists[0].append(3)
          >>> lists
          [[3], [3], [3]]

     上のコードでは、 `lists' はリスト `[[]]' (空のリストを唯一の
     要素として含んでいるリスト) の3つのコピーを要素とするリストです。
     しかし、リスト内の要素に含まれているリストは各コピー間で共有されています。
     以下のようにすると、異なるリストを要素とするリストを生成できます:
     上のコードで、`[[]]'
     は空のリストを要素として含んでいるリストですから、 `[[]] * 3'
     の3つの要素の全てが、空のリスト（への参照）になります。 `lists'
     のいずれかの要素を修正することでこの単一のリストが変更されます。以下のようにすると、異なる個別のリストを生成できます:

          >>> lists = [[] for i in range(3)]
          >>> lists[0].append(3)
          >>> lists[1].append(5)
          >>> lists[2].append(7)
          >>> lists
          [[3], [5], [7]]

`(3)'
     I または J が負の数の場合、インデクスは文字列の
     末端からの相対インデクスになります: `len(S) + I' または `len(S) +
     J' が代入されます。 しかし `-0' は `0'
     のままなので注意してください。

`(4)'
     S の I から J へのスライスは `I <= K < J' となるようなインデクス K
     を持つ要素からなるシーケンスとして定義されます。I または J が
     `len(S)' よりも大きい場合、`len(S)' を使います。 I が省略されるか
     `None' だった場合、`0' を使います。 J が省略されるか `None'
     だった場合、`len(S)' を使います。 I が J
     以上の場合、スライスは空のシーケンスになります。

`(5)'
     S の I 番目から J 番目まで K 毎のスライスは、$0 <=n < {j-i}{k}$
     となるような、 インデクス`X = I + N*K' を持つ要素からなる
     シーケンスとして定義されます。言い換えるとインデクスは `i'、`i+k'、
     `i+2*k'、`i+3*k' などであり、J に達したところ (しかし J
     は含みません)でストップします。 I または J が `len(S)'
     より大きい場合、`len(S)' を使います。I または J を省略するか
     `None' だった場合、"最後" (K の符号に依存)を示す値を使います。K
     はゼロにできないので 注意してください。K が `None' だった場合、`1'
     として扱われます。

`(6)'
     S と T の両者が文字列であるとき、CPythonのような実装では、 `S=S+T'
     や `S+=T'という書式で 代入をするのにin-place
     optimizationが働きます。このような時、最適化は二
     乗の実行時間の低減をもたらします。この最適化はバージョンや実装に依存し
     ます。実行効率が必要なコードでは、バージョンと実装が変わっても、直線的
     な連結の実行効率を保証する`str.join()' を使うのがより望ましいで
     しょう。 _Changed in Python version 2.4_


* Menu:

* 文字列メソッド::
* 文字列フォーマット操作::
* XRange 型::
* 変更可能なシーケンス型::

---------- Footnotes ----------

(1)
パーザが被演算子の型を識別できるようにするために、このような優先度でなければならないのです。


File: python-lib-jp.info,  Node: 文字列メソッド,  Next: 文字列フォーマット操作,  Prev: シーケンス型 str,  Up: シーケンス型 str

3.6.1 文字列メソッド
--------------------

以下は 8 ビット文字列および Unicode オブジェクトでサポートされる
メソッドです:

`capitalize()'
     最初の文字を大文字にした文字列のコピーを返します。

     8ビット文字列では、メソッドはロケール依存になります。

`center(width[, fillchar])'
     WIDTH の長さをもつ中央寄せされた文字列を返します。パディングには
     FILLCHAR で指定された値（デフォルトではスペース）が使われます。
     _Changed in Python version 2.4_

`count(sub[, start[, end]])'
     文字列 S`[START:END]' 中に部分文字列 SUB
     が出現する回数を返します。オプション引数 START および END
     はスライス表記と同じように解釈されます。

`decode([encoding[, errors]])'
     codec に登録された文字コード系 ENCODING を使って文字列をデコード
     します。ENCODING は標準でデフォルトの文字列エンコーディング
     になります。標準とは異なるエラー処理を行うために ERRORS を
     与えることができます。標準のエラー処理は `'strict'' で、エンコード
     に関するエラーは `UnicodeError' を送出します。 他に利用できる値は
     `'ignore'' 、 `'replace'' および 関数 `codecs.register_error'
     によって登録された名前です。 これについてはセクション~*Note Codec
     基底クラス::節を参照してください。 _Added in Python version 2.2_
     _Changed in Python version 2.3_

`encode([encoding[,errors]])'
     文字列のエンコードされたバージョンを返します。標準のエンコーディング
     は現在のデフォルト文字列エンコーディングです。
     標準とは異なるエラー処理を行うために ERRORS を
     与えることができます。標準のエラー処理は `'strict'' で、エンコード
     に関するエラーは `UnicodeError' を送出します。 他に利用できる値は
     `'ignore'' 、 `'replace'' 、 `'xmlcharrefreplace''、
     `'backslashreplace'' および 関数 `codecs.register_error'
     によって登録された名前です。 これについてはセクション~*Note Codec
     基底クラス::を参照してください。
     利用可能なエンコーディングの一覧は、セクション~*Note
     利用可能なデータ型:: を参照してください。

     _Added in Python version 2.0_ _Changed in Python version 2.3_

`endswith(suffix[, start[, end]])'
     文字列の一部が SUFFIX で終わるときに `True' を返します。そう
     でない場合 `False' を返します。SUFFIX は見つけたい複数の接尾語
     のタプルでも構いません。オプション引数 START がある場 合、文字列の
     START から比較を始めます。END がある場合、文字 列の END
     で比較を終えます。

     _Changed in Python version 2.5_

`expandtabs([tabsize])'
     全てのタブ文字が空白で展開された文字列のコピーを返します。 TABSIZE
     が与えられていない場合、タブ幅は `8' 文字分 と仮定します。

`find(sub[, start[, end]])'
     文字列中の領域 [START, END] に SUB が含まれる場合、
     その最小のインデクスを返します。 オプション引数 START および END
     はスライス表記と 同様に解釈されます。SUB が見つからなかった場合
     `-1' を返します。

`index(sub[, start[, end]])'
     `find()' と同様ですが、SUB が見つからなかった場合 `ValueError'
     を送出します。

`isalnum()'
     文字列中の全ての文字が英数文字で、かつ 1
     文字以上ある場合には真を返し、 そうでない場合は偽を返します。

     8ビット文字列では、メソッドはロケール依存になります。

`isalpha()'
     文字列中の全ての文字が英文字で、かつ 1
     文字以上ある場合には真を返し、 そうでない場合はを返します。

     8ビット文字列では、メソッドはロケール依存になります。

`isdigit()'
     文字列中に数字しかない場合には真を返し、その他の場合は偽を返します。

     8ビット文字列では、メソッドはロケール依存になります。

`islower()'
     文字列中の大小文字の区別のある文字全てが小文字で、かつ 1 文字以上
     ある場合には真を返し、そうでない場合は偽を返します。

     8ビット文字列では、メソッドはロケール依存になります。

`isspace()'
     文字列が空白文字だけからなり、かつ 1 文字以上ある場合には真を返し、
     そうでない場合は偽を返します。

     8ビット文字列では、メソッドはロケール依存になります。

`istitle()'
     文字列がタイトルケース文字列であり、かつ 1 文字以上ある場合、
     例えば大文字は大小文字の区別のない文字の後にのみ続き、
     小文字は大小文字の区別のある文字の後ろにのみ続く場合には真を返します。
     そうでない場合は偽を返します。

     8ビット文字列では、メソッドはロケール依存になります。

`isupper()'
     文字列中の大小文字の区別のある文字全てが大文字で、かつ 1 文字以上
     ある場合には真を返し、そうでない場合は偽を返します。

     8ビット文字列では、メソッドはロケール依存になります。

`join(seq)'
     シーケンス SEQ 中の文字列を結合した文字列を返します。文字列を
     結合するときの区切り文字は、このメソッドを適用する対象の文字列に
     なります。

`ljust(width[, fillchar])'
     WIDTH の長さをもつ左寄せした文字列を返します。 パディングには
     FILLCHAR で指定された文字(デフォルトではスペース）
     が使われます。WIDTH が `len(S)'
     よりも小さい場合、元の文字列が返されます。 _Changed in Python
     version 2.4_

`lower()'
     文字列をコピーし、小文字に変換して返します。

     8ビット文字列では、メソッドはロケール依存になります。

`lstrip([chars])'
     文字列の先頭部分を除去したコピーを返します。 引数 CHARS
     は除去される文字集合を指定する文字列です。 CHARS が省略されるか
     `None' の場合、空白文字が 除去されます。CHARS
     文字列は接頭語ではなく、そこに
     含まれる文字の組み合わせ全てがはぎ取られます。
              >>> '   spacious   '.lstrip()
              'spacious   '
              >>> 'www.example.com'.lstrip('cmowz.')
              'example.com'

     _Changed in Python version 2.2.2_

`partition(sep)'
     文字列を SEP の最初の出現位置で区切り、3要素のタプルを返します。
     タプルの内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分です。
     もし区切れなければ、タプルには元の文字列そのものとその後ろに二つの空文字列が入ります。
     _Added in Python version 2.5_

`replace(old, new[, count])'
     文字列をコピーし、部分文字列 OLD のある部分全てを NEW
     に置換して返します。オプション引数 COUNT が与えられて
     いる場合、先頭から COUNT 個の OLD だけを置換します。

`rfind(sub [,start [,end]])'
     文字列中の領域 [START, END) に SUB が含まれる場合、
     その最大のインデクスを返します。 オプション引数 START および END
     はスライス表記と 同様に解釈されます。SUB が見つからなかった場合
     `-1' を返します。

`rindex(sub[, start[, end]])'
     `find()' と同様ですが、SUB が見つからなかった場合 `ValueError'
     を送出します。

`rjust(width[, fillchar])'
     WIDTH の長さをもつ右寄せした文字列を返します。 パディングには
     FILLCHAR で指定された文字(デフォルトではスペース）
     が使われます。WIDTH が `len(S)'
     よりも小さい場合、元の文字列が返されます。 _Changed in Python
     version 2.4_

`rpartition(sep)'
     文字列を SEP の最後の出現位置で区切り、3要素のタプルを返します。
     タプルの内容は、区切りの前の部分、区切り文字列そのもの、そして区切りの後ろの部分です。
     もし区切れなければ、タプルには二つの空文字列とその後ろに元の文字列そのものが入ります。
     _Added in Python version 2.5_

`rsplit([sep [,maxsplit]])'
     SEP を区切り文字とした、文字列中の単語のリストを返します。
     MAXSPLIT が与えられた場合、最大で MAXSPLIT 個になるように
     分割が行なわれます、_最も右側_ （の単語）は1つになります。 SEP
     が指定されていない、あるいは `None'のとき、全ての
     空白文字が区切り文字となります。右から分割していくことを除けば、
     `rsplit()' は後ほど詳しく述べる `split()' と同様に振る舞います。
     _Added in Python version 2.4_

`rstrip([chars])'
     文字列の末尾部分を除去したコピーを返します。 引数 CHARS
     は除去される文字集合を指定する文字列です。 CHARS が省略されるか
     `None' の場合、空白文字が 除去されます。CHARS
     文字列は接尾語ではなく、そこに
     含まれる文字の組み合わせ全てがはぎ取られます。
              >>> '   spacious   '.rstrip()
              '   spacious'
              >>> 'mississippi'.rstrip('ipz')
              'mississ'

     _Changed in Python version 2.2.2_

`split([sep [,maxsplit]])'
     SEP を単語の境界として文字列を単語に分割し、分割された単語
     からなるリストを返します。 (したがって返されるリストは`MAXSPLIT+1'
     の要素を持ちます） MAXSPLIT
     が与えられていない場合、無制限に分割が行なわれます
     （全ての可能な分割が行なわれる）。連続した区切り文字はグループ化されず、
     空の文字列を区切っていると判断されます(例えば `'1,,2'.split(',')'
     は `['1', '', '2']' を返します)。引数 SEP は複数の文字にも
     できます(例えば `'1, 2, 3'.split(', ')' は `['1', '2', '3']'
     を返します)。区切り文字を指定して空の文字列を 分割すると、`['']'
     を返します。

     SEP が指定されていないか `None' が指定されている場合、異なる分割
     アルゴリズムが適用されます。最初に空白文字（スペース、タブ、改行(newline)、
     復帰(return)、改ページ(formfeed)) が文字列の両端から除去されます。
     次に任意の長さの空白文字列によって単語に分割されます。
     連続した空白の区切り文字は単一の区切り文字として扱われます （`'1
     2  3'.split()' は `['1', '2', '3']' を返します）。
     空の文字列や空白文字だけから成る文字列を分割する場合には空のリストを返します。

`splitlines([keepends])'
     文字列を改行部分で分解し、各行からなるリストを返します。 KEEPENDS
     が与えられていて、かつその値が真でない限り、
     返されるリストには改行文字は含まれません。

     8ビット文字列では、メソッドはロケール依存になります。

`startswith(prefix[, start[, end]])'
     文字列の一部が PREFIX で始まるときに `True' を返します。そう
     でない場合 `False' を返します。PREFIX は複数の接頭語の
     タプルにしても構いません。オプション引数 START がある場
     合、文字列の START から比較を始めます。END がある場合、文字 列の
     END で比較を終えます。

     _Changed in Python version 2.5_

`strip([chars])'
     文字列の先頭および末尾部分を除去したコピーを返します。 引数 CHARS
     は除去される文字集合を指定する文字列です。 CHARS が省略されるか
     `None' の場合、空白文字が 除去されます。CHARS
     文字列は接頭語でも接尾語でもなく、
     そこに含まれる文字の組み合わせ全てがはぎ取られます。
              >>> '   spacious   '.strip()
              'spacious'
              >>> 'www.example.com'.strip('cmowz.')
              'example'

     _Changed in Python version 2.2.2_

`swapcase()'
     文字列をコピーし、大文字は小文字に、小文字は大文字に変換して返します。

`title()'
     文字列をタイトルケースにして返します: 大文字から始まり、残りの
     文字のうち大小文字の区別があるものは全て小文字にします。

`translate(table[, deletechars])'
     文字列をコピーし、オプション引数の文字列 DELETECHARS の中に
     含まれる文字を全て除去します。その後、残った文字を変換テーブル
     TABLE に従ってマップして返します。変換テーブルは長さ 256
     の文字列でなければなりません。

     Unicode オブジェクトの場合、`translate()' メソッドはオプションの
     DELETECHARS 引数を受理しません。その代わり、メソッドは
     すべての文字が与えられた変換テーブルで対応付けされている S の
     コピーを返します。この変換テーブルは Unicode 順 (ordinal) から
     Unicode 順、Unicode 文字列、または `None' への対応付け
     でなくてはなりません。対応付けされていない文字は何もせず放置されます。
     `None' に対応付けられた文字は削除されます。ちなみに、
     より柔軟性のあるアプローチは、自作の文字対応付けを行う codec を
     `codecs' モジュールを使って作成することです (例えば
     `encodings.cp1251' を参照してください。

`upper()'
     文字列をコピーし、大文字に変換して返します。

     8ビット文字列では、メソッドはロケール依存になります。

`zfill(width)'
     数値文字列の左側をゼロ詰めし、幅 WIDTH にして返します。 WIDTH が
     `len(S)' よりも短い場合もとの文字列自体が 返されます。 _Added in
     Python version 2.2.2_


File: python-lib-jp.info,  Node: 文字列フォーマット操作,  Next: XRange 型,  Prev: 文字列メソッド,  Up: シーケンス型 str

3.6.2 文字列フォーマット操作
----------------------------

文字列および Unicode オブジェクトには固有の操作: `%' 演算子 (モジュロ)
があります。この演算子は文字列 _フォーマット化_ または _補間_
演算としても知られています。 `FORMAT % VALUES' (FORMAT は文字列または
Unicode オブジェクト)とすると、FORMAT 中の `%' 変換指定は VALUES
中のゼロ個またはそれ以上の要素で置換されます。 この動作は C
言語における `sprintf()' に似ています。 FORMAT が Unicode
オブジェクトであるか、または `%s' 変換を使って Unicode
オブジェクトが変換される場合、その結果も Unicode
オブジェクトになります。

FORMAT が単一の引数しか要求しない場合、VALUES は
タプルでない単一のオブジェクトでもかまいません。 (1)
それ以外の場合、VALUES はフォーマット文字列中で指定された項目と
正確に同じ数の要素からなるタプルか、単一のマップオブジェクトでなければ
なりません。

一つの変換指定子は 2 またはそれ以上の文字を含み、その構成要素は
以下からなりますが、示した順に出現しなければなりません:

  1. 変換指定子が開始することを示す文字 `%'。

  2. マップキー (オプション)。 丸括弧で囲った文字列からなります (例えば
     `(someone)') 。

  3. 変換フラグ (オプション)。一部の変換型の結果に影響します。

  4. 最小のフィールド幅 (オプション).  `*' (アスタリスク)
     を指定した場合、実際の文字列幅が VALUES タプルの次の要素から読み
     出されます。タプルには最小フィールド幅やオプションの精度指定の後に
     変換したいオブジェクトがくるようにします。

  5. 精度 (オプション)。`.' (ドット) とその後に続く精度
     で与えられます。`*' (アスタリスク) を指定した場合、精度
     の桁数はタプルの次の要素から読み出されます。タプルには精度指定の
     後に変換したい値がくるようにします。

  6. 精度長変換子 (オプション)。

  7. 変換型。

`%' 演算子の右側の引数が辞書の場合 (またはその他のマップ型の場合)、
文字列中のフォーマットには、辞書に挿入されているキーを丸括弧で囲い、文字
`%' の直後にくるようにしたものが含まれていなければ _なりません_
。マップキーはフォーマット化したい値をマップから 選び出します。例えば:

     >>> print '%(language)s has %(#)03d quote types.' % \
               {'language': "Python", "#": 2}
     Python has 002 quote types.

この場合、 `*' 指定子をフォーマットに含めてはいけません (`*'
指定子は順番付けされたパラメタのリストが必要だからです。)

変換フラグ文字を以下に示します:

フラグ                               意味
------                               -----
#                                    値の変換に (下で定義されている)
                                     "別の形式" を使います。
0                                    数値型に対してゼロによるパディングを行います。
-                                    変換された値を左寄せにします (`0'
                                     と同時に与えた 場合、`0'
                                     を上書きします) 。
{~}                                  (スペース)
                                     符号付きの変換で正の数の場合、前に一つスペースを空けます
                                     (そうでない場合は空文字になります)	。
+                                    変換の先頭に符号文字 (`+' または
                                     `-') を付けます("スペース"
                                     フラグを上書きします) 。

精度長変換子(`h' 、 `l' 、または `L') を使う ことができますが、Python
では必要ないため無視されます。

変換型を以下に示します:

変換                     意味                     注釈
------                   -----                    -----
d                        符号付き 10 進整数。     
i                        符号付き 10 進整数。     
o                        符号なし 8 進数。        (1)
u                        符号なし 10 進数。       
x                        符号なし 16 進数         (2)
                         (小文字)。               
X                        符号なし 16 進数         (2)
                         (大文字)。               
e                        指数表記の浮動小数点数   (3)
                         (小文字)。               
E                        指数表記の浮動小数点数   (3)
                         (大文字)。               
f                        10 進浮動小数点数。      (3)
F                        10 進浮動小数点数。      (3)
g                        浮動小数点数。指数部が   (4)
                         -4                       
                         以上または精度以下の場合には
                         指数表記、それ以外の場合には10進表記。
G                        浮動小数点数。指数部が   (4)
                         -4                       
                         以上または精度以下の場合には
                         指数表記、それ以外の場合には10進表記。
c                        文字一文字               
                         (整数または一文字からなる文字列を受理します)。
r                        文字列 (python           (5)
                         オブジェクトを `repr()'  
                         で変換します)。          
s                        文字列 (python           (6)
                         オブジェクトを `str()'   
                         で変換します)。          
%                        引数を変換せず、返される文字列中では文字
                         `%' になります。         

注釈:
`(1)'
     この形式の出力にした場合、変換結果の先頭の数字がゼロ (`0')
     でないときには、数字の先頭と左側のパディングとの間にゼロを挿入します。

`(2)'
     この形式にした場合、変換結果の先頭の数字がゼロでないときには、
     数字の先頭と左側のパディングとの間に `'0x'' または `'0X''
     (フォーマット文字が `x' か `X' かに依存します) が挿入されます。

`(3)'
     この形式にした場合、変換結果には常に小数点が含まれ、
     それはその後ろに数字が続かない場合にも適用されます。

     指定精度は小数点の後の桁数を決定し、そのデフォルトは 6 です。

`(4)'
     この形式にした場合、変換結果には常に小数点が含まれ
     他の形式とは違って末尾の 0 は取り除かれません。

     指定精度は小数点の前後の有効桁数を決定し、そのデフォルトは 6 です。

`(5)'
     `%r' 変換は Python 2.0 で追加されました。

     指定精度は最大文字数を決定します。

`(6)'
     オブジェクトや与えられた書式が `unicode'
     文字列の場合、変換後の文字列も `unicode' になります。

     指定精度は最大文字数を決定します。

Python 文字列には明示的な長さ情報があるので、`%s' 変換において `'\0''
を文字列の末端と仮定したりはしません。

安全上の理由から、浮動小数点数の精度は 50 桁でクリップされます;
絶対値が 1e25 を超える値の `%f' による変換は `%g' 変換で置換されます (2)
その他のエラーは例外を送出します。

その他の文字列操作は標準モジュール `string'  および `re'.  で定義されています。

---------- Footnotes ----------

(1)
従って、一個のタプルだけをフォーマット出力したい場合には出力したいタプルを唯一の要素とする単一のタプルを
VALUES に与えなくてはなりません。

(2) この範囲に関する値はかなり適当なものです。
この仕様は、正しい使い方では障害とならず、かつ特定のマシンにおける
浮動小数点数の正確な精度を知らなくても、際限なく長くて意味のない数字から
なる文字列を印字しないですむようにするためのものです。


File: python-lib-jp.info,  Node: XRange 型,  Next: 変更可能なシーケンス型,  Prev: 文字列フォーマット操作,  Up: シーケンス型 str

3.6.3 XRange 型
---------------

`xrange'  型は値の変更不能なシーケンスで、広範なループ処理に
使われています。`xrange' 型の利点は、 `xrange' オブジェクトは
表現する値域の大きさにかかわらず常に同じ量のメモリしか占めないということです。
はっきりしたパフォーマンス上の利点はありません。

XRange
オブジェクトは非常に限られた振る舞い、すなわち、インデクス検索、反復、
`len()' 関数のみをサポートしています。


File: python-lib-jp.info,  Node: 変更可能なシーケンス型,  Prev: XRange 型,  Up: シーケンス型 str

3.6.4 変更可能なシーケンス型
----------------------------

リストオブジェクトはオブジェクト自体の変更を可能にする追加の操作を
サポートします。他の変更可能なシーケンス型 (を言語に追加する場合) も、
それらの操作をサポートしなければなりません。
文字列およびタプルは変更不可能なシーケンス型です: これらのオブジェクトは
一度生成されたらそのオブジェクト自体を変更することができません。
以下の操作は変更可能なシーケンス型で定義されています (ここで X は
任意のオブジェクトとします): 

操作                     結果                     注釈
------                   -----                    -----
S[I] = X                 S の要素 S を X          
                         と入れ替えます           
S[I:J] = T               S の I から J            
                         番目までのスライスを     
                         イテラブル T             
                         の内容に入れ替えます     
del S[I:J]               `S[I:J] = []'            
                         と同じです               
S[I:J:K] = T             `S[I:J:K]' の要素を T    (1)
                         と入れ替えます           
del S[I:J:K]             リストから `S[I:J:K]'    
                         の要素を削除します       
S.append(X)              `S[len(S):len(S)] =      (2)
                         [X]' と同じです          
S.extend(X)              `S[len(S):len(S)] = X'   (3)
                         と同じです               
S.count(X)               `S[I] == X' となる I     
                         の個数を返します         
S.index(X[, I[, J]])     `S[K] == X' かつ `I <=   (4)
                         K < J' となる最小の K    
                         を返します。             
S.insert(I, X)           `I >= 0' の場合の        (5)
                         `S[I:I] = [X]'           
                         と同じです               
S.pop([I])               `X = S[I]; del S[I];     (6)
                         return X' と同じです     
S.remove(X)              `del S[S.index(X)]'      (4)
                         と同じです               
S.reverse()              S                        (7)
                         の値の並びを反転します   
S.sort([CMP[, KEY[,      S の要素を並べ替えます   (7), (8), (9), (10)
REVERSE]]])                                       

{types} 

Notes:
`(1)'
     T は入れ替えるスライスと同じ長さでなければいけません。

`(2)'
     かつての Python の C 実装では、複数パラメタを受理し、
     非明示的にそれらをタプルに結合していました。この間違った機能は
     Python 1.4 で廃用され、Python 2.0 の導入とともにエラーにする
     ようになりました。

`(3)'
     X は任意のイテラブル(繰り返し可能オブジェクト)にできます。

`(4)'
     X が S 中に見つからなかった場合 `ValueError' を送出します。　
     負のインデクスが二番目または三番目のパラメタとして `index()'
     メソッドに渡されると、これらの値にはスライスのインデクスと同様に
     リストの長さが加算されます。加算後もまだ負の場合、その値はスライス
     のインデクスと同様にゼロに切り詰められます。 _Changed in Python
     version 2.3_

`(5)'
     `insert()'
     の最初のパラメタとして負のインデクスが渡された場合、スライスのインデクスと同じく、リストの長さが加算されます。それでも負の値を取る場合、スライスのインデクスと同じく、0
     に丸められます。_Changed in Python version 2.3_

`(6)'
     `pop()' メソッドはリストおよびアレイ型のみでサポート
     されています。オプションの引数 I は標準で `-1' なので、
     標準では最後の要素をリストから除去して返します。

`(7)'
     `sort()' および `reverse()' メソッドは
     大きなリストを並べ替えたり反転したりする際、容量の節約のために
     リストを直接変更します。副作用があることをユーザに思い出させるために、
     これらの操作は並べ替えまたは反転されたリストを返しません。

`(8)'
     `sort()' メソッドは、比較を制御するためにオプションの
     引数をとります。

     CMP は2つの引数(list items)からなるカスタムの比較関数を指定します。
     これは始めの引数が2つ目の引数に比べて小さい、等しい、大きいかに応じて
     負数、ゼロ、正数を返します。 `CMP=`lambda' X,Y: `cmp'(x.lower(),
     y.lower())'

     KEY
     は1つの引数からなる関数を指定します。これは個々のリストの要素から
     比較のキーを取り出すのに使われます。 `KEY=`str.lower''

     REVERSE は真偽値です。 `True' がセットされた場合、リストの要素は
     個々の比較が反転したものとして並び替えられます。

     一般的に、 KEY および REVERSE の変換プロセスは同等の CMP 関数を
     指定するより早く動作します。これは KEY および REVERSE
     がそれぞれの要素に 一度だけ触れる間に、CMP
     はリストのそれぞれの要素に対して複数回呼ばれることに よるものです。

     _Changed in Python version 2.3_

     _Changed in Python version 2.4_

`(9)'
     Python2.3 以降、`sort()' メソッドは安定していることが
     保証されています。
     ソートは等しいとされた要素の相対オーダーが変更されないことが
     保証されれば、安定しています --
     これは複合的なパス（例えば部署ごとにソートして、
     それを給与の等級）でソートを行なうのに役立ちます。

`(10)'
     リストが並べ替えられている間は、リストの変更はもとより、
     その値の閲覧すらその結果は未定義です。 Python 2.3以降 の C
     実装では、この間リストは空に見えるようになり、
     並べ替え中にリストが変更されたことが検出されると `ValueError'
     が送出されます。


File: python-lib-jp.info,  Node: set（集合）型,  Next: マップ型,  Prev: シーケンス型 str,  Up: 組み込み型

3.7 `set', `frozenset'
======================

"set"
オブジェクトは順序付けされていない変更不可能な値のコレクションです。
よくある使い方には、メンバーシップのテスト、数列から重複を削除する、
そして論理積、論理和、差集合、対称差など数学的演算の計算が含まれます。
_Added in Python version 2.4_

他のコレクションと同様、 setsは `X in SET'、 `len(SET)'および `for X in
SET'
をサポートします。順序を持たないコレクションとして、setsは要素の位置と
（要素の）挿入位置を保持しません。したがって、setsはインデックス、スライス、
その他のシーケンス的な振る舞いをサポートしません。

`set' および `frozenset'という、2つの組み込みset型があります。 `set'
は変更可能な --  `add()' や `remove()'のような
メソッドを使って内容を変更できます。変更可能なため、ハッシュ値を持たず、また
辞書のキーや他のsetの要素として用いることができません。`frozenset' 型は
変更不能であり、ハッシュ化可能で -- 一度作成されると内容を改変することが
できません。一方で辞書のキーや他のsetの要素として用いることができます。

`set' および `frozenset' のインスタンスは、以下の演算を提供します。

Operation                Equivalent               Result
------                   -----                    -----
len(S)                                            set S の基数
X in S                                            S のメンバに X
                                                  があるか調べる
X not in S                                        S のメンバに X
                                                  がないか調べる
S.issubset(T)            `S <= T'                 T に S
                                                  の全ての要素が含まれるか調べる
S.issuperset(T)          `S >= T'                 S に T
                                                  の全ての要素が含まれるか調べる
S.union(T)               S | T                    S と
                                                  Tに含まれるすべての要素を持った新しいsetを作成
S.intersection(T)        S & T                    S と
                                                  T共通に含まれる要素を持った新しいsetを作成
S.difference(T)          S - T                    S には含まれるが
                                                  Tには含まれない要素を持った新しいsetを作成
S.symmetric_difference(T)S ^ T                    S と
                                                  Tのうち、両者には含まれない要素を持った新しいsetを作成
S.copy()                                          Sの浅いコピーを持った新しいsetを作成

注意すべき点として、演算子ではないバージョンのメソッド `union()'、
`intersection()'、+`difference()'、`symmetric_difference()'、
`issubset()'および `issuperset()'はどの種類のiterableでも引数として
受け入れます。対照的に、（それぞれのメソッドに）対応する演算子は引数にsetsを
要求します。これはより読みやすい`set('abc').intersection('cbs')'
という構文を 優先して `set('abc') & 'cbs''
というような、エラーになりがちな構文を除外します。

`set' と `frozenset'の両者とも、setsとsetsの比較をサポートしています。
もし、あるいは少なくともそれぞれのsetsの全ての要素が他のsetsに含まれている
（それぞれのsetsがもう片方のサブセットである）場合、2つのsetsは等しいと言えます。
もし、あるいは少なくとも1つめのsetが2つめのsetの厳密なサブセットである
（サブセットではあるが等しくない）場合、setは他のsetより小さいと言えます。
もし、あるいは少なくとも1つめのsetが2つめのsetの厳密なスーパーセットである
（スーパーセットではあるが等しくない）場合、setは他のsetより大きいと言えます。

`set' のインスタンスは`frozenset' のインスタンスと、そのメンバを基に
比較されます。例えば `set('abc') == frozenset('abc')' は
`True'を返します。

サブセットと同一性の比較は完全な順序付け関数によって一般化されません。
例えば、どのような共通部分も持たない2つのsetsは、等しくもなく、互いのサブセットでもないので、
以下のコードの _全て_ に`False'を返します。 `A<B'、 `A==B'、 `A>B'。
それに応じて、setsは `__cmp__' メソッドを実装していません。

setsが部分的な順序付け（サブセットの関係）しか定義していないことから、
`list.sort()' メソッドの結果は不確定のsetsのリストとなります。

set の要素は辞書のキーと同様に `__hash__' と `__eq__' の
両方を定義していることが必要です。

`set' と`frozenset'のインスタンスを混在させたバイナリ演算は
結果を1つめのオペランドの型で返します。例えば `frozenset('ab') |
set('bc')' は、`frozenset'のインスタンスを返します。

以下の表は`set'で可能なリスト操作です。これらの操作は変更不能な
`frozenset' のインスタンスには適用されません。

Operation                Equivalent               Result
------                   -----                    -----
S.update(T)              S |= T                   set S を T
                                                  の要素を追加して更新します
S.intersection_update(T) S &= T                   set S を S と T
                                                  の両方に属する要素だけ残すように更新します
S.difference_update(T)   S -= T                   set S を T
                                                  に属する要素を削除するように更新します
S.symmetric_difference_update(T)S ^= T                   set S を S か T
                                                  に属するが両方には属さない要素を持つように更新します
S.add(X)                                          set S に要素 X
                                                  を追加します
S.remove(X)                                       set S から要素 X
                                                  を削除します。要素が存在しない場合は
                                                  `KeyError' を送出します
S.discard(X)                                      set S に要素 X
                                                  が存在していれば削除します
S.pop()                                           S
                                                  から、任意の要素を返してその要素を削除します。空の場合は
                                                  `KeyError' を送出します
S.clear()                                         set S
                                                  から全ての要素を削除します

注意すべき点として、演算子ではないバージョンのメソッド `update()'、
`intersection_update()'、 `difference_update()' および
`symmetric_difference_update()' は、どんなiterableでも引数として
受け入れます。

set 型のデザインは `sets' で学んだことに基づいています。

See also:
    `*comparison-to-builtin-set.html*'
          (Comparison to the built-in set types) `sets'
          モジュールと組み込み set 型の違い



File: python-lib-jp.info,  Node: マップ型,  Next: ファイルオブジェクト,  Prev: set（集合）型,  Up: 組み込み型

3.8 マップ型
============

"マップ型" ("mapping") オブジェクトは変更不可能な値を任意の
オブジェクトに 対応付けます。対応付け自体は変更可能なオブジェクトです。
現在のところは標準のマップ型、"dictionary" だけです。
辞書のキーにはほとんど任意の値をつかうことができます。使うことが
できないのはリスト、辞書、その他の変更可能な型 (オブジェクトの一致
ではなく、その値で比較されるような型) です。
キーに使われた数値型は通常の数値比較規則に従います: 二つの数字を
比較した時等価であれば (例えば `1' と `1.0' のように)、
これらの値はお互いに同じ辞書のエントリを示すために使うことが できます。

辞書は `KEY: VALUE' からなるペアを
カンマで区切ったリストを波括弧の中に入れて作ります。 例えば: `{'jack':
4098, 'sjoerd': 4127}' または `{4098: 'jack', 4127: 'sjoerd'}' です。

以下の操作がマップ型で定義されています (ここで、A および B
はマップ型で、K はキー、 V および X は任意の オブジェクトです):

操作                     結果                     注釈
------                   -----                    -----
len(A)                   A 内の要素の数です       
A[K]                     キー K を持つA           (1), (10)
                         の要素です               
A[K] = V                 `A[K]' を V              
                         に設定します             
del A[K]                 A から `A[K]'            (1)
                         を削除します             
A.clear()                `a'                      
                         から全ての要素を削除します
A.copy()                 `a' の(浅い)コピーです   
K in A                   A にキー K があれば      (2)
                         `True' 、                
                         そうでなければ `False'   
                         です                     
K not in A               `not' K in A と同じです  (2)
A.has_key(K)             K `in' A                 
                         と同じなので、新しく書くコードではその形を使ってください
A.items()                A における (KEY, VALUE)  (3)
                         ペアのリストのコピーです 
A.keys()                 A                        (3)
                         におけるキーのリストのコピーです
A.update([B])            B によって key/value     (9)
                         ペアを更新（上書き）     
A.fromkeys(SEQ[,         SEQ                      (7)
VALUE])                  からキーを作り、値が     
                         VALUE                    
                         であるような、新しい辞書を作成します
A.values()               A                        (3)
                         における値のリストのコピーです
A.get(K[, X])            もし `K in               (4)
                         A'なら`A[K]'、           
                         そうでなければ           
                         Xを返します              
A.setdefault(K[, X])     もし `K in               (5)
                         A'なら`A[K]'、           
                         そうでなければ X         
                         (が与えられていた場合)を返します
A.pop(K[, X])            もし `K in A' なら       (8)
                         `A[K]' 、                
                         そうでなければ X         
                         を返して kを除去します   
A.popitem()              任意の (KEY, VALUE)      (6)
                         ペアを除去して返します   
A.iteritems()            (KEY, VALUE)             (2), (3)
                         ペアにわたるイテレータを返します
A.iterkeys()             マップのキー列にわたるイテレータを返します(2), (3)
A.itervalues()           マップの値列にわたるイテレータを返します(2), (3)

注釈:
`(1)'
     K がマップ内にない場合、例外 `KeyError' を 送出します。

`(2)'
     _Added in Python version 2.2_

`(3)'
     キーおよび値は任意の順序でリスト化されています。この順序は
     ランダムではなく、Pythonの実装によって異なり、辞書の挿入、削除の履歴に
     依存します。 `items()'、 `keys()'、 `values()'、 `iteritems()'、
     `iterkeys()'および `itervalues()'が
     途中で辞書を変更せずに呼ばれた場合、リストも直接対応するでしょう。
     これにより、`(VALUE, KEY)' のペアを `zip()' を 使って: `pairs =
     zip(A.values(), A.keys())'
     のように生成することができます。`iterkeys()' および `itervalues()'
     メソッドの間でも同じ関係が成り立ちます: `pairs =
     zip(A.itervalues(), A.iterkeys())' は `pairs' と同じ値になります。
     同じリストを生成するもう一つの方法は `pairs = [(v, k) for (k, v)
     in A.iteritems()]' です。

`(4)'
     K がマップ中になくても例外を送出せず、代わりに X を返します。X
     はオプションです; X が与えられて おらず、かつ K
     がマップ中になければ、 `None' が返されます。

`(5)'
     `setdefault()' は `get()' に似ていますが、 K
     が見つからなかった場合、X が返されると同時に辞書の K
     に対する値として挿入されます。デフォルトで X は NONEです。

`(6)'
     `popitem()' は、集合アルゴリズムでよく行われる
     ような、辞書を取り崩しながらの反復を行うのに便利です。もし辞書が空なら
     `popitem()' の呼び出しは `KeyError' の送出を引き起こします。

`(7)'
     `fromkeys()' は、新しい辞書を返すクラスメソッドです。 VALUE
     のデフォルト値は `None' です。 _Added in Python version 2.3_

`(8)'
     `pop()'
     は、デフォルト値が渡されず、かつ、キーが見つからない場合に、
     `KeyError' を送出します。 _Added in Python version 2.3_

`(9)'
     `update()' はその他のマッピングオブジェクトや反復可能な
     キー/値のペア（タプルやその他2つの要素を持つ反復可能な要素）を受け入れます。
     キーワードとなる引数が指定されている場合、マッピングはそれらのキー/値のペアで
     更新されます。 `d.update(red=1, blue=2)' _Changed in Python
     version 2.4_

`(10)'
     dict のサブクラスが `__missing__' メソッドを定義しているならば、
     キー K が無ければ A[K] は K を引数にそのメソッドを
     呼び出します。したがってキーが無いときに A[K] が結果を返すのも
     例外を送出するのも、`__missing__'(K) が結果を返すか
     例外を送出するかで決まります。他のどんなメソッドも演算も
     `__missing__'() を呼び出すことはありません。このような
     `__missing__' が定義されていなければ、`KeyError' が送出されます。
     `__missing__'
     はメソッドでなければならず、インスタンス変数では駄目です。
     例として `collections'.`defaultdict' を見てください。 _Added in
     Python version 2.5_



File: python-lib-jp.info,  Node: ファイルオブジェクト,  Next: コンテキストマネージャ型,  Prev: マップ型,  Up: 組み込み型

3.9 ファイルオブジェクト
========================

ファイルオブジェクト  は C の`stdio' パッケージを使って実装されており、
*Note 組み込み関数:: 節の "組み込み関数"
で解説されている組み込みのコンストラクタ `file()'  で生成することができます。
(1) ファイルオブジェクトはまた、`os.popen()' や `os.fdopen()'
、ソケットオブジェクトの `makefile()'
メソッドのような、他の組み込み関数およびメソッドによっても返されます。 

ファイル操作が I/O 関連の理由で失敗した場合例外 `IOError'
が送出されます。この理由には例えば `seek()' を端末デバイスに
行ったり、読み出し専用で開いたファイルに書き込みを行うといった、
何らかの理由によってそのファイルで定義されていない操作を行った
ような場合も含まれます。

ファイルは以下のメソッドを持ちます:

`close()'
     ファイルを閉じます。閉じられたファイルはそれ以後読み書きすることは
     できません。ファイルが開かれていることが必要な操作は、ファイルが
     閉じられた後はすべて `ValueError' を送出します。 `close'
     を一度以上呼び出してもかまいません。

     Python 2.5 から `with' 文を使えばこのメソッドを直接呼び出す必要
     はなくなりました。たとえば、以下のコードは `f' を `with'
     ブロックを抜ける際に自動的に閉じます。

          from __future__ import with_statement

          with open("hello.txt") as f:
              for line in f:
                  print line

     古いバージョンの Python
     では同じ効果を得るために次のようにしなければい けませんでした。

          f = open("hello.txt")
          try:
              for line in f:
                  print line
          finally:
              f.close()

     _Note:_ 全ての Python の "ファイル的" 型が `with' 文用の
     コンテキスト・マネージャとして使えるわけではありません。もし、全ての
     ファイル的オブジェクトで動くようにコードを書きたいのならば、オブジェクトを
     直接使うのではなく `contextlib' にある `closing()' を
     使うと良いでしょう。詳細はセクション~*Note contextlib::
     を参照してください。


`flush()'
     `stdio' の `fflush()' のように、内部バッファを
     フラッシュします。ファイル類似のオブジェクトによっては、この
     操作は何も行いません。

`fileno()'
     背後にある実装系がオペレーティングシステムに I/O
     操作を要求するために 用いる、整数の "ファイル記述子"
     を返します。この値は他の用途として、 `fcntl'  モジュールや
     `os.read()'
     やその仲間のような、ファイル記述子を必要とする低レベルのインタフェース
     で役に立ちます。 _Note:_
     ファイル類似のオブジェクトが実際のファイルに関連付けられていない
     場合、このメソッドを提供すべきでは_ありません。_

`isatty()'
     ファイルが tty (または類似の) デバイスに接続されている場合 `True'
     を返し、そうでない場合 `False' を返します。 _Note:_
     ファイル類似のオブジェクトが実際のファイルに関連付けられていない
     場合、このメソッドを実装_すべきではありません。_

`next()'
     ファイルオブジェクトはそれ自身がイテレータです。すなわち、
     `iter(F)' は (F が閉じられていない限り) F を返します。`for' ループ
     (例えば `for line in f: print line')
     のようにファイルがイテレータとして 使われた場合、`next()'
     メソッドが繰り返し呼び出されます。
     個のメソッドは次の入力行を返すか、または `EOF' に到達したときに
     `StopIteration' を送出します。ファイル内の各行に対する `for'
     ループ (非常によくある操作です) を効率的な方法で
     行うために、`next()' メソッドは隠蔽された先読みバッファ
     を使います。先読みバッファを使った結果として、(`readline()'
     のような) 他のファイルメソッドと `next()' を組み合わせて使うと
     うまく動作しません。しかし、`seek()' を使ってファイル位置
     を絶対指定しなおすと、先読みバッファはフラッシュされます。

     _Added in Python version 2.3_

`read([size])'
     最大で SIZE バイトをファイルから読み込みます (SIZE バイト
     を取得する前に `EOF' に到達した場合、それ以下の長さになります)
     SIZE 引数が負であるか省略された場合、`EOF' に到達するまでの
     全てのデータを読み込みます。読み出されたバイト列は文字列オブジェクト
     として返されます。直後に `EOF'
     に到達した場合、空の文字列が返されます。
     (端末のようなある種のファイルでは、 `EOF' に到達した後でファイルを
     読みつづけることにも意味があります。) このメソッドは、SIZE
     バイトに可能な限り近くデータを取得するために、背後の C 関数
     `fread()' を 1 度以上呼び出すかもしれないので注意してください。
     また、非ブロック・モードでは、SIZE パラメータが与えられなくても、
     要求されたよりも少ないデータが返される場合があることに注意してください。

`readline([size])'
     ファイルから一行を読み出します。末尾の改行文字は文字列中に
     残されます（ですが、ファイルが不完全な行で終わっている場合は
     何も残らないかもしれません）。 (2) 引数 SIZE
     が指定されていて負数でない場合、 (末尾の改行を含めて)
     読み込む最大のバイト数です。この場合、
     不完全な行が返されるかもしれません。空文字列が返されるのは、
     直後に `EOF' に到達した場合 _だけ_ です。 _Note:_ `stdio' の
     `fgets()' と違い、入力中に ヌル文字 (`'\0'')
     が含まれていれば、ヌル文字を含んだ 文字列が返されます。

`readlines([sizehint])'
     `readline()' を使ってに到達するまで読み出し、`EOF'
     読み出された行を含むリストを返します。オプションの SIZEHINT
     引数が存在すれば、`EOF'まで読み出す代わりに 完全な行を全体で大体
     SIZEHINT バイトになるように
     (おそらく内部バッファサイズを切り詰めて) 読み出します。
     ファイル類似のインタフェースを実装しているオブジェクトは、
     SIZEHINT を実装できないか効率的に実装できない場合には
     無視してもかまいません。

`xreadlines()'
     個のメソッドは `iter(f)' と同じ結果を返します。 _Added in Python
     version 2.1_ _This is deprecated in Python 2.3.  代わりに `for
     LINE in FILE' を使ってください。_


`seek(offset[, whence])'
     `stdio' の `fseek()' と同様に、ファイルの現在位置を
     返します。WHENCE 引数はオプションで、標準の値は `0' (絶対位置指定)
     です; 他に取り得る値は `1' (現在のファイル位置 から相対的に seek
     する) および `2' (ファイルの末端から相対的に seek する)
     です。戻り値はありません。ファイルを追記モード (モード `'a''
     または `'a+'') で開いた場合、書き込みを行う までに行った`seek()'
     操作はすべて元に戻されるので注意してください。
     ファイルが追記のみの書き込みモード (`'a'') で開かれた場合、
     このメソッドは実質何も行いませんが、読み込みが可能な追記モード
     (`'a+'') で開かれたファイルでは役に立ちます。
     ファイルをテキストモードで (`'b'' なしで) 開いた場合、 `tell()'
     が返すオフセットのみが正しい値になります。
     他のオフセット値を使った場合、その振る舞いは未定義です。

     全てのファイルオブジェクトが seek
     できるとは限らないので注意してください。

`tell()'
     `stdio' の `ftell()' と同様、ファイルの現在位置を 返します。

     _Note:_ Windows では、(`fgets()' の後で) UNIX-スタイルの改行
     のファイルを読むときに`tell()' が不正な値を返すことがあります。
     この問題に遭遇しないためにはバイナリーモード (`'rb'') を使うよう
     にしてください。

`truncate([size])'
     ファイルのサイズを切り詰めます。オプションの SIZE が存在
     すれば、ファイルは (最大で) 指定されたサイズに切り詰められます。
     標準設定のサイズの値は、現在のファイル位置までのファイルサイズです。
     現在のファイル位置は変更されません。指定されたサイズがファイルの
     現在のサイズを越える場合、その結果はプラットフォーム依存なので
     注意してください: 可能性としては、ファイルは変更されないか、
     指定されたサイズまでゼロで埋められるか、指定されたサイズまで
     未定義の新たな内容で埋められるか、があります。 利用可能な環境:
     Windows, 多くの UNIX 系。

`write(str)'
     文字列をファイルに書き込みます。戻り値はありません。バッファリング
     によって、`flush()' または `close()' が呼び出されるまで
     実際にファイル中に文字列が書き込まれないこともあります。

`writelines(sequence)'
     文字列からなるシーケンスをファイルに書き込みます。シーケンスは文字列を生成
     する反復可能なオブジェクトなら何でもかまいません。よくあるのは
     文字列からなるリストです。戻り値はありません。 (関数の名前は
     `readlines()' と対応づけてつけられました; `writelines()'
     は行間の区切りを追加しません)

ファイルはイテレータプロトコルをサポートします。各反復操作では
`FILE.readline()' と同じ結果を返し、反復は `readline()'
メソッドが空文字列を返した際に終了します。

ファイルオブジェクトはまた、多くの興味深い属性を提供します。
これらはファイル類似オブジェクトでは必要ではありませんが、
特定のオブジェクトにとって意味を持たせたいなら実装しなければ
なりません。

`closed'
     現在のファイルオブジェクトの状態を示すブール値です。この値は
     読み出し専用の属性です; `close()' メソッドがこの値を
     変更します。全てのファイル類似オブジェクトで利用可能とは
     限りません。

`encoding'
     このファイルが使っているエンコーディングです。Unicode 文字列が
     ファイルに書き込まれる際、Unicode 文字列はこのエンコーディングを
     使ってバイト文字列に変換されます。さらに、ファイルが端末に
     接続されている場合、この属性は端末が使っているとおぼしきエンコーディング
     (この情報は端末がうまく設定されていない場合には不正確なこともあります)
     を与えます。この属性は読み出し専用で、すべてのファイル類似オブジェクト
     にあるとは限りません。またこの値は `None' のこともあり、
     この場合、ファイルはUnicode
     文字列の変換のためにシステムのデフォルト
     エンコーディングを使います。

     _Added in Python version 2.3_

`mode'
     ファイルの I/O モードです。ファイルが組み込み関数 `open()'
     で作成された場合、この値は引数 MODE の値になります。
     この値は読み出し専用の属性で、全てのファイル類似オブジェクトに
     存在するとは限りません。

`name'
     ファイルオブジェクトが `open()' を使って生成された時の
     ファイルの名前です。そうでなければ、ファイルオブジェクト生成の
     起源を示す何らかの文字列になり、`<...>' の形式を
     とります。この値は読み出し専用の属性で、全てのファイル類似オブジェクトに
     存在するとは限りません。

`newlines'
     Python をビルドするとき、`--with-universal-newlines'
     オプションが`configure' に指定された場合（デフォルト）、
     この読み出し専用の属性が存在します。一般的な
     改行に変換する読み出しモードで開かれたファイルにおいて、この属性はファイ
     ルの読み出し中に遭遇した改行コードを追跡します。取り得る値は
     `'\r''、`'\n''、`'\r\n''、`None' (不明または、まだ改行
     していない）、見つかった全ての改行文字を含むタプルのいずれかです。最後の
     タプルは、複数の改行慣例に遭遇したことを示します。一般的な改行文字を使う
     読み出しモードで開かれていないファイルの場合、この属性の値は `None'
     です。

`softspace'
     `print' 文を使った場合、他の値を出力する前にスペース文字を
     出力する必要があるかどうかを示すブール値です。
     ファイルオブジェクトをシミュレート仕様とするクラスは書き込み可能な
     `softspace' 属性を持たなければならず、この値はゼロに初期化
     されなければなりません。この値は Python で実装されているほとんどの
     クラスで自動的に初期化されます (属性へのアクセス手段を上書きする
     ようなオブジェクトでは注意が必要です); C で実装された型では、
     書き込み可能な `softspace' 属性を提供しなければなりません。
     _Note:_ この属性は `print' 文を制御するために用いられますが、
     `print' の内部状態を乱さないために、その実装を行うことは
     できません。

---------- Footnotes ----------

(1)  `file()' は Python 2.2 で新しく追加されました。
古いバージョンの組み込み関数 `open()' は `file()' の別名です。

(2) 改行を残す利点は、空の文字列が返ると `EOF'
を示し、紛らわしくなくなるからです。また、ファイルの最後の行
が改行で終わっているかそうでない (ありえることです！) か
(例えば、ファイルを行単位で読みながらその完全なコピーを作成
した場合には問題になります) を調べることができます。


File: python-lib-jp.info,  Node: コンテキストマネージャ型,  Next: 他の組み込み型,  Prev: ファイルオブジェクト,  Up: 組み込み型

3.10 コンテキストマネージャ型
=============================

_Added in Python version 2.5_ 

Python の `with' 文はコンテキストマネージャによって定義される
実行時コンテキストの概念をサポートします。これは、ユーザ定義クラスが文の本体
が実行される前に進入し文の終わりで脱出する実行時コンテキストを定義することを許す
二つの別々のメソッドを使って実装されます。

"コンテキスト管理プロトコル" ("context management protocol") は
実行時コンテキストを定義するコンテキストマネージャオブジェクトが提供すべき
一対のメソッドから成ります。

`__enter__()'
     実行時コンテキストに入り、このオブジェクトまたは他の実行時コンテキストに関連した
     オブジェクトを返します。このメソッドが返す値はこのコンテキストマネージャを使う
     `with' 文の `as' 節の識別子に束縛されます。

     自分自身を返すコンテキストマネージャの例としてファイルオブジェクトがあります。
     ファイルオブジェクトは `__enter__()' から自分自身を返して `open()'
     が `with' 文のコンテキスト式として使われる ようにします。

     関連オブジェクトを返すコンテキストマネージャの例としては
     `decimal.localcontext()' が返すものがあります。
     このマネージャはアクティブな10進数コンテキストをオリジナルのコンテキストのコピーに
     セットしてそのコピーを返します。こうすることで、`with' 文の本体の
     内部で、外側のコードに影響を与えずに、10進数コンテキストを変更できます。

`__exit__(exc_type, exc_val, exc_tb)'
     実行時コンテキストから抜け、例外(がもし起こっていたとしても)を抑制することを示す
     ブール値フラグを返します。`with'
     文の本体を実行中に例外が起こったならば、引数には
     その例外の型と値とトレースバック情報を渡します。そうでなければ、引数は全て
     NONE です。

     このメソッドから真となる値が返されると `with'
     文は例外の発生を抑え、 `with'
     文の直後の文に実行を続けます。そうでなければ、このメソッドの実行を
     終えると例外の伝播が続きます。このメソッドの実行中に起きた例外は
     `with' 文の本体の実行中に起こった例外を置き換えてしまいます。

     渡された例外を直接的に再送出すべきではありません。その代わりに、このメソッドが偽の
     値を返すことでメソッドの正常終了と送出された例外を抑制しないことを伝えるべきです。
     このようにすれば(`contextlib.nested'
     のような)コンテキストマネージャは `__exit__()'
     メソッド自体が失敗したのかどうかを簡単に見分けることができます。

Python は幾つかのコンテキストマネージャを、易しいスレッド同期・ファイル
などのオブジェクトの即時クローズ・単純化されたアクティブな10進算術コン
テキストのサポートのために用意しています。各型はコンテキスト管理プロトコル
を実装しているという以上の特別の取り扱いを受けるわけではありません。

Python のジェネレータと `contextlib.contextfactory' デコレータはこの
プロトコルの簡便な実装方法を提供します。ジェネレータ関数を
`contextlib.contextfactory' でデコレートすると、デコレートしなければ
返されるイテレータを返す代わりに、必要な `__enter__()' および
`__exit__()'
メソッドを実装したコンテキストマネージャを返すようになります。

これらのメソッドのために Python/C API の中の Python オブジェクトの型構
造体に特別なスロットが作られたわけではないことに注意してください。これ
らのメソッドを定義したい拡張型については通常の Python からアクセスでき
るメソッドとして提供しなければなりません。実行時コンテキストを準備する
ことに比べたら、一つのクラスの辞書引きは無視できるオーバーヘッドです。


File: python-lib-jp.info,  Node: 他の組み込み型,  Next: 特殊な属性,  Prev: コンテキストマネージャ型,  Up: 組み込み型

3.11 他の組み込み型
===================

インタプリタはその他の種類のオブジェクトをいくつかサポート
します。これらのほとんどは 1 または 2 つの演算だけをサポート します。

* Menu:

* モジュール::
* Classes and Instances::
* 関数::
* メソッド::
* コードオブジェクト::
* 型オブジェクト::
* ヌルオブジェクト::
* 省略表記オブジェクト::
* ブール値::
* 内部オブジェクト::


File: python-lib-jp.info,  Node: モジュール,  Next: Classes and Instances,  Prev: 他の組み込み型,  Up: 他の組み込み型

3.11.1 モジュール
-----------------

モジュールに対する唯一の特殊な演算は属性へのアクセス: `M.NAME'
です。ここで M はモジュールで、 NAME は M
のシンボルテーブル上に定義された名前に
アクセスします。モジュール属性も代入することができます。 (`import'
文は、厳密にいえば、モジュールオブジェクトに 対する演算です; `import
FOO' は FOO と名づけられた
モジュールオブジェクトが存在することを必要とはせず、 むしろ FOO
と名づけられた (外部の) モジュールの_定義_ を必要とします。)

各モジュールの特殊なメンバは `__dict__' です。
これはモジュールのシンボルテーブルを含む辞書です。
この辞書を修正すると、実際にはモジュールのシンボルテーブルを変更
しますが、`__dict__' 属性を直接代入することはできません
(`M.__dict__['a'] = 1' と書いて `M.a' を `1'
に定義することはできますが、`M.__dict__ = @' と 書くことはできません)
。 `__dict__' を直接編集するのは推奨されません。

インタプリタ内に組み込まれたモジュールは、 `<module 'sys' (built-in)>'
のように書かれます。 ファイルから読み出された場合、 `<module 'os' from
'/usr/local/lib/python2.5/os.pyc'>' と書かれます。


File: python-lib-jp.info,  Node: Classes and Instances,  Next: 関数,  Prev: モジュール,  Up: 他の組み込み型

3.11.2 クラスおよびクラスインスタンス
-------------------------------------

これらに関しては、 の 3 章および 7 章を読んで下さい。


File: python-lib-jp.info,  Node: 関数,  Next: メソッド,  Prev: Classes and Instances,  Up: 他の組み込み型

3.11.3 関数
-----------

関数オブジェクトは関数定義によって生成されます。関数オブジェクトに
対する唯一の操作は、それを呼び出すことです: `FUNC(ARGUMENT-LIST)'.

関数オブジェクトには実際には 2 つの種: 組み込み関数とユーザ定義関数
があります。両方とも同じ操作 (関数の呼び出し) をサポートしますが、
実装は異なるので、オブジェクトの型も異なります。

より詳しい情報は  を 参照してください。


File: python-lib-jp.info,  Node: メソッド,  Next: コードオブジェクト,  Prev: 関数,  Up: 他の組み込み型

3.11.4 メソッド
---------------

メソッドは属性表記を使って呼び出される関数です。メソッドには二つの
種類があります: (リストへの`append()'のような) 組み込みメソッド
と、クラスインスタンスのメソッドです。組み込みメソッドはそれをサポート
する型と一緒に記述されています。

実装では、クラスインスタンスのメソッドに 2 つの読み込み専用の属性
を追加しています: `M.im_self' はメソッドが操作するオブジェクト
で、`M.im_func' はメソッドを実装している関数です。 `M(ARG-1, ARG-2,
..., ARG-N)' の呼び出しは、`M.im_func(M.im_self, ARG-1, ARG-2, ...,
ARG-N)' の呼び出しと完全に等価です。

クラスインスタンスメソッドには、 メソッドがインスタンスからアクセス
されるかクラスからアクセスされるかによって、それぞれ_バインド_ または
_非バインド_　があります。メソッドが非バインドメソッドの
場合、`im_self' 属性は `None' になるため、呼び出す際 には `self'
オブジェクトを明示的に第一引数として指定しなければ
なりません。この場合、`self' は非バインドメソッドのクラス (サブクラス)
のインスタンスでなければならず、そうでなければ `TypeError'
が送出されます。

関数オブジェクトと同じく、メソッドオブジェクトは任意の属性を取得
できます。しかし、メソッド属性は実際には背後の関数オブジェクト
(`meth.im_func') に記憶されているので、バインド、ヒバインド
メソッドへのメソッド属性の設定は許されていません。
メソッド属性の設定を試みると `TypeError' が送出されます。
メソッド属性を設定するためには、その背後の関数オブジェクトで 明示的に:

     class C:
         def method(self):
             pass

     c = C()
     c.method.im_func.whoami = 'my name is c'

のように設定しなければなりません。 詳しくは

を読んで下さい。


File: python-lib-jp.info,  Node: コードオブジェクト,  Next: 型オブジェクト,  Prev: メソッド,  Up: 他の組み込み型

3.11.5 コードオブジェクト
-------------------------

コードオブジェクトは、関数本体のような "擬似コンパイルされた" Python
の実行可能コードを表すために実装系によって使われます。
コードオブジェクトはグローバルな実行環境への参照を持たない点で
関数オブジェクトとは異なります。コードオブジェクトは 組み込み関数
`compile()' によって返され、関数オブジェクト の `func_code'
属性として取り出すことができます。 

コードオブジェクトは `exec' 文や組み込み関数 `eval()'
に(ソースコード文字列の代わりに) 渡すことで、実行したり値評価したり
することができます。 

詳しくは

を読んで下さい。


File: python-lib-jp.info,  Node: 型オブジェクト,  Next: ヌルオブジェクト,  Prev: コードオブジェクト,  Up: 他の組み込み型

3.11.6 型オブジェクト
---------------------

型オブジェクトは様々なオブジェクト型を表します。オブジェクトの型は
組み込み関数 `type()' でアクセスされます。型オブジェクトには
特有の操作はありません。標準モジュール `types' には全ての
組み込み型名が定義されています。 

型は `<type 'int'>' のように書き表されます。


File: python-lib-jp.info,  Node: ヌルオブジェクト,  Next: 省略表記オブジェクト,  Prev: 型オブジェクト,  Up: 他の組み込み型

3.11.7 ヌルオブジェクト
-----------------------

このオブジェクトは明示的に値を返さない関数によって返されます。
このオブジェクトには特有の操作はありません。ヌルオブジェクト
は一つだけで、`None' (組み込み名) と名づけられています。

`None' と書き表されます。


File: python-lib-jp.info,  Node: 省略表記オブジェクト,  Next: ブール値,  Prev: ヌルオブジェクト,  Up: 他の組み込み型

3.11.8 省略表記オブジェクト
---------------------------

このオブジェクトは拡張スライス表記によって使われます ( を参照して
ください)。特殊な操作は何もサポートしていません。省略表記オブジェクト
は一つだけで、その名前は `Ellipsis' (組み込み名) です。

`Ellipsis' と書き表されます。


File: python-lib-jp.info,  Node: ブール値,  Next: 内部オブジェクト,  Prev: 省略表記オブジェクト,  Up: 他の組み込み型

3.11.9 ブール値
---------------

ブール値とは二つの定数オブジェクト `False' および `True' です。
これらは真偽値を表すために使われます (他の値も偽または真とみなされ
ます) 数値処理のコンテキスト (例えば算術演算子の引数として使われた
場合) では、これらはそれぞれ 0 および 1 と同様に振舞います。
任意の値に対して真偽値を変換できる場合、組み込み関数 `bool()' は
値をブール値にキャストするのに使われます (真値テストの節を参照
してください)

これらはそれぞれ `False' および `True' と書き表されます。 


File: python-lib-jp.info,  Node: 内部オブジェクト,  Prev: ブール値,  Up: 他の組み込み型

3.11.10 内部オブジェクト
------------------------

この情報については  を読んで
下さい。このオブジェクトではスタックフレーム、トレースバック、
スライスオブジェクトを記述しています。


File: python-lib-jp.info,  Node: 特殊な属性,  Prev: 他の組み込み型,  Up: 組み込み型

3.12 特殊な属性
===============

実装では、いくつかのオブジェクト型に対して、数個の読み出し専用の特殊な
属性を追加しています。それぞれ:

`__dict__'
     オブジェクトの (書き込み可能な)
     属性を保存するために使われる辞書または
     他のマップ型オブジェクトです。

`__methods__'
     _This is deprecated in Python 2.2.
     オブジェクトの属性からなるリストを取得するには、 組み込み関数
     `dir()' を使ってください。この属性はもう 利用できません。_


`__members__'
     _This is deprecated in Python 2.2.
     オブジェクトの属性からなるリストを取得するには、 組み込み関数
     `dir()' を使ってください。この属性はもう 利用できません。_


`__class__'
     クラスインスタンスが属しているクラスです。

`__bases__'
     クラスオブジェクトの基底クラスからなるタプルです。基底クラスを
     持たない場合、空のタプルになります。


File: python-lib-jp.info,  Node: 文字列処理,  Next: データ型,  Prev: 組み込み型,  Up: Top

4 文字列処理
************

この章で解説されているモジュールは文字列を操作するさまざまな処理を提供し
ます。以下に概要を示します。

stringオブジェクトのメソッドについては、*Note 文字列メソッド::節の
"文字列型のメソッド"もごらんください。

* Menu:

* string::
* re::
* struct::
* difflib::
* StringIO::
* cStringIO::
* textwrap::
* codecs::
* unicodedata::
* stringprep::
* fpformat::


File: python-lib-jp.info,  Node: string,  Next: re,  Prev: 文字列処理,  Up: 文字列処理

4.1 一般的な文字列操作
======================

一般的な文字列操作

`string' モジュールには便利な定数やクラスが数多く入っています。
また、現在は文字列のメソッドとして利用できる、すでに撤廃された古い関数
も入っています。正規表現に関する文字列操作の関数は `re'  を参照してください。

* Menu:

* 文字列定数::
* テンプレート文字列::
* 文字列操作関数::
* 撤廃された文字列関数::


File: python-lib-jp.info,  Node: 文字列定数,  Next: テンプレート文字列,  Prev: string,  Up: string

4.1.1 文字列定数
----------------

このモジュールでは以下の定数を定義しています。

`ascii_letters'
     後述の `ascii_lowercase' と`ascii_uppercase' を合わ
     せたもの。この値はロケールに依存しません。

`ascii_lowercase'
     小文字 `'abcdefghijklmnopqrstuvwxyz''。この値はロケールに依存せ
     ず、固定です。

`ascii_uppercase'
     大文字 `'ABCDEFGHIJKLMNOPQRSTUVWXYZ''。この値はロケールに依存せ
     ず、固定です。

`digits'
     文字列 `'0123456789'' です。

`hexdigits'
     文字列 `'0123456789abcdefABCDEF'' です。

`letters'
     後述の `lowercase' と `uppercase' を合わせた文字列です。
     具体的な値はロケールに依存しており、`locale.setlocale()'
     が呼ばれたときに更新されます。

`lowercase'
     小文字として扱われる文字全てを含む文字列です。ほとんどのシステムでは
     文字列 `'abcdefghijklmnopqrstuvwxyz'' です。この定義を変更しては
     なりません -- 変更した場合の`upper()' と `swapcase()'
     に対する影響は定義されていません。具体的な値はロケールに依存しており、
     `locale.setlocale()' が呼ばれたときに更新されます。

`octdigits'
     文字列 `'01234567'' です。

`punctuation'
     `C' ロケールにおいて、句読点として扱われる ASCII 文字の文字列です。

`printable'
     印刷可能な文字で構成される文字列です。
     `digits'、`letters'、`punctuation' および `whitespace'
     を組み合わせたものです。

`uppercase'
     大文字として扱われる文字全てを含む文字列です。ほとんどのシステムでは
     `'ABCDEFGHIJKLMNOPQRSTUVWXYZ'' です。この定義を変更してはなりません
     --- 変更した場合の`lower()' と `swapcase()' に対する
     影響は定義されていません。具体的な値はロケールに依存しており、
     `locale.setlocale()' が呼ばれたときに更新されます。

`whitespace'
     空白 (whitespace) として扱われる文字全てを含む文字列です。
     ほとんどのシステムでは、これはスペース (space)、タブ (tab)、改行
     (linefeed)、 復帰 (return)、改頁 (formfeed)、垂直タブ (vertical
     tab) です。 この定義を変更してはなりません --
     変更した場合の`strip()' と `split()'
     に対する影響は定義されていません。


File: python-lib-jp.info,  Node: テンプレート文字列,  Next: 文字列操作関数,  Prev: 文字列定数,  Up: string

4.1.2 テンプレート文字列
------------------------

テンプレート (template) を使うと、PEP 292 で解説されているように
より簡潔に文字列置換 (string substitution) を行えるようになります。
通常の`%' ベースの置換に代わって、テンプレートでは以下のような
規則に従った`$'ベースの置換をサポートしています:

   * `$$' はエスケープ文字です; `$' 一つに置換されます。

   * `$identifier' は置換プレースホルダの指定で、 "identifier"
     というキーへの対応付けに相当します。デフォルトは、"identifier"
     の部分には Python の識別子が書かれていなければなりません。 `$'
     の後に識別子に使えない文字が出現すると、そこでプレースホルダ名の
     指定が終わります。

   * `${identifier}' は`$identifier' と同じです。
     プレースホルダ名の後ろに識別子として使える文字列が続いていて、それを
     プレースホルダ名の一部として扱いたくない場合、例えば
     "${noun}ification" のような場合に必要な書き方です。

上記以外の書き方で文字列中に`$' を使うと`ValueError' を送出します。

_Added in Python version 2.4_

`string' モジュールでは、上記のような規則を実装した `Template'
クラスを提供しています。 `Template' のメソッドを以下に示します:

`Template(template)'
     コンストラクタはテンプレート文字列になる引数を一つだけ取ります。

`substitute(mapping[, **kws])'
     テンプレート置換を行い、新たな文字列を生成して返します。MAPPING は
     テンプレート中のプレースホルダに対応するキーを持つような任意の辞書類似
     オブジェクトです。辞書を指定する代わりに、キーワード引数も指定でき、その
     場合にはキーワードをプレースホルダ名に対応させます。 MAPPING と
     KWS の両方が指定され、内容が重複した場合には、 KWS
     に指定したプレースホルダを優先します。

`safe_substitute(mapping[, **kws])'
     `substitute()' と同じですが、プレースホルダに対応するものを
     MAPPING や KWS から見つけられなかった場合に、 `KeyError'
     例外を送出する代わりにもとのプレースホルダが
     そのまま入ります。また、`substitute()'とは違い、規則外の 書き方で
     `$' を使った場合でも、`ValueError' を送出 せず単に `$' を返します。

     その他の例外も発生しうる一方で、このメソッドが「安全 (safe)」
     と呼ばれているのは、置換操作が常に例外を送出する代わりに利用可能な
     文字列を返そうとしているからです。別の見方をすれば、
     `safe_substitute()' は区切り間違いによるぶら下がり (dangling
     delimiter) や波括弧の非対応、Python の識別子として無効な
     プレースホルダ名を含むような不正なテンプレートを何も警告せずに
     無視するため、安全とはいえないのです。

`Template' のインスタンスは、次のような public な属性を 提供しています:

`template'
     コンストラクタの引数 TEMPLATE に渡されたオブジェクトです。通常、
     この値を変更すべきではありませんが、読み込み専用アクセスを強制している
     わけではありません。

Templateの使い方の例を以下に示します:

     >>> from string import Template
     >>> s = Template('$who likes $what')
     >>> s.substitute(who='tim', what='kung pao')
     'tim likes kung pao'
     >>> d = dict(who='tim')
     >>> Template('Give $who $100').substitute(d)
     Traceback (most recent call last):
     [...]
     ValueError: Invalid placeholder in string: line 1, col 10
     >>> Template('$who likes $what').substitute(d)
     Traceback (most recent call last):
     [...]
     KeyError: 'what'
     >>> Template('$who likes $what').safe_substitute(d)
     'tim likes $what'

さらに進んだ使い方: `Template' のサブクラスを導出して、
プレースホルダの書式、区切り文字、テンプレート文字列の解釈に
使われている正規表現全体をカスタマイズできます。
こうした作業には、以下のクラス属性をオーバライドします:

   * DELIMITER - プレースホルダの開始を示すリテラル文字列
     です。デフォルトの値は `$' です。実装系はこの文字列に対して
     必要に応じて `re.escape()' を呼び出すので、正規表現を表す
     ような文字列にしては _なりません_。

   * IDPATTERN - 波括弧でくくらない形式のプレースホルダ
     の表記パターンを示す正規表現です (波括弧は自動的に適切な場所に追加
     されます)。で尾フォルトの値は`[_a-z][_a-z0-9]*' という
     正規表現です。

他にも、クラス属性PATTERN をオーバライドして、正規表現パターン
全体を指定できます。オーバライドを行う場合、PATTERN の値は 4
つの名前つきキャプチャグループ (capturing group) を持った
正規表現オブジェクトでなければなりません。これらのキャプチャグループは、
上で説明した規則と、無効なプレースホルダに対する規則に対応しています:

   * ESCAPED - このグループはエスケープシーケンス、すなわち
     デフォルトパターンにおける `$$' に対応します。

   * NAMED - このグループは波括弧でくくらないプレースホルダ名に
     対応します; キャプチャグループに区切り文字を含めてはなりません。

   * BRACED - このグループは波括弧でくくったプレースホルダ名に
     対応します; キャプチャグループに区切り文字を含めてはなりません。

   * INVALID - このグループはそのほかの区切り文字のパターン
     (通常は区切り文字一つ)
     に対応し、正規表現の末尾に出現せねばなりません。


File: python-lib-jp.info,  Node: 文字列操作関数,  Next: 撤廃された文字列関数,  Prev: テンプレート文字列,  Up: string

4.1.3 文字列操作関数
--------------------

以下の関数は文字列またはUnicodeオブジェクトを操作できます。これらの関数は
文字列型のメソッドにはありません。

`capwords(s)'
     `split()' を使って引数を単語に分割し、`capitalize()' を
     使ってそれぞれの単語の先頭の文字を大文字に変換し、 `join()'
     を使ってつなぎ合わせます。
     この置換処理は文字列中の連続する空白文字をスペース一つに置き換え、
     先頭と末尾の空白を削除するので注意してください。

`maketrans(from, to)'
     `translate()' や `regex.compile()' に渡すのに適した
     変換テーブルを返します。このテーブルは、 FROM 内の各文字を TO
     の同じ位置にある文字に対応付けます; FROM と TO
     は同じ長さでなければなりません。

     _`lowercase' と `uppercase' から取り出した
     文字列を引数に使ってはなりません; ロケールによっては、これらは同じ
     長さになりません。大文字小文字の変換には、常に`lower()'  または
     `upper()'を使ってください。_


File: python-lib-jp.info,  Node: 撤廃された文字列関数,  Prev: 文字列操作関数,  Up: string

4.1.4 撤廃された文字列関数
--------------------------

以下の一連の関数は、文字列型や Unicode
型のオブジェクトのメソッドとしても 定義されています; 詳しくは
"文字列型のメソッド" (*Note 文字列メソッド::)を 参照してください。
ここに挙げた関数は Python 3.0 で削除されることはないはずですが、
撤廃された関数とみなして下さい。このモジュールで定義されている関数は以下の
通りです:

`atof(s)'
     _This is deprecated in Python 2.0.  組み込み関数 `float()'
     を使ってください。_

     文字列を浮動小数点型の数値に変換します。文字列は Python における
     標準的なの浮動小数点リテラルの文法に従っていなければなりません。
     先頭に符号（`+' または `-'）が付くのは構いません。
     この関数に文字列を渡した場合は、組み込み関数 `float()'  と同じように振舞います。

     _Note:_ 文字列を渡した場合、根底にある C ライブラリによって NaN  や
     Infinity  を返す場合があります。
     こうした値を返させるのがどんな文字列の集合であるかは、全て C
     ライブラリに依存しており、ライブラリによって異なると知られています。

`atoi(s[, base])'
     _This is deprecated in Python 2.0.  組み込み関数 `int()'
     を使ってください。_

     文字列 S を、BASE を基数とする整数に変換します。 文字列は 1
     桁またはそれ以上の数字からなっていなければなりません。 先頭に符号
     (`+' または `-') が付くのは構いません。 BASE のデフォルト値は 10
     です。 BASE が 0 の場合、 (符号を剥ぎ取った後の)
     文字列の先頭にある文字列に従ってデフォルトの
     基数を決定します。`0x' か `0X' なら 16、`0' なら 8、
     その他の場合は 10 が基数になります。BASE が 16 の場合、先頭の `0x'
     や `0X' が付いていても受け付けますが、必須ではありません。
     文字列を渡す場合、この関数は組み込み関数 `int()' と同じように
     振舞います。
     (数値リテラルをより柔軟に解釈したい場合には、組み込み関数 `eval()'  を使ってください。)

`atol(s[, base])'
     _This is deprecated in Python 2.0.  組み込み関数 `long()'
     を使ってください。_

     文字列 S を、BASE を基数とする長整数に変換します。 文字列は 1
     桁またはそれ以上の数字からなっていなければなりません。 先頭に符号
     (`+' または `-') が付くのは構いません。 BASE は `atoi()'
     と同じ意味です。基数が 0 の場合を 除き、文字列末尾に `l' や`L'
     を付けてはなりません。 BASE を指定しないか、10
     を指定して文字列を渡した場合には、 この関数は組み込み関数
     `long()' 

     と同じように振舞います。

`capitalize(word)'
     先頭文字だけ大文字にした WORD のコピーを返します。

`expandtabs(s[, tabsize])'
     現在のカラムと指定タブ幅に従って文字列中のタブを展開し、
     一つまたはそれ以上のスペースに置き換えます。文字列中に改行が出現する
     たびにカラム番号は 0 にリセットされます。
     この関数は、他の非表示文字やエスケープシーケンスを解釈しません。
     タブ幅のデフォルトは 8 です。

`find(s, sub[, start[,end]])'
     `S[START:END]' の中で、部分文字列 SUB が
     完全な形で入っている場所のうち、最初のものを S のインデクスで
     返します。見つからなかった場合は `-1' を返します。 START と END
     のデフォルト値、および、負の値を指定した
     場合の解釈は文字列のスライスと同じです。

`rfind(s, sub[, start[, end]])'
     `find()' と同じですが、最後に見つかったもののインデックスを返
     します。

`index(s, sub[, start[, end]])'
     `find()' と同じですが、部分文字列が見つからなかったときに
     `ValueError' を送出します。

`rindex(s, sub[, start[, end]])'
     `rfind()' と同じですが、部分文字列が見つからなかったときに
     `ValueError' 送出します。

`count(s, sub[, start[, end]])'
     `S[START:END]' における、部分文字列 SUB の (重複しない)
     出現回数を返します。START と END のデフォルト値、
     および、負の値を指定した場合の解釈は文字列のスライスと同じです。

`lower(s)'
     S のコピーを大文字を小文字に変換して返します。

`split(s[, sep[, maxsplit]])'
     文字列S 内の単語からなるリストを返します。オプションの第二引数 SEP
     を指定しないか、または`None' にした場合、 空白文字
     (スペース、タブ、改行、リターン、改頁) からなる任意の文字列
     で単語に区切ります。SEP を`None' 以外の値に指定した場合、
     単語の分割に使う文字列の指定になります。戻り値のリストには、
     文字列中に分割文字列が重複せずに出現する回数より一つ多い要素が
     入るはずです。オプションの第三引数 MAXSPLIT はデフォルトで 0 です。
     この値がゼロでない場合、最大でも MAXSPLIT 回の分割しか行わず、
     リストの最後の要素は未分割の残りの文字列になります
     (従って、リスト中の 要素数は最大でも`MAXSPLIT+1' です)。

     空文字列に対する分割を行った場合の挙動は SEP の値に依存します。
     SEP を指定しないか`None' にした場合、結果は空のリストに なります。
     SEP に文字列を指定した場合、空文字列一つの入った リストになります。

`rsplit(s[, sep[, maxsplit]])'
     S 中の単語からなるリストを S の末尾から検索して生成し
     返します。関数の返す語のリストは全ての点で `split()' の
     返すものと同じになります。ただし、オプションの第三引数 MAXSPLIT
     をゼロでない値に指定した場合には必ずしも同じにはなりません。
     MAXSPLIT がゼロでない場合には、最大でMAXSPLIT 個の 分割を
     _右端から_ 行います - 未分割の残りの文字列はリストの
     最初の要素として返されます (従って、リスト中の要素数は最大でも
     `MAXSPLIT+1' です)。 _Added in Python version 2.4_

`splitfields(s[, sep[, maxsplit]])'
     この関数は `split()' と同じように振舞います。 (以前は `split()'
     は単一引数の場合にのみ使い、`splitfields()'
     は引数2つの場合でのみ使っていました)。

`join(words[, sep])'
     単語のリストやタプルを間にSEP を入れて連結します。 SEP
     のデフォルト値はスペース文字 1 つです。
     `string.join(string.split(S, SEP), SEP)' は 常に S になります。

`joinfields(words[, sep])'
     この関数は `join()' と同じふるまいをします (以前は、 `join()'
     を使えるのは引数が 1 つの場合だけで、 `joinfields()'
     は引数2つの場合だけでした)。 文字列オブジェクトには `joinfields()'
     メソッドがないので 注意してください。代わりに `join()'
     メソッドを使ってください。

`lstrip(s[, chars])'
     文字列の先頭から文字を取り除いたコピーを生成して返します。 CHARS
     を指定しない場合や `None' にした場合、
     先頭の空白を取り除きます。CHARS を`None' 以外の値にする場合、
     CHARS は文字列でなければなりません。 _Changed in Python version
     2.2.3_

`rstrip(s[, chars])'
     文字列の末尾から文字を取り除いたコピーを生成して返します。 CHARS
     を指定しない場合や `None' にした場合、
     末尾の空白を取り除きます。CHARS を`None' 以外の値にする場合、
     CHARS は文字列でなければなりません。 _Changed in Python version
     2.2.3_

`strip(s[, chars])'
     文字列の先頭と末尾から文字を取り除いたコピーを生成して返します。
     CHARS を指定しない場合や `None' にした場合、
     先頭と末尾の空白を取り除きます。CHARS を `None' 以外に指定する
     場合、CHARS は文字列でなければなりません。 _Changed in Python
     version 2.2.3_

`swapcase(s)'
     S の大文字と小文字を入れ替えたものを返します。

`translate(s, table[, deletechars])'
     S の中から、 (もし指定されていれば) DELETECHARS に入っている
     文字を削除し、TABLE を使って文字変換を行って返します。 TABLE は
     256 文字からなる文字列で、各文字はそのインデクスを序数と
     する文字に対する変換先の文字の指定になります。

`upper(s)'
     S に含まれる小文字を大文字に置換して返します。

`ljust(s, width)'

`rjust s, width'

`center s, width'
     文字列を指定した文字幅のフィールド中でそれぞれ左寄せ、右寄せ、中央寄せ
     します。これらの関数は指定幅になるまで文字列 S の左側、右側、および
     両側のいずれかにスペースを追加して、少なくとも WIDTH 文字からなる
     文字列にして返します。文字列を切り詰めることはありません。

`zfill(s, width)'
     数値を表現する文字列の左側に、指定の幅になるまでゼロを付加します。符号付きの
     数字も正しく処理します。

`replace(str, old, new[, maxreplace])'
     S 内の部分文字列 OLD を全て NEW に置換したものを返し ます。
     MAXREPLACE を指定した場合、最初に見つかった MAXREPLACE
     個分だけ置換します。


File: python-lib-jp.info,  Node: re,  Next: struct,  Prev: string,  Up: 文字列処理

4.2 正規表現操作
================

Perl 風のシンタクスを用いた正規表現検索とマッチ操作。

このモジュールでは、Perl で見られるものと同様な正規表現マッチング操作
を提供しています。正規表現のパターン文字列にはヌルバイトを含められませ
んが、`\NUMBER' 記法を使えばヌルバイトを指定できます。
パターンと検索対象文字列の両方について、 8 ビット文字列と Unicode 文字
列を同じように扱えます。`re' モジュールはいつでも利用できます。

正規表現では、特殊な形式を表したり、特殊文字の持つ特別な意味を呼び出さ
ずにその特殊な文字を使えるようにするために、バックスラッシュ文字 (`\')
を使います。こうしたバックスラッシュの使い方は、 Python
の文字列リテラルにおける同じバックスラッシュ文字と衝突を起こし
ます。例えば、バックスラッシュ自体にマッチさせるには、パターン文字列と
して`'\\\\'' と書かなければなりません、というのも、正規表現は `\\'
でなければならず、さらに正規な Python 文字列リテラルでは各々
のバックスラッシュを `\\' と表現せねばならないからです。

正規表現パターンに Python の raw string 記法を使えばこの問題を解決でき
ます。`r'を前置した文字列リテラル内ではバックスラッシュを特
別扱いしません。従って、`"\n"' が改行一文字の入った文字列になる
のに対して、`r"\n"' は `\' と`n'という二つ
の文字の入った文字列になります。通常、 Python コード中では、パターンを
この raw string 記法を使って表現します。

See also:
     `Mastering Regular Expressions 詳説 正規表現'{Jeffrey Friedl
     著、O'Reilly 刊の正規表現に関する本です。この本の第2版
     ではPyhonについては触れていませんが、良い正規表現パターンの書き方を非
     常にくわしく説明しています。}

* Menu:

* 正規表現のシンタクス::
* マッチング vs 検索::
* Contents of Module re::
* 正規表現オブジェクト::
* MatchObject オブジェクト::
* 例::


File: python-lib-jp.info,  Node: 正規表現のシンタクス,  Next: マッチング vs 検索,  Prev: re,  Up: re

4.2.1 正規表現のシンタクス
--------------------------

正規表現 (すなわち RE) は、表現にマッチ (match) する文字列の集合を表し
ています。このモジュールの関数を使えば、ある文字列が指定の正規表現にマッ
チするか (または指定の正規表現がある文字列にマッチするか、つまりは同じ
ことですが) を検査できます。

正規表現を連結すると新しい正規表現を作れます。_A_ と _B_ が
ともに正規表現であれば _AB_ も正規表現です。一般的に、文字列 _p_ が A
とマッチし、別の文字列 _q_ が B とマッチすれば、文 字列 _pq_は AB
にマッチします。ただし、この状況が成り立つのは、 _A_ と _B_
との間に境界条件がある場合や、番号付けされたグルー
プ参照のような、優先度の低い演算を_A_ や _B_ が含まない場合 だけです。
かくして、ここで述べるような、より簡単でプリミティブな正規表現から、
複雑な正規表現を容易に構築できます。正規表現に関する理論と実装の詳細に
ついては上記の Friedl 本か、コンパイラの構築に関する教科書を調べて下さ
い。

以下で正規表現の形式に関する簡単な説明をしておきます。より詳細な情報や
よりやさしい説明に関しては、`http://www.python.org/doc/howto/'
からアクセスできる正規表現ハウツウを調べて下さい。

正規表現には、特殊文字と通常文字の両方を含められます。`A'、
`a'、あるいは `0'のようなほとんどの通常文字は最も
簡単な正規表現になります。こうした文字は、単純にその文字自体にマッチし
ます。通常の文字は連結できるので、"last" は文字列
`'last''とマッチします。(この節の以降の説明では、正規表現を引用符
を使わずに"この表示スタイル: special style" で書き、マッチ対象
の文字列は、`'引用符で括って'' 書きます。)

`|' や `(' といったいくつかの文字は特殊文字です。
特殊文字は通常の文字の種別を表したり、あるいは特殊文字の周辺にある通常
の文字に対する解釈方法に影響します。

特殊文字を以下に示します:
``.''
     (ドット) デフォルトのモードでは改行以外の任意の文字にマッチします。
     `DOTALL' フラグが指定されていれば改行も含むすべての文字にマッ
     チします。

``^''
     (キャレット) 文字列の先頭とマッチします。`MULTILINE'
     モードでは各改行の直 後にマッチします。

``$''
     文字列の末尾、あるいは文字列の末尾の改行の直前にマッチします。例えば、
     "foo" は 'foo' と 'foobar' の両方にマッチします。一方、正規表現
     "foo$"は 'foo' だけとマッチします。興味深いことに、 'foo1\nfoo2\n'
     を "foo.$" で検索し た場合、通常のモードでは 'foo2'
     だけにマッチし、`MULTILINE' モードでは 'foo1' にもマッチします。

``*''
     直前にある RE に作用して、 RE を 0
     回以上できるだけ多く繰り返したもの
     にマッチさせるようにします。例えば "ab*" は 'a'、'ab'、あるいは
     'a' に任意個数の'b' を続けたものにマッチします。

``+''
     直前にある RE に作用して、 RE を、1
     回以上繰り返したものにマッチさせる ようにします。例えば "ab+" は
     'a' に一つ以上の 'b' が続いたも のにマッチし、 'a'
     単体にはマッチしません。

``?''
     直前にある RE に作用して、 RE を 0 回か 1
     回繰り返したものにマッチさせ るようにします。例えば "ab?" は 'a'
     あるいは 'ab' にマッチしま す。

``*?', `+?', `??''
     `*'、`+'、 `?' といった修飾子は、すべて "貪欲 (greedy)"
     マッチ、すなわちできるだけ多くのテキストにマッチす
     るようになっています。時にはこの動作が望ましくない場合もあります。例え
     ば正規表現 "<.*>" を `'<H1>title</H1>'' にマッチさせると、
     `'<H1>'' だけにマッチするのではなく全文字列にマッチしてしまいます。
     `?'を修飾子の後に追加すると、"非貪欲 (non-greedy)" ある いは
     "最小一致 (minimal)" のマッチになり、できるだけ _少ない_
     文字数のマッチになります。例えば上の式で ".*?"を使うと `'<H1>''
     だけにマッチします。

``{M}''
     前にある RE の M 回の正確なコピーとマッチすべきであることを指定
     します；マッチ回数が少なければ、RE 全体ではマッチしません。例えば、
     "a{6}" は、正確に 6個の `a' 文字とマッチしますが、
     5個ではマッチしません。

``{M,N}''
     結果の RE は、前にある RE を、 M回からN 回まで繰り返したもので、
     できるだけ多く繰り返したものとマッチするように、マッチします。
     例えば、"a{3,5}"は、3個から 5個の `a' 文字とマッチします。
     Mを省略するとマッチ回数の下限として0を指定した事になり、 N
     を省略することは、上限が無限であることを指定します； "a{4,}b" は
     `aaaab'や、千個の `a' 文字に `b'が
     続いたものとマッチしますが、`aaab'とはマッチしません。
     コンマは省略できません、そうでないと修飾子が上で述べた形式と混同されてしまうからです。

``{M,N}?''
     結果の RE は、前にある RE の M回からN
     回まで繰り返したもので、できるだけ_少なく_
     繰り返したものとマッチするように、マッチします。これは、前の修飾子の
     控え目バージョンです。 例えば、 6文字 文字列
     `'aaaaaa''では、"a{3,5}" は、5個の `a'
     文字とマッチしますが、"a{3,5}?" は3個の文字と マッチするだけです。

``\''
     特殊文字をエスケープする( `*'や `?'等のような文字との
     マッチをできるようにする)か、あるいは、特殊シーケンスの合図です;
     特殊シーケンスは後で議論します。

     もしパターンを表現するのに raw string を使用していないのであれば、
     Python
     も、バックスラッシュを文字列リテラルでのエスケープシーケンスとして
     使っていることを覚えていて下さい；もしエスケープシーケンスを
     Python の構文解析器が認識して処理しなければ、そのバックスラッシュと
     それに続く文字は、結果の文字列にそのまま含まれます。しかし、もし
     Python が 結果のシーケンスを認識するのであれば、バックスラッシュを
     2回 繰り返さなければ いけません。このことは複雑で理解しにくいので、
     最も簡単な表現以外は、 すべて raw string を使うことをぜひ勧めます。

``[ '] 文字の集合を指定するのに使用します。文字は個々に'
     リストするか、文字の範囲を、2つの文字と`-'でそれらを分離
     して指定することができます。特殊文字は集合内では有効ではありません。
     例えば、"[akm$]"は、文字 `a'、`k'、 `m'、あるいは
     `$'のどれかとマッチします； "[a-z]"
     は、任意の小文字と、`[a-zA-Z0-9]' は、
     任意の文字や数字とマッチします。 (以下で定義する) `\w'
     や`\S'のような
     文字クラスも、範囲に含めることができます。もし文字集合に `]' や
     `-' を含めたいのなら、その前にバックスラッシュを
     付けるか、それを最初の文字として指定します。たとえば、パターン
     "[]]" は `']'' とマッチします。

     範囲内にない文字とは、その集合の"補集合をとること"で
     マッチすることができます。これは、集合の最初の文字として `^'
     を含めることで表すことができます； 他の場所にある `^'は、単純に
     `^'文字とマッチするだけです。例えば、 "[{^}5]" は、
     `5'以外の任意の文字とマッチし、 "[^`^']" は、 `^'
     以外の任意の文字とマッチします。

``|''
     `A|B' は、ここで A と B は任意の RE ですが、 A か B
     のどちらかとマッチする正規表現を作成します。任意個数の RE を、
     こういう風に `|' で分離することができます。これはグループ
     (以下参照)
     内部でも同様に使えます。検査対象文字列をスキャンする中で、 `|'
     で分離された RE は左から右への順に検査されます。
     一つでも完全にマッチしたパターンがあれば、そのパターン枝が受理されます。
     このことは、もし `A' がマッチすれば、たとえ`B' によるマッチが
     全体としてより長いマッチになったとしても、`B'
     を決して検査しないことを 意味します。 言いかえると、`|'
     演算子は決して貪欲 (greedy) ではありません。 文字通りの
     `|'とマッチするには、"\|" を使うか、 あるいはそれを "[|]"
     のように文字クラス内に入れます。

``(...)''
     丸括弧の中にどのような正規表現があってもマッチし、
     またグループの先頭と末尾を表します；グループの中身は、マッチが
     実行された後に検索され、後述する "\NUMBER"
     特殊シーケンス付きの文字列内で、後でマッチされます。 文字通りの
     `(' や `)'とマッチするには、 "\(" あるいは "\)" を
     使うか、それらを文字クラス内に入れます： "[(] [)]"。

``(?...)''
     これは拡張記法です( `(' に続く`?'は他には意味がありません)。
     `?'の後の最初の文字が、この構造の意味とこれ以上の
     シンタクスがどういうものであるかを決定します。
     拡張記法は普通新しいグループを作成しません；
     "(?P<NAME>...)"がこの規則の唯一の例外です。
     以下に現在サポートされている拡張記法を示します。

``(?iLmsux)''
     ( 集合 `i'、`L'、 `m'、 `s'、`u'、`x'
     から1文字以上)。グループは空文字列ともマッチします；文字は、
     正規表現全体の対応するフラグ (`re.I'、 `re.L'、 `re.M'、 `re.S'、
     `re.U'、 `re.X' ) を設定します。 これはもしFLAG 引数を`compile()'
     関数に渡さずに、そのフラグを正規表現の一 部として含めたいならば
     役に立ちます。

     "(?x)" フラグは、式が構文解析される
     方法を変更することに注意して下さい。
     これは式文字列内の最初か、あるいは1つ以上の空白文字の後で使うべきです。
     もしこのフラグの前に非空白文字があると、その結果は未定義です。

``(?:...)''
     正規表現の丸括弧の非グループ化バージョンです。
     どのような正規表現が丸括弧内にあってもマッチしますが、
     グループによってマッチされたサブ文字列は、
     マッチを実行したあと検索されることも、あるいは後でパターンで
     参照されることも _できません_。

``(?P<NAME>...)''
     正規表現の丸括弧と同様ですが、
     グループによってマッチされたサブ文字列は、記号グループ名
     NAMEを介してアクセスできます。グループ名は、正しい Python
     識別子でなければならず、各グループ名は、正規表現内で一度だけ定義され
     なければなりません。記号グループは、グループに名前が付けられていない場合のように、
     番号付けされたグループでもあります。そこで上の例で
     'id'という名前がついた グループは、番号グループ 1
     として参照することもできます。

     たとえば、もしパターンが
     "(?P<id>[a-zA-Z_]\w*)"であれば、このグループは、
     マッチオブジェクトのメソッドへの引数に、 `m.group('id')' あるいは
     `m.end('id')'のような名前で、 またパターンテキスト内(例えば、
     "(?P=id)") や 置換テキスト内( `\g<id>'のように)
     で名前で参照することができます。

``(?P=NAME)''
     前に NAME と名前付けされたグループに
     マッチした、いかなるテキストにもマッチします。

``(?#...)''
     コメントです；括弧の内容は 単純に無視されます。

``(?=...)''
     もし "..."が次に続くものとマッチすればマッチしますが、
     文字列をまったく消費しません。これは先読みアサーション(lookahead
     assertion)と呼ばれます。 例えば、"Isaac (?=Asimov)"
     は、`'Isaac~''に
     `'Asimov''が続く場合だけ、`'Isaac~''とマッチします。

``(?!...)''
     もし "..." が次に続くものとマッチしなければマッチします。
     これは否定先読みアサーション(negative lookahead
     assertion)です。例えば、 "Isaac (?!Asimov)"は、`'Isaac~'' に
     `'Asimov''が続か_ない_場合のみマッチします。

``(?<=...)''
     もし文字列内の現在位置の前に、 現在位置で終わる "..."
     とのマッチがあれば、マッチします。 これは
     "肯定後読みアサーション(positive lookbehind
     assertion)"と呼ばれます。 "(?<=abc)def" は、`abcdef'
     にマッチを見つけます、
     というのは後読みが3文字をバックアップして、含まれているパターンと
     マッチするかどうか検査するからです。含まれるパターンは、
     固定長の文字列にのみマッチしなければなりません、ということは、
     "abc" や "a|b" は許されますが、 "a*" や "a{3,4}"
     は許されないことを意味します。
     肯定後読みアサーションで始まるパターンは、検索される文字列の
     先頭とは決してマッチしないことに注意して下さい； 多分、`match()'
     関数よりは `search()'関数を使いたいでしょう：

          >>> import re
          >>> m = re.search('(?<=abc)def', 'abcdef')
          >>> m.group(0)
          'def'

     この例ではハイフンに続く単語を探します：

          >>> m = re.search('(?<=-)\w+', 'spam-egg')
          >>> m.group(0)
          'egg'

``(?<!...)''
     もし文字列内の現在位置の前に "..."との
     マッチがないならば、マッチします。これは
     "否定後読みアサーション(negative lookbehind
     assertion)"と呼ばれます。
     肯定後読みアサーションと同様に、含まれるパターンは固定長さの文字列だけに
     マッチしなければいけません。否定後読みアサーションで始まるパターンは、
     検索される文字列の先頭とマッチすることができます。

``(?(ID/NAME)yes-pattern|no-pattern)''
     グループに ID が与えられている、もしくは NAME
     があるとき、"yes-pattern" とマッチします。存在しないときには
     "no-pattern" とマッチします。 "|no-pattern"
     はオプションで省略できます。例えば
     "(<)?(\w+@\w+(?:\.\w+)+)(?(1)>)"  はemailアドレスとマッチする
     最低限のパターンです。これは `'<user@host.com>'' や
     `'user@host.com'' にはマッチしますが、 `'<user@host.com''
     にはマッチしません。 _Added in Python version 2.4_


特殊シーケンスは `\' と以下のリストにある文字から
構成されます。もしリストにあるのが通常文字でないならば、結果の RE は
2番目の文字とマッチします。例えば、 "\$" は文字 `$'とマッチします。
``\NUMBER''
     同じ番号のグループの中身とマッチします。
     グループは1から始まる番号をつけられます。例えば、 "(.+) \1"
     は、`'the the'' あるいは `'55 55''とマッチしますが、 `'the
     end''とはマッチしません(グループの後のスペースに注意して下さい)。
     この特殊シーケンスは最初の 99
     グループのうちの一つとマッチするのに使うことが
     できるだけです。もし NUMBERの最初の桁が 0 である、すなわち
     NUMBERが 3
     桁の8進数であれば、それはグループのマッチとは解釈されず、 8進数値
     NUMBER を持つ文字として解釈されます。 文字クラスの `['と
     `]'の中の数値エスケープは、文字として 扱われます。

``\A''
     文字列の先頭だけにマッチします。

``\b''
     空文字列とマッチしますが、単語の先頭か末尾の時だけです。
     単語は英数字あるいは下線文字の並んだものとして定義されていますので、単語の末尾は
     空白あるいは非英数字、非下線文字によって表されます。 {}`\b'
     は、`\w' と `\W'の間の境界として定義されているので、
     英数字であると見なされる文字の正確な集合は、`UNICODE'と`LOCALE'フラグの
     値に依存することに注意して下さい。 文字の範囲の中では、"\b" は、
     Python の文字列リテラルと互換性を持たせるために、
     後退(backspace)文字を表します。

``\B''
     空文字列とマッチしますが、それが単語の先頭あるいは末尾に
     _ない_時だけです。これは {}`\b'のちょうど反対ですので、 `LOCALE'
     と`UNICODE'の設定にも影響されます。

``\d''
     `UNICODE' フラグが指定されていない場合、
     任意の十進数とマッチします；これは集合 "[0-9]" と同じ意味です。
     `UNICODE' がある場合、Unicode 文字特性データベースで
     数字と分類されているものにマッチします。

``\D''
     `UNICODE' フラグが指定されていない場合、
     任意の非数字文字とマッチします；これは集合 "[{^}0-9]" と
     同じ意味です。`UNICODE' がある場合、これは Unicode 文字
     特性データベースで数字とマーク付けされている文字以外にマッチします。

``\s''
     `LOCALE' と `UNICODE' フラグが
     指定されていない場合、任意の空白文字とマッチします；これは 集合 "[
     \t\n\r\f\v]"と同じ意味です。

     `LOCALE' がある場合、これはこの集合に加えて現在のロケールで
     空白と定義されている全てにマッチします。`UNICODE' が設定されると、
     これは "[ \t\n\r\f\v]" と Unicode 文字特性データベースで
     空白と分類されている全てにマッチします。

``\S''
     `LOCALE' と `UNICDOE' がフラグが
     指定されていない場合、任意の非空白文字とマッチします；これは 集合
     "[^ \t\n\r\f\v]" と同じ意味です。 `LOCALE'
     がある場合、これはこの集合に無い文字と、現在の
     ロケールで空白と定義されていない文字にマッチします。`UNICODE' が
     設定されていると、"[ \t\n\r\f\v]" でない文字と、 Unicode
     文字特性データベースで空白とマーク付けされていないものに
     マッチします。

``\w''
     `LOCALE' と`UNICODE' フラグが
     指定されていない時は、任意の英数文字および下線とマッチします；これは、集合
     "[a-zA-Z0-9_]"と同じ意味です。`LOCALE'が設定されていると、 集合
     "[0-9_]" プラス 現在のロケール用に英数字として定義されている任意の
     文字とマッチします。 もし `UNICODE' が設定されていれば、 文字
     "[0-9_]" プラス Unicode
     文字特性データベースで英数字として分類されて
     いるものとマッチします。

``\W''
     `LOCALE'と `UNICODE' フラグが
     指定されていない時、任意の非英数文字とマッチします；これは 集合
     "[{^}a-zA-Z0-9_]"と同じ意味です。 `LOCALE'が指定されていると、
     集合 "[0-9_]"になく、
     現在のロケールで英数字として定義されていない任意の文字とマッチします。
     もし `UNICODE'がセットされていれば、これは "[0-9_]" および Unicode
     文字特性データベースで
     英数字として表されている文字以外のものとマッチします。

``\Z''
     文字列の末尾とのみマッチします。


Python 文字列リテラルによってサポートされている標準エスケープの
ほとんども、正規表現パーザに認識されます：

     \a      \b      \f      \n
     \r      \t      \v      \x
     \\

8進エスケープは制限された形式で含まれています：もし第1桁が 0
であるか、もし8進3桁であれば、それは8進エスケープとみなされます。
そうでなければ、それはグループ参照です。文字列リテラルについて、
8進エスケープはほとんどの場合3桁長になります。


File: python-lib-jp.info,  Node: マッチング vs 検索,  Next: Contents of Module re,  Prev: 正規表現のシンタクス,  Up: re

4.2.2 マッチング vs 検索
------------------------

Python は、正規表現に基づく、2つの異なるプリミティブな操作を
提供しています：マッチと検索です。もしあなたが Perl
の記号に慣れているのであれば、 検索操作があなたの求めるものです。
`search()' 関数と、 コンパイルされた正規表現オブジェクトでの
対応するメソッドを見て下さい。

マッチは、`^'で始まる正規表現を使うと、検索とは
異なるかもしれないことに注意して下さい： `^'
は文字列の先頭でのみ、あるいは `MULTILINE'
モードでは改行の直後ともマッチします。 "マッチ" 操作は
、もしそのパターンが、モードに拘らず文字列の先頭とマッチ
するか、あるいは改行がその前にあるかどうかに拘らず、省略可能な POS
引数によって 与えられる先頭位置でマッチする場合のみ成功します。

     re.compile("a").match("ba", 1)           # 成功
     re.compile("^a").search("ba", 1)         # 失敗； 'a' は先頭にない
     re.compile("^a").search("\na", 1)        # 失敗； 'a' は先頭にない
     re.compile("^a", re.M).search("\na", 1)  # 成功
     re.compile("^a", re.M).search("ba", 1)   # 失敗； \n が前にない


File: python-lib-jp.info,  Node: Contents of Module re,  Next: 正規表現オブジェクト,  Prev: マッチング vs 検索,  Up: re

4.2.3 モジュール コンテンツ
---------------------------

このモジュールは幾つかの関数、定数、例外を定義します。この関数のいくつかは
コンパイル済み正規表現向けの完全版のメソッドを簡略化したバージョンです。
それなりのアプリケーションのほとんどで、コンパイルされた形式が用いられる
のが普通です。

`compile(pattern[, flags])'
     正規表現パターンを正規表現オブジェクトにコンパイルします。
     このオブジェクトは、以下で述べる `match()' と `search()'
     メソッドを使って、マッチングに使うことが できます。

     式の動作は、FLAGSの値を指定することで加減することが
     できます。値は以下の変数を、ビットごとの OR ( `|' 演算子)を
     使って組み合わせることができます。

     シーケンス

          prog = re.compile(pat)
          result = prog.match(str)

     は、

          result = re.match(pat, str)

     と同じ意味ですが、`compile()' を使うバージョンの方が、
     その式を一つのプログラムで何回も使う時にはより効率的です。

`I'

`IGNORECASE'
     大文字・小文字を区別しないマッチングを実行します；
     "[A-Z]"のような式は、
     小文字にもマッチします。これは現在のロケールには 影響されません。

`L'

`LOCALE'
     "\w"、 "\W"、 "\b"および、"\B"、 "\s" と "\S"
     を、現在のロケールに従わさせます。

`M'

`MULTILINE'
     指定されると、パターン文字 `^' は、
     文字列の先頭および各行の先頭(各改行の直後)とマッチします；そして
     パターン文字 `$' は文字列の末尾および各行の末尾
     (改行の直前)とマッチします。デフォールトでは、 `^' は、
     文字列の先頭とだけマッチし、
     `$'は、文字列の末尾および文字列の末尾の
     改行の直前(がもしあれば)とマッチします。

`S'

`DOTALL'
     特殊文字 `.' を、改行をを含む任意の文字と、とにかくマッチ
     させます；このフラグがなければ、`.' は、改行 _以外の_
     任意の文字とマッチします。

`U'

`UNICODE'
     "\w"、 "\W"、 "\b"、 "\B"、 "\d"、 "\D"、 "\s" と "\S" を、
     Unicode 文字特性データベースに従わさせます。 _Added in Python
     version 2.0_

`X'

`VERBOSE'
     このフラグによって、より見やすく正規表現を書くことができます。
     パターン内の空白は、文字クラス内にあるか、エスケープされていない
     バックスラッシュが前にある時以外は無視されます。
     また、行に、文字クラス内にもなく、エスケープされていない
     バックスラッシュが前にもない `#' がある時は、 そのような
     `#'の左端から その行の末尾までが無視されます。

`search(pattern, string[, flags])'
     STRING全体を走査して、正規表現 PATTERN がマッチを発生する
     位置を探して、対応する `MatchObject' インスタンスを返します。
     もし文字列内に、そのパターンとマッチする位置がないならば、 `None'
     を返します； これは、文字列内のある点で長さゼロのマッチ
     を探すこととは異なることに注意して下さい。

`match(pattern, string[, flags])'
     もし STRING の先頭で0 個以上の文字が正規表現 PATTERN と
     マッチすれば、対応する `MatchObject' インスタンスを返します。
     もし文字列がパターンとマッチしなければ、 `None' を返します；
     これは長さゼロのマッチとは異なることに 注意して下さい。

     _Note:_ もし STRING のどこかにマッチを位置付けたいのであれば、
     代わりに `search()' を使って下さい。

`split(pattern, string[, maxsplit` = 0'])'
     STRINGを、 PATTERNがあるたびに分割します。もし 括弧のキャプチャが
     PATTERNで使われていれば、パターン内の
     すべてのグループのテキストも結果のリストの一部として返されます。
     MAXSPLIT がゼロでなければ、高々  MAXSPLIT個の分割が
     発生し、文字列の残りは、リストの最終要素として返されます。
     (非互換性ノート：オリジナルの Python 1.5 リリースでは、
     MAXSPLITは無視されていました。これはその後のリリースでは
     修正されました。)

          >>> re.split('\W+', 'Words, words, words.')
          ['Words', 'words', 'words', '']
          >>> re.split('(\W+)', 'Words, words, words.')
          ['Words', ', ', 'words', ', ', 'words', '.', '']
          >>> re.split('\W+', 'Words, words, words.', 1)
          ['Words', 'words, words.']


`findall(pattern, string[, flags])'
     PATTERN のSTRING へのマッチのうち、重複しない全てのマッチ
     からなるリストを返します。パターン中に何らかのグループがある場合、グルー
     プのリストを返します。グループが複数定義されていた場合、タプルのリスト
     になります。他のマッチの開始部分に接触しないかぎり、空のマッチも結果に
     含められます。 _Added in Python version 1.5.2_ _Changed in Python
     version 2.4_

`finditer(pattern, string[, flags])'
     STRING 内の RE PATTERNの重複しないマッチのすべての
     イテレータを返します。各マッチごとに、イテレータはマッチ
     オブジェクトを返します。他にマッチがなければ、
     空のマッチも結果に入ります。 _Added in Python version 2.2_
     _Changed in Python version 2.4_

`sub(pattern, repl, string[, count])'
     STRING 内で、 PATTERNと重複しないマッチの内、一番左にあるものを
     置換 REPL で置換して得られた文字列を返します。もしパターンが
     見つからなければ、STRING を変更せずに返します。 REPL
     は文字列でも関数でも構いません；もしそれが文字列であれば、
     それにある任意のバックスラッシュエスケープは処理されます。すなわち、
     `\n' は単一の改行文字に変換され、`\r'は、
     行送りコードに変換されます、等々。 `\j'
     のような未知のエスケープはそのままにされます。
     `\6'のような後方参照(backreference)は、パターンのグループ 6
     とマッチ したサブ文字列で置換されます。 例えば：

          >>> re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
          ...        r'static PyObject*\npy_\1(void)\n{',
          ...        'def myfunc():')
          'static PyObject*\npy_myfunc(void)\n{'

     もし REPL が関数であれば、重複しない PATTERNが発生する
     たびにその関数が呼ばれます。この関数は一つのマッチオブジェクト
     引数を取り、置換文字列を返します。例えば：

          >>> def dashrepl(matchobj):
          ...     if matchobj.group(0) == '-': return ' '
          ...     else: return '-'
          >>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')
          'pro--gram files'

     パターンは、文字列でも RE
     でも構いません；もし正規表現フラグを指定する 必要があれば、RE
     オブジェクトを使うか、パターンに埋込み修飾子を使わ
     なければなりません；たとえば、`sub("(?i)b+", "x", "bbbb BBBB")' は
     `'x x'' を返します。

     省略可能な引数 COUNT は、置換されるパターンの出現回数の
     最大値です；COUNT は非負の整数でなければなりません。
     もし省略されるかゼロであれば、出現したものがすべて置換されます。
     パターンのマッチが空であれば、以前のマッチと隣合わせでない時だけ
     置換されますので、`sub('x*', '-', 'abc')' は `'-a-b-c-'' を
     返します。

     上で述べた文字エスケープや後方参照の他に、 `\g<name>' は、
     "(?P<name>...)" のシンタクスで定義されているように、 `name'
     という名前のグループとマッチしたサブ文字列を
     使います。`\g<number>' は対応するグループ番号を使います； それゆえ
     `\g<2>' は `\2'と同じ意味ですが、 `\g<2>0'
     のような置換でもあいまいではありません。 `\20' は、 グループ 20
     への参照として解釈されますが、グループ 2 にリテラル文字 `0'
     が続いたものへの参照としては解釈されません。 後方参照  `\g<0>' は、
     RE とマッチするサブ文字列全体を置き換えます。

`subn(pattern, repl, string[, count])'
     `sub()' と同じ操作を行いますが、タプル `(NEW_STRING、
     NUMBER_OF_SUBS_MADE)'を返します。

`escape(string)'
     バックスラッシュにすべての非英数字をつけたSTRINGを返します；これは
     もし、その中に正規表現のメタ文字を持つかもしれない任意のリテラル文字列と
     マッチしたいとき、役に立ちます。

`error'
     ここでの関数の一つに渡された文字列が、正しい正規表現ではない時
     (例えば、その括弧が対になっていなかった)、あるいはコンパイルや
     マッチングの間になんらかのエラーが発生したとき、発生する例外です。
     たとえ文字列がパターンとマッチしなくても、
     決してエラーではありません。


File: python-lib-jp.info,  Node: 正規表現オブジェクト,  Next: MatchObject オブジェクト,  Prev: Contents of Module re,  Up: re

4.2.4 正規表現オブジェクト
--------------------------

コンパイルされた正規表現オブジェクトは、以下のメソッドと属性をサポート
します：

`match(string[, pos[, endpos]])'
     もし STRINGの先頭の 0 個以上の文字がこの正規表現とマッチすれば、
     対応する `MatchObject' インスタンスを返します。
     もし文字列がパタンーとマッチしなければ、`None' を返します；
     これは長さゼロのマッチとは異なることに 注意して下さい。

     _Note:_ もしマッチを STRING のどこかに位置付けたければ、 代わりに
     `search()' を使って下さい。

     省略可能な第2のパラメータ
     POSは、文字列内の検索を始めるインデッスクを
     与えます；デフォールトでは `0' です。これは、文字列のスライシングと
     完全に同じ意味だというわけではありません；`'^'' パターン文字は、
     文字列の実際の先頭と改行の直後とマッチしますが、
     それが必ずしも検索が開始するインデックスであるわけでは
     ないからです。

     省略可能なパラメータ ENDPOSは、どこまで文字列が検索されるかを
     制限します；あたかもその文字列が ENDPOS 文字長であるかのように
     しますので、 POS から `ENDPOS - 1' までの文字が、
     マッチのために検索されます。もし ENDPOS が POSより小さければ、
     マッチは見つかりませんが、そうでなくて、もしRX がコンパイルされた
     正規表現オブジェクトであれば、 `RX.match(STRING, 0, 50)' は
     `RX.match(STRING[:50], 0)'と同じ意味になります。

`search(string[, pos[, endpos]])'
     STRING全体を走査して、この正規表現がマッチする位置を探して、
     対応する `MatchObject' インスタンスを返します。もし文字列内に
     パターンとマッチする位置がないならば、`None' を返します；
     これは文字列内のある点で長さゼロのマッチを探すこととは異なることに
     注意して下さい。

     省略可能な POS と ENDPOS パラメータは、 `match()'
     メソッドのものと同じ意味を持ちます。

`split(string[, maxsplit` = 0'])'
     `split()' 関数と同様で、コンパイルしたパターンを使います。

`findall(string[, pos[, endpos]])'
     `findall()' 関数と同様で、コンパイルしたパターンを使います。

`finditer(string[, pos[, endpos]])'
     `finditer()' 関数と同様で、コンパイルしたパターンを使います。

`sub(repl, string[, count` = 0'])'
     `sub()' 関数と同様で、コンパイルしたパターンを使います。

`subn(repl, string[, count` = 0'])'
     `subn()' 関数と同様で、コンパイルしたパターンを使います。

`flags'
     flags 引数は、RE オブジェクトがコンパイルされたとき使われ、 もし
     flags が何も提供されなければ `0' です。

`groupindex'
     "(?P<ID>)"で定義された任意の記号グループ名の、グループ番号
     への辞書マッピングです。もし記号グループが
     パターン内で何も使われていなければ、辞書は空です。

`pattern'
     RE オブジェクトがそれからコンパイルされたパターン文字列です。


File: python-lib-jp.info,  Node: MatchObject オブジェクト,  Next: 例,  Prev: 正規表現オブジェクト,  Up: re

4.2.5 MatchObject オブジェクト
------------------------------

`MatchObject' インスタンスは以下のメソッドと属性を サポートします：

`expand(template)'
     テンプレート文字列 TEMPLATE に、`sub()' メソッドがするような
     バックスラッシュ置換をして得られる文字列を返します。
     `\n'のようなエスケープは適当な文字に変換され、数値の後方参照
     (`\1'、 `\2') と名前付きの後方参照 (`\g<1>'、 `\g<name>')
     は、対応するグループの 内容で置き換えられます。

`group([group1, ...])'
     マッチした1個以上のサブグループを返します。もし引数で一つであれば、
     その結果は一つの文字列です；複数の引数があれば、その結果は、
     引数ごとに一項目を持つタプルです。引数がなければ、 GROUP1
     はデフォールトでゼロです(マッチしたものすべてが 返されます)。 もし
     GROUPN 引数がゼロであれば、対応する戻り値は、マッチ
     する文字列全体です；もしそれが範囲 [1..99]
     内であれば、それは、対応する
     丸括弧つきグループとマッチする文字列です。もしグループ番号が負であるか、
     あるいはパターンで定義されたグループの数より大きければ、
     `IndexError' 例外が発生します。もしグループがマッチしなかった
     パターンの一部に含まれていれば、対応する結果は `None' です。
     もしグループが、複数回マッチしたパターンの一部に 含まれていれば、
     最後のマッチが返されます。

     もし正規表現が "(?P<NAME>...)" シンタクスを使うならば、
     GROUPN引数は、それらのグループ名によってグループを識別する文字列であっても
     構いません。もし文字列引数がパターンのグループ名として使われていないもので
     あれば、`IndexError' 例外が発生します。

     適度に複雑な例題：

          m = re.match(r"(?P<int>\d+)\.(\d*)", '3.14')

     このマッチを実行したあとでは、`m.group(1)' は `m.group('int')'
     と同じく、`'3'' であり、そして`m.group(2)' は `'14'' です。

`groups([default])'
     1からどれだけ多くであろうがパターン内にあるグループ数までの、
     マッチの、すべてのサブグループを含むタプルを返します。 DEFAULT
     引数は、マッチに加わらなかったグループ用に使われます；
     それはデフォールトでは `None' です。 (非互換性ノート：オリジナルの
     Python 1.5 リリースでは、たとえタプルが一要素長で
     あっても、その代わりに文字列を返すことはありません。(1.5.1
     以降の)後のバージョンでは、
     そのような場合には、シングルトンタプルが返されます。)

`groupdict([default])'
     すべての _名前つきの_サブグループを含む、マッチの、
     サブグループ名でキー付けされた辞書を返します。 DEFAULT
     引数はマッチに加わらなかったグループ用に
     使われます；それはデフォールトでは `None'です。

`start([group])'

`end([group])'
     GROUPとマッチしたサブ文字列の先頭と末尾のインデックスを
     返します；GROUP は、デフォールトでは (マッチしたサブ文字列
     全体を意味する）ゼロです。 GROUP
     が存在してもマッチに寄与しなかった場合は、 `-1'
     を返します。マッチオブジェクト M および
     マッチに寄与しなかったグループ Gがあって、 グループ G
     とマッチしたサブ文字列 ( `M.group(G)'と同じ意味ですが) は、

          m.string[m.start(g):m.end(g)]

     です。 もし GROUPがヌル文字列とマッチすれば、 `m.start(GROUP)'が
     `m.end(GROUP)' と等しくなろことに 注意して下さい。例えば、 `M =
     re.search('b(c?)', 'cba')' の後では、`M.start(0)'は 1 で、
     `M.end(0)' は 2 であり、 `M.start(1)' と `M.end(1)' はともに 2
     であり、 `M.start(2)' は `IndexError'例外を発生します。

`span([group])'
     `MatchObject' M については、 2-タプル `(M.start(GROUP)、
     M.end(GROUP))'を 返します。もし GROUP
     がマッチに寄与しなかったら、これは `(-1, -1)' です。また GROUP
     はデフォールトでゼロです。

`pos'
     `RegexObject' の `search()' あるいは `match()' メソッドに渡された
     POSの値です。 これは RE
     エンジンがマッチを探し始める位置の文字列のインデックスです。

`endpos'
     `RegexObject' の `search()' あるいは `match()' メソッドに渡された
     ENDPOSの値です。 これは RE
     エンジンがそれ以上は進まない位置の文字列のインデックスです。

`lastindex'
     最後にマッチした取り込みグループの整数インデックスです。もしどのグループも
     全くマッチしなければ `None' です。例えば、"(a)b"、"((a)(b))" や
     "((ab))" といった表現が `'ab'' に適用された場合、`lastindex == 1'
     となり、同じ文字列に "(a)(b)" が適用された場合には `lastindex == 2'
     となるでしょう。

`lastgroup'
     最後にマッチした取り込みグループの名前です。もしグループに名前がないか、
     あるいはどのグループも全くマッチしなければ `None' です。

`re'
     その `match()'あるいは `search()' メソッドが、この `MatchObject'
     インスタンスを生成した正規表現オブジェクトです。

`string'
     `match()' あるいは `search()'に渡された文字列です。


File: python-lib-jp.info,  Node: 例,  Prev: MatchObject オブジェクト,  Up: re

4.2.6 例
--------

*`scanf()'をシミュレートする*

Python には現在のところ、`scanf()'に相当するものがありません。 正規表現は、
`scanf()'のフォーマット文字列よりも、一般的に
より強力であり、また冗長でもあります。以下の表に、 `scanf()'
のフォーマットトークンと正規表現の 大体同等な対応付けを示します。

`scanf()' トークン                   正規表現
------                               -----
`%c'                                 "."
`%5c'                                ".{5}"
`%d'                                 "[-+]?\d+"
`%e', `%E', `%f', `%g'               "[-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?"
`%i'                                 "[-+]?(0[xX][\dA-Fa-f]+|0[0-7]*|\d+)"
`%o'                                 "0[0-7]*"
`%s'                                 "\S+"
`%u'                                 "\d+"
`%x', `%X'                           "0[xX][\dA-Fa-f]+"

         /usr/sbin/sendmail - 0 errors, 4 warnings

のような文字列からファイル名と数値を抽出するには、

         %s - %d errors, %d warnings

のように `scanf()'フォーマットを使うでしょう。 それと同等な正規表現は

         (\S+) - (\d+) errors, (\d+) warnings

*再帰を避ける*

エンジンに大量の再帰を要求するような正規表現を作成すると、 `maximum
recursion limit exceeded(最大再帰制限を超過した)'
というメッセージを持つ `RuntimeError'
例外に出くわすかもしれません。たとえば、

     >>> import re
     >>> s = "Begin" + 1000 * 'a very long string' + 'end'
     >>> re.match('Begin (\w| )*? end', s).end()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
       File "/usr/local/lib/python2.5/re.py", line 132, in match
         return _compile(pattern, flags).match(string)
     RuntimeError: maximum recursion limit exceeded

再帰を避けるように正規表現を組みなおせることはよくあります。

Python 2.3 からは、再帰を避けるために "*?" パターンの利用が
特別扱いされるようになりました。したがって、上の正規表現は "Begin
[a-zA-Z0-9_ ]*?end" に書き直すことで再帰を防ぐことが
できます。それ以上の恩恵として、そのような正規表現は、
再帰的な同等のものよりもより速く動作します。


File: python-lib-jp.info,  Node: struct,  Next: difflib,  Prev: re,  Up: 文字列処理

4.3 文字列データをパックされたバイナリデータとして解釈する
==========================================================

文字列データをパックされたバイナリデータとして解釈します。

このモジュールは、 Python の値と Python 上で文字列データとして表される
C の構造体データとの間の変換を実現します。このモジュールでは、C 構造体の
レイアウトおよび Python の値との間で行いたい変換をコンパクトに表現する
ために、"フォーマット文字列" を使います。
このモジュールは特に、ファイルに保存されたり、ネットワーク接続を経由
したバイナリデータを扱うときに使われます。

このモジュールは以下の例外と関数を定義しています:

`error'
     様々な状況で送出された例外です; 引数は何が問題かを記述する文字列
     です。

`pack(fmt, v1, v2, ...)'
     値 `V1, V2, ...' が与えられたフォーマット
     で含まれる文字列データを返します。引数は指定したフォーマットが要求する
     型と正確に一致していなければなりません。

`unpack(fmt, string)'
     (おそらく `pack(FMT, ...)' でパックされた) 文字列
     データを、与えられた書式に従ってアンパックします。値が一つしかない場合を
     含め、結果はタプルで返されます。文字列データにはフォーマットが要求する
     だけのデータが正確に含まれていなければなりません (`len(STRING)' が
     `calcsize(FMT)' と一致しなければ なりません)。

`calcsize(fmt)'
     与えられたフォーマットに対応する構造体のサイズ
     (すなわち文字列データの サイズ) を返します。

フォーマット文字 (format character) は以下の意味を持っています; C と
Python の間の変換では、値は正確に以下に指定された型でなくては
なりません:

フォーマット       C での型           Python             備考
------             ------             ------             ------
x                  pad byte           no value           
c                  `char'             長さ 1 の文字列    
b                  `signed char'      整数型 (integer)   
B                  `unsigned char'    整数型             
h                  `short'            整数型             
H                  `unsigned short'   整数型             
i                  `int'              整数型             
I                  `unsigned int'     long 整数型        
l                  `long'             整数型             
L                  `unsigned long'    long 整数型        
q                  `long long'        long 整数型        (1)
Q                  `unsigned long     long 整数型        (1)
                   long'                                 
f                  `float'            浮動小数点型       
d                  `double'           浮動小数点型       
s                  `char[]'           文字列             
p                  `char[]'           文字列             
P                  `void *'           整数型             

注意事項:

`(1)'
     フォーマット文字 `q' および `Q' は、 プラットフォームの C
     コンパイラが C の `long long' 型、 Windows では `__int64'
     をサポートする場合にのみ、
     プラットフォームネイティブの値との変換を行うモードだけで利用することが
     できます。

     _Added in Python version 2.2_

フォーマット文字の前に整数をつけ、繰り返し回数 (count) を指定することが
できます。 例えば、フォーマット文字列 `'4h'' は `'hhhh'' と全く同じ
意味です。

フォーマット文字間の空白文字は無視されます; count とフォーマット
文字の間にはスペースを入れてはいけません。

フォーマット文字 `s' では、count は文字列のサイズと
して扱われます。他のフォーマット文字のように繰り返し回数ではありません;
例えば、`'10c'' が 10 個のキャラクタを表すのに対して、 `'10s'' は 10
バイトの長さを持った 1 個 の文字列です。文字列をパックする際には、
指定した長さにフィットするように、必要に応じて切り詰められたりヌル文字
で穴埋めされたりします。また特殊なケースとして、(`'0c'' が 0 個の
キャラクタを表すのに対して) `'0s'' は 1 個の空文字列を意味します。

フォーマット文字 `p' は "Pascal 文字列 (pascal string)"
をコードします。Pascal 文字列は固定長のバイト列に収められた短い可変長の
文字列です。count は実際に文字列データ中に収められる全体の長さ
です。このデータの先頭の 1 バイトには文字列の長さか255 のうち、小さい
方の数が収められます。その後に文字列のバイトデータが続きます。 `pack()'
に渡された Pascal 文字列の長さが長すぎた (count-1 よりも長い)
場合、先頭の count-1 バイトが書き込まれます。文字列が count-1
よりも短い場合、指定した count バイトに達するまでの残りの
部分はヌルで埋められます。`unpack()' では、フォーマット文字 `p'
は指定された count バイトだけデータを読み込みますが、
返される文字列は決して 255 文字を超えることはないので注意してください。

フォーマット文字 `I'、 `L'、 `q' および `Q' では、返される値は Python
long 整数です。

フォーマット文字 `P' では、返される値は Python 整数型または long
整数型で、これはポインタの値を Python での整数にキャストする際に、
値を保持するために必要なサイズに依存します。 `NULL' ポインタは常に
Python 整数型の `0' になります。
ポインタ型のサイズを持った値をパックする際には、Python 整数型 および
long 整数型オブジェクトを使うことができます。例えば、 Alpha および
Merced プロセッサは 64 bit のポインタ値を使いますが、これは
ポインタを保持するために Python long 整数型が使われることを意味します;
32 bit ポインタを使う他のプラットフォームでは Python 整数型が使われ
ます。

デフォルトでは、C では数値はマシンのネイティブ (native) の形式
およびバイトオーダ (byte order) で表され、適切にアラインメント
(alignment)
するために、必要に応じて数バイトのパディングを行ってスキップします
(これは C コンパイラが用いるルールに従います)。

これに代わって、フォーマット文字列の最初の文字を使って、バイトオーダや
サイズ、アラインメントを指定することができます。指定できる文字を
以下のテーブルに示します:

文字                     バイトオーダ             サイズおよびアラインメント
------                   -----                    -----
@                        ネイティブ               ネイティブ
=                        ネイティブ               標準
<                        リトルエンディアン       標準
>                        ビッグエンディアン       標準
!                        ネットワークバイトオーダ 標準
                         (= ビッグエンディアン)   

フォーマット文字列の最初の文字が上のいずれかでない場合、`@'
であるとみなされます。

ネイティブのバイトオーダはビッグエンディアンかリトルエンディアンで、
ホスト計算機に依存します。例えば、Motorola および Sun のプロセッサは
ビッグエンディアンです; Intel および DEC
のプロセッサはリトルエンディアン です。

ネイティブのサイズおよびアラインメントは C コンパイラの `sizeof'
式で決定されます。ネイティブのサイズおよびアラインメントは大抵ネイティブ
のバイトオーダと同時に使われます。

標準のサイズおよびアラインメントは以下のようになります:
どの型に対しても、 アラインメントは必要ありません
(ので、パディングを使う必要があります); `short' は 2 バイトです; `int'
と `long' は 4 バイトです; `long long' (Windows では `__int64') は 8
バイトです; `float' と `double' は順に 32-bit あるいは 64-bit の IEEE
浮動小数点数です。

`@' と `=' の違いに注意してください: 両方とも
ネイティブのバイトオーダですが、後者のバイトサイズやバイトオーダは
標準のものに合わせてあります。

`!' 表記法はネットワークバイトオーダがビッグエンディアンか
リトルエンディアンか忘れちゃったという熱意に乏しい人向けに用意されて
います。

バイトオーダに関して、「(強制的にバイトスワップを行う)ネイティブの逆」
を指定する方法はありません; `<' または `>' のうち
ふさわしい方を選んでください。

`P' フォーマット文字はネイティブバイトオーダでのみ利用可能 です
(デフォルトのネットワークバイトオーダに設定するか、`@'
バイトオーダ指定文字を指定しなければなりません)。 `=' を指定
した場合、ホスト計算機のバイトオーダに基づいてリトルエンディアンと
ビッグエンディアンのどちらを使うかを決めます。struct モジュールはこの
設定をネイティブのオーダ設定として解釈しないので、`P' を
使うことはできません。

以下に例を示します (この例は全てビッグエンディアンのマシンで、
ネイティブのバイトオーダ、サイズおよびアラインメントの場合です):

     >>> from struct import *
     >>> pack('hhl', 1, 2, 3)
     '\x00\x01\x00\x02\x00\x00\x00\x03'
     >>> unpack('hhl', '\x00\x01\x00\x02\x00\x00\x00\x03')
     (1, 2, 3)
     >>> calcsize('hhl')
     8

ヒント: 特定の型によるアラインメント要求に従うように構造体の末端を
そろえるには、count をゼロにした特定の型でフォーマットを終端します。
例えば、フォーマット `'llh0l'' は、 long 型が 4 バイトを境界と
してそろえられていると仮定して、末端に 2 バイトをパディングします。
この機能は変換対象がネイティブのサイズおよびアラインメントの場合
にのみ働きます; 標準に型サイズおよびアラインメントの設定ではいかなる
アラインメントも行いません。

See also:
     *Note array:: 一様なデータ型からなるバイナリ記録データのパック
     *Note xdrlib:: XDR データのパックおよびアンパック。


File: python-lib-jp.info,  Node: difflib,  Next: StringIO,  Prev: struct,  Up: 文字列処理

4.4 差異の計算を助ける
======================

オブジェクト同士の違いを計算する

_Added in Python version 2.1_

`SequenceMatcher'
     柔軟性のあるクラスで、ハッシュ化できる要素の連続であれば、
     どんな型のものであっても比較可能です。基礎的なアルゴリズムは
     可塑的なものであり、1980年代の後半に発表されたRatcliffとObershelp
     によるアルゴリズム、大げさに名づけられた"ゲシュタルトパターン
     マッチング"よりはもう少し良さそうなものです。その考え方は、
     "junk"要素を含まない最も長いマッチ列を探すことです（Ratcliffと
     Obershelpのアルゴリズムではjunkを示しません）。このアイデアは、
     下位のマッチ列から左または右に伸びる列の断片に対して再帰的に
     あてはまります。これは小さな文字列に対して効率良いものでは
     ありませんが、人間の目からみて「良く見える」ようにマッチする
     傾向があります。

     *実行時間:* 基本的なRatcliff-Obershelpアルゴリズムは、最
     悪の場合3乗、期待値でも2乗となります。`SequenceMatcher'
     オブジェクトは、最悪のケースで4乗、期待値はシーケンスの
     中の要素数に非常にややこしく依存しています。最良の場合
     は線形時間になります。

`Differ'
     テキスト行からなるシーケンスを比較するクラスです。人が読むことの
     できる差異を作成します。Differクラスは`SequenceMatcher'
     クラスを利用します。これらは、列からなるシーケンスを比較し、
     (ほぼ) 同一の列内の文字を比較します。

     `Differ'クラスによる差異の各行は、2文字のコードではじめられます。

     コード                             意味
     ------                             -----
     '- '                               列は文字列1にのみ存在する
     '+ '                               列は文字列2にのみ存在する
     '  '                               列は両方の文字列で同一
     '? '                               列は入力文字列のどちらにも存在しない

     '? 'で始まる列は線内の差異に注意を向けようとします。その差異は、
     入力されたシーケンスのどちらにも存在しません。シーケンスが
     タブ文字を含むとき、これらのラインは判別しづらいものになる
     ことがあります。

`HtmlDiff'
     このクラスは、二つのテキストを左右に並べて比較表示し、行間あるいは行内の
     変更点を強調表示するような HTML テーブル (またはテーブルの入った
     完全な HTML ファイル)
     を生成するために使います。テーブルは完全差分モード、
     コンテキスト差分モードのいずれでも生成できます。

     このクラスのコンストラクタは以下のようになっています:

    `__init__([tabsize][, wrapcolumn][, linejunk][, charjunk])'
          `HtmlDiff' のインスタンスを初期化します。

          TABSIZE はオプションのキーワード引数で、タブストップ幅を指定
          します。デフォルトは `8' です。

          WRAPCOLUMN はオプションのキーワード引数で、テキストを折り返す
          カラム幅を指定します。デフォルトは `None'
          で折り返しを行いません。

          LINEJUNK および CHARJUNK はオプションのキーワード引数で、
          `ndiff()' (`HtmlDiff' はこの関数を使って左右のテキストの
          差分を HTML で生成します)
          に渡されます。それぞれの引数のデフォルト値 および説明は
          `ndiff()' のドキュメントを参照してください。


     以下のメソッドが public になっています:

    `make_file(fromlines, tolines [, fromdesc][, todesc][, context][, numlines])'
          FROMLINES と TOLINES (いずれも文字列のリスト) を比較し、
          行間または行内の変更点が強調表示された行差分の入った表を持つ完全な
          HTML ファイルを文字列で返します。

          FROMDESC および TODESC はオプションのキーワード引数で、
          差分表示テーブルにおけるそれぞれ差分元、差分先ファイルのカラムの
          ヘッダになる文字列を指定します
          (いずれもデフォルト値は空文字列です)。

          CONTEXT および NUMLINES はともにオプションのキーワード
          引数です。CONTEST を `True' にするとコンテキスト差分を
          表示し、デフォルトの `False' にすると完全なファイル差分を
          表示します。NUMLINES のデフォルト値は `5' で、 CONTEXT が
          `True' の場合、 NUMLINES は強調部分の前後に
          あるコンテキスト行の数を制御します。CONTEXT が `False'
          の場合、NUMLINES は "next"
          と書かれたハイパーリンクをたどった時に
          到達する場所が次の変更部分より何行前にあるかを制御します
          (値をゼロにした場合、"next"
          ハイパーリンクを辿ると変更部分の強調表示が
          ブラウザの最上部に表示されるようになります)。

    `make_table(fromlines, tolines [, fromdesc][, todesc][, context][, numlines])'
          FROMLINES と TOLINES (いずれも文字列のリスト) を比較し、
          行間または行内の変更点が強調表示された行差分の入った完全な
          HTML テーブル を文字列で返します。

          このメソッドの引数は、`make_file()' メソッドの引数と同じです。

     `Tools/scripts/diff.py'
     はこのクラスへのコマンドラインフロントエンド
     で、使い方を学ぶ上で格好の例題が入っています。

     _Added in Python version 2.4_

`context_diff(a, b[, fromfile][, tofile][, fromfiledate][, tofiledate][, n][, lineterm])'
     A と B (文字列のリスト) を比較し、差異
     (差異のある行を生成するジェネレータ) を、diff
     のコンテクスト形式で返します。

     コンテクスト形式は、変更があった行に前後数行を加えてある、コンパクトな表
     現方法です。変更箇所は、変更前/変更後に分けて表します。コンテクスト（変
     更箇所前後の行）の行数は N で指定し、デフォルト値は 3 です。

     デフォルトでは、diff の制御行 (`***' や `---' を含む行) の最
     後には、改行文字が付加されます。この場合、入出力共、行末に改行文字を持つ
     ので、`file.readlines()' で得た入力から生成した差異を、
     `file.writelines()' に渡す場合に便利です。行末に改行文字を持た
     ない入力に対しては、出力でも改行文字を付加しないように LINETERM 引
     数に `""' を渡してください。

     diff
     コンテクスト形式は、通常、ヘッダにファイル名と変更時刻を持ってい
     ます。この情報は、文字列 FROMFILE、TOFILE、FROMFILEDATE、
     TOFILEDATE で指定できます。変更時刻の書式は、通常、 `time.ctime()'
     の戻り値と同じものを使います。指定しなかった場合
     のデフォルト値は、空文字列です。

     `Tools/scripts/diff.py'
     は、この関数のコマンドラインのフロントエンド（インターフェイス）になっています。

     _Added in Python version 2.3_

`get_close_matches(word, possibilities[, n][, cutoff])'
     最も「十分」なマッチのリストを返します。WORDは、なるべく
     マッチして欲しい（一般的には文字列の）シーケンスです。
     POSSIBILITIESはWORDにマッチさせる（一般的には文字列）
     シーケンスのリストです。

     オプションの引数N（デフォルトでは`3'）はメソッドの返す
     マッチの最大数です。N は `0' より大きくなければなりません。

     オプションの引数 CUTOFF （デフォルトでは `0.6'）は、 [0,
     1]の間となるfloatの値です。可能性として、少なくとも WORD
     が無視されたのと同様の数値にはなりません。

     可能性のある、（少なくとも N に比べて）最もよいマッチはリストに
     よって返され、同一性を表す数値に応じて最も近いものから順に格納されます。

          >>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy'])
          ['apple', 'ape']
          >>> import keyword
          >>> get_close_matches('wheel', keyword.kwlist)
          ['while']
          >>> get_close_matches('apple', keyword.kwlist)
          []
          >>> get_close_matches('accept', keyword.kwlist)
          ['except']


`ndiff(a, b[, linejunk[, charjunk]])'
     A と B （文字列からなるリスト）を比較し、`Differ'
     オブジェクト形式の差異（解析器は差異のある列）を返します。

     オプションのパラメータ LINEJUNK と CHARJUNK は、filter
     機能のためのキーワードです（使わないときは空にする）。

     LINEJUNK: string型の引数ひとつを受け取る関数で、文字列が
     junkか否かによってtrueを（違うときにはtrueを）返します。Python
     2.3以降、デフォルトでは（`None'）になります。それまでは、
     モジュールレべルの関数`IS_LINE_JUNK()'であり、それは
     少なくともひとつのシャープ記号（`#'）をのぞく、可視の
     キャラクタを含まない行をフィルタリングします。 Python
     2.3では、下位にある`SequenceMatcher'クラスが、
     雑音となるくらい頻繁に登場する列であるか否かを、動的に分析します。
     これは、バージョン2.3以前でのデフォルト値よりうまく動作します。

     CHARJUNK: 長さ1の文字を受け取る関数です。デフォルトでは、
     モジュールレべルの関数 IS_CHARACTER_JUNK()であり、これは空白文字列
     （空白またはタブ、注：改行文字をこれに含めるのは悪いアイデア！）を
     フィルタリングします。

     `Tools/scripts/ndiff.py' は、この関数のコマンドラインのフロント
     エンド（インターフェイス）です。

          >>> diff = ndiff('one\ntwo\nthree\n'.splitlines(1),
          ...              'ore\ntree\nemu\n'.splitlines(1))
          >>> print ''.join(diff),
          - one
          ?  ^
          + ore
          ?  ^
          - two
          - three
          ?  -
          + tree
          + emu


`restore(sequence, which)'
     差異を生成したシーケンスのひとつを返します。

     与えられるSEQUENCEは `Differ.compare()' または
     `ndiff()'によって生成され、ファイル1または2（引数
     WHICHで指定される）によって元の列に復元され、行頭の
     プレフィクスが取りのぞかれます。

     例:

          >>> diff = ndiff('one\ntwo\nthree\n'.splitlines(1),
          ...              'ore\ntree\nemu\n'.splitlines(1))
          >>> diff = list(diff) # materialize the generated delta into a list
          >>> print ''.join(restore(diff, 1)),
          one
          two
          three
          >>> print ''.join(restore(diff, 2)),
          ore
          tree
          emu


`unified_diff(a, b[, fromfile][, tofile][, fromfiledate][, tofiledate][, n][, lineterm])'
     A と B (共に文字列のリスト) を比較し、diff の unified 形式
     で、差異 (差分行を生成するジェネレータ) を返します。

     unified
     形式は変更があった行に前後数行を加えた、コンパクトな表現方法で
     す。変更箇所は (変更前/変更後を分離したブロックではなく)
     インライン・ス
     タイルで表されます。コンテクスト（変更箇所前後の行）の行数は、N で
     指定し、デフォルト値は 3 です。

     デフォルトでは、diff の制御行 (`---'、`+++'、`@@' を含 む行)
     は行末で改行します。この場合、入出力共、行末に改行文字を持つので、
     `file.readlines()' で得た入力を処理して生成した差異を、
     `file.writelines()' に渡す場合に便利です。

     行末に改行文字を持たない入力には、出力も同じように改行なしになるように、LINETERM
     引数を `""' にセットしてください

     diff
     コンテクスト形式は、通常、ヘッダにファイル名と変更時刻を持ってい
     ます。  この情報は、文字列 FROMFILE、TOFILE、
     FROMFILEDATE、TOFILEDATE で指定できます。変更時刻の書式は、
     通常、`time.ctime()' の戻り値と同じものを使います。 指定しなかっ
     た場合のデフォルト値は、空文字列です。

     `Tools/scripts/diff.py' は、この関数のコマンドラインのフロントエ
     ンド（インターフェイス）です。

     _Added in Python version 2.3_

`IS_LINE_JUNK(line)'
     無視できる列のときtrueを返します。列 LINE が空白、または `#"'
     ひとつのときには無視できます。それ以外の時には
     無視できません。`ndiff()' の引数LINKJUNKとして
     デフォルトで使用されます。 `ndiff()'のLINEJUNKはPython
     2.3以前のものです。

`IS_CHARACTER_JUNK(ch)'
     無視できる文字のときtrueを返します。文字 CH が空白、または
     タブ文字のときには無視できます。それ以外の時には無視できません。
     `ndiff()' の引数CHARJUNKとしてデフォルトで使用されます。

See also:
     `Pattern Matching: The Gestalt Approach （パターン マッチング:
     全体アプローチ）'{John W. Ratcliff と  D. E. Metzener
     による同一性アルゴリズムに関する議論。  1988年7月号掲載。}

* Menu:

* SequenceMatcherオブジェクト::
* SequenceMatcher の例::
* Differ オブジェクト::
* Differ の例::


File: python-lib-jp.info,  Node: SequenceMatcherオブジェクト,  Next: SequenceMatcher の例,  Prev: difflib,  Up: difflib

4.4.1 SequenceMatcherオブジェクト
---------------------------------

The `SequenceMatcher'
クラスには、以下のようなコンストラクタがあります。:

`SequenceMatcher([isjunk[, a[, b]]])'
     オプションの引数 ISJUNK は、`None' (デフォルトの値です)
     にするか、単一の引数をとる関数にせねばなりません。後者の場合、関数は
     シーケンスの要素を受け取り、要素が "junk"
     であり、無視すべきである場合に
     限り真をかえすようにせねばなりません。 ISJUNK に `None'
     を渡すと、`lambda x: 0' を渡したのと 同じになります;
     すなわち、いかなる要素も無視しなくなります。
     例えば以下のような引数を渡すと、空白とタブ文字を無視して文字のシーケンスを
     比較します。

          lambda x: x in " \t"

     オプションの引数 A と B は、比較される文字列です。
     デフォルトで、それらは空の文字列で、文字列の要素はハッシュ化できます。

`SequenceMatcher' オブジェクトは以下のメソッドを持ちます。

`set_seqs(a, b)'
     比較される2つの文字列を設定します。

`SequenceMatcher' オブジェクトは2つ目の文字列についての詳細な情報を
算定し、保管します。そのため、ひとつの文字列をいくつもの文字列と比較する場合、
まず `set_seq2()' を使って文字列を設定しておき、別の文字列をひとつづつ
比較するために、繰り返し `set_seq()' を呼び出します。

`set_seq1(a)'
     比較を行うひとつ目の文字列を設定します。比較される2つ目の文字列は
     変更されません。

`set_seq2(b)'
     比較を行う2つめ目のシーケンスを設定します。比較されるひとつ目の
     シーケンスは変更されません。

`find_longest_match(alo, ahi, blo, bhi)'
     `A[ALO:AHI]' と`B[BLO: BHI]'の中から、最長のマッチ列を探します。

     ISJUNKが省略されたか`None'の時、`get_longest_match()' は`A[I:I+K]
     'が`B[J: J+K]'と等しいような`(I, J, K)'を 返します。その値は`ALO
     <= I <= I+K <=  AHI'かつ`BLO <= J <= J+K <=  BHI'となります。`(I',
     J', K')'でも、 同じようになります。さらに`K >= K', I <= I'' が`I
     == I', J <= J''でも同様です。
     言い換えると、いくつものマッチ列すべてのうち、A内で最初に
     始まるものを返します。そしてそのA内で最初のマッチ列すべての
     うちB内で最初に始まるものを返します。

          >>> s = SequenceMatcher(None, " abcd", "abcd abcd")
          >>> s.find_longest_match(0, 5, 0, 9)
          (0, 4, 5)

     引数ISJUNKが与えられている場合、上記の通り、はじめに再長の
     マッチ列を判定します。ブロック内にjunk要素が見当たらないような
     追加条件の際はこれに該当しません。次にそのマッチ列を、その両側の
     junk要素にマッチするよう、できる限り広げていきます。そのため結果
     となる列は、探している列のたまたま直前にあった同一のjunk以外の
     junkにはマッチしません。

     以下は前と同じサンプルですが、空白をjunkとみなしています。これは
     `' abcd''が2つ目の列の末尾にある`' abcd''にマッチしない
     ようにしています。代わりに`'abcd''にはマッチします。そして
     2つ目の文字列中、一番左の`'abcd''にマッチします。

          >>> s = SequenceMatcher(lambda x: x==" ", " abcd", "abcd abcd")
          >>> s.find_longest_match(0, 5, 0, 9)
          (1, 0, 4)

     どんな列にもマッチしない時は、`(ALO, BLO, 0)'を 返します。

`get_matching_blocks()'
     マッチしたシーケンス中で個別にマッチしたシーケンスをあらわす、
     3つの値のリストを返します。それぞれの値は`(I, J,
     N)'という形式であらわされ、`A[I:I+N] ==
     B[J:J+N]'いう関係を意味します。3つの値は
     IとJの間で単調に増加します。

     最後のタプルはダミーで、`(len(A), len(B), 0)'という
     値を持ちます。これは`N==0'である唯一のタプルです。

     もし `(I, J, N)' と `(I', J', N')' がリストで並んでいる3つ組で、
     2つ目が最後の3つ組でなければ、 `I+N != I'' または `J+N != J''
     です。言い換えると並んでいる3つ組
     は常に隣接していない同じブロックを表しています。 _Changed in
     Python version 2.5_

          >>> s = SequenceMatcher(None, "abxcd", "abcd")
          >>> s.get_matching_blocks()
          [(0, 0, 2), (3, 2, 2), (5, 4, 0)]


`get_opcodes()'
     aをbにするための方法を記述する5つのタプルを返します。それぞれの
     タプルは`(TAG, I1, I2, J1, J2)'
     という形式であらわされます。最初のタプルは`I1 == J1 ==
     0'であり、I1はその前にあるタプルのI2と同じ値です。
     同様にJ1は前のJ2と同じ値になります。

     TAGの値は文字列であり、次のような意味です。

     値                                 意味
     ------                             -----
     'replace'                          `A[I1:I2]'は`B[
                                        J1:J2]'に置き換えられる
     'delete'                           `A[I1:I2]' は削除される。
                                        この時、`J1 == J2'である
     'insert'                           `B[J1:J2]' が`A
                                        [I1:I1]'に挿入される。 この時`I1
                                        == I2'である。
     'equal'                            `A[I1:I2] == B[J1:J2]'
                                        (下位の文字列は同一)

     例:

          >>> a = "qabxcd"
          >>> b = "abycdf"
          >>> s = SequenceMatcher(None, a, b)
          >>> for tag, i1, i2, j1, j2 in s.get_opcodes():
          ...    print ("%7s a[%d:%d] (%s) b[%d:%d] (%s)" %
          ...           (tag, i1, i2, a[i1:i2], j1, j2, b[j1:j2]))
           delete a[0:1] (q) b[0:0] ()
            equal a[1:3] (ab) b[0:2] (ab)
          replace a[3:4] (x) b[2:3] (y)
            equal a[4:6] (cd) b[3:5] (cd)
           insert a[6:6] () b[5:6] (f)


`get_grouped_opcodes([n])'
     最大 N
     行までのコンテクストを含むグループを生成するような、ジェネレータを返します。

     このメソッドは、`get_opcodes()' で返されるグループの中から、似
     たような差異のかたまりに分け、間に挟まっている変更の無い部分を省きます。

     グループは `get_opcodes()' と同じ書式で返されます。

     _Added in Python version 2.3_

`ratio()'
     [0, 1]の範囲の浮動小数点で、シーケンスの同一性を測る値を返します。

     Tが2つのシーケンスそれぞれがもつ要素の総数だと仮定し、Mをマッチした
     数とすると、この値は2.0*M/Tであらわされます。もしシーケンスがまったく
     同じ場合、値は1.0となり、まったく異なる場合には`0.0'となります。

     このメソッドは`get_matching_blocks()'または`get_opcodes()'が
     まだ呼び出されていない場合には非常にコストが高く、この時より限定された
     機能をもった`quick_ratio()'もしくは`real_quick_ratio()'を
     最初に試してみることができます。


`quick_ratio()'
     `ratio()'で測定する同一性をより素早く、限定された形で測ります。

     このメソッドは`ratio()'より限定されており、これを超えるとは
     見なされませんが、高速に実行します。

`real_quick_ratio()'
     ratio()で測定する同一性を非常に素早く測ります。

     このメソッドは`ratio()'より限定されており、これを
     超えるとは見なされませんが、`ratio()'や`
     quick_ratio()'より高速に実行します。

この文字列全体のマッチ率を返す3つのメソッドは、異なる近似値に基づく
異なる結果を返します。とはいえ、`quick_ratio()'と`
real_quick_ratio()'は、常に`ratio()'より大きな値を示します。

     >>> s = SequenceMatcher(None, "abcd", "bcde")
     >>> s.ratio()
     0.75
     >>> s.quick_ratio()
     0.75
     >>> s.real_quick_ratio()
     1.0


File: python-lib-jp.info,  Node: SequenceMatcher の例,  Next: Differ オブジェクト,  Prev: SequenceMatcherオブジェクト,  Up: difflib

4.4.2 SequenceMatcher の例
--------------------------

この例は2つの文字列を比較します。空白を"junk"とします。

     >>> s = SequenceMatcher(lambda x: x == " ",
     ...                     "private Thread currentThread;",
     ...                     "private volatile Thread currentThread;")

`ratio()' は、[0, 1] の範囲の値を返し、シーケンスの同一性を測ります。
経験によると、`ratio()' の値が0.6を超えると、シーケンスがよく似て
いることを示します。

     >>> print round(s.ratio(), 3)
     0.866

シーケンスのどこがマッチしているかにだけ興味のある時には
`get_matching_blocks()' が手軽でしょう。

     >>> for block in s.get_matching_blocks():
     ...     print "a[%d] and b[%d] match for %d elements" % block
     a[0] and b[0] match for 8 elements
     a[8] and b[17] match for 6 elements
     a[14] and b[23] match for 15 elements
     a[29] and b[38] match for 0 elements

注意:最後のタプルは、`get_matching_blocks()'が常にダミーで
あることで返されるものです。 `(len(A), len(B), 0)'
であり、これは最後のタプルの要素（マッチするようその数）がゼロとなる
唯一のケースです。

はじめのシーケンスがどのようにして2番目のものになるのかを知るには、
`get_opcodes()' を使います。

     >>> for opcode in s.get_opcodes():
     ...     print "%6s a[%d:%d] b[%d:%d]" % opcode
      equal a[0:8] b[0:8]
     insert a[8:8] b[8:17]
      equal a[8:14] b[17:23]
      equal a[14:29] b[23:38]

See also the function `get_close_matches()' in this module, which shows
how simple code building on `SequenceMatcher' can be used to do useful
work.  `SequenceMatcher' を使った、シンプルで使えるコードを知るには、
このモジュールの関数 `get_close_matches()' を参照してください。


File: python-lib-jp.info,  Node: Differ オブジェクト,  Next: Differ の例,  Prev: SequenceMatcher の例,  Up: difflib

4.4.3 Differ オブジェクト
-------------------------

`Differ'オブジェクトによって抽出された差分は、*最小単位*の
差分を見ても問題なく抽出されます。反対に、最小の差分の場合にはこれとは
反対のように見えます。それらが、どこれも可能ときに同期するからです。
時折、思いがけなく100ページもの部分にマッチします。隣接するマッチ列の
同期するポイントを制限することで、より長い差異を算出する再帰的なコスト
での、局所性の概念を制限します。

`Differ'は、以下のようなコンストラクタを持ちます。

`Differ([linejunk[, charjunk]])'
     オプションのパラメータLINEJUNKとCHARJUNKはfilter関数の
     ために指定します（もしくは`None'を指定）。

     LINEJUNK:ひとつの文字列引数を受け取れるべき関数です。
     文字列がjunkのときにtrueを返します。デフォルトでは、`None'
     であり、どんな行であってもjunkとは見なされません。

     CHARJUNK: この関数は（長さ1の）文字列を引数として受け取り、文字列が
     junkであるときにtrueを返します。デフォルトは`None'であり、どんな文字列も
     junkとは見なされません。

`Differ'オブジェクトは、以下のひとつのメソッドによって使われます
（違いを生成します）。

`compare(a, b)'
     文字列からなる2つのシーケンスを比較し、差異（を表す文字列からなる
     シーケンス）を生成します。

     Each sequence must contain individual single-line strings ending
     with newlines. Such sequences can be obtained from the
     `readlines()' method of file-like objects.  The delta generated
     also consists of newline-terminated strings, ready to be printed
     as-is via the `writelines()' method of a file-like object.
     それぞれのシーケンスは、改行文字によって終了する、独立したひと連なりの
     文字列でなければなりません。そのようなシーケンスは、ファイル形式オブジェクトの
     `readline()'メソッドによって得ることができます。（得られる）差異は
     改行文字で終了する文字列として得られ、ファイル形式オブジェクトの`writeline()'
     メソッドによって出力できる形になっています。


File: python-lib-jp.info,  Node: Differ の例,  Prev: Differ オブジェクト,  Up: difflib

4.4.4 Differ の例
-----------------

この例では2つのテキストを比較します。初めに、改行文字で終了する独立した
1行の連続した（ファイル形式オブジェクトの`readlines()'メソッドに
よって得られるような）テキストを用意します。

     >>> text1 = '''  1. Beautiful is better than ugly.
     ...   2. Explicit is better than implicit.
     ...   3. Simple is better than complex.
     ...   4. Complex is better than complicated.
     ... '''.splitlines(1)
     >>> len(text1)
     4
     >>> text1[0][-1]
     '\n'
     >>> text2 = '''  1. Beautiful is better than ugly.
     ...   3.   Simple is better than complex.
     ...   4. Complicated is better than complex.
     ...   5. Flat is better than nested.
     ... '''.splitlines(1)

次にDifferオブジェクトをインスタンス化します。

     >>> d = Differ()

注意：`Differ'オブジェクトをインスタンス化するとき、
"junk."である列と文字をフィルタリングす関数を渡すことができます。
詳細は`Differ()'コンストラクタを参照してください。

最後に、2つを比較します。

     >>> result = list(d.compare(text1, text2))

`result'は文字列のリストなので、pretty-printしてみましょう。

     >>> from pprint import pprint
     >>> pprint(result)
     ['    1. Beautiful is better than ugly.\n',
      '-   2. Explicit is better than implicit.\n',
      '-   3. Simple is better than complex.\n',
      '+   3.   Simple is better than complex.\n',
      '?     ++                                \n',
      '-   4. Complex is better than complicated.\n',
      '?            ^                     ---- ^  \n',
      '+   4. Complicated is better than complex.\n',
      '?           ++++ ^                      ^  \n',
      '+   5. Flat is better than nested.\n']

これは、複数行の文字列として、次のように出力されます。

     >>> import sys
     >>> sys.stdout.writelines(result)
         1. Beautiful is better than ugly.
     -   2. Explicit is better than implicit.
     -   3. Simple is better than complex.
     +   3.   Simple is better than complex.
     ?     ++
     -   4. Complex is better than complicated.
     ?            ^                     ---- ^
     +   4. Complicated is better than complex.
     ?           ++++ ^                      ^
     +   5. Flat is better than nested.


File: python-lib-jp.info,  Node: StringIO,  Next: cStringIO,  Prev: difflib,  Up: 文字列処理

4.5 ファイルのように文字列を読み書きする
========================================

ファイルのように文字列を読み書きする。

このモジュールは、(_メモリファイル_としても知られている)
文字列のバッファに対して読み書きを行うファイルのようなクラス、
`StringIO' 、を実装しています。

操作方法についてはファイルオブジェクトの説明を参照してください(セクション
*Note ファイルオブジェクト::)。

`StringIO([buffer])'
     `StringIO'
     オブジェクトを作る際に、コンストラクターに文字列を渡すこと
     で初期化することができます。 文字列を渡さない場合、最初は
     `StringIO' はカラです。 どちらの場合でも最初のファイル位置は 0
     から始まります。

     `StringIO' オブジェクトはユニコードも 8-bit
     の文字列も受け付けますが、
     この2つを混ぜることには少し注意が必要です。
     この2つが一緒に使われると、 `getvalue()' が呼ばれたときに、 (8th
     ビットを使っている)7-bit ASCII に解釈できない 8-bit の文字列は、
     `UnicodeError' を引き起こします。

次にあげる `StringIO' オブジェクトのメソッドには特別な説明が必要です:

`getvalue()'
     `StringIO' オブジェクトの `close()'
     メソッドが呼ばれる前ならいつでも、 "file" の中身全体を返します。
     ユニコードと 8-bit
     の文字列を混ぜることの説明は、上の注意を参照してください。
     この2つの文字コードを混ぜると、このメソッドは `UnicodeError' を
     引き起こすかもしれません。

`close()'
     メモリバッファを解放します。

使用例:

     import StringIO

     output = StringIO.StringIO()
     output.write('First line.\n')
     print >>output, 'Second line.'

     # ファイルの内容を取り出す -- ここでは
     # 'First line.\nSecond line.\n'
     contents = output.getvalue()

     # オブジェクトを閉じてメモリバッファを解放する --
     # .getvalue() は例外を送出するようになる。
     output.close()


File: python-lib-jp.info,  Node: cStringIO,  Next: textwrap,  Prev: StringIO,  Up: 文字列処理

4.6 高速化された `StringIO'
===========================

`StringIO'を高速にしたものだが、サブクラス化はできない。

`cStringIO' モジュールは `StringIO' モジュールと同様の
インターフェースを提供しています。 `StringIO.StringIO'
オブジェクトを酷使する場合、 このモジュールにある `StringIO()'
関数をかわりに使うと効果的です。

このモジュールは、ビルトイン型のオブジェクトを返すファクトリー関数を提供しているので、
サブクラス化して自分用の物を作ることはできません。
そうした場合には、オリジナルの `StringIO' モジュールを使ってください。

`StringIO' モジュールで実装されているメモリファイルとは異なり、
このモジュールで提供されているものは、プレイン ASCII
文字列にエンコードできない ユニコードを受け付けることができません。

また、引数に文字列を指定して`StringIO()'呼び出すと読み出し専用のオブジェクト
が生成されますが、この場合 `cStringIO.StringIO()' では
write()メソッドを持たない オブジェクトを生成します。
これらのオブジェクトは普段は見えません。 トレースバックに `StringI' と
`StringO' として表示されます。

次にあげるデータオブジェクトも提供されています:

`InputType'
     文字列をパラメーターに渡して `StringIO'
     を呼んだときに作られるオブジェクトの オブジェクト型。

`OutputType'
     パラメーターを渡さすに `StringIO'
     を呼んだときに返されるオブジェクトの オブジェクト型。

このモジュールには C API
もあります。詳しくはこのモジュールのソースを参照してください。

使用例:

     import cStringIO

     output = cStringIO.StringIO()
     output.write('First line.\n')
     print >>output, 'Second line.'

     # ファイルの内容を取り出す -- ここでは
     # 'First line.\nSecond line.\n'
     contents = output.getvalue()

     # オブジェクトを閉じてメモリバッファを解放する --
     # 以降 .getvalue() は例外を送出するようになる。
     output.close()


File: python-lib-jp.info,  Node: textwrap,  Next: codecs,  Prev: cStringIO,  Up: 文字列処理

4.7 テキストの折り返しと詰め込み
================================

テキストの折り返しと詰め込み

_Added in Python version 2.3_

`textwrap'モジュールでは、二つの簡易関数`wrap()'と
`fill()'、そして作業のすべてを行うクラス`TextWrapper'
とユーティリティ関数 `dedent()' を提供しています。
単に一つや二つのテキスト文字列の折り返しまたは詰め込みを行っている
ならば、簡易関数で十分間に合います。そうでなければ、
効率のために`TextWrapper'のインスタンスを使った方が良いでしょう。

`wrap(text[, width[, ...]])'
     TEXT(文字列)内の段落を一つだけ折り返しを行います。したがって、すべての行が高々WIDTH文字の長さになります。最後に改行が付かない出力行のリストを返します。

     オプションのキーワード引数は、以下で説明する`TextWrapper'のインスタンス属性に対応しています。WIDTHはデフォルトで`70'です。

`fill(text[, width[, ...]])'
     TEXT内の段落を一つだけ折り返しを行い、折り返しが行われた段落を含む一つの文字列を返します。`fill()'は
          "\n".join(wrap(text, ...))

     の省略表現です。

     特に、`fill()'は`wrap()'とまったく同じ名前のキーワード引数を受け取ります。

`wrap()'と`fill()'の両方ともが`TextWrapper'インスタンスを作成し、その一つのメソッドを呼び出すことで機能します。そのインスタンスは再利用されません。したがって、たくさんのテキスト文字列を折り返し/詰め込みを行うアプリケーションのためには、あなた自身の`TextWrapper'オブジェクトを作成することでさらに効率が良くなるでしょう。

追加のユーティリティ関数である `dedent()' は、不要な
空白をテキストの左側に持つ文字列からインデントを取り去ります。

`dedent(text)'
     TEXT の各行に対し、共通して現れる先頭の空白を削除します。

     この関数は通常、三重引用符で囲われた文字列をスクリーン/その他の
     左端にそろえ、なおかつソースコード中ではインデントされた形式を
     損なわないようにするために使われます。

     タブとスペースはともにホワイトスペースとして扱われますが、同じではないこ
     とに注意してください:  `" {} hello"' という行と
     `"\thello"'　は、同じ先頭の空白文字をもっていない
     とみなされます。(このふるまいは Python
     2.5で導入されました。古いバージョ
     ンではこのモジュールは不正にタブを展開して共通の先頭空白文字列を探して
     いました）

     以下に例を示します:
          def test():
              # end first line with \ to avoid the empty line!
              s = '''\
              hello
                world
              '''
              print repr(s)          # prints '    hello\n      world\n    '
              print repr(dedent(s))  # prints 'hello\n  world\n'


`TextWrapper(...)'
     `TextWrapper'コンストラクタはたくさんのオプションのキーワード引数を受け取ります。それぞれの引数は一つのインスタンス属性に対応します。したがって、例えば、
          wrapper = TextWrapper(initial_indent="* ")

     は
          wrapper = TextWrapper()
          wrapper.initial_indent = "* "

     と同じです。

     あなたは同じ`TextWrapper'オブジェクトを何回も再利用できます。また、使用中にインスタンス属性へ代入することでそのオプションのどれでも変更できます。

`TextWrapper'インスタンス属性(とコンストラクタのキーワード引数)は以下の通りです:

`width'
     (デフォルト: `70')
     折り返しが行われる行の最大の長さ。入力行に`width'より長い単一の語が無い限り、`TextWrapper'は`width'文字より長い出力行が無いことを保証します。

`expand_tabs'
     (デフォルト: `True')
     もし真ならば、そのときはTEXT内のすべてのタブ文字はTEXTの`expand_tabs()'メソッドを用いて空白に展開されます。

`replace_whitespace'
     (デフォルト: `True')
     もし真ならば、タブ展開の後に残る(`string.whitespace'に定義された)空白文字のそれぞれが一つの空白と置き換えられます。_Note:_
     `expand_tabs'が偽で`replace_whitespace'が真ならば、各タブ文字は一つの空白に置き換えられます。それはタブ展開と同じでは_ありません_。

`initial_indent'
     (デフォルト: `''')
     折り返しが行われる出力の一行目の先頭に付けられる文字列。一行目の折り返しの長さになるまで含められます。

`subsequent_indent'
     (デフォルト: `''')
     一行目以外の折り返しが行われる出力のすべての行の先頭に付けられる文字列。一行目以外の各行が折り返しの長さまで含められます。

`fix_sentence_endings'
     (デフォルト: `False')
     もし真ならば、`TextWrapper'は文の終わりを見つけようとし、確実に文がちょうど二つの空白で常に区切られているようにします。これは一般的に固定スペースフォントのテキストに対して望ましいです。しかし、文の検出アルゴリズムは完全ではありません:
     文の終わりには、後ろに空白がある`.'、`!'または`?'の中の一つ、ことによると`"'あるいは`''が付随する小文字があると仮定しています。これに伴う一つの問題は

          [...] Dr. Frankenstein's monster [...]

     の"Dr."と

          [...] See Spot. See Spot run [...]

     の"Spot."の間の差異を検出できないアルゴリズムです。

     `fix_sentence_endings'はデフォルトで偽です。

     文検出アルゴリズムは"小文字"の定義のために`string.lowercase'に依存し、同一行の文を区切るためにピリオドの後に二つの空白を使う慣習に依存しているため、英文テキストに限定されたものです。

`break_long_words'
     (デフォルト: `True')
     もし真ならば、そのとき`width'より長い行が確実にないようにするために、`width'より長い語は切られます。偽ならば、長い語は切られないでしょう。そして、`width'より長い行があるかもしれません。(`width'を超える分を最小にするために、長い語は単独で一行に置かれるでしょう。)

`TextWrapper'はモジュールレベルの簡易関数に類似した二つの公開メソッドも提供します:

`wrap(text)'
     TEXT(文字列)内の段落を一つだけ折り返しを行います。したがって、すべての行は高々`width'文字です。すべてのラッピングオプションは`TextWrapper'インスタンスのインスタンス属性から取られています。最後に改行の無い出力された行のリストを返します。

`fill(text)'
     TEXT内の段落を一つだけ折り返しを行い、折り返しが行われた段落を含む一つの文字列を返します。


File: python-lib-jp.info,  Node: codecs,  Next: unicodedata,  Prev: textwrap,  Up: 文字列処理

4.8 codec レジストリと基底クラス
================================

データやストリームのエンコード・デコード。

このモジュールでは、内部的な Python codec レジストリに対するアクセス手
段を提供しています。codec レジストリは、標準の Python codec(エンコー
ダとデコーダ)の基底クラスを定義し、codec およびエラー処理の検索手順を
管理しています。

`codecs' では以下の関数を定義しています:

`register(search_function)'
     codec 検索関数を登録します。検索関数は第 1
     引数にアルファベットの小文字 から成るエンコーディング名を取り、
     以下の属性を持つ `CodecInfo' オブジェクトを返します。

        * `name' エンコーディング名

        * `encoder' 内部状態を持たないエンコード関数

        * `decoder' 内部状態を持たないデコード関数

        * `incrementalencoder'
          漸増的エンコーダクラスまたはファクトリ関数

        * `incrementaldecoder' 漸増的デコーダクラスまたはファクトリ関数

        * `streamwriter' ストリームライタクラスまたはファクトリ関数

        * `streamreader' ストリームリーダクラスまたはファクトリ関数

     種々の関数やクラスが以下の引数をとります。

     ENCODER と DECODER: これらの引数は、Codec インスタンスの
     `encode()'と`decode()' (Codec Interface 参照) と同じ
     インタフェースを持つ関数、またはメソッドでなければなりません。これらの関
     数・メソッドは内部状態を持たずに動作する (stateless mode)
     と想定されて います。

     INCREMENTALENCODER と INCREMENTALDECODER: これらは
     以下のインタフェースを持つファクトリ関数でなければなりません。

     `factory(ERRORS='strict')'

     ファクトリ関数は、それぞれ基底クラスの `IncrementalEncoder' や
     `IncrementalDecoder' が定義しているインタフェースを提供する
     オブジェクトを返さねばなりません。漸増的 codecs
     は内部状態を維持できます。

     STREAMREADER と STREAMWRITER: これらの引数は、次のような
     インタフェースを持つファクトリ関数でなければなりません:

     `factory(STREAM, ERRORS='strict')'

     ファクトリ関数は、基底クラスの `StreamWriter' や `StreamReader'
     が定義しているインタフェースを提供する
     オブジェクトを返さねばなりません。ストリーム codecs
     は内部状態を維持で きます。

     ERRORS が取り得る値は、 `'strict''
     (エンコーディングエラーの際に例外を発生)、 `'replace''
     (奇形データを `?'等の適切な文字で置換)、 `'ignore''
     (奇形データを無視し何も通知せずに処理を継続)、
     `'xmlcharrefreplace''' (適切な XML 文字参照で置換
     (エンコーディングのみ))、 および `'backslashreplace''
     (バックスラッシュによるエスケープシーケンス
     (エンコーディングのみ)) と、`register_error()' で定義されたその他の
     エラー処理名になります。

     検索関数は、与えられたエンコーディングを見つけられなかった場合、
     `None' を返さねばなりません。

`lookup(encoding)'
     Python codec レジストリから codec 情報を探し、上で定義したような
     `CodecInfo' オブジェクトを返します。

     エンコーディングの検索は、まずレジストリのキャッシュから行います。
     見つからなければ、登録されている検索関数のリストから探します。
     `CodecInfo' オブジェクトが一つも見つからなければ `LookupError'
     を送出します。 見つかったら、その `CodecInfo'
     オブジェクトはキャッシュに保存され、 呼び出し側に返されます。

さまざまな codec へのアクセスを簡便化するために、このモジュールは以下
のような関数を提供しています。これらの関数は、 codec の検索に
`lookup()' を使います。

`getencoder(encoding)'
     ENCODING に指定した codec を検索し、エンコーダ関数を返します。

     ENCODING が見つからなければ `LookupError' を送出します。

`getdecoder(encoding)'
     ENCODING に指定した codec を検索し、デコーダ関数を返します。

     ENCODING が見つからなければ `LookupError' を送出します。

`getincrementalencoder(encoding)'
     ENCODING に指定した codec
     を検索し、漸増的エンコーダクラス、またはファク トリ関数を返します。

     ENCODING が見つからない、もしくは codec
     が漸増的エンコーダをサポートしないとき `LookupError' を送出します。
     _Added in Python version 2.5_

`getincrementaldecoder(encoding)'
     ENCODING に指定した codec
     を検索し、漸増的デコーダクラス、またはファク トリ関数を返します。

     ENCODING が見つからない、もしくは codec
     が漸増的デコーダをサポートしないとき `LookupError' を送出します。
     _Added in Python version 2.5_

`getreader(encoding)'
     ENCODING に指定した codec を検索し、StreamReader
     クラス、またはファク トリ関数を返します。

     ENCODING が見つからなければ `LookupError' を送出します。

`getwriter(encoding)'
     ENCODING に指定した codec を検索し、StreamWriter
     クラス、またはファク トリ関数を返します。

     ENCODING が見つからなければ `LookupError' を送出します。

`register_error(name, error_handler)'
     エラー処理関数 ERROR_HANDLER を名前 NAME で登録します。
     エンコード中およびデコード中にエラーが送出された場合、 ERRORS
     パラメタにNAME を指定していれば ERROR_HANDLER
     を呼び出すようになります。

     ERROR_HANDLER はエラーの場所に関する情報の入った
     `UnicodeEncodeError' インスタンスとともに呼び出されます。
     エラー処理関数はこの例外を送出するか、別の例外を送出するか、または
     入力のエンコードができなかった部分の代替文字列とエンコードを再開する
     場所の指定が入ったタプルを返すかしなければなりません。最後の場合、
     エンコーダは代替文字列をエンコードし、元の入力中の指定位置から
     エンコードを再開します。位置を負の値にすると、入力文字列の末端からの
     相対位置として扱われます。境界の外側にある位置を返した場合には
     `IndexError' が送出されます。

     デコードと翻訳は同様に働きますが、エラー処理関数に渡されるのが
     `UnicodeDecodeError' か`UnicodeTranslateError'
     である点と、エラー処理関数の置換した内容が直接出力になる点が異なります。

`lookup_error(name)'
     名前NAME で登録済みのエラー処理関数を返します。

     エラー処理関数が見つからなければ `LookupError' を送出します。

`strict_errors(exception)'
     `strict' エラー処理の実装です。

`replace_errors(exception)'
     `replace' エラー処理の実装です。

`ignore_errors(exception)'
     `ignore' エラー処理の実装です。

`xmlcharrefreplace_errors_errors(exception)'
     `xmlcharrefreplace' エラー処理の実装です。

`backslashreplace_errors_errors(exception)'
     `backslashreplace' エラー処理の実装です。

エンコードされたファイルやストリームの処理を簡便化するため、, このモジュ
ールは次のようなユーティリティ関数を定義しています。

`open(filename, mode[, encoding[, errors[, buffering]]])'
     MODE でエンコードされたファイルを開き、
     透過的にエンコード・デコードを行うようにラップしたファイルオブジェクト
     を返します。

     _Note:_ ラップ版のファイルオブジェクトを操作する関数は、該当する
     codec  が定義している形式のオブジェクトだけを受け付けます。
     多くの組み込み codec では  Unicode オブジェクトです。
     関数の戻り値も codec に依存し、通常は Unicode オブジェクトです。

     ENCODING にはファイルのエンコーディングを指定します。

     ERRORS を指定して、エラー処理を定義することもできます。デフォルト
     では `'strict'' で、エンコード時にエラーがあれば `ValueError'
     を送出します。

     BUFFERING は、組み込み関数 `open()' と同じです。デフォル
     トでは行バッファリングです。

`EncodedFile(file, input[, output[, errors]])'
     ラップしたファイルオブジェクトを返します。このオブジェクトは透過な
     エンコード変換を提供します。

     ラップされたファイルに書かれた文字列は、INPUT に指定したエンコー
     ディングに従って変換され、OUTPUT に指定したエンコーディングを使っ
     て string
     型に変換され、ファイルに書き込まれます。中間エンコーディング
     は指定された codecs に依存しますが、普通は Unicode です。

     OUTPUT が与えられなければ、INPUT がデフォルトになります。

     ERRORS を与えて、エラー処理を定義することもできます。デフォルト
     では `'strict'' で、エンコード時にエラーがあれば `ValueError'
     を送出します。

`iterencode(iterable, encoding[, errors])'
     漸増的エンコーダを使って、ITERABLE から供給される入力を反復的に
     エンコードします。この関数はジェネレータです。ERRORS は
     (そして他のキーワード引数も同様に)漸増的エンコーダにそのまま引き渡されます。
     _Added in Python version 2.5_

`iterdecode(iterable, encoding[, errors])'
     漸増的デコーダを使って、ITERABLE から供給される入力を反復的に
     デコードします。この関数はジェネレータです。ERRORS は
     (そして他のキーワード引数も同様に)漸増的デコーダにそのまま引き渡されます。
     _Added in Python version 2.5_

このモジュールは以下のような定数も定義しています。プラットフォーム依存なファ
イルを読み書きするのに役立ちます。

`BOM'

`BOM_BE'

`BOM_LE'

`BOM_UTF8'

`BOM_UTF16'

`BOM_UTF16_BE'

`BOM_UTF16_LE'

`BOM_UTF32'

`BOM_UTF32_BE'

`BOM_UTF32_LE'
     ここで定義された定数は、様々なエンコーディングの Unicode の
     バイトオーダマーカ (BOM) で、UTF-16 と UTF-32 における
     データストリームやファイルストリームのバイトオーダを指定したり、
     UTF-8 における Unicode signature として使われます。 `BOM_UTF16' は
     `BOM_UTF16_BE' と `BOM_UTF16_LE' のいずれかで、プラットフォームの
     ネイティブバイトオーダに依存します。`BOM' は `BOM_UTF16'
     の別名です。同様に `BOM_LE'は `BOM_UTF16_LE'の、`BOM_BE' は
     `BOM_UTF16_BE' の別名です。他は UTF-8 と UTF-32 エンコーディングの
     BOM を表します。

* Menu:

* Codec 基底クラス::
* エンコーディングと Unicode::
* 標準エンコーディング::
* encodingsidna --- アプリケーションにおける国際化ドメイン名 IDNA::
* encodingsutf_8_sig --- BOM 印付き UTF-8::


File: python-lib-jp.info,  Node: Codec 基底クラス,  Next: エンコーディングと Unicode,  Prev: codecs,  Up: codecs

4.8.1 Codec 基底クラス
----------------------

`codecs' モジュールでは、codec のインタフェースを定義する一連の
基底クラスを用意して、Python 用 codec を簡単に自作できるように
しています。

Python で何らかの codec を使えるようにするには、
状態なしエンコーダ、状態なしデコーダ、ストリームリーダ、
ストリームライタの 4 つのインタフェースを定義せねばなりません。
通常は、状態なしエンコーダとデコーダを再利用して
ストリームリーダとライタのファイル・プロトコルを実装します。

`Codec' クラスは、状態なしエンコーダ・デコーダのインタフェースを
定義しています。

エラー処理の簡便化と標準化のため、`encode()' メソッドと `decode()'
メソッドでは、ERRORS 文字列引数を指定した
場合に別のエラー処理を行うような仕組みを実装してもかまいません。
全ての標準 Python codec では以下の文字列が定義され、実装されています。

Value                                Meaning
------                               -----
'strict'                             `UnicodeError'
                                     (または、そのサブクラス)
                                     を送出します -
                                     デフォルトの動作です。
'ignore'                             その文字を無視し、次の文字から変換を再開します。
'replace'                            適当な文字で置換します - Python
                                     の組み込み  Unicode codec
                                     のデコード時には公式の U+FFFD
                                     REPLACEMENT CHARACTER を、
                                     エンコード時には '?' を使います。
'xmlcharrefreplace'                  適切な XML 文字参照で置換します
                                     (エンコードのみ)
'backslashreplace'                   バックスラッシュつきのエスケープシーケンス
                                     で置換します (エンコードのみ)

codecs がエラーハンドラとして受け入れる値は`register_error' を
使って追加できます。

* Menu:

* Codec オブジェクト::
* IncrementalEncoder オブジェクト::
* IncrementalDecoder オブジェクト::
* StreamWriter オブジェクト::
* StreamReader オブジェクト::
* StreamReaderWriter オブジェクト::
* StreamRecoder オブジェクト::


File: python-lib-jp.info,  Node: Codec オブジェクト,  Next: IncrementalEncoder オブジェクト,  Prev: Codec 基底クラス,  Up: Codec 基底クラス

4.8.1.1 Codec オブジェクト
..........................

`Codec' クラスは以下のメソッドを定義します。これらのメソッドは、
内部状態を持たないエンコーダ／デコーダ関数のインタフェースを定義します。

`encode(input[, errors])'
     オブジェクト INPUT エンコードし、(出力オブジェクト, 消費した 長さ)
     のタプルを返します。 codecs は Unicode 専用ではありませんが、
     Unicode の文脈では、エンコーディングは Unicode オブジェクトを
     特定の文字集合エンコーディング(たとえば `cp1252' や
     `iso-8859-1')を使って文字列オブジェクトに変換します。

     ERRORS は適用するエラー処理を定義します。`'strict'' 処理が
     デフォルトです。

     このメソッドは `Codec' に内部状態を保存してはなりません。効率
     よくエンコード／デコードするために状態を保持しなければならない
     ような codecs には `StreamCodec' を使ってください。

     エンコーダは長さが 0 の入力を処理できねばなりません。この場合、
     空のオブジェクトを出力オブジェクトとして返さねばなりません。

`decode(input[, errors])'
     オブジェクト INPUT をデコードし、(出力オブジェクト,  消費した長
     さ) のタプルを返します。Unicode
     の文脈では、デコードは特定の文字集合
     エンコーディングでエンコードされた文字列を Unicode
     オブジェクトに変換 します。

     INPUT は `bf_getreadbuf' バッファスロットを提供するオブジェ
     クトでなければなりません。バッファスロットを提供しているオブジェクトには
     Python
     文字列オブジェクト、バッファオブジェクト、メモリマップファイル
     があります。

     ERRORS は適用するエラー処理を定義します。`'strict'' がデフ
     ォルト値です。

     このメソッドは、`Codec' インスタンスに内部状態を保存しては
     なりません。効率よくエンコード／デコードするために状態を保持しなけれ
     ばならないような codecs には `StreamCodec' を使ってください。

     デコーダは長さが 0 の入力を処理できねばなりません。この場合、
     空のオブジェクトを出力オブジェクトとして返さねばなりません。

`IncrementalEncoder' クラスおよび `IncrementalDecoder' クラスは
それぞれ漸増的エンコーディングおよびデコーディングのための基本的なインタフェースを提供
します。エンコーディング／デコーディングは内部状態を持たないエンコーダ／デコーダを
一度呼び出すことで行なわれるのではなく、漸増的エンコーダ／デコーダの
`encode'/`decode' メソッドを複数回呼び出すことで行なわれます。
漸増的エンコーダ／デコーダはメソッド呼び出しの間エンコーディング／デコーディング処理の
進行を管理します。 `encode'/`decode'
メソッド呼び出しの出力結果をまとめたものは、
入力をひとまとめにして内部状態を持たないエンコーダ／デコーダでエンコード／デコード
したものと同じになります。


File: python-lib-jp.info,  Node: IncrementalEncoder オブジェクト,  Next: IncrementalDecoder オブジェクト,  Prev: Codec オブジェクト,  Up: Codec 基底クラス

4.8.1.2 IncrementalEncoder オブジェクト
.......................................

_Added in Python version 2.5_

`IncrementalEncoder' クラスは入力を複数ステップでエンコードするのに
使われます。全ての漸増的エンコーダが Python codec
レジストリと互換性を持つために
定義すべきメソッドとして、このクラスには以下のメソッドが定義されています。

`IncrementalEncoder([errors])'
     `IncrementalEncoder' インスタンスのコンストラクタ。

     全ての漸増的エンコーダはこのコンストラクタインタフェースを提供しなければなりません。
     さらにキーワード引数を付け加えるのは構いませんが、Python codec
     レジストリで 利用されるのはここで定義されているものだけです。

     `IncrementalEncoder' は ERRORS キーワード引数を提供して
     異なったエラー取扱方法を実装することもできます。あらかじめ定義されている
     パラメータは以下の通りです。

        * `'strict'' `ValueError' (またはそのサブクラス)
          を送出します。これがデフォルトです。

        * `'ignore'' 一文字無視して次に進みます。

        * `'replace'' 適当な代替文字で置き換えます。

        * `'xmlcharrefreplace'' 適切な XML 文字参照に置き換えます。

        * `'backslashreplace''
          バックスラッシュ付きのエスケープシーケンスで 置き換えます。

     引数 ERRORS は同名の属性に割り当てられます。属性に割り当てることで
     `IncrementalEncoder' オブジェクトが生きている間にエラー取扱戦略を
     違うものに切り替えることができるようになります。

     ERRORS 引数に許される値の集合は `register_error()' で
     拡張できます。

`encode(object[, final])'
     OBJECT を(エンコーダの現在の状態を考慮に入れて)エンコードし、
     得られたエンコードされたオブジェクトを返します。`encode' 呼び出し
     がこれで最後という時には FINAL
     は真でなければなりません(デフォルトは偽です)。

`reset()'
     エンコーダを初期状態にリセットします。


File: python-lib-jp.info,  Node: IncrementalDecoder オブジェクト,  Next: StreamWriter オブジェクト,  Prev: IncrementalEncoder オブジェクト,  Up: Codec 基底クラス

4.8.1.3 IncrementalDecoder オブジェクト
.......................................

`IncrementalDecoder' クラスは入力を複数ステップでデコードするのに
使われます。全ての漸増的デコーダが Python codec
レジストリと互換性を持つために
定義すべきメソッドとして、このクラスには以下のメソッドが定義されています。

`IncrementalDecoder([errors])'
     `IncrementalDecoder' インスタンスのコンストラクタ。

     全ての漸増的デコーダはこのコンストラクタインタフェースを提供しなければなりません。
     さらにキーワード引数を付け加えるのは構いませんが、Python codec
     レジストリで 利用されるのはここで定義されているものだけです。

     `IncrementalDecoder' は ERRORS キーワード引数を提供して
     異なったエラー取扱方法を実装することもできます。あらかじめ定義されている
     パラメータは以下の通りです。

        * `'strict'' `ValueError' (またはそのサブクラス)
          を送出します。これがデフォルトです。

        * `'ignore'' 一文字無視して次に進みます。

        * `'replace'' 適当な代替文字で置き換えます。

     引数 ERRORS は同名の属性に割り当てられます。属性に割り当てることで
     `IncrementalDecoder' オブジェクトが生きている間にエラー取扱戦略を
     違うものに切り替えることができるようになります。

     ERRORS 引数に許される値の集合は `register_error()' で
     拡張できます。

`decode(object[, final])'
     OBJECT を(デコーダの現在の状態を考慮に入れて)デコードし、
     得られたデコードされたオブジェクトを返します。`decode' 呼び出し
     がこれで最後という時には FINAL
     は真でなければなりません(デフォルトは偽です)。 もし FINAL
     が真ならばデコーダは入力をデコードし切り全てのバッファを
     フラッシュしなければなりません。そうできない場合(たとえば入力の最後に
     不完全なバイト列があるから)、デコーダは内部状態を持たない場合と同じように
     エラーの取り扱いを開始しなければなりません(例外を送出するかもしれません)。

`reset()'
     デコーダを初期状態にリセットします。

`StreamWriter' と `StreamReader' クラスは、新しいエンコーデ
ィングモジュールを、非常に簡単に実装するのに使用できる、一般的なインターフ
ェイス提供します。実装例は `encodings.utf_8' をご覧ください。


File: python-lib-jp.info,  Node: StreamWriter オブジェクト,  Next: StreamReader オブジェクト,  Prev: IncrementalDecoder オブジェクト,  Up: Codec 基底クラス

4.8.1.4 StreamWriter オブジェクト
.................................

`StreamWriter' クラスは `Codec' のサブクラスで、以下のメソッ
ドを定義しています。全てのストリームライタは、Python の codec レジス
トリとの互換性を保つために、これらのメソッドを定義する必要があります。

`StreamWriter(stream[, errors])'
     `StreamWriter' インスタンスのコンストラクタです。

     全てのストリームライタはコンストラクタとしてこのインタフェースを提供
     せねばなりません。キーワード引数を追加しても構いませんが、 Python
     の codec レジストリはここで定義されている引数だけを使います。

     STREAM は、(バイナリで) 書き込み可能なファイル類似のオブジェクト
     でなくてはなりません。

     `StreamWriter' は、ERRORS キーワード引数を受けて、異なった
     エラー処理の仕組みを実装しても構いません。定義済みのパラメタを以下に
     示します。

        * `'strict'' `ValueError' (または、そのサブクラス)
          送出します。デフォルトの動作です。

        * `'ignore'' 文字を無視して、次の文字から続けます。

        * `'replace'' 適切な置換文字で置換します。

        * `'xmlcharrefreplace'' 適切な XML 文字参照で置換します。

        * `'backslashreplace'' バックスラッシュ付きのエスケープ
          シーケンスで置換します。

     ERRORS 引数は、同名の属性に代入されます。この属性を変更すると、
     `StreamWriter' オブジェクトが生きている間に、異なるエラー処理に
     変更できます。

     ERRORS 引数が取りえる値の種類は`register_error()' で 拡張できます。

`write(object)'
     OBJECT の内容をエンコードしてストリームに書き出します。

`writelines(list)'
     文字列からなるリストを連結して、(必要に応じて `write()' を
     何度も使って) ストリームに書き出します。

`reset()'
     状態保持に使われていた codec のバッファを強制的に出力してリセット
     します。

     このメソッドが呼び出された場合、出力先データをきれいな状態にし、
     わざわざストリーム全体を再スキャンして状態を元に戻さなくても
     新しくデータを追加できるようにせねばなりません。

ここまでで挙げたメソッドの他にも、`StreamWriter' では背後にある
ストリームの他の全てのメソッドや属性を継承せねばなりません。


File: python-lib-jp.info,  Node: StreamReader オブジェクト,  Next: StreamReaderWriter オブジェクト,  Prev: StreamWriter オブジェクト,  Up: Codec 基底クラス

4.8.1.5 StreamReader オブジェクト
.................................

`StreamReader' クラスは `Codec' のサブクラスで、以下のメソッ
ドを定義しています。全てのストリームリーダは、Python の codec レジス
トリとの互換性を保つために、これらのメソッドを定義する必要があります。

`StreamReader(stream[, errors])'
     `StreamReader' インスタンスのコンストラクタです。

     全てのストリームリーダはコンストラクタとしてこのインタフェースを提供
     せねばなりません。キーワード引数を追加しても構いませんが、 Python
     の codec レジストリはここで定義されている引数だけを使います。

     STREAM は、(バイナリで) 読み出し可能なファイル類似のオブジェクト
     でなくてはなりません。

     `StreamReader' は、ERRORS キーワード引数を受けて、異なった
     エラー処理の仕組みを実装しても構いません。定義済みのパラメタを以下に
     示します。

        * `'strict'' `ValueError' (または、そのサブクラス)
          を送出します。デフォルトの処理です。

        * `'ignore'' 文字を無視して、次の文字から続けます。

        * `'replace'' 適切な置換文字で置換します。

     ERRORS 引数は、同名の属性に代入されます。この属性を変更すると、
     `StreamReader' オブジェクトが生きている間に、異なるエラー処理に
     変更できます。

     ERRORS 引数が取りえる値の種類は`register_error()' で 拡張できます。


`read([size[, chars, [firstline]]])'
     ストリームからのデータをデコードし、デコード済のオブジェクトを返しま
     す。

     CHARS はストリームから読み込む文字数です。 `read()'
     はCHARS以上の文字を返しませんが、それより少
     ない文字しか取得できない場合にはCHARS以下の文字を返します。

     SIZE は、デコードするためにストリームから読み込む、およその最大バ
     イト数を意味します。デコーダはこの値を適切な値に変更できます。
     デフォルト値 -1 にすると可能な限りたくさんのデータを読み込みます。
     SIZE の目的は、巨大なファイルの一括デコードを防ぐことにあります。

     FIRSTLINE は、1行目さえ返せばその後の行でデコードエラーがあっても
     無視して十分だ、ということを示します。

     このメソッドは貪欲な読み込み戦略を取るべきです。すなわち、エンコーディ
     ング定義と size
     の値が許す範囲で、できるだけ多くのデータを読むべきだと
     いうことです。たとえば、ストリーム上にエンコーディングの終端や状態の目
     印があれば、それも読み込みます。 _Changed in Python version 2.4_
     _Changed in Python version 2.4.2_

`readline([size[, keepends]])'
     入力ストリームから1行読み込み、デコード済みのデータを返します。

     SIZE が与えられた場合、ストリームにおける `readline()' の size
     引数に渡されます。

     KEEPENDS が偽の場合には行末の改行が削除された行が返ります。

     _Changed in Python version 2.4_

`readlines([sizehint[, keepends]])'
     入力ストリームから全ての行を読み込み、行のリストとして返します。

     KEEPENDSが真なら、改行は、codec
     のデコーダメソッドを使って実装され、 リスト要素の中に含まれます。

     SIZEHINT が与えられた場合、 ストリームの `read()' メソッ ドに SIZE
     引数として渡されます。

`reset()'
     状態保持に使われた codec のバッファをリセットします。

     ストリームの読み位置を再設定してはならないので注意してください。
     このメソッドはデコードの際にエラーから復帰できるようにするためのものです。

ここまでで挙げたメソッドの他にも、`StreamReader' では背後にある
ストリームの他の全てのメソッドや属性を継承せねばなりません。

次に挙げる2つの基底クラスは、利便性のために含まれています。codec
レジスト
リは、これらを必要としませんが、実際のところ、あると有用なものでしょう。


File: python-lib-jp.info,  Node: StreamReaderWriter オブジェクト,  Next: StreamRecoder オブジェクト,  Prev: StreamReader オブジェクト,  Up: Codec 基底クラス

4.8.1.6 StreamReaderWriter オブジェクト
.......................................

`StreamReaderWriter' を使って、読み書き両方に使えるストリームをラ
ップできます。

`lookup()' 関数が返すファクトリ関数を使って、インスタンスを生成
するという設計です。

`StreamReaderWriter(stream, Reader, Writer, errors)'
     `StreamReaderWriter' インスタンスを生成します。  STREAM は
     ファイル類似のオブジェクトです。  READER と WRITER は、 それぞれ
     `StreamReader' と `StreamWriter' インタフェースを
     提供するファクトリ関数かファクトリクラスでなければなりません。
     エラー処理は、ストリームリーダとライタで定義したものと同じように
     行われます。

`StreamReaderWriter' インスタンスは、`StreamReader' クラスと
`StreamWriter'クラスを合わせたインタフェースを継承します。元にな
るストリームからは、他のメソッドや属性を継承します。


File: python-lib-jp.info,  Node: StreamRecoder オブジェクト,  Prev: StreamReaderWriter オブジェクト,  Up: Codec 基底クラス

4.8.1.7 StreamRecoder オブジェクト
..................................

`StreamRecoder' はエンコーディングデータの、フロントエンド-バック
エンドを観察する機能を提供します。異なるエンコーディング環境を扱うとき、
便利な場合があります。

`lookup()' 関数が返すファクトリ関数を使って、インスタンスを生成
するという設計になっています。

`StreamRecoder(stream, encode, decode, Reader, Writer, errors)'
     双方向変換を実装する `StreamRecoder' インスタンスを生成します。
     ENCODE と DECODE はフロントエンド (`read()' への入
     力と`write()'からの出力) を処理し、READER と WRITER は
     バックエンド (ストリームに対する読み書き) を処理します。

     これらのオブジェクトを使って、たとえば、Latin-1 から
     UTF-8、あるいは逆 向きの変換を、透過に記録できます。

     STREAM はファイル的オブジェクトでなくてはなりません。

     ENCODE と DECODE は `Codec' のインタフェースに忠
     実でなくてはならず、READER と WRITER は、それぞれ `StreamReader'
     と `StreamWriter' のインタフェースを提供
     するオブジェクトのファクトリ関数かクラスでなくてはなりません。

     ENCODE と DECODE はフロントエンドの変換に必要で、 READER と WRITER
     はバックエンドの変換に必要です。中間のフ
     ォーマットはコデックの組み合わせによって決定されます。たとえば、
     Unicode コデックは中間エンコーディングに Unicode を使います。

     エラー処理はストリーム・リーダやライタで定義されている方法と同じように
     行われます。

`StreamRecoder' インスタンスは、`StreamReader' と `StreamWriter'
クラスを合わせたインタフェースを定義します。また、
元のストリームのメソッドと属性も継承します。


File: python-lib-jp.info,  Node: エンコーディングと Unicode,  Next: 標準エンコーディング,  Prev: Codec 基底クラス,  Up: codecs

4.8.2 エンコーディングと Unicode
--------------------------------

Unicode 文字列は内部的にはコードポイントのシーケンスとして格納されます
(正確に言えば `Py_UNICODE' 配列です)。 Python
がどのようにコンパイルされたか (デフォルトである
`--enable-unicode=ucs2' かまたは `--enable-unicode=ucs4' のどちらか)
によって、 `Py_UNICODE' は16ビットまたは32ビットのデータ型です。
Unicode オブジェクトが CPU とメモリの外で使われることになると、 CPU
のエンディアンやこれらの配列がバイト列としてどのように格納されるかが
問題になってきます。Unicode オブジェクトをバイト列に変換することを
エンコーディングと呼び、バイト列から Unicode
オブジェクトを再生することを
デコーディングと呼びます。どのようにこの変換を行うかには多くの異なった方法が
あります(これらの方法のこともエンコーディングと言います)。最も単純な方法は
コードポイント 0-255 をバイト `0x0'-`0xff' に写すことです。 これは
`U+00FF' より上のコードポイントを持つ Unicode オブジェクトは
この方法ではエンコードできないということを意味します (この方法を
`'latin-1'' とか `'iso-8859-1'' と呼びます)。 `unicode.encode()'
は次のような `UnicodeEncodeError' を送出することになります:
`UnicodeEncodeError: 'latin-1' codec can't encode character u'\u1234'
in position 3: ordinal not in range(256)'。

他のエンコーディングの一群(charmap
エンコーディングと呼ばれます)がありますが、 Unicode
コードポイントの別の部分集合とこれらがどのように `0x0'-`0xff'
のバイトに写されるかを選んだものです。これがどのように行なわれるかを知るには、
単にたとえば `encodings/cp1252.py' (主に Windows で使われる
エンコーディングです) を開いてみてください。256 文字のひとつの文字列定数
がありどの文字がどのバイト値に写されるかを示しています。

上に挙げた全てのエンコーディングは Unicode
に定義された65536(あるいは1114111)
あるコードポイント中256文字しかエンコードできません。全ての Unicode
コードポイント
を収める単純明快な方法は、それぞれのコードポイントを二つの引き続くバイトに収める
ものです。二つの可能性があります。すなわちビッグエンディアンかリトルエンディアンか。
これら二つのエンコーディングはそれぞれ UTF-16-BE あるいは UTF-16-LE
と呼ばれます。 欠点は、たとえば UTF-16-BE
をリトルエンディアンの機械で使うときに、エンコーディング
でもデコーディングでも常に二つのバイトを交換しなければならないことです。
UTF-16
はこの問題を解消します。バイトはいつでも自然なエンディアンに従います。
これらのバイトが異なるエンディアンの CPU
で読まれる時は、結局交換しない訳にはいきません。 UTF-16
のバイト列のエンディアンを検知できるようにするために、いわゆる BOM
("Byte Order Mark") があります。Unicode 文字で言うと `U+FEFF' です。
この文字は全ての UTF-16
バイト列の先頭に付加されます。この文字のバイト位置を 交換したもの
(`0xFFFE') は Unicode テキストに出現しないはずの違法な
文字です。そこで、UTF-16 バイト列の一文字目が `U+FFFE' に見えたなら、
デコーディングの際にバイトを交換しなければなりません。不幸なことに、Unicode
4.0 までは文字 `U+FEFF' には第二の目的 `ZERO WIDTH NO-BREAK SPACE'
(幅を持たず単語が分割されるのを許さない文字) がありました。
たとえばリガチャ(合字)アルゴリズムに対するヒントを与えるために使われることが
あり得ます。Unicode 4.0 になって `U+FEFF' の `ZERO WIDTH NO-BREAK
SPACE' としての使用法は撤廃されました (`U+2060' (`WORD JOINER') に
この役割を譲りました)。しかしながら、Unicode ソフトウェアは依然として
`U+FEFF' の二つの役割を扱えなければなりません。一つは BOM
として、エンコードされたバイトの
記憶装置上のレイアウトを決め、バイト列が Unicode
文字列にデコードされた暁には 消え去るものという役割。もう一つは `ZERO
WIDTH NO-BREAK SPACE' として、
通常の文字と同じようにデコードされる文字という役割です。

さらにもう一つ Unicode
文字全てをエンコードできるエンコーディングがあり、UTF-8
と呼ばれています。UTF-8 は8ビットエンコーディングで、したがって UTF-8
には バイト順の問題はありません。UTF-8
バイト列の各バイトは二つのパートから成ります。
二つはマーカ(上位数ビット)とペイロードです。マーカは0ビットから6ビットの1の列に
0のビットが一つ続いたものです。Unicode
文字は次のようにエンコードされます (x
はペイロードを表わし、連結されると一つの Unicode 文字を表わします):

範囲                                 エンコーディング
------                               -----
`U-00000000' ... `U-0000007F'        0xxxxxxx
`U-00000080' ... `U-000007FF'        110xxxxx 10xxxxxx
`U-00000800' ... `U-0000FFFF'        1110xxxx 10xxxxxx 10xxxxxx
`U-00010000' ... `U-001FFFFF'        11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
`U-00200000' ... `U-03FFFFFF'        111110xx 10xxxxxx 10xxxxxx 10xxxxxx
                                     10xxxxxx
`U-04000000' ... `U-7FFFFFFF'        1111110x 10xxxxxx 10xxxxxx 10xxxxxx
                                     10xxxxxx 10xxxxxx

Unicode 文字の最下位ビットとは最も右にある x のビットです。

UTF-8 は8ビットエンコーディングなので BOM は必要とせず、デコードされた
Unicode 文字列中の `U+FEFF' は(たとえ最初の文字であったとしても) `ZERO
WIDTH NO-BREAK SPACE' として扱われます。

外部からの情報無しには、Unicode
文字列のエンコーディングにどのエンコーディングが
使われたのか信頼できる形で決定することは不可能です。どの charmap
エンコーディングも どんなランダムなバイト列でもデコードできます。しかし
UTF-8 では、
任意のバイト列が許される訳ではないような構造を持っているので、
そのようなことは可能ではありません。UTF-8
エンコーディングであることを検知する
信頼性を向上させるために、Microsoft は Notepad プログラム用に UTF-8
の変種 (Python 2.5 はで `"utf-8-sig"' と呼んでいます) を考案しました。
まだ Unicode 文字がファイルに書き込まれない前に UTF-8 でエンコードした
BOM (バイト列では `0xef', `0xbb', `0xbf' のように見えます)
を書き込んでしまいます。このようなバイト値で charmap
エンコードされたファイルが 始まることはほとんどあり得ない(たとえば
iso-8859-1 では

LATIN SMALL LETTER I WITH DIAERESIS \ RIGHT-POINTING DOUBLE ANGLE
QUOTATION MARK \ INVERTED QUESTION MARK

のようになる)ので、utf-8-sig
エンコーディングがバイト列から正しく推測される
確率を高めます。つまりここでは BOM
はバイト列を生成する際のバイト順を決定
できるように使われているのではなく、エンコーディングを推測する助けになる印
として使われているのです。utf-8-sig codec
はエンコーディングの際ファイルに 最初の3文字として `0xef', `0xbb',
`0xbf' を書き込みます。
デコーディングの際はファイルの先頭に現れたこれら3バイトはスキップします。

