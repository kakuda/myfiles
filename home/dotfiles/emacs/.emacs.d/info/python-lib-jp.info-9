これは python-lib-jp.info、python-lib-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-lib-jp.info,  Node: クラスと関数,  Next: TestCase オブジェクト,  Prev: 既存テストコードの再利用,  Up: unittest

23.3.4 クラスと関数
-------------------

`TestCase([methodName])'
     `TestCase'クラスのインスタンスは、`unittest'の世界における
     テストの最小実行単位を示しま
     す。このクラスをベースクラスとして使用し、必要なテストを具象サブクラス
     に実装します。`TestCase'クラスでは、テストランナーがテストを実行
     するためのインターフェースと、各種のチェックやテスト失敗をレポートする
     ためのメソッドを実装しています。

     それぞれの`TestCase'クラスのインスタンスはただ一つのテストメソッド、
     METHODNAMEという名のメソッドを実行します。既に次のような例を扱った
     ことを憶えているでしょうか。

            def suite():
                suite = unittest.TestSuite()
                suite.addTest(WidgetTestCase('testDefaultSize'))
                suite.addTest(WidgetTestCase('testResize'))
                return suite

     ここでは、それぞれが一つずつのテストを実行するような`WidgetTestCase'の
     二つのインスタンスを作成しています。

     METHODNAMEのデフォルトは`'runTest''です。

`FunctionTestCase(testFunc[, setUp[, tearDown[, description]]])'
     このクラスでは`TestCase'インターフェースの内、テストランナーがテ
     ストを実行するためのインターフェースだけを実装しており、テスト結果のチ
     ェックやレポートに関するメソッドは実装していません。既存のテストコード
     を`unittest'によるテストフレームワークに組み込むために使用し ます。

`TestSuite([tests])'
     このクラスは、個々のテストケースやテストスイートの集約を示します。通常
     のテストケースと同じようにテストランナーで実行するためのインタフェース
     を備えています。`TestSuite'インスタンスを実行することはスイートの
     繰り返しを使って個々のテストを実行することと同じです。

     引数TESTSが与えられるならば、それはテストケースに亘る繰り返し可能オブジェクト
     または内部でスイートを組み立てるための他のテストスイートでなければなりません。
     後からテストケースやスイートをコレクションに付け加えるためのメソッドも提供されています。

`TestLoader()'
     モジュールまたは`TestCase'クラスから、指定した条件に従ってテス
     トをロードし、`TestSuite'にラップして返します。このクラスは与え
     られたモジュールまたは`TestCase'のサブクラスの中から全てのテス
     トをロードできます。

`TestResult()'
     このクラスはどのテストが成功しどのテストが失敗したかの情報を集積する
     のに使います。

`defaultTestLoader'
     `TestLoader'のインスタンスで、共用することが目的です。
     `TestLoader'をカスタマイズする必要がなければ、新しい
     `TestLoader'オブジェクトを作らずにこのインスタンスを使用します。

`TextTestRunner([stream[, descriptions[, verbosity]]])'
     実行結果を標準エラーに出力する、単純なテストランナー。いくつかの設定項目
     がありますが、非常に単純です。グラフィカルなテスト実行アプリケーション
     では、独自のテストランナーを作成してください。

`main([module[, defaultTest[, argv[, testRunner[, testRunner]]]]])'
     テストを実行するためのコマンドラインプログラム。この関数を使えば、
     簡単に実行可能なテストモジュールを作成する事ができます。
     一番簡単なこの関数の使い方は、以下の行をテストスクリプトの最後に置くことです。

          if __name__ == '__main__':
              unittest.main()


場合によっては、`doctest' モジュールを使って書かれた
既存のテストがあります。その場合、モジュールは
既存の`doctest'に基づいたテストコードから `unittest.TestSuite'
インスタンスを 自動的に構築できる `DocTestSuite' クラスを提供します。
_Added in Python version 2.3_


File: python-lib-jp.info,  Node: TestCase オブジェクト,  Next: TestSuite オブジェクト,  Prev: クラスと関数,  Up: unittest

23.3.5 TestCase オブジェクト
----------------------------

`TestCase'クラスのインスタンスは個別のテストをあらわすオブジェクト
ですが、`TestCase'の具象サブクラスには複数のテストを定義する事がで
きます -- 具象サブクラスは、特定のfixture(テスト設備)を示している、と考
えてください。fixtureは、それぞれのテストケースごとに作成・解放されま
す。

`TestCase'インスタンスには、次の3種類のメソッドがあります:テストを
実行するためのメソッド・条件のチェックやテスト失敗のレポートのためのメソ
ッド・テストの情報収集に使用する問い合わせメソッド。

テストを実行するためのメソッドを以下に示します:

`setUp()'
     テストを実行する直前に、fixtureを作成する為に呼び出されます。このメソ
     ッドを実行中に例外が発生した場合、テストの失敗ではなくエラーとされま
     す。デフォルトの実装では何も行いません。


`tearDown()'
     テストを実行し、結果を記録した直後に呼び出されます。テスト実行中に例外
     が発生しても呼び出されますので、内部状態に注意して処理を行ってくださ
     い。メソッドを実行中に例外が発生した場合、テストの失敗ではなくエラーと
     みなされます。このメソッドは、`setUp()'が正常終了した場合にはテ
     ストメソッドの実行結果に関わり無く呼び出されます。デフォルトの実装では
     何も行いません。

`run([result])'
     テストを実行し、テスト結果をRESULTに指定されたテスト結果オブジェ
     クトに収集します。RESULTが`None'か省略された場合、一時
     的な結果オブジェクトを(`defaultTestCase()'メソッドを呼んで)生
     成して使用しますが`run()'の呼び出し元には渡されません。

     このメソッドは、`TestCase'インスタンスの呼び出しと等価です。

`debug()'
     テスト結果を収集せずにテストを実行します。例外が呼び出し元に通知される
     ため、テストをデバッガで実行することができます。

テスト結果のチェックとレポートには、以下のメソッドを使用してください。

`assert_(expr[, msg])'

`failUnless(expr[, msg])'
     EXPRが偽の場合、テスト失敗を通知します。MSGにはエラーの説
     明を指定するか、または`None'を指定してください。

`assertEqual(first, second[, msg])'

`failUnlessEqual(first, second[, msg])'
     FIRSTとSECONDEXPRが等しくない場合、テスト失敗を通知
     します。エラー内容はMSGに指定された値か、または`None'となり
     ます。`failUnlessEqual()'ではMSGのデフォルト値は
     FIRSTとSECONDを含んだ文字列となりますので、
     `failUnless()'の第一引数に比較の結果を指定するよりも便利です。

`assertNotEqual(first, second[, msg])'

`failIfEqual(first, second[, msg])'
     FIRSTとSECONDEXPRが等しい場合、テスト失敗を通知しま
     す。エラー内容はMSGに指定された値か、または`None'となりま
     す。`failUnlessEqual()'ではMSGのデフォルト値はFIRST
     とSECONDを含んだ文字列となりますので、`failUnless()'の第
     一引数に比較の結果を指定するよりも便利です。

`assertAlmostEqual(first, second[, places[, msg]])'

`failUnlessAlmostEqual(first, second[, places[, msg]])'
     FIRST と SECOND を PLACES で与えた小数位で値を丸めて差分を計算し、
     ゼロと比較することで、近似的に等価であるかどうかをテストします。
     指定小数位の比較というものは指定有効桁数の比較ではないので注意してください。
     値の比較結果が等しくなかった場合、テストは失敗し、MSG で指定した
     説明か、`None' を返します。

`assertNotAlmostEqual(first, second[, places[, msg]])'

`failIfAlmostEqual(first, second[, places[, msg]])'
     FIRST と SECOND を PLACES で与えた小数位で値を丸めて差分を計算し、
     ゼロと比較することで、近似的に等価でないかどうかをテストします。
     指定小数位の比較というものは指定有効桁数の比較ではないので注意してください。
     値の比較結果が等しかった場合、テストは失敗し、MSG で与えた
     説明か、`None' を返します。

`assertRaises(exception, callable, ...)'

`failUnlessRaises(exception, callable, ...)'
     CALLABLEを呼び出し、発生した例外をテストします。
     `assertRaises()'には、任意の位置パラメータとキーワードパラメー
     タを指定する事ができます。EXCEPTIONで指定した例外が発生した場合
     はテスト成功とし、それ以外の例外が発生するか例外が発生しない場合にテス
     ト失敗となります。複数の例外を指定する場合には、例外クラスのタプルを
     EXCEPTIONに指定します。

`failIf(expr[, msg])'
     `failIf()'は`failUnless()'の逆で、EXPRが真の場合、
     テスト失敗を通知します。エラー内容はMSGに指定された値か、または
     `None'となります。

`fail([msg])'
     無条件にテスト失敗を通知します。エラー内容はMSGに指定された値
     か、または`None'となります。

`failureException'
     `test()'メソッドが送出する例外を指定するクラス属性。テストフ
     レームワークで追加情報を持つ等の特殊な例外を使用する場合、この例外のサ
     ブクラスとして作成します。この属性の初期値は`AssertionError' です。

テストフレームワークは、テスト情報を収集するために以下のメソッドを使用し
ます:

`countTestCases()'
     テストオブジェクトに含まれるテストの数を返します。`TestCase'イン
     スタンスは常に`1'を返します。

`defaultTestResult()'
     このテストケースクラスで使われるテスト結果クラスのインスタンス
     を(もし`run()'メソッドに他の結果インスタンスが提供されないなら
     ば)返します。

     `TestCase'インスタンスに対しては、いつも`TestResult'のイ
     ンスタンスですので、`TestCase'のサブクラスでは必要に応じてこの
     メソッドをオーバライドしてください。

`id()'
     テストケースを特定する文字列を返します。通常、IDはモジュール名・
     クラス名を含む、テストメソッドのフルネームを指定します。

`shortDescription()'
     テストの説明を一行分、または説明がない場合には`None'を返します。
     デフォルトでは、テストメソッドのdocstringの先頭の一行、または
     `None'を返します。


File: python-lib-jp.info,  Node: TestSuite オブジェクト,  Next: TestResultオブジェクト,  Prev: TestCase オブジェクト,  Up: unittest

23.3.6 TestSuite オブジェクト
-----------------------------

`TestSuite'オブジェクトは`TestCase'とよく似た動作をします
が、実際のテストは実装せず、一まとめにに実行するテストのグループをまとめ
るために使用します。`TestSuite'には以下のメソッドが追加されていま す:

`addTest(test)'
     `TestCase'又は`TestSuite'のインスタンスをスイートに追加し ます。

`addTests(tests)'
     イテラブルTESTSに含まれる全ての`TestCase'又は
     `TestSuite'のインスタンスをスイートに追加します。

     このメソッドはTEST上のイテレーションをしながらそれぞれの要素に
     `addTest()'を呼び出すのと等価です。

`TestSuite'クラスは`TestCase'と以下のメソッドを共有します:

`run(result)'
     スイート内のテストを実行し、結果をRESULTで指定した結果オブジェク
     トに収集します。`TestCase.run()'と異なり、
     `TestSuite.run()'では必ず結果オブジェクトを指定する必要がありま
     す。

`debug()'
     このスイートに関連づけられたテストを結果を収集せずに実行します。
     これによりテストで送出された例外は呼び出し元に伝わるようになり、
     デバッガの下でのテスト実行をサポートできるようになります。

`countTestCases()'
     このテストオブジェクトによって表現されるテストの数を返します。
     これには個別のテストと下位のスイートも含まれます。

通常、`TestSuite'の`run()'メソッドは`TestRunner'が起
動するため、ユーザが直接実行する必要はありません。


File: python-lib-jp.info,  Node: TestResultオブジェクト,  Next: TestLoader オブジェクト,  Prev: TestSuite オブジェクト,  Up: unittest

23.3.7 TestResultオブジェクト
-----------------------------

`TestResult'は、複数のテスト結果を記録します。`TestCase'クラ
スと`TestSuite'クラスのテスト結果を正しく記録しますので、テスト開
発者が独自にテスト結果を管理する処理を開発する必要はありません。

`unittest'を利用したテストフレームワークでは、
`TestRunner.run()'が返す`TestResult'インスタンスを参照し、
テスト結果をレポートします。

以下の属性は、テストの実行結果を検査する際に使用することができます:

`errors'
     `TestCase'と例外のトレースバック情報をフォーマットした文字列の
     2要素タプルからなるリスト。それぞれのタプルは予想外の例外を送出したテストに
     対応します。 _Changed in Python version 2.2_

`failures'
     `TestCase'と例外のトレースバック情報をフォーマットした文字列の
     2要素タプルからなるリスト。それぞれのタプルは`TestCase.fail*()'や
     `TestCase.assert*()'メソッドを使って見つけ出した失敗に対応します。
     _Changed in Python version 2.2_

`testsRun'
     これまでに実行したテストの総数。

`wasSuccessful()'
     これまでに実行したテストが全て成功していれば`True'を、
     それ以外なら`False'を返す。

`stop()'
     このメソッドを呼び出して`TestResult'の`shouldStop'属性
     に`True'をセットすることで、実行中のテストは中断しなければな
     らないというシグナルを送ることができます。`TestRunner'オブジェ
     クトはこのフラグを尊重してそれ以上のテストを実行することなく復帰しな
     ければなりません。

     たとえばこの機能は、ユーザのキーボード割り込みを受け取っ
     て`TextTestRunner'クラスがテストフレームワークを停止させるのに
     使えます。`TestRunner'の実装を提供する対話的なツールでも同じよ
     うに使用することができます。

以下のメソッドは内部データ管理用のメソッドですが、対話的にテスト結果をレ
ポートするテストツールを開発する場合などにはサブクラスで拡張することがで
きます。

`startTest(test)'
     TESTを実行する直前に呼び出されます。

     デフォルトの実装では単純にインスタンスの`testRun'カウンタをイン
     クリメントします。

`stopTest(test)'
     TESTの実行直後に、テスト結果に関わらず呼び出されます。

     デフォルトの実装では何もしません。

`addError(test, err)'
     テストTEST実行中に、想定外の例外が発生した場合に呼び出されます。
     ERRは`sys.exc_info()'が返すタプル`(TYPE, VALUE, TRACEBACK)'です。

     デフォルトの実装ではインスタンスの`errors'属性 に`(TEST,
     ERR)'を追加します。

`addFailure(test, err)'
     テストが失敗した場合に呼び出されます。ERRは
     `sys.exc_info()'が返すタプル`(TYPE, VALUE, TRACEBACK)'です。

     デフォルトの実装ではインスタンスの`failures'属性 に`(TEST,
     ERR)'を追加します。

`addSuccess(test)'
     テストケースTESTが成功した場合に呼び出されます。

     デフォルトの実装では何もしません。


File: python-lib-jp.info,  Node: TestLoader オブジェクト,  Prev: TestResultオブジェクト,  Up: unittest

23.3.8 TestLoader オブジェクト
------------------------------

`TestLoader'クラスは、クラスやモジュールからテストスイートを作成す
るために使用します。通常はこのクラスのインスタンスを作成する必要はなく、
`unittest'モジュールのモジュール属性`unittest.defaultTestLoader'を
共用インスタンスとして使用することができます。
ただ、サブクラスや別のインスタンスを活用すると設定可能なプロパティを
カスタマイズすることもできます。

`TestLoader' オブジェクトには以下のメソッドがあります:

`loadTestsFromTestCase(testCaseClass)'
     `TestCase'の派生クラス`testCaseClass'に含まれる全テスト
     ケースのスイートを返します。

`loadTestsFromModule(module)'
     指定したモジュールに含まれる全テストケースのスイートを返します。このメ
     ソッドはMODULE内の`TestCase'派生クラスを検索し、見つかった
     クラスのテストメソッドごとにクラスのインスタンスを作成します。

     _`TestCase'クラスを基底クラスとしてクラス階層を構築する
     とfixtureや補助的な関数をうまく共用することができますが、基底クラスに
     直接インスタンス化できないテストメソッドがあると、この
     `loadTestsFromModule'を使うことができません。この場合でも、
     fixtureが全て別々で定義がサブクラスにある場合は使用することができま
     す。_

`loadTestsFromName(name[, module])'
     文字列で指定される全テストケースを含むスイートを返します。

     NAMEには"ドット修飾名"でモジュールかテストケースクラス、テス
     トケースクラス内のメソッド、`TestSuite'インスタンスまた
     は`TestCase'か`TestSuite'のインスタンスを返す呼び出し可能
     オブジェクトを指定します。このチェックはここで挙げた順番に行なわれます。
     すなわち、候補テストケースクラス内のメソッドは「呼び出し可能オブジェクト」
     としてではなく「テストケースクラス内のメソッド」として拾い出されます。

     例えば`SampleTests'モジュールに
     `TestCase'から派生した`SampleTestCase'クラスがあり、
     `SampleTestCase'にはテストメソッド`test_one()'・
     `test_two()'・`test_three()'があるとします。この場合、
     NAMEに`'SampleTests.SampleTestCase''と指定すると、
     `SampleTestCase'の三つのテストメソッドを実行するテストスイートが
     作成されます。`'SampleTests.SampleTestCase.test_two''と指定すれ
     ば、`test_two()'だけを実行するテストスイートが作成されます。イ
     ンポートされていないモジュールやパッケージ名を含んだ名前を指定した場合
     は自動的にインポートされます。

     また、MODULEを指定した場合、MODULE内のNAMEを取得しま す。

`loadTestsFromNames(names[, module])'
     `loadTestsFromName()'と同じですが、名前を一つだけ指定するのでは
     なく、複数の名前のシーケンスを指定する事ができます。戻り値は
     NAMES中の名前で指定されるテスト全てを含むテストスイートです。

`getTestCaseNames(testCaseClass)'
     TESTCASECLASS中の全てのメソッド名を含むソート済みシーケンスを返
     します。TESTCASECLASSは`TestCase'のサブクラスでなければな
     りません。

以下の属性は、サブクラス化またはインスタンスの属性値を変更し
て`TestLoader'をカスタマイズする場合に使用します。

`testMethodPrefix'
     テストメソッドの名前と判断されるメソッド名の接頭語を示す文字列。デフォ
     ルト値は`'test''です。

     この値は`getTestCaseNames()'と全て
     の`loadTestsFrom*()'メソッドに影響を与えます。

`sortTestMethodsUsing'
     `getTestCaseNames()'および全て
     の`loadTestsFrom*()'メソッドでメソッド名をソートする際に使用する比較関
     数。デフォルト値は組み込み関数`cmp()'です。ソートを行なわないように
     この属性に`None'を指定することもできます。

`suiteClass'
     テストのリストからテストスイートを構築する呼び出し可能オブジェクト。メ
     ソッドを持つ必要はありません。デフォルト値は`TestSuite'です。

     この値は全ての`loadTestsFrom*()'メソッドに影響を与えます。


File: python-lib-jp.info,  Node: test,  Prev: unittest,  Up: 開発ツール

23.4 Python用回帰テストパッケージ
=================================

Python用テストスイートを含む回帰テストパッケージ。

`test' パッケージには、Python 用の全ての回帰テストと、
`test.test_support'および`test.regrtest' モジュール
が入っています。`test.test_support' はテストを充実させる
ために使い、`test.regtest' はテストスイートを駆動するのに 使います。

`test'パッケージ内の各モジュールのうち、名前が`test_'
で始まるものは、特定のモジュールや機能に対するテストスイートです。
新しいテストはすべて`unittest'モジュールを使って書くように
してください; 必ずしも`unittest' を使う必要はないのですが、 `unittest'
はテストをより柔軟にし、メンテナンスをより簡単に
します。古いテストのいくつかは`doctest' を利用しており、 "伝統的な"
テスト形式になっています。これらのテスト形式をカバー
する予定はありません。

See also:
     *Note unittest:: PyUnit 回帰テストを書く。 *Note doctest::
     ドキュメンテーション文字列に埋め込まれたテスト。

* Menu:

* testパッケージのためのユニットテストを書く::
* testregrtestを使ってテストを実行する::
* testtest_support --- テストのためのユーティリティ関数::


File: python-lib-jp.info,  Node: testパッケージのためのユニットテストを書く,  Next: testregrtestを使ってテストを実行する,  Prev: test,  Up: test

23.4.1 `test'パッケージのためのユニットテストを書く
---------------------------------------------------

`test' パッケージ用のテストを書く場合、`unittest'
モジュールを使い、以下のいくつかのガイドラインに従うよう推奨します。
一つは、テストモジュールの名前を、`test_'で始め、テスト
対象となるモジュール名で終えることです。
テストモジュール中のテストメソッドは
名前を`test_'で始めて、そのメソッドが何をテストしているかという説明で終えます。
これはテスト駆動プログラムに
そのメソッドをテストメソッドとして認識させるため必要です。
また、テストメソッドにはドキュメンテーション文字列を入れるべきでは
ありません。 テストメソッドのドキュメント記述には、 (`# True あるいは
False だけを返すテスト関数' のような) コメントを使ってください。
これは、ドキュメンテーション文字列が存在する場合にはその内容が出力
されるため、どのテストを実行しているのかをいちいち表示しなくするためです。

以下のような基本的な決まり文句を使います:

     import unittest
     from test import test_support

     class MyTestCase1(unittest.TestCase):

         # Only use setUp() and tearDown() if necessary

         def setUp(self):
             ... code to execute in preparation for tests ...

         def tearDown(self):
             ... code to execute to clean up after tests ...

         def test_feature_one(self):
             # Test feature one.
             ... testing code ...

         def test_feature_two(self):
             # Test feature two.
             ... testing code ...

         ... more test methods ...

     class MyTestCase2(unittest.TestCase):
         ... same structure as MyTestCase1 ...

     ... more test classes ...

     def test_main():
         test_support.run_unittest(MyTestCase1,
                                   MyTestCase2,
                                   ... list other tests ...
                                  )

     if __name__ == '__main__':
         test_main()

この定型的なコードによって、テストスイートを`regrtest.py'
から起動できると同時に、スクリプト自体からも実行できるようになります。

回帰テストの目的はコードの分解です。
そのためには以下のいくつかのガイドラインに従ってください:

   * テストスイートはすべてのクラス、関数および定数を用いるべきです。
     これは外部に公開される外部APIだけでなく"非公開"コードも含んでいます。

   * ホワイトボックス・テスト (テストを書くときに対象のコードをすぐ
     テストする) を推奨します。ブラックボックス・テスト
     (最終的に公開された ユーザーインターフェイスだけをテストする)
     は、すべての境界条件と
     極端条件を確実にテストするには完全ではありません。

   * 無効な値を含み、すべての取りうる値を確実にテストするように
     してください。そうすることで、全ての有効な値を受理するだけでなく、
     不適切な値を正しく処理することも確認できます。

   * できる限り多くのコード経路を網羅してください。分岐が生じる
     テストし、入力を調整して、コードの全体に渡って取りえる限りの個々の
     処理経路を確実にたどらせるようにしてください。

   * テスト対象のコードにどんなバグが発見された場合でも、明示的な
     テスト追加するようにしてください。そうすることで、将来コードを変更した
     際にエラーが再発しないようにできます。

   * (一時ファイルをすべて閉じたり削除したりするといった) テストの
     後始末を必ず行ってください。

   * テストがオペレーティングシステムの特定の状況に依存する場合、
     テストを開始する前に状況を確認してください。

   * import するモジュールをできるかぎり少なくし、可能な限り 早期に
     import を行ってください。そうすることで、てテストの外部依存性を
     最小限にし、モジュールの import
     による副作用から生じる変則的な動作を 最小限にできます。

   * コードの再利用を最大限に行うようにしてください。時として、
     テストの多様性はどんな型の入力を受け取るかの違いまで小さくなります。
     例えば以下のように、入力が指定されたサブクラスで基底テストクラスを
     サブクラス化して、コードの複製を最小化します:
          class TestFuncAcceptsSequences(unittest.TestCase):

              func = mySuperWhammyFunction

              def test_func(self):
                  self.func(self.arg)

          class AcceptLists(TestFuncAcceptsSequences):
              arg = [1,2,3]

          class AcceptStrings(TestFuncAcceptsSequences):
              arg = 'abc'

          class AcceptTuples(TestFuncAcceptsSequences):
              arg = (1,2,3)


See also:
     `Test Driven Development'{コードより前にテストを書く
     方法論に関する Kent Beck の著書}


File: python-lib-jp.info,  Node: testregrtestを使ってテストを実行する,  Next: testtest_support --- テストのためのユーティリティ関数,  Prev: testパッケージのためのユニットテストを書く,  Up: test

23.4.2 `test.regrtest'を使ってテストを実行する
----------------------------------------------

`test.regrtest' を使うと Python の回帰テストスイートを駆動
できます。スクリプトを単独で実行すると、自動的に`test'
パッケージ内のすべての回帰テストを実行し始めます。パッケージ内の
名前が`test_'で始まる全モジュールを見つけ、それをインポートし、
もしあるなら関数 `test_main' を実行してテストを行います。
実行するテストの名前もスクリプトに渡される可能性もあります。
単一の回帰テストを指定 (`python regrtest.py' `test_spam.py') すると、
出力を最小限にします。テストが成功したかあるいは失敗したかだけを出力
するので、出力は最小限になります。

直接 `test.regrtest' を実行すると、テストに利用するリソースを
設定できます。これを行うには、`-u'
コマンドラインオプションを使います。すべてのリソースを使うには、
`python regrtest.py' `-uall' を実行します。 `-u' のオプションに `all'
を指定すると、 すべてのリソースを有効にします。(よくある場合ですが)
何か一つを除く
全てが必要な場合、カンマで区切った不要なリソースのリストを `all'
の後に並べます。 コマンド`python regrtest.py' `-uall,-audio,-largefile'
とすると、`audio' と `largefile' リソースを除く
全てのリソースを使って`test.regrtest' を実行します。
すべてのリソースのリストと追加のコマンドラインオプションを出力
するには、`python regrtest.py' `-h' を実行 してください。

テストを実行しようとするプラットフォームによっては、回帰テストを
実行する別の方法があります。 UNIX では、Python
をビルドしたトップレベルディレクトリで `make' `test' を実行できます。
Windows上では、`PCBuild' ディレクトリから `rt.bat' を
実行すると、すべての回帰テストを実行します。


File: python-lib-jp.info,  Node: testtest_support --- テストのためのユーティリティ関数,  Prev: testregrtestを使ってテストを実行する,  Up: test

23.4.3 `test.test_support' -- テストのためのユーティリティ関数
--------------------------------------------------------------

Python 回帰テストのサポート

`test.test_support' モジュールでは、 Python の回帰テストに対する
サポートを提供しています。

このモジュールは次の例外を定義しています:

`TestFailed'
     テストが失敗したとき送出される例外です。

`TestSkipped'
     `TestFailed'のサブクラスです。
     テストがスキップされたとき送出されます。 テスト時に
     (ネットワーク接続のような) 必要なリソースが利用
     できないときに送出されます。

`ResourceDenied'
     `TestSkipped'のサブクラスです。
     (ネットワーク接続のような)リソースが利用できないとき送出されます。
     `requires'関数によって送出されます。

`test.test_support' モジュールでは、以下の定数を定義しています:

`verbose'
     冗長な出力が有効な場合は`True' です。
     実行中のテストについてのより詳細な情報が欲しいときにチェックします。
     VERBOSE は `test.regrtest' によって設定されます。

`have_unicode'
     ユニコードサポートが利用可能ならば`True' になります。

`is_jython'
     実行中のインタプリタが Jython ならば`True' になります。

`TESTFN'
     一時ファイルを作成するパスに設定されます。
     作成した一時ファイルは全て閉じ、unlink (削除) せねばなりません。

`test.test_support' モジュールでは、以下の関数を定義しています:

`forget(module_name)'
     モジュール名MODULE_NAMEを`sys.modules'から取り除き、
     モジュールのバイトコンパイル済みファイルを全て削除します。

`is_resource_enabled(resource)'
     RESOURCE が有効で利用可能ならば`True'を返します。
     利用可能なリソースのリストは、`test.regrtest'がテストを
     実行している間のみ設定されます。

`requires(resource[, msg])'
     RESOURCE が利用できなければ、`ResourceDenied'を
     送出します。その場合、MSGは `ResourceDenied' の引数に
     なります。__NAME__ が `"__main__"' である関数にから
     呼び出された場合には常に真を返します。 テストを`test.regrtest'
     から実行するときに使われます。

`findfile(filename)'
     FILENAMEという名前のファイルへのパスを返します。
     一致するものが見つからなければ、FILENAME 自体を返します。 FILENAME
     自体もファイルへのパスでありえるので、 FILENAME
     が返っても失敗ではありません。

`run_unittest(*classes)'
     渡された `unittest.TestCase' サブクラスを実行します。
     この関数は名前が `test_' で始まるメソッドを探して、
     テストを個別に実行します。
     この方法をテストの実行方法として推奨しています。

`run_suite(suite[, testclass=None])'
     `unittest.TestSuite' のインスタンス SUITEを実行します。
     オプション引数TESTCLASS はテストスイート内のテストクラスの
     一つを受け取り、指定するとテストスイートが存在する場所についてさらに
     詳細な情報を出力します。


File: python-lib-jp.info,  Node: Pythonデバッガ,  Next: Python プロファイラ,  Prev: 開発ツール,  Up: Top

24 Pythonデバッガ
*****************

対話的インタプリタのためのPythonデバッガ。

モジュール`pdb'はPythonプログラム用の対話的ソースコードデバッガ を定義します。(条件付き)ブレークポイントの設定やソース行レベルでのシングルステップ実行、スタックフレームのインスペクション、ソースコードリスティングおよびいかなるスタックフレームのコンテキストにおける任意のPythonコードの評価をサポートしています。事後解析デバッギングもサポートし、プログラムの制御下で呼び出すことができます。

デバッガは拡張可能です -- 実際にはクラス`Pdb' として定義されています。現在これについてのドキュメントはありませんが、ソースを読めば簡単に理解できます。拡張インターフェースはモジュール`bdb' (ドキュメントなし)と`cmd' を使っています。

デバッガのプロンプトは`(Pdb)
'です。デバッガに制御された状態でプログラムを実行するための典型的な使い方は:

     >>> import pdb
     >>> import mymodule
     >>> pdb.run('mymodule.test()')
     > <string>(0)?()
     (Pdb) continue
     > <string>(1)?()
     (Pdb) continue
     NameError: 'spam'
     > <string>(1)?()
     (Pdb)

他のスクリプトをデバッグするために、`pdb.py'をスクリプトとして呼び出すこともできますせます。例えば:

     python -m pdb myscript.py

スクリプトとして pdb を起動すると、デバッグ中のプログラムが異常終了した
時に pdb が自動的に検死デバッグモードに入ります。検死デバッグ後
(またはプログラムの正常終了後) には、pdb はプログラムを再起動します。
自動再起動を行った場合、 pdb の状態 (ブレークポイントなど) は
そのまま維持されるので、たいていの場合、プログラム終了時に
デバッガも終了させるよりも便利なはずです。 _Added in Python version 2.4_

クラッシュしたプログラムを調べるための典型的な使い方は:

     >>> import pdb
     >>> import mymodule
     >>> mymodule.test()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
       File "./mymodule.py", line 4, in test
         test2()
       File "./mymodule.py", line 3, in test2
         print spam
     NameError: spam
     >>> pdb.pm()
     > ./mymodule.py(3)test2()
     -> print spam
     (Pdb)

モジュールは以下の関数を定義しています。それぞれが少しづつ違った方法でデバッガに入ります:

`run(statement[, globals[, locals]])'
     デバッガに制御された状態で(文字列として与えられた)STATEMENTを実行します。デバッガプロンプトはあらゆるコードが実行される前に現れます。ブレークポイントを設定し、`continue'とタイプできます。あるいは、文を`step'や`next'を使って一つづつ実行することができます(これらのコマンドはすべて下で説明します)。オプションのGLOBALSとLOCALS引数はコードを実行する環境を指定します。デフォルトでは、モジュール`__main__'の辞書が使われます。(`exec'文または`eval()'組み込み関数の説明を参照してください。)

`runeval(expression[, globals[, locals]])'
     デバッガの制御もとで(文字列として与えられる)EXPRESSIONを評価します。`runeval()'がリターンしたとき、式の値を返します。その他の点では、この関数は`run()'を同様です。

`runcall(function[, argument, ...])'
     FUNCTION(関数またはメソッドオブジェクト、文字列ではありません)を与えられた引数とともに呼び出します。`runcall()'がリターンしたとき、関数呼び出しが返したものは何でも返します。デバッガプロンプトは関数に入るとすぐに現れます。

`set_trace()'
     スタックフレームを呼び出したところでデバッガに入ります。たとえコードが別の方法でデバッグされている最中でなくても(例えば、アサーションが失敗するとき)、これはプログラムの所定の場所でブレークポイントをハードコードするために役に立ちます。

`post_mortem(traceback)'
     与えられたTRACEBACKオブジェクトの事後解析デバッギングに入ります。

`pm()'
     `sys.last_traceback'のトレースバックの事後解析デバッギングに入ります。

* Menu:

* デバッガコマンド::
* どのように動作しているか::


File: python-lib-jp.info,  Node: デバッガコマンド,  Next: どのように動作しているか,  Prev: Pythonデバッガ,  Up: Pythonデバッガ

24.1 デバッガコマンド
=====================

デバッガは以下のコマンドを認識します。ほとんどのコマンドは一文字または二文字に省略することができます。例えば、`h(elp)'が意味するのは、ヘルプコマンドを入力するために`h'か`help'のどちらか一方を使うことができるということです(が、`he'や`hel'は使えず、また`H'や`Help'、`HELP'も使えません)。コマンドの引数は空白(スペースまたはタブ)で区切られなければなりません。オプションの引数はコマンド構文の角括弧(`[]')の中に入れなければなりません。角括弧をタイプしてはいけません。コマンド構文における選択肢は垂直バー(`|')で区切られます。

空行を入力すると入力された直前のコマンドを繰り返します。例外:
直前のコマンドが`list'コマンドならば、次の11行がリストされます。

デバッガが認識しないコマンドはPython文とみなして、デバッグしているプログラムのコンテキストおいて実行されます。Python文は感嘆符(`!')を前に付けることもできます。これはデバッグ中のプログラムを調査する強力な方法です。変数を変更したり関数を呼び出したりすることさえ可能です。このような文で例外が発生した場合には例外名がプリントされますが、デバッガの状態は変化しません。

複数のコマンドを`;;'で区切って一行で入力することができます。(一つだけの`;'は使われません。なぜなら、Pythonパーサへ渡される行内の複数のコマンドのための分離記号だからです。)コマンドを分割するために何も知的なことはしていません。たとえ引用文字列の途中であっても、入力は最初の`;;'対で分割されます。

デバッガはエイリアスをサポートします。エイリアスはパラメータを持つことができ、調査中のコンテキストに対して人がある程度柔軟に対応できます。

ファイル`.pdbrc' はユーザのホームディレクトリか、またはカレントディレクトリにあります。それはまるでデバッガのプロンプトでタイプしたかのように読み込まれて実行されます。これは特にエイリアスのために便利です。両方のファイルが存在する場合、ホームディレクトリのものが最初に読まれ、そこに定義されているエイリアスはローカルファイルにより上書きされることがあります。

`h(elp) [COMMAND]'
     引数なしでは、利用できるコマンドの一覧をプリントします。引数としてCOMMANDがある場合は、そのコマンドについてのヘルプをプリントします。`help
     pdb'は完全ドキュメンテーションファイルを表示します。環境変数`PAGER'が定義されているならば、代わりにファイルはそのコマンドへパイプされます。COMMAND引数が識別子でなければならないので、`!'コマンドについてのヘルプを得るためには`help
     exec'と入力しなければならない。

`w(here)'
     スタックの底にある最も新しいフレームと一緒にスタックトレースをプリントします。矢印はカレントフレームを指し、それがほとんどのコマンドのコンテキストを決定します。

`d(own)'
     (より新しいフレームに向かって)スタックトレース内でカレントフレームを一レベル下げます。

`u(p)'
     (より古いフレームに向かって)スタックトレース内でカレントフレームを一レベル上げます。

`b(reak) [[FILENAME:]LINENO`{|}'FUNCTION[, CONDITION]]'
     LINENO引数がある場合は、現在のファイルのその場所にブレークポイントを設定します。FUNCTION引数がある場合は、その関数の中の最初の実行可能文にブレークポイントを設定します。別のファイル(まだロードされていないかもしれないもの)のブレークポイントを指定するために、行番号はファイル名とコロンをともに先頭に付けられます。
     ファイルは`sys.path'にそって検索されます。各ブレークポイントは番号を割り当てられ、その番号を他のすべてのブレークポイントコマンドが参照することに注意してください。

     第二引数を指定する場合、その値は式で、その評価値が真でなければ
     ブレークポイントは有効になりません。

     引数なしの場合は、それぞれのブレークポイントに対して、そのブレークポイントに行き当たった回数、現在の通過カウント(ignore
     count)と、もしあれば関連条件を含めてすべてのブレークポイントをリストします。

`tbreak [[FILENAME:]LINENO`{|}'FUNCTION[, CONDITION]]'
     一時的なブレークポイントで、最初にそこに達したときに自動的に取り除かれます。引数はbreakと同じです。

`cl(ear) [BPNUMBER [BPNUMBER ...]]'
     スペースで区切られたブレークポイントナンバーのリストを与えると、それらのブレークポイントを解除します。引数なしの場合は、すべてのブレークポイントを解除します(が、はじめに確認します)。

`disable [BPNUMBER [BPNUMBER ...]]'
     スペースで区切られたブレークポイントナンバーのリストとして与えられるブレークポイントを無効にします。ブレークポイントを無効にすると、プログラムの実行を止めることができなくなりますが、ブレークポイントの解除と違いブレークポイントのリストに残ったままになり、(再び)有効にすることができます。

`enable [BPNUMBER [BPNUMBER ...]]'
     指定したブレークポイントを有効にします。

`ignore BPNUMBER [COUNT]'
     与えられたブレークポイントナンバーに通過カウントを設定します。countが省略されると、通過カウントは0に設定されます。通過カウントがゼロになったとき、ブレークポイントが機能する状態になります。ゼロでないときは、そのブレークポイントが無効にされず、どんな関連条件も真に評価されていて、ブレークポイントに来るたびにcountが減らされます。

`condition BPNUMBER [CONDITION]'
     conditionはブレークポイントが取り上げられる前に真と評価されなければ
     ならない式です。conditionがない場合は、どんな既存の条件も取り除かれま
     す。すなわち、ブレークポイントは無条件になります。

`commands [BPNUMBER]'
     ブレークポイントナンバー BPNUMBER にコマンドのリストを指定します。
     コマンドそのものはその後の行に続けます。'end'
     だけからなる行を入力することで
     コマンド群の終わりを示します。例を挙げます:

          (Pdb) commands 1
          (com) print some_variable
          (com) end
          (Pdb)

     ブレークポイントからコマンドを取り除くには、commands のあとに end
     だけを続けます。つまり、コマンドを一つも指定しないようにします。

     BPNUMBER 引数が指定されない場合、最後にセットされたブレークポイント
     を参照することになります。

     ブレークポイントコマンドはプログラムを走らせ直すのに使えます。
     ただ continue コマンドや
     step、その他実行を再開するコマンドを使えば良いのです。

     実行を再開するコマンド(現在のところ continue, step, next, return,
     jump, quit
     とそれらの省略形)によって、コマンドリストは終了するものと見なされます(コマンドに
     すぐ end
     が続いているかのように)。というのも実行を再開すれば(それが単純な
     next や step
     であっても)別のブレークポイントに到達するかもしれないからです。
     そのブレークポイントにさらにコマンドリストがあれば、どちらのリストを実行すべきか
     状況が曖昧になります。

     コマンドリストの中で 'silent'
     コマンドを使うと、ブレークポイントで停止
     したという通常のメッセージはプリントされません。この振る舞いは特定のメッ
     セージを出して実行を続けるようなブレークポイントでは望ましいものでしょ
     う。他のコマンドが何も画面出力をしなければ、そのブレークポイントに到達
     したというサインを見ないことになります。

     _Added in Python version 2.5_

`s(tep)'
     現在の行を実行し、最初に実行可能なものがあらわれたときに(呼び出された関数の」中か、現在の関数の次の行で)停止します.

`n(ext)'
     現在の関数の次の行に達するか、あるいは関数が返るまで実行を継続します。(`next'と`step'の差は`step'が呼び出された関数の内部で停止するのに対し、`next'は呼び出された関数を(ほぼ)全速力で実行し、現在の関数内の次の行で停止するだけです。

`r(eturn)'
     現在の関数が返るまで実行を継続します。

`c(ont(inue))'
     ブレークポイントに出会うまで、実行を継続します。

`j(ump) LINENO'
     次に実行する行を指定します。最も底のフレーム中でのみ実行可能です。
     前に戻って実行したり、不要な部分をスキップして先の処理を実行する
     場合に使用します。

     ジャンプには制限があり、例えば
     `for'ループの中には飛び込めませんし、
     `finally'節の外にも飛ぶ事ができません。

`l(ist) [FIRST[, LAST]]'
     現在のファイルのソースコードをリスト表示します。引数なしの場合は、現在の行の周囲を11行リストするか、または前のリストの続きを表示します。引数が一つある場合は、その行の周囲を11行表示します。引数が二つの場合は、与えられた範囲をリスト表示します。第二引数が第一引数より小さいときは、カウントと解釈されます。

`a(rgs)'
     現在の関数の引数リストをプリントします。

`p EXPRESSION'
     現在のコンテキストにおいてEXPRESSIONを評価し、その値をプリントします。(注意:
     `print'も使うことができますが、デバッガコマンドではありません --
     これはPythonの`print'文を実行します。)

`pp EXPRESSION'
     `pprint'モジュールを使って例外の値が整形されることを除いて`p'コマンドと同様です。

`alias [NAME [command]]'
     NAMEという名前のCOMMANDを実行するエイリアスを作成します。コマンドは引用符で囲まれていては_いけません_。入れ替え可能なパラメータは`%1'、`%2'などで指し示され、さらに`%*'は全パラメータに置き換えられます。コマンドが与えられなければ、NAMEに対する現在のエイリアスを表示します。引数が与えられなければ、すべてのエイリアスがリストされます。

     エイリアスは入れ子になってもよく、pdbプロンプトで合法的にタイプできるどんなものでも含めることができます。内部pdbコマンドをエイリアスによって上書きすることが_できます_。そのとき、このようなコマンドはエイリアスが取り除かれるまで隠されます。エイリアス化はコマンド行の最初の語へ再帰的に適用されます。行の他のすべての語はそのままです。

     例として、二つの便利なエイリアスがあります(特に`.pdbrc'ファイルに置かれたときに):

          #Print instance variables (usage "pi classInst")
          alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]
          #Print instance variables in self
          alias ps pi self

`unalias NAME'
     指定したエイリアスを削除します。

`[!]STATEMENT'
     現在のスタックフレームのコンテキストにおいて(一行の)STATEMENTを実行します。文の最初の語がデバッガコマンドと共通でない場合は、感嘆符を省略することができます。グローバル変数を設定するために、同じ行に`global'コマンドとともに代入コマンドの前に付けることができます。

          (Pdb) global list_options; list_options = ['-l']
          (Pdb)

`q(uit)'
     デバッガを終了します。実行しているプログラムは中断されます。



File: python-lib-jp.info,  Node: どのように動作しているか,  Prev: デバッガコマンド,  Up: Pythonデバッガ

24.2 どのように動作しているか
=============================

いくつかの変更がインタプリタへ加えられました:

   * `sys.settrace(FUNC)'がグローバルトレース関数を設定します

   * そこで、ローカルトレース関数を使うこともできます(後ろを参照)

トレース関数は三つの引数、 FRAME、EVENTおよびARG を持ちます。
FRAMEは現在のスタックフレームです。
EVENTは文字列で、`'call''、`'line''、`'return''、
`'exception''、`'c_call''、`'c_return'' または`'c_exception''です。
ARGはイベント型に依存します。

新しいローカルスコープに入ったときはいつでも、グローバルトレース関数が(`'call''に設定されたEVENTとともに)呼び出されます。そのスコープで用いられるローカルトレース関数への参照を返すか、またはスコープがトレースされるべきでないならば`None'を返します。

ローカルトレース関数はそれ自身への(あるいは、さらにそのスコープ内でさらにトレースを行うための他の関数への)参照を返します。または、そのスコープにおけるトレースを停止させるために`None'を返します。

トレース関数としてインスタンスメソッドが受け入れられます(また、とても便利です)。

イベントは以下のような意味を持ちます:

``'call'''
     関数が呼び出されます(または、他のコードブロックに入ります)。グローバルトレース関数が呼び出されます。ARGは`None'です。戻り値はローカルトレース関数を指定します。

``'line'''
     インタプリタがコードの新しい行を実行しようとしているところです(ときどき、一行に複数行イベントが存在します)。ローカルトレース関数が呼び出されます。ARGは`None'です。戻り値は新しいローカルトレース関数を指定します。

``'return'''
     関数(または、コードブロック)が返ろうとしているところです。ローカルトレース関数が呼び出されます。ARGは返るであろう値です。トレース関数の戻り値は無視されます。

``'exception'''
     例外が生じています。ローカルトレース関数が呼び出されます。ARGは三要素の`(EXCEPTION,
     VALUE,
     TRACEBACK)'です。戻り値は新しいローカルトレース関数を指定します。

``'c_call'''
     拡張モジュールまたは組み込みの C 関数が呼び出されようとしています。
     ARG は C 関数オブジェクトです。

``'c_return'''
     C 関数が処理を戻しました。ARG は`None' です。

``'c_exception'''
     C 関数が例外を送出しました。ARG は`None' です。


例外が一連の呼び出し元を伝えられて行くときに、`'exception''イベントは各レベルで生成されることことに注意してください。

コードとフレームオブジェクトについてさらに情報を得るには、を参照してください。


File: python-lib-jp.info,  Node: Python プロファイラ,  Next: Python ランタイム サービス,  Prev: Pythonデバッガ,  Up: Top

25 Python プロファイラ
**********************

Copyright (C) 1994, by InfoSeek Corporation, all rights reserved.  

執筆者 James Roskind (1)

Permission to use, copy, modify, and distribute this Python software
and its associated documentation for any purpose (subject to the
restriction in the following sentence) without fee is hereby granted,
provided that the above copyright notice appears in all copies, and
that both that copyright notice and this permission notice appear in
supporting documentation, and that the name of InfoSeek not be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission.  This permission is
explicitly restricted to the copying and modification of the software
to remain in Python, compiled Python, or other languages (such as C)
wherein the modified or derived code is exclusively imported into a
Python module.

INFOSEEK CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL INFOSEEK CORPORATION BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

このプロファイラは私が Python プログラミングを始めてからわずか3週間後
に書いたものです。その結果、稚拙なコードが出来上がってしまったのかもし
れませんが、なにせ私はまだ初心者なのでそれもよくわかりません :-) コー
ドはプロファイリングにふさわしいスピードを実現することに心血を注ぎまし
た。しかし部分的な繰り返しを避けたため、かなり不格好になってしまったと
ころがあります。改善のための意見があれば、ぜひ <jar@netscape.com>
までメールをください。サポートの _約束_
はできませんが...フィードバックへの感謝だけは確実にいたします。

* Menu:

* Profiler Introduction::
* インスタント・ユーザ・マニュアル::
* Deterministic Profiling::
* リファレンス・マニュアル - profile と cProfile::
* 制限事項 2::
* キャリブレーション補正::
* Profiler Extensions::
* hotshot::
* timeit::
* trace::

---------- Footnotes ----------

(1)  アップデートと LaTeX への変換は  Guido van Rossum によるもの。
さらに Python 2.5 の新しい `cProfile' モジュールの文書を統合する
アップデートは Armin Rigo による。


File: python-lib-jp.info,  Node: Profiler Introduction,  Next: インスタント・ユーザ・マニュアル,  Prev: Python プロファイラ,  Up: Python プロファイラ

25.1 プロファイラとは
=====================

"プロファイラ"とは、プログラム実行時の様々な状態を得ることにより、
その実行効率を調べるためのプログラムです。ここで解説するのは、
`profile' と `pstats' モジュールが提供するプロファイラ機
能についてです。このプロファイラはどの Python プログラムに対しても
"決定論的プロファイリング"をおこないます。また、プロファイルの結果
検証をす早くおこなえるよう、レポート生成用のツールも提供されています。 

Python 標準ライブラリは3つの異なるプロファイラを提供します。

  1. `profile' はピュア Python モジュールで、このあとすぐ説明します。
     Copyright (C) 1994, by InfoSeek Corporation.  _Changed in Python
     version 2.4_

  2. `cProfile' は C で書かれたモジュールで、少ないオーバーヘッドにより
     長く実行されるプログラムのプロファイルに向きます。 Brett Rosen と
     Ted Czotter が提供した `lsprof' に基づいています。 _Added in
     Python version 2.5_

  3. `hotshot' は C モジュールでプロファイル中のオーバーヘッドを
     極力小さくすることに焦点を絞っており、その代わりに後処理時間の長さという
     つけを払います。 _Changed in Python version 2.5_

`profile' と `cProfile' の両モジュールは同じインタフェースを
提供しているので、ほぼ取り替え可能です。 `cProfile' はずっと
小さなオーバーヘッドで動きますが、まだ同じぐらいテストされたとは言えず、
全てのシステムで使えるとは限らないでしょう。 `cProfile' は実際には
`_lsprof' 内部モジュールに被せられた 互換性レイヤです。 `hotshot'
モジュールは特別な使い道のために取っておいてあります。


File: python-lib-jp.info,  Node: インスタント・ユーザ・マニュアル,  Next: Deterministic Profiling,  Prev: Profiler Introduction,  Up: Python プロファイラ

25.2 インスタント・ユーザ・マニュアル
=====================================

この節は "マニュアルなんか読みたくない人"のために書かれています。こ
こではきわめて簡単な概要説明とアプリケーションのプロファイリングを手っ
とり早くおこなう方法だけを解説します。

main エントリにある関数 `foo()' をプロファイルしたいとき、モ
ジュールに次の内容を追加します。

     import cProfile
     cProfile.run('foo()')

(お使いのシステムで `cProfile' が使えないときは代わりに `profile'
を使って下さい)

このように書くことで `foo()' を実行すると同時に一連の情報(プロ
ファイル)が表示されます。この方法はインタプリタ上で作業をしている場合、
最も便利なやり方です。プロファイルの結果をファイルに残し、後で検証した
いときは、`run()' の2番目の引数にファイル名を指定します。

     import cProfile
     cProfile.run('foo()', 'fooprof')

ファイル `cProfile.py' を使って、別のスクリプトをプロファ
イルすることも可能です。次のように実行します。

     python -m cProfile myscript.py

`cProfile.py' はオプションとしてコマンドライン引数を2つ受け取りま す。

     cProfile.py [-o output_file] [-s sort_order]

`-s' は標準出力(つまり、 `-o' が与えられなかった 場合)にのみ有効です。
利用可能なソートの値は、 `Stats' のドキュメントをご覧ください。

プロファイル内容を確認するときは、`pstats' モジュールのメソッド
を使用します。統計データの読み込みは次のようにします。

     import pstats
     p = pstats.Stats('fooprof')

`Stats' クラス(上記コードはこのクラスのインスタンスを生成するだ
けの内容です)は `p' に読み込まれたデータを操作したり、表示するた
めの各種メソッドを備えています。先に `cProfile.run()' を実行し
たとき表示された内容と同じものは、3つのメソッド・コールにより実現でき
ます。

     p.strip_dirs().sort_stats(-1).print_stats()

最初のメソッドはモジュール名からファイル名の前に付いているパス部分を取
り除きます。2番目のメソッドはエントリをモジュール名/行番号/名前にもと
づいてソートします 。3番目のメソッドで全ての統計情報を出力します。
次のようなソート・メソッドも使えます。

     p.sort_stats('name')
     p.print_stats()

最初の行ではリストを関数名でソートしています。2号目で情報を出力してい
ます。さらに次の内容も試してください。

     p.sort_stats('cumulative').print_stats(10)

このようにすると、関数が消費した累計時間でソートされ、さらにその上位10
件だけを表示します。どのアルゴリズムが時間を多く消費しているのか知りた
いときは、この方法が役に立つはずです。

ループで多くの時間を消費している関数はどれか調べたいときは、次のように
します。

     p.sort_stats('time').print_stats(10)

上記は関数の実行で消費した時間でソートされ、上位10個の関数の情報が表示
されます。

次の内容も試してください。

     p.sort_stats('file').print_stats('__init__')

このようにするとファイル名でソートされ、そのうちクラスの初期化メソッド
(メソッド名 `__init__')に関する統計情報だけが表示されます。

     p.sort_stats('time', 'cum').print_stats(.5, 'init')

上記は情報を時間 (time) をプライマリ・キー、累計時間 (cumulative time)
をセカンダリ・キーにしてソートした後でさらに条件を絞って統計情報を出力
します。 `.5' は上位 50% だけの選択を意味し、さらにその中から 文字列
`init' を含むものだけが表示されます。

どの関数がどの関数を呼び出しているのかを知りたければ、次のようにします
(`p' は最後に実行したときの状態でソートされています)。

     p.print_callers(.5, 'init')

このようにすると、各関数ごとの呼出し側関数の一覧が得られます。

さらに詳しい機能を知りたければマニュアルを読むか、次の関数の実行結果
から内容を推察してください。

     p.print_callees()
     p.add('fooprof')

スクリプトとして起動した場合、`pstats' モジュールはプロファイル
のダンプを読み込み、分析するための統計ブラウザとして動きます。シンプル
な行指向のインタフェース(`cmd' を使って実装)とヘルプ機能を
備えています。


File: python-lib-jp.info,  Node: Deterministic Profiling,  Next: リファレンス・マニュアル - profile と cProfile,  Prev: インスタント・ユーザ・マニュアル,  Up: Python プロファイラ

25.3 決定論的プロファイリングとは何か?
======================================

"決定論的プロファイリング"とは、すべての
_関数呼出し_、_関数からのリターン_、_例外発生_をモニターし、正確なタイミングを
記録することで、イベント間の時間、つまりどの時間にユーザ・コードが実行
されているのかを計測するやり方です。もう一方の"統計学的プロファイ
リング"(このモジュールでこの方法は採用していません)とは、有効なインス
トラクション・ポインタからランダムにサンプリングをおこない、プログラム
のどこで時間が使われているかを推定する方法です。後者の方法は、オーバヘッ
ドが少いものの、プログラムのどこで多くの時間が使われているか、その相対
的な示唆に留まります。

Python の場合、実行中必ずインタプリタが動作するため、決定論的プロファ
イリングをおこなうにあたり、計測用のコードは必須ではありません。Python
は自動的に各イベントに"フック"(オプションとしてコールバック)を提供
します。Python インタプリタの特性として、大きなオーバーヘッドを伴う傾
向がありますが、一般的なアプリケーションに決定論的プロファイリングを用
いると、プロセスのオーバーヘッドは少くて済む傾向があります。結果的に決
定論的プロファイリングは少ないコストで、Python プログラムの実行時間に
関する統計を得られる方法となっているのです。

呼出し回数はコード中のバグ発見にも使用できます(とんでもない数の呼出し
がおこなわれている部分)。インライン拡張の対象とすべき部分を見つけるた
めにも使えます(呼出し頻度の高い部分)。内部時間の統計は、注意深く最適化
すべき"ホット・ループ"の発見にも役立ちます。累積時間の統計は、アルゴ
リズム選択に関連した高レベルのエラー検知に役立ちます。なお、このプロファ
イラは再帰的なアルゴリズム実装の累計時間を計ることが可能で、通常のルー
プを使った実装と直接比較することもできるようになっています。


File: python-lib-jp.info,  Node: リファレンス・マニュアル - profile と cProfile,  Next: 制限事項 2,  Prev: Deterministic Profiling,  Up: Python プロファイラ

25.4 リファレンス・マニュアル - `profile' と `cProfile'
=======================================================

Python profiler

プロファイラのプライマリ・エントリ・ポイントはグローバル関数
`profile.run()' (または `cProfile.run()')
です。通常、プロファイル情報の作成に使われま す。情報は `pstats.Stats'
クラスのメソッドを使って整形や出力をお
こないます。以下はすべての標準エントリポイントと関数の解説です。さらに
いくつかのコードの詳細を知りたければ、「プロファイラの拡張」を読んでく
ださい。派生クラスを使ってプロファイラを"改善"する方法やモジュールの
ソースコードの読み方が述べられています。

`run(command[, filename])'
     この関数はオプション引数として `exec' 文に渡すファイル名を指定
     できます。このルーチンは必ず最初の引数の `exec' を試み、実行結
     果からプロファイル情報を収集しようとします。ファイル名が指定されていな
     いときは、各行の標準名(standard
     name)文字列(ファイル名/行数/関数名)で
     ソートされた、簡単なレポートが表示されます。以下はその出力例です。

                2706 function calls (2004 primitive calls) in 4.504 CPU seconds

          Ordered by: standard name

          ncalls  tottime  percall  cumtime  percall filename:lineno(function)
               2    0.006    0.003    0.953    0.477 pobject.py:75(save_objects)
            43/3    0.533    0.012    0.749    0.250 pobject.py:99(evaluate)
           ...

     最初の行は2706回の関数呼出しがあったことを示しています。
     このうち2004回は"プリミティブ"なものです。"プリミティブ" な呼
     び出しとは、再帰によるものではない関数呼出しを指します。次の行
     `Ordered by: standard name' は、一番右側の欄の文字列を使ってソー
     トされたことを意味します。各カラムの見出しの意味は次の通りです。

    `ncalls'
          呼出し回数

    `tottime'
          この関数が消費した時間の合計(サブ関数呼出しの時間は除く)

    `percall'
          `tottime' を `ncalls' で割った値

    `cumtime'
          サブ関数を含む関数の(実行開始から終了までの)消費時間の合計。この項目は
          再帰的な関数においても正確に計測されます。

    `percall'
          `cumtime' をプリミティブな呼び出し回数で割った値

    `filename:lineno(function)'
          その関数のファイル名、行番号、関数名


     (`43/3' など)最初の欄に2つの数字が表示されている場合、最初の値は
     呼出し回数、2番目はプリミティブな呼び出しの回数を表しています。関数が再
     帰していない場合はどちらの回数も同じになるため、1つの数値しか表示され
     ません。

`runctx(command, globals, locals[, filename])'
     この関数は `run()' に似ていますが、COMMAND 文字
     列用にグローバル辞書とローカル辞書の引数を追加しています。

プロファイラ・データの分析は `Stats' クラスを使っておこないます。

_Note:_ `Stats' クラスは `pstats' モジュールで定義されています。

`Stats(filename[, stream=sys.stdout[, ...]])'
     このコンストラクタは FILENAME で指定した(単一または複数の)ファイ
     ルから"統計情報オブジェクト"のインスタンスを生成します。 `Stats'
     オブジェクトはレポートを出力するメソッドを通じて操作しま
     す。また別の出力ストリームをキーワード引数 `stream'
     で指定できます。

     上記コンストラクタで指定するファイルは、使用する `Stats' に対応
     したバージョンの `profile' または `cProfile' で作成され
     たものでなければなりません。
     将来のバージョンのプロファイラとの互換性は_保証されておらず_、
     他のプロファイラとの互換性もないことに注意してください。

     複数のファイルを指定した場合、同一の関数の統計情報はすべて合算され、複
     数のプロセスで構成される全体をひとつのレポートで検証することが可能にな
     ります。既存の `Stats' オブジェクトに別のファイルの情報を追加す
     るときは、`add()' メソッドを使用します。

     _Changed in Python version 2.5_

* Menu:

* Stats クラス::


File: python-lib-jp.info,  Node: Stats クラス,  Prev: リファレンス・マニュアル - profile と cProfile,  Up: リファレンス・マニュアル - profile と cProfile

25.4.1 `Stats' クラス
---------------------

`Stats' には次のメソッドがあります。

`strip_dirs()'
     このメソッドは `Stats' にファイル名の前に付いているすべてのパス
     情報を取り除かせるためのものです。出力の幅を80文字以内に収めたいときに
     重宝します。このメソッドはオブジェクトを変更するため、取り除いたパス情
     報は失われます。パス情報除去の操作後、オブジェクトが保持するデータエント
     リは、オブジェクトの初期化、ロード直後と同じように"ランダムに"並んで
     います。`strip_dirs()' を実行した結果、2つの関数名が区別できな
     い(両者が同じファイルの同じ行番号で同じ関数名となった)場合、一つのエン
     トリに合算されされます。

`add(filename[, ...])'
     `Stats' クラスのこのメソッドは、既存のプロファイリング・オブジェ
     クトに情報を追加します。引数は対応するバージョンの `profile.run()'
     または `cProfile.run()' によって生成
     されたファイルの名前でなくてはな
     りません。関数の名前が区別できない(ファイル名、行番号、関数名が同じ)場
     合、一つの関数の統計情報として合算されます。

`dump_stats(filename)'
     `Stats' オブジェクトに読み込まれたデータを、ファイル名 FILENAME
     のファイルに保存します。ファイルが存在しない場合
     新たに作成され、すでに存在する場合には上書きされます。
     このメソッドは `profile.Profile' クラスおよび `cProfile.Profile'
     クラスの同名のメソッドと等価です。 _Added in Python version 2.3_

`sort_stats(key[, ...])'
     このメソッドは `Stats' オブジェクトを指定した基準に従ってソート
     します。引数には通常ソートのキーにしたい項目を示す文字列を指定します
     (例: `'time'' や`'name'' など)。

     2つ以上のキーが指定された場合、2つ目以降のキーは、それ以前のキーで同等
     となったデータエントリの再ソートに使われます。たとえば
     `sort_stats('name', 'file')' とした場合、まずすべてのエントリが関
     数名でソートされた後、同じ関数名で複数のエントリがあればファイル名でソー
     トされるのです。

     キー名には他のキーと判別可能である限り綴りを省略して名前を指定できます。
     現バージョンで定義されているキー名は以下の通りです。

     正式名                             内容
     ------                             -----
     'calls'                            呼び出し回数
     'cumulative'                       累積時間
     'file'                             ファイル名
     'module'                           モジュール名
     'pcalls'                           プリミティブな呼び出しの回数
     'line'                             行番号
     'name'                             関数名
     'nfl'                              関数名/ファイル名/行番号
     'stdname'                          標準名
     'time'                             内部時間

     すべての統計情報のソート結果は降順(最も多く時間を消費したものが一番上
     に来る)となることに注意してください。ただし、関数名、ファイル名、行数
     に関しては昇順(アルファベット順)になります。`'nfl'' と `'stdname''
     はやや異なる点があります。標準名(standard name)とは表
     示欄の名前なのですが、埋め込まれた行番号の文字コード順でソートされます。
     たとえば、(ファイル名が同じで)3、20、40という行番号のエントリがあった
     場合、20、30、40 の順に表示されます。一方 `'nfl'' は行番号を数値
     として比較します。結果的に、`sort_stats('nfl')' は
     `sort_stats('name', 'file', 'line')' と指定した場合と同じになりま
     す。

     後方互換性のため、数値を引数に使った `-1'、 `0'、 `1'、 `2'
     の形式もサポートしています。 それぞれ
     `'stdname''、`'calls''、`'time''、 `'cumulative''
     として処理されます。引数をこの旧スタイルで指定した場合、
     最初のキー(数値キー)だけが使われ、複数のキーを指定しても2番目以降は無
     視されます。

`reverse_order()'
     `Stats' クラスのこのメソッドは、オブジェクト内の情報のリストを逆
     順にソートします。
     デフォルトでは選択したキーに応じて昇順、降順が適切に選ばれることに注意
     してください。

`print_stats([restriction, ...])'
     `Stats' クラスのこのメソッドは、`profile.run()' の項で 述べた
     プロファイルのレポートを出力します。

     出力するデータの順序はオブジェクトに対し最後におこなった
     `sort_stats()' による操作にもとづいたものになります (`add()' と
     `strip_dirs()' による制限にも支配されます)。

     引数は一覧に大きな制限を加えることになります。初期段階でリストはプロファ
     イルした関数の完全な情報を持っています。制限の指定は(行数を指定する)整
     数、(行のパーセンテージを指定する) 0.0 から 1.0
     までの割合を指定する小 数、(出力する standard name
     にマッチする)正規表現のいずれかを使ってお こないます。正規表現は
     Python 1.5b1 で導入された `re' モジュー ルで使える Perl
     スタイルのものです。複数の制限は指定された場合、それは
     指定の順に適用されます。たとえば次のようになります。

          print_stats(.1, 'foo:')

     上記の場合まず出力するリストは全体の10%に制限され、さらにファイル名の
     一部に文字列 `.*foo:' を持つ関数だけが出力されます。

          print_stats('foo:', .1)

     こちらの例の場合、リストはまずファイル名に `.*foo:' を持つ関数だ
     けに制限され、その中の最初の 10% だけが出力されます。

`print_callers([restriction, ...])'
     `Stats' クラスのこのメソッドは、プロファイルのデータベースの中か
     ら何らかの関数呼び出しをおこなった関数すべてを出力します。出力の順序は
     `print_stats()' によって与えられるものと同じです。出力を制限す
     る引数も同じです。
     各呼出し側関数についてそれぞれ一行ずつ表示されます。
     フォーマットは統計を作り出したプロファイラごとに微妙に異なります。

        * `profile' を使った場合、
          呼出し側関数の後にパーレンで囲まれて表示される数値は
          呼出しが何回おこなわれたかを示すものです。続いてパーレンなしで表示され
          る数値は、便宜上右側の関数が消費した累積時間を繰り返したものです。

        * `cProfile' を使った場合、
          各呼出し側関数は3つの数字の後に来ます。その3つとは、
          呼出しが何回おこなわれたか、
          呼出しの結果現在の関数内で費やされた合計時間および累積時間です。


`print_callees([restriction, ...])'
     `Stats' クラスのこのメソッドは指定した関数から呼出された関数のリ
     ストを出力します。呼出し側、呼出される側の方向は逆ですが、引数と出力の
     順序に関しては `print_callers()' と同じです。


File: python-lib-jp.info,  Node: 制限事項 2,  Next: キャリブレーション補正,  Prev: リファレンス・マニュアル - profile と cProfile,  Up: Python プロファイラ

25.5 制限事項
=============

制限はタイミング情報の正確さに関するものです。決定論的プロファ
イラの正確さに関する根本的問題です。最も明白な制限は、(一般に)"クロッ
ク"は .001 秒の精度しかないということです。これ以上の精度で計測するこ
とはできません。仮に充分な精度が得られたとしても、"エラー"が計測の平
均値に影響を及ぼすことがあります。最初のエラーを取り除いたとしても、そ
れがまた別のエラーを引き起こす原因となります。

もうひとつの問題として、イベントを検知してからプロファイラがその時刻を
実際に_取得_するまでに "いくらかの時間がかかる" ことです。プロ
ファイラが時刻を取得する(そしてその値を保存する)までの間に、ユーザコー
ドがもう一度処理を実行したときにも、同様の遅延が発生します。結果的に多
く呼び出される関数または多数の関数から呼び出される関数の情報にはこの種
のエラーが蓄積する傾向にあります。

この種のエラーによる遅延の蓄積は一般にクロックの精度を越える(1クロック
以下のタイミング)ところで起きていますが、一方でこの時間を累計_可
能_ということが大きな意味を持っています。

この問題はオーバーヘッドの小さい `cProfile' よりも `profile'
においてより重要です。そのため、`profile' はプラットフォー
ムごとに(平均値から)予想されるエラーによる遅延を補正する機能を備えてい
ます。プロファイラに補正を施すと(少くとも形式的には)正確さが増しますが、
ときには数値が負の値になってしまうこともあります(呼出し回数が少く、確
率の神があなたに意地悪をしたとき :-) )。プロファイルの結果に負の値が出
力されても_驚かないでください_。これは補正をおこなった場合にのみ
現れることで、実際の計測結果は補正をおこなわない場合より、より正確なは
ずだからです。


File: python-lib-jp.info,  Node: キャリブレーション補正,  Next: Profiler Extensions,  Prev: 制限事項 2,  Up: Python プロファイラ

25.6 キャリブレーション(補正)
=============================

`profile' のプロファイラは time 関数呼出しおよびその値を保存する
ためのオーバーヘッドを補正するために、各イベントハンドリング時間から定
数を引きます。デフォルトでこの定数の値は 0 です。以下の手順で、プラット
フォームに合った、より適切な定数が得られます(前節「制限事項」の説明を参
照)。

     import profile
     pr = profile.Profile()
     for i in range(5):
         print pr.calibrate(10000)

メソッドは引数として与えられた数だけ Python の呼出しをおこないます。呼
出しは直接、プロファイラを使って呼出しの両方が実施され、それぞれの時間
が計測されます。その結果、プロファイラのイベントに隠されたオーバーヘッ
ドが計算され、その値は浮動小数として返されます。たとえば、800 MHz の
Pentium で Windows 2000 を使用、Python の time.clock() をタイマとして
使った場合、値はおよそ 12.5e-6 となります。

この手順で使用しているオブジェクトはほぼ一定の結果を返します。_非
常に_早いコンピュータを使う場合、もしくはタイマの性能が貧弱な場合は一
定の結果を得るために引数に 100000 や 1000000 といった大きな値を指定す
る必要があるかもしれません。

一定の結果が得られたら、それを使う方法には3通りあります。(1)

     import profile

     # 1. 算出した補正値 (your_computed_bias) をこれ以降生成する
     #    Profile インスタンスに適用する。
     profile.Profile.bias = your_computed_bias

     # 2. 特定の Profile インスタンスに補正値を適用する。
     pr = profile.Profile()
     pr.bias = your_computed_bias

     # 3. インスタンスのコンストラクタに補正値を指定する。
     pr = profile.Profile(bias=your_computed_bias)

方法を選択したら、補正値は小さめに設定した方が良いでしょう。プロファイ
ルの結果に負の値が表われる"確率が少なく"なるはずです。

---------- Footnotes ----------

(1)  Python 2.2
より前のバージョンではプロファイラのソースコードに補正値と
して埋め込まれた定数を直接編集する必要がありました。今でも同じことは可
能ですが、その方法は説明しません。なぜなら、もうソースを編集する必要が
ないからです。


File: python-lib-jp.info,  Node: Profiler Extensions,  Next: hotshot,  Prev: キャリブレーション補正,  Up: Python プロファイラ

25.7 プロファイラの改善
=======================

`profile' モジュールおよび `cProfile' モジュールの `Profile'
クラスはプロファイラの機
能を拡張するため、派生クラスの作成を前提に書かれています。しかしその方
法を説明するには、`Profile' の内部動作について詳細な解説が必要と
なるため、ここでは述べません。もし拡張をおこないたいのであれば、
使用するモジュールのソースを注意深く読む必要があります。

プロファイラが時刻を取得する方法を変更したいだけなら(たとえば、通常の
時間(wall-clock)を使いたいとか、プロセスの経過時間を使いたい場合)、時
刻取得用の関数を `Profile' クラスのコンストラクタに指定すること
ができます。

     pr = profile.Profile(your_time_func)

この結果生成されるプロファイラは時刻取得に `your_time_func()' を
呼び出すようになります。

``profile.Profile''
     `your_time_func()' は単一の数値、あるいは その合計が(`os.times()'
     と同じように)累計時間を示すリストを返
     すようになっていなければなりません。関数が1つの数値、あるいは長さ2の数
     値のリストを返すようになっていれば、非常に高速に処理が可能になります。

     選択する時刻取得関数によって、プロファイラクラスを補正する必要があるこ
     とに注意してください。多くのマシンにおいて、プロファイル時のオーバヘッ
     ドを少なくする方法として、タイマはロング整数を返すのが最善です。
     `os.times()' は浮動小数のタプルを返すので _おすすめできま
     せん_)。タイマをより正確なものに置き換えたいならば、派生クラスでそのディ
     スパッチ・メソッドを適切なタイマ呼出しと適切な補正をおこなうように書き
     直す必要があります。

``cProfile.Profile''
     `your_time_func()' は単一の数値を返さなければなりません。
     もしこれが整数を返す関数ならば、2番目の引数に時間単位当たりの実際の持続
     時間を指定してクラスのコンスタラクタを呼び出すことができます。
     たとえば、`your_integer_time_func()' が1000分の1秒単位で計測し
     た時間を返すとすると、`Profile' インスタンスを次のように生成するこ
     とができます。

          pr = profile.Profile(your_integer_time_func, 0.001)

     `cProfile.Profile' クラスはキャリブレーションができないので、
     自前のタイマ関数は注意を払って使う必要があり、またそれは可能な限り
     速くなければなりません。自前のタイマ関数で最高の結果を得るには、
     `_lsprof' 内部モジュールの C ソースファイルにハードコードする
     必要があるかもしれません。



File: python-lib-jp.info,  Node: hotshot,  Next: timeit,  Prev: Profiler Extensions,  Up: Python プロファイラ

25.8 ハイパフォーマンス・ロギング・プロファイラ
===============================================

コードの大半が C で書かれたハイパフォーマンス・ロギン グ・プロファイラ

_Added in Python version 2.2_

このモジュールは `_hotshot' C モジュールへのより良いインターフェー
スを提供します。Hotshot は既存の `profile' に置き換わるもの
です。その大半が C で書かれているため、`profile' に比べパフォー
マンス上の影響がはるかに少なく済みます。

_Notice:_ [注意] `hotshot' は C
モジュールでプロファイル中のオーバーヘッドを
極力小さくすることに焦点を絞っており、その代わりに後処理時間の長さという
つけを払います。通常の使用法についてはこのモジュールではなく `cProfile'
を使うことを推奨します。`hotshot' は保守され
ておらず、将来的には標準ライブラリから外されるかもしれません。

_Changed in Python version 2.5_

_Notice:_ [注意]
`hotshot'プロファイラはまだスレッド環境ではうまく動作しません。
測定したいコード上でプロファイラを実行するためにスレッドを使わない版の
スクリプトを使う方法が有用です。

`Profile(logfile[, lineevents[, linetimings]])'
     プロファイラ・オブジェクト。引数 LOGFILE はプロファイル・データ
     のログを保存するファイル名です。引数 LINEEVENTS はソースコー ドの1
     行ごとにイベントを発生させるか、関数の呼び出し/リターンのときだ
     け発生させるかを指定します。デフォルトの値は `0' (関数の呼び出し/
     リターンのときだけログを残す)です。引数 LINETIMINGS は時間情報を
     記録するかどうかを指定します。デフォルトの値は `1' (時間情報を記
     録する)です。


* Menu:

* プロファイル・オブジェクト::
* hotshot データの利用::
* 使用例 8::


File: python-lib-jp.info,  Node: プロファイル・オブジェクト,  Next: hotshot データの利用,  Prev: hotshot,  Up: hotshot

25.8.1 プロファイル・オブジェクト
---------------------------------

プロファイル・オブジェクトは以下のメソッドを持っています。

`addinfo(key, value)'
     プロファイル出力の際、任意のラベル名を追加します。

`close()'
     ログファイルを閉じ、プロファイラを終了します。

`fileno()'
     プロファイラのログファイルのファイル・ディスクリプタを返します。

`run(cmd)'
     スクリプト環境で `exec' 互換文字列のプロファイルをおこないます。
     `__main__' モジュールのグローバル変数は、スクリプトの
     グローバル変数、ローカル変数の両方に使われます。

`runcall(func, *args, **keywords)'
     単一の呼び出し可能オブジェクトのプロファイルをおこないます。位置依存引
     数やキーワード引数を追加して呼び出すオブジェクトに渡すこともできます。
     呼び出しの結果はそのまま返されます。例外が発生したときはプロファイリン
     グが無効になり、例外をそのまま伝えるようになっています。

`runctx(cmd, globals, locals)'
     指定した環境で `exec' 互換文字列の評価をおこないます。文字列の
     コンパイルはプロファイルを開始する前におこなわれます。

`start()'
     プロファイラを開始します。

`stop()'
     プロファイラを停止します。


File: python-lib-jp.info,  Node: hotshot データの利用,  Next: 使用例 8,  Prev: プロファイル・オブジェクト,  Up: hotshot

25.8.2 hotshot データの利用
---------------------------

Hotshot の統計分析

_Added in Python version 2.2_

このモジュールは hotshot プロファイル・データを標準の `pstats'
オブジェクトにロードします。

`load(filename)'
     FILENAME から hotshot データを読み込み、`pstats.Stats' ク
     ラスのインスタンスを返します。

See also:
     *Note リファレンス・マニュアル - profile と cProfile:: `profile'
     モジュールの `Stats' クラス


File: python-lib-jp.info,  Node: 使用例 8,  Prev: hotshot データの利用,  Up: hotshot

25.8.3 使用例
-------------

これは Python の"ベンチマーク" pystone を使った例です。実行にはやや
時間がかかり、巨大な出力ファイルを生成するので注意してください。

     >>> import hotshot, hotshot.stats, test.pystone
     >>> prof = hotshot.Profile("stones.prof")
     >>> benchtime, stones = prof.runcall(test.pystone.pystones)
     >>> prof.close()
     >>> stats = hotshot.stats.load("stones.prof")
     >>> stats.strip_dirs()
     >>> stats.sort_stats('time', 'calls')
     >>> stats.print_stats(20)
              850004 function calls in 10.090 CPU seconds

        Ordered by: internal time, call count

        ncalls  tottime  percall  cumtime  percall filename:lineno(function)
             1    3.295    3.295   10.090   10.090 pystone.py:79(Proc0)
        150000    1.315    0.000    1.315    0.000 pystone.py:203(Proc7)
         50000    1.313    0.000    1.463    0.000 pystone.py:229(Func2)
      .
      .
      .


File: python-lib-jp.info,  Node: timeit,  Next: trace,  Prev: hotshot,  Up: Python プロファイラ

25.9 小さなコード断片の実行時間計測
===================================

小さなコード断片の実行時間計測。

_Added in Python version 2.3_ 

このモジュールは Python の小さなコード断片の時間を簡単に計測する手段を
提供します。インターフェースはコマンドラインとメソッドとして呼び出し可
能なものの両方を備えています。また、このモジュールは実行時間の計測にあ
たり陥りがちな落し穴に対する様々な対策が取られています。詳しくは、
O'Reilly の 、"Algorithms" の章にある Tim Peters
が書いた解説を参照してください。

このモジュールには次のパブリック・クラスが定義されています。

`Timer([stmt=`'pass'' [, setup=`'pass'' [, timer=<timer function>]]])'
     小さなコード断片の実行時間計測をおこなうためのクラスです。

     コンストラクタは引数として、時間計測の対象となる文、セットアップに使用
     する追加の文、タイマ関数を受け取ります。文のデフォルト値は両方とも
     `'pass'' で、タイマ関数はプラットフォーム依存(モジュールの doc
     string
     を参照)です。文には複数行の文字列リテラルを含まない限り、改行を
     入れることも可能です。

     最初の文の実行時間を計測には `timeit()' メソッドを使用します。
     また `timeit()' を複数回呼び出し、その結果のリストを返す
     `repeat()' メソッドも用意されています。

`print_exc([file=`None'])'
     計測対象コードのトレースバックを出力するためのヘルパー。

     利用例:

              t = Timer(...)       # try/except の外側で
              try:
                  t.timeit(...)    # または t.repeat(...)
              except:
                  t.print_exc()

     標準のトレースバックより優れた点は、コンパイルしたテンプレートのソース
     行が表示されることです。オプションの引数 FILE にはトレースバック
     の出力先を指定します。デフォルトは `sys.stderr' になっています。

`repeat([repeat`=3' [, number`=1000000']])'
     `timeit()' を複数回呼び出します。

     このメソッドは `timeit()' を複数回呼び出し、その結果をリストで
     返すユーティリティ関数です。最初の引数には `timeit()' を呼び出
     す回数を指定します。2番目の引数は `timeit()' へ引数として渡す
     数値です。

     _Notice:_

     結果のベクトルから平均値や標準偏差を計算して出力させたいと思うかもしれ
     ませんが、それはあまり意味がありません。多くの場合、最も低い値がそのマ
     シンが与えられたコード断片を実行する場合の下限値です。結果のうち高めの
     値は、Python
     のスピードが一定しないために生じたものではなく、時刻取得
     の際他のプロセスと衝突がおこったため、正確さが損なわれた結果生じたもの
     です。したがって、結果のうち `min()' だけが見るべき値となりま
     す。この点を押さえた上で、統計的な分析よりも常識的な判断で結果を見るよ
     うにしてください。


`timeit([number`=1000000'])'
     メイン文の実行時間を NUMBER 回取得します。このメソッドはセットアッ
     プ文を1回だけ実行し、メイン文を指定回数実行するのにかかった秒数を浮動
     小数で返します。引数はループを何回実行するかの指定で、デフォルト値は
     100万回です。メイン文、セットアップ文、タイマ関数はコンストラクタで指
     定されたものを使用します。

     _Notice:_ デフォルトでは、 `timeit()'
     は時間計測中、一時的にガーベッジコレ クションを切ります。
     このアプローチの利点は、個別の測定結果を比較しやすくなることです。
     不利な点は、GC
     が測定している関数のパフォーマンスの重要な一部かもしれな
     いということです。 そうした場合、SETUP 文字列の最初の文で GC
     を再度有効にすることがで きます。 例えば :
              timeit.Timer('for i in xrange(10): oct(i)', 'gc.enable()').timeit()


* Menu:

* コマンドライン・インターフェース::
* 使用例 9::


File: python-lib-jp.info,  Node: コマンドライン・インターフェース,  Next: 使用例 9,  Prev: timeit,  Up: timeit

25.9.1 コマンドライン・インターフェース
---------------------------------------

コマンドラインからプログラムとして呼び出す場合は、次の書式を使います。

     python timeit.py [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement ...]

以下のオプションが使用できます。

`-n N/`--number'=N'
     'statement' を何回実行するか

`-r N/`--repeat'=N'
     タイマを何回リピートするか(デフォルトは 3)

`-s S/`--setup'=S'
     最初に1回だけ実行する文 (デフォルトは `'pass'')

`-t/`--time''
     `time.time()' を使用する (Windows
     を除くすべてのプラットフォームのデフォルト)

`-c/`--clock''
     `time.clock()' を使用する(Windows のデフォルト)

`-v/`--verbose''
     時間計測の結果をそのまま詳細な数値でくり返し表示する

`-h/`--help''
     簡単な使い方を表示して終了する

文は複数行指定することもできます。その場合、各行は独立した文として引数
に指定されたものとして処理します。クォートと行頭のスペースを使って、イ
ンデントした文を使うことも可能です。この複数行のオプションは `-s'
においても同じ形式で指定可能です。

オプション `-n' でループの回数が指定されていない場合、10回
から始めて、所要時間が 0.2 秒になるまで回数を増やすことで適切なループ
回数が自動計算されるようになっています。

デフォルトのタイマ関数はプラットフォーム依存です。Windows の場合、
`time.clock()' はマイクロ秒の精度がありますが、 `time.time()' は 1/60
秒の精度しかありません。一方 UNIXの場 合、`time.clock()' でも 1/100
秒の精度があり、 `time.time()'
はもっと正確です。いずれのプラットフォームにお
いても、デフォルトのタイマ関数は CPU 時間ではなく通常の時間を返します。
つまり、同じコンピュータ上で別のプロセスが動いている場合、タイミングの
衝突する可能性があるということです。正確な時間を割り出すために最善の方
法は、時間の取得を数回くり返しその中の最短の時間を採用することです。
`-r' オプションはこれをおこなうもので、デフォルトのくり返し
回数は3回になっています。多くの場合はデフォルトのままで充分でしょう。
UNIXの場合 `time.clock()' を使って CPU 時間で測定することも できます。

_Notice:_ pass
文の実行による基本的なオーバーヘッドが存在することに注意してく
ださい。ここにあるコードはこの事実を隠そうとはしておらず、注意を払う
必要があります。基本的なオーバーヘッドは引数なしでプログラムを起動す
ることにより計測できます。

基本的なオーバヘッドは Python のバージョンによって異なります。Python
2.3 とそれ以前の Python の公平な比較をおこなう場合、古い方の Python は
`-O' オプションで起動し `SET_LINENO' 命令の実行時間が
含まれないようにする必要があります。


File: python-lib-jp.info,  Node: 使用例 9,  Prev: コマンドライン・インターフェース,  Up: timeit

25.9.2 使用例
-------------

以下に2つの使用例を記載します(ひとつはコマンドライン・インターフェース
によるもの、もうひとつはモジュール・インターフェースによるものです)。
内容はオブジェクトの属性の有無を調べるのに `hasattr()' を使っ た場合と
`try'/`except' を使った場合の比較です。

     % timeit.py 'try:' '  str.__nonzero__' 'except AttributeError:' '  pass'
     100000 loops, best of 3: 15.7 usec per loop
     % timeit.py 'if hasattr(str, "__nonzero__"): pass'
     100000 loops, best of 3: 4.26 usec per loop
     % timeit.py 'try:' '  int.__nonzero__' 'except AttributeError:' '  pass'
     1000000 loops, best of 3: 1.43 usec per loop
     % timeit.py 'if hasattr(int, "__nonzero__"): pass'
     100000 loops, best of 3: 2.23 usec per loop

     >>> import timeit
     >>> s = """\
     ... try:
     ...     str.__nonzero__
     ... except AttributeError:
     ...     pass
     ... """
     >>> t = timeit.Timer(stmt=s)
     >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
     17.09 usec/pass
     >>> s = """\
     ... if hasattr(str, '__nonzero__'): pass
     ... """
     >>> t = timeit.Timer(stmt=s)
     >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
     4.85 usec/pass
     >>> s = """\
     ... try:
     ...     int.__nonzero__
     ... except AttributeError:
     ...     pass
     ... """
     >>> t = timeit.Timer(stmt=s)
     >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
     1.97 usec/pass
     >>> s = """\
     ... if hasattr(int, '__nonzero__'): pass
     ... """
     >>> t = timeit.Timer(stmt=s)
     >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
     3.15 usec/pass

定義した関数に `timeit' モジュールがアクセスできるように
するために、import 文の入った `setup' 引数を渡すことができます:

     def test():
         "Stupid test function"
         L = []
         for i in range(100):
             L.append(i)

     if __name__=='__main__':
         from timeit import Timer
         t = Timer("test()", "from __main__ import test")
         print t.timeit()

-- Python-Docs-2.4/./lib/libtrace.tex	1970-01-01 09:00:00.000000000 +0900
+++ Python-Docs-2.5/./lib/libtrace.tex	2006-05-03 11:04:40.000000000
+0900 @@ -0,1 +1,1 @@


File: python-lib-jp.info,  Node: trace,  Prev: timeit,  Up: Python プロファイラ

25.10 Python ステートメント実行のトレースと追跡
===============================================

Python ステートメント実行のトレースと追跡

`trace' モジュールはプログラム実行のトレースを可能にし, generate
ステートメントのカバレッジリストを注釈付きで生成して、呼び出し元/呼び出し先の
関連やプログラム実行中に実行された関数のリストを出力します。これは別個の
プログラム中またはコマンドラインから利用することができます。

* Menu:

* コマンドラインからの利用::
* プログラミングインターフェース::


File: python-lib-jp.info,  Node: コマンドラインからの利用,  Next: プログラミングインターフェース,  Prev: trace,  Up: trace

25.10.1 コマンドラインからの利用
--------------------------------

`trace'
モジュールはコマンドラインから起動することができます。これは次のように単純です。

     python -m trace --count somefile.py ...

これで、`somefile.py' の実行中に import された Python
モジュールの注釈付きリストが生成されます。

以下のコマンドライン引数がサポートされています：

``--trace', `-t''
     実行されるままに行を表示します。

``--count', `-c''
     プログラム完了時に、それぞれのステートメントが何回実行されたかを示す
     注釈付きリストのファイルを生成します。

``--report', `-r''
     `--count' と `--file' 引数を使った、過去の
     プログラム実行結果から注釈付きリストのファイルを生成します。

``--no-report', `-R''
     注釈付きリストを生成しません。これは `--count' を何度か走らせてから
     最後に単一の注釈付きリストを生成するような場合に便利です。

``--listfuncs', `-l''
     プログラム実行の際に実行された関数を列挙します。

``--trackcalls', `-T''
     プログラム実行によって明らかになった呼び出しの関連を生成します。

``--file', `-f''
     カウント(count) を含む（べき）ファイルに名前をつけます。

``--coverdir', `-C''
     中に注釈付きリストのファイルを保存するディレクトリを指定します。

``--missing', `-m''
     注釈付きリストの生成時に、実行されなかった行に ``>>>>>>''
     の印を付けます。

``--summary', `-s''
     `--count' または `--report' の利用時に、
     処理されたファイルそれぞれの簡潔なサマリを標準出力(stdout)に書き出します。

``--ignore-module''
     指定されたモジュールとそのサブモジュールを（パッケージだった場合に）無視します。
     複数回指定できます。

``--ignore-dir''
     指定されたディレクトリとサブディレクトリ中のモジュールとパッケージを
     全て無視します。複数回指定できます。


File: python-lib-jp.info,  Node: プログラミングインターフェース,  Prev: コマンドラインからの利用,  Up: trace

25.10.2 プログラミングインターフェース
--------------------------------------

`Trace([count=1[, trace=1[, countfuncs=0[, countcallers=0[, ignoremods=()[, ignoredirs=()[, infile=None[, outfile=None]]]]]]]])'
     文(statement)や式(expression)の実行をトレースするオブジェクトを作成します。
     全てのパラメタがオプションです。COUNT は行数を数えます。 TRACE
     は行実行のトレースを行います。COUNTFUNCS は実行中に
     呼ばれた関数を列挙します。COUNTCALLERS は呼び出しの関連の追跡を
     行います。IGNOREMODS は無視するモジュールやパッケージのリストです。
     IGNOREDIRS
     は無視するパッケージやモジュールを含むディレクトリのリストです。
     INFILE は保存された集計(count)情報を読むファイルです。OUTFILE は
     更新された集計(count)情報を書き出すファイルです。

`run(cmd)'
     CMD を、Trace オブジェクトのコントロール下で
     現在のトレースパラメタのもとに実行します。

`runctx(cmd[, globals=None[, locals=None]])'
     CMD を、Trace オブジェクトのコントロール下で
     現在のトレースパラメタのもと、定義されたグローバルおよびローカル環境で
     実行します。定義しない場合、GLOBALS と LOCALS はデフォルトで
     空の辞書となります。

`runfunc(func, *args, **kwds)'
     与えられた引数の FUNC を、Trace オブジェクトのコントロール下で
     現在のトレースパラメタのもとに呼び出します。

これはこのモジュールの使い方を示す簡単な例です：

     import sys
     import trace

     # Trace オブジェクトを、無視するもの、トレースや行カウントのいずれか
     # または両方を行うか否かを指定して作成します。
     tracer = trace.Trace(
         ignoredirs=[sys.prefix, sys.exec_prefix],
         trace=0,
         count=1)

     # 与えられたトレーサを使って、コマンドを実行します。
     tracer.run('main()')

     # 出力先を /tmp としてレポートを作成します。
     r = tracer.results()
     r.write_results(show_missing=True, coverdir="/tmp")


File: python-lib-jp.info,  Node: Python ランタイム サービス,  Next: カスタム Python インタプリタ,  Prev: Python プロファイラ,  Up: Top

26 Python ランタイム サービス
*****************************

この章では、PythonインタープリタやPython環境に深く関連する各種の機能を解説します。以下に一覧を示します:

* Menu:

* sys::
* __builtin__::
* __main__::
* warnings::
* contextlib::
* atexit::
* traceback::
* __future__::
* gc::
* inspect::
* site::
* user::
* fpectl::


File: python-lib-jp.info,  Node: sys,  Next: __builtin__,  Prev: Python ランタイム サービス,  Up: Python ランタイム サービス

26.1 システムパラメータと関数
=============================

システムパラメータと関数へのアクセス

このモジュールでは、インタープリタで使用・管理している変数や、インタープ
リタの動作に深く関連する関数を定義しています。このモジュールは常に利用可能で
す。

`argv'
     Pythonスクリプトに渡されたコマンドライン引数のリスト。`argv[0]'は
     スクリプトの名前となりますが、フルパス名かどうかは、オペレーティングシ
     ステムによって異なります。コマンドライン引数に`-c'を付けて
     Pythonを起動した場合、`argv[0]'は文字列`'-c''となります。引
     数なしでPythonを起動した場合、`argv'は長さ0のリストになります。

`byteorder'
     プラットフォームのバイト順を示します。ビッグエンディアン(最上位バ
     イトが先頭)のプラットフォームでは`'big''、リトルエンディアン(最下
     位バイトが先頭)では`'little''となります。 _Added in Python version
     2.0_

`subversion'
     3つ組 (repo, branch, version) で Python インタプリタの Subversion
     情報を表します。 REPO はリポジトリの名前で、`'CPython''。 BRANCH
     は `'trunk''、`'branches/name'' または `'tags/name''
     のいずれかの形式の文字列です。 VERSION はもしインタプリタが
     Subversion のチェックアウトから ビルドされたものならば
     `svnversion' の出力であり、 リビジョン番号 (範囲)
     とローカルでの変更がある場合には最後に 'M' が付きます。
     ツリーがエクスポートされたもの (または svnversion が取得できない)
     で、 branch がタグならば `Include/patchlevel.h'
     のリビジョンになります。 それ以外の場合には `None' です。 _Added
     in Python version 2.5_

`builtin_module_names'
     コンパイル時にPythonインタープリタに組み込まれた、全てのモジュール名の
     タプル(この情報は、他の手段では取得することができません。
     `modules.keys()'は、インポートされたモジュールのみのリストを返し
     ます。)

`copyright'
     Pythonインタープリタの著作権を表示する文字列。

`_current_frames()'
     各スレッドの識別子を関数が呼ばれた時点のそのスレッドでアクティブになっ
     ている一番上のスタックフレームに結びつける辞書を返します。モジュー
     ル `traceback' の関数を使えばそのように与えられたフレームの
     コールスタックを構築できます。

     この関数はデッドロックをデバッグするのに非常に有効です。デッドロック
     状態のスレッドの協調動作を必要としませんし、そういったスレッドのコー
     ルスタックはデッドロックである限り凍り付いたままです。デッドロックに
     ないスレッドのフレームについては、そのフレームを調べるコードを呼んだ
     時にはそのスレッドの現在の実行状況とは関係ないところを指し示している
     かもしれません。

     この関数は外部に見せない特別な目的でのみ使われるべきです。 _Added
     in Python version 2.5_

`dllhandle'
     Python DLLのハンドルを示す整数。 利用可能: Windows

`displayhook(VALUE)'
     VALUEが`None'以外の場合、`value'を`sys.stdout'に
     出力して`__builtin__._'に保存します。

     `sys.displayhook'は、Pythonの対話セッションで入力された式が評価さ
     れたときに呼び出されます。対話セッションの出力をカスタマイズする場合、
     `sys.displayhook'に引数の数が一つの関数を指定します。

`excepthook(TYPE, VALUE, TRACEBACK)'
     指定したトレースバックと例外を`sys.stderr'に出力します。

     例外が発生し、その例外が捕捉されない場合、インタープリタは例外クラス・
     例外インスタンス・トレースバックオブジェクトを引数として
     `sys.excepthook'を呼び出します。対話セッション中に発生した場合は
     プロンプトに戻る直前に呼び出され、Pythonプログラムの実行中に発生した場合
     はプログラムの終了直前に呼び出されます。このトップレベルでの例外情報出
     力処理をカスタマイズする場合、`sys.excepthook'に引数の数が三つの
     関数を指定します。

`__displayhook__'

`__excepthook__'
     それぞれ、起動時の`displayhook'と`excepthook'の値を保存して
     います。この値は、`displayhook'と`excepthook'に不正なオブジ
     ェクトが指定された場合に、元の値に復旧するために使用します。

`exc_info()'
     この関数は、現在処理中の例外を示す三つの値のタプルを返します。この値
     は、現在のスレッド・現在のスタックフレームのものです。現在のスタックフ
     レームが例外処理中でない場合、例外処理中のスタックフレームが見つかるま
     で次々とその呼び出し元スタックフレームを調べます。ここで、"例外処理中
     "とは"except節を実行中、または実行した"フレームを指します。どのスタ
     ックフレームでも、最後に処理した例外の情報のみを参照することができま
     す。

     スタック上で例外が発生していない場合、三つの`None'のタプルを返し
     ます。例外が発生している場合、`(TYPE, VALUE,
     TRACEBACK)'を返します。TYPEは、処理中の例外の型を示します
     (クラスオブジェクト)。VALUEは、例外パラメータ
     (例外に"関連する値"または`raise'の第二引数。TYPEが
     クラスオブジェクトの場合は常にクラスインスタンス)です。TRACEBACK
     は、トレースバックオブジェクトで、例外が発生した時点でのコールスタック
     をカプセル化したオブジェクトです(リファレンスマニュアル参照)。 

     `exc_clear()'が呼び出されると、現在のスレッドで他の例外が発生するか、
     又は別の例外を処理中のフレームに実行スタックが復帰するまで、
     `exc_info()'は三つの`None'を返します。

     _例外処理中に戻り値のTRACEBACKをローカル変数に代入すると
     循環参照が発生し、関数内のローカル変数やトレースバックが参照している全
     てのオブジェクトは解放されなくなります。特にトレースバック情報が必要で
     はなければ`exctype, value = sys.exc_info()[:2]'のように例外型と例
     外オブジェクトのみを取得するようにして下さい。もしトレースバックが必要
     な場合には、処理終了後にdeleteして下さい。このdeleteは、`try' ...
     `finally' ...で行うと良いでしょう。_ _Note:_ Python 2.2
     以降では、ガベージコレクションが有効であればこのような
     到達不能オブジェクトは自動的に削除されます。しかし、循環参照を作らない
     ようにしたほうが効率的です。

`exc_clear()'
     この関数は、現在のスレッドで処理中、又は最後に発生した例外の情報を全てクリア
     します。この関数を呼び出すと、現在のスレッドで他の例外が発生するか、
     又は別の例外を処理中のフレームに実行スタックが復帰するまで、
     `exc_info()'は三つの`None'を返します。

     この関数が必要となることは滅多にありません。ロギングやエラー処理などで最後に
     発生したエラーの報告を行う場合などに使用します。また、リソースを解放して
     オブジェクトの終了処理を起動するために使用することもできますが、オブジェクト
     が実際にされるかどうかは保障の限りではありません。 _Added in
     Python version 2.3_

`exc_type'

`exc_value'

`exc_traceback'
     _This is deprecated in Python 1.5.  `exc_info()'を使用してください_

     これらの変数はグローバル変数なのでスレッド毎の情報を示すことができませ
     ん。この為、マルチスレッドなプログラムでは安全に参照することはできませ
     ん。例外処理中でない場合、`exc_type'の値は`None'となり、
     `exc_value'と`exc_traceback'は未定義となります。

`exec_prefix'
     Pythonのプラットフォーム依存なファイルがインストールされているディレク
     トリ名(サイト固有)。デフォルトでは、この値は`'/usr/local''です
     が、ビルド時に`configure'の`--exec-prefix'引数で
     指定することができます。全ての設定ファイル(`pyconfig.h'など)は
     `exec_prefix + '/lib/pythonVERSION/config''に、共有ライブラ
     リは`exec_prefix + '/lib/pythonVERSION/lib-dynload''にイン
     ストールされます(但しVERSIONは`version[:3]')。


`executable'
     Pythonインタープリタの実行ファイルの名前を示す文字列。このような名前が
     意味を持つシステムでは利用可能。

`exit([arg])'
     Pythonを終了します。`exit()'は`SystemExit'を送出す
     るので、`try'ステートメントの`finally'節に終了処理を記
     述したり、上位レベルで例外を捕捉してexit処理を中断したりすることができ
     ます。オプション引数ARGには、終了ステータスとして整数(デフォルト
     は0）または整数以外の型のオブジェクトを指定することができます。整数を
     指定した場合、シェル等は0は"正常終了"、0以外の整数を"異常終了"とし
     て扱います。多くのシステムでは、有効な終了ステータスは0-127で、これ以
     外の値を返した場合の動作は未定義です。システムによっては特定の終了コー
     ドに個別の意味を持たせている場合がありますが、このような定義は僅かしか
     ありません。UNIXプログラムでは文法エラーの場合には2を、それ以外のエ
     ラーならば1を返します。ARGにNONEを指定した場合は、数値の0
     を指定した場合と同じです。それ以外のオブジェクトを指定すると、そのオブ
     ジェクトが`sys.stderr'に出力され、終了コードをして1を返します。エ
     ラー発生時には`sys.exit("エラーメッセージ")'と書くと、簡単にプロ
     グラムを終了することができます。

`exitfunc'
     この値はモジュールに存在しませんが、ユーザプログラムでプログラム終了時
     に呼び出される終了処理関数として、引数の数が0の関数を設定することがで
     きます。この関数は、インタープリタ終了時に呼び出されます。
     `exitfunc'に指定することができる終了処理関数は一つだけですので、
     複数のクリーンアップ処理が必要な場合は`atexit'モジュールを使
     用してください。 _Note:_
     プログラムがシグナルでkillされた場合，Python内部で致命的なエラーが
     発生した場合，`os._exit()'が呼び出された場合には，
     終了処理関数は呼び出されません。 _This is deprecated in Python
     2.4.  `atexit' を使ってください．_


`getcheckinterval()'
     インタプリタの "チェックインターバル (check interval)" を
     返します; `setcheckinterval()' を参照してください。 _Added in
     Python version 2.3_

`getdefaultencoding()'
     現在のUnicode処理のデフォルトエンコーディング名を返します。 _Added
     in Python version 2.0_

`getdlopenflags()'
     `dlopen()'で指定されるフラグを返します。このフラグは
     `dl'と`DLFCN'で定義されています。

     利用可能: UNIX.  _Added in Python version 2.2_

`getfilesystemencoding()'
     Unicodeファイル名をシステムのファイル名に変換する際に使用する
     エンコード名を返します。システムのデフォルトエンコーディングを使用する
     場合には`None'を返します。
        * Windows 9xでは、エンコーディングは "mbcs" となります。

        * OS Xでは、エンコーディングは "utf-8" となります。

        * UNIXでは、エンコーディングは`nl_langinfo(CODESET)'が返す
          ユーザの設定となります。
          `nl_langinfo(CODESET)'が失敗すると`None'を返します。

        * Windows NT+では、Unicodeをファイル名として使用できるので
          変換の必要はありません。`getfilesystemencoding()' は `'mbcs''
          を返しますが、これはある Unicode
          文字列をバイト文字列に明示的に変換
          して、ファイル名として使うと同じファイルを指すようにしたい場合に、
          アプリケーションが使わねばならないエンコーディングです。

     _Added in Python version 2.3_

`getrefcount(object)'
     OBJECTの参照数を返します。OBJECTは(一時的に)
     `getrefcount()'からも参照されるため、参照数は予想される数
     よりも1多くなります。

`getrecursionlimit()'
     現在の最大再帰数を返します。最大再帰数は、Pythonインタープリタスタック
     の最大の深さです。この制限はPythonプログラムが無限に再帰し、Cスタック
     がオーバーフローしてクラッシュすることを防止するために設けられていま
     す。この値は`setrecursionlimit()'で指定することができます。

`_getframe([depth])'
     コールスタックからフレームオブジェクトを取得します。オプション引数
     DEPTHを指定すると、スタックのトップからDEPTHだけ下のフレー
     ムオブジェクトを取得します。DEPTHがコールスタックよりも深けれ
     ば、`ValueError'が発生します。DEPTHのデフォルト値は0
     で、この場合はコールスタックのトップのフレームを返します。

     この関数は、内部的な、特殊な用途にのみ利用することができます。

`getwindowsversion()'
     実行中のWindowsのバージョンを示す、以下の値のタプルを返します：
     MAJOR, MINOR, BUILD, PLATFORM, TEXT。
     TEXTは文字列、それ以外の値は整数です。

     PLATFORMは、以下の値となります:
     Constant                           Platform
     ------                             -----
     0 (VER_PLATFORM_WIN32s)            Win32s on Windows 3.1
     1 (VER_PLATFORM_WIN32_WINDOWS)     Windows 95/98/ME
     2 (VER_PLATFORM_WIN32_NT)          Windows NT/2000/XP
     3 (VER_PLATFORM_WIN32_CE)          Windows CE

     この関数は、Win32 `GetVersionEx()'関数を呼び出します。詳細は
     マイクロソフトのドキュメントを参照してください。

     利用可能: Windows.  _Added in Python version 2.3_

`hexversion'
     整数にエンコードされたバージョン番号。この値は新バージョン(正規リリー
     ス以外であっても)ごとにかならず増加します。例えば、Python
     1.5.2以降で
     のみ動作するプログラムでは、以下のようなチェックを行います。

          if sys.hexversion >= 0x010502F0:
              # use some advanced feature
              ...
          else:
              # use an alternative implementation or warn the user
              ...

     `hexversion'は`hex()'で16進数に変換しなければ値の意味が
     わかりません。より読みやすいバージョン番号が必要な場合には
     `version_info'を使用してください。 _Added in Python version 1.5.2_

`last_type'

`last_value'

`last_traceback'
     通常は定義されておらず、捕捉されない例外が発生してインタープリタがエ
     ラーメッセージとトレースバックを出力した場合にのみ設定されます。この値
     は、対話セッション中にエラーが発生したとき、デバッグモジュールをロード
     (例:`import pdb; pdb.pm()'など。詳細は*Note
     Pythonデバッガ::を参照)して発
     生したエラーを調査する場合に利用します。デバッガをロードすると、プログ
     ラムを再実行せずに情報を取得することができます。

     変数の意味は、上の`exc_info()'の戻り値と同じです。対話セッシ
     ョンを実行するスレッドは常に一つだけなので、`exc_type'のようにス
     レッドに関する問題は発生しません。

`maxint'
     Pythonの整数型でサポートされる、最大の整数。この値は最低でも2**31-1で
     す。最大の負数は`-maxint-1'となります。正負の最大数が非対称です
     が、これは2の補数計算を行うためです。

`maxunicode'
     Unicode文字の最大のコードポイントを示す整数。この値は、オプション設定
     でUnicode文字の保存形式としてUSC-2とUCS-4のいずれを指定したかによって
     異なります。

`modules'
     ロード済みモジュールのモジュール名とモジュールオブジェクトの辞書。強制
     的にモジュールを再読み込みする場合などに使用します。この辞書からモジ
     ュールを削除するのは、`reload()' の呼び出
     しと等価では_ありません_。

`path'
     モジュールを検索するパスを示す文字列のリスト。`PYTHONPATH'環境
     変数と、インストール時に指定したデフォルトパスで初期化されます。

     開始時に初期化された後、リストの先頭(`path[0]')にはPythonインター
     プリタを起動するために指定したスクリプトのディレクトリが挿入されます。
     スクリプトのディレクトリがない(インタープリタで対話セッションで起
     動された時や、スクリプトを標準入力から読み込む場合など)場合、
     `path[0]'には空文字列となり、Pythonはカレントディレクトリからモジ
     ュールの検索を開始します。スクリプトディレクトリは、
     `PYTHONPATH'で指定したディレクトリの_前_に挿入されますので
     注意が必要です。

     必要に応じて、プログラム内で自由に変更することができます。

     _Changed in Python version 2.3_

`platform'
     プラットフォームを識別する文字列(例: `'sunos5'', `'linux1''
     等)。`path'にプラットフォーム別のサブディレクトリを追加する場
     合などに利用します。

`prefix'
     サイト固有の、プラットフォームに依存しないファイルを格納するディレクト
     リを示す文字列。デフォルトでは`'/usr/local''になります。この値は
     ビルド時に`configure'スクリプトの`--prefix'引数で
     指定する事ができます。Pythonライブラリの主要部分は `prefix +
     '/lib/pythonVERSION''にインストールされ、プラット
     フォーム非依存なヘッダファイル(`pyconfig.h'以外)は `prefix +
     '/include/pythonVERSION''に格納されます
     (但しVERSIONは`version[:3]')。

`ps1'

`ps2'
     インタープリタの一次プロンプト、二次プロンプトを指定する文字列。対話
     モードで実行中のみ定義され、初期値は`'>>>~''と
     `'...~''です。文字列以外のオブジェクトを指定した場合、インタープ
     リタが対話コマンドを読み込むごとにオブジェクトの`str()'を評価
     します。この機能は、動的に変化するプロンプトを実装する場合に利用しま
     す。

`setcheckinterval(interval)'
     インタープリタの"チェック間隔"を示す整数値を指定します。この値はスレ
     ッドスイッチやシグナルハンドラのチェックを行う周期を決定します。デフォ
     ルト値は`100'で、この場合 100
     の仮想命令を実行するとチェックを行いま
     す。この値を大きくすればスレッドを利用するプログラムのパフォーマンスが
     向上します。この値が`<=0'以下の場合、全ての仮想命令を実行するたび
     にチェックを行い、レスポンス速度と最大になりますがオーバヘッドもまた最
     大となります。

`setdefaultencoding(name)'
     現在のUnicode処理のデフォルトエンコーディング名を設定します。
     NAMEに一致するエンコーディングが見つからない場合、
     `LookupError'が発生します。この関数は、`site'モジ
     ュールの実装が、`sitecustomize'モジュールから使用するためだけに
     定義されています。`site'から呼び出された後、この関数は
     `sys'から削除されます。 _Added in Python version 2.0_

`setdlopenflags(n)'
     インタープリタが拡張モジュールをロードする時、`dlopen()'で使
     用するフラグを設定します。`sys.setdlopenflags(0)'とすれば、モジ
     ュールインポート時にシンボルの遅延解決を行う事ができます。シンボルを拡
     張モジュール間で共有する場合には、 `sys.setdlopenflags(dl.RTLD_NOW
     | dl.RTLD_GLOBAL)'と指定します。
     フラグの定義名は`dl'か`DLFCN'で定義されています。
     `DLFCN'が存在しない場合、`h2py'スクリプトを使って
     `/usr/include/dlfcn.h'から生成することができます。

     利用可能: UNIX.  _Added in Python version 2.2_

`setprofile(profilefunc)'
     システムのプロファイル関数を登録します。プロファイル関数は、
     Pythonのソースコードプロファイルを行う関数で、Pythonで記述する
     ことができます。  詳細は*Note リファレンス・マニュアル - profile
     と cProfile::を参照してく
     ださい。プロファイル関数はトレース関数(`settrace()'参照)と
     似ていますが、ソース行が実行されるごとに呼び出されるのではなく、関数の
     呼出しと復帰時のみ呼び出されます(例外が発生している場合でも、復帰時の
     イベントは発生します)。プロファイル関数はスレッド毎に設定することがで
     きますが、プロファイラはスレッド間のコンテキスト切り替えを検出すること
     はできません。従って、マルチスレッド環境でのプロファイルはあまり意味が
     ありません。`setprofile'は常に`None'を返します。

`setrecursionlimit(limit)'
     Pythonインタープリタの、スタックの最大の深さをLIMITに設定しま
     す。この制限はPythonプログラムが無限に再帰し、Cスタックがオーバーフ
     ローしてクラッシュすることを防止するために設けられています。

     LIMITの最大値はプラットフォームによって異なります。深い再帰処理
     が必要な場合にはプラットフォームがサポートしている範囲内でより大きな値
     を指定することができますが、この値が大きすぎればクラッシュするので注意
     が必要です。

`settrace(tracefunc)'
     システムのトレース関数を登録します。トレース関数
     はPythonのソースデバッガを実装するために使用することができます。
     *Note どのように動作しているか::の"How It
     Works,"を参照してください。  トレース関数はスレッド毎に設定することができますの
     で、デバッグを行う全てのスレッドで`settrace()'を呼び出し、ト
     レース関数を登録してください。 _Note:_ `settrace()'
     関数は，デバッガ，プロファイラ，
     カバレッジツール等で使うためだけのものです．
     この関数の挙動は言語定義よりも実装プラットフォームの分野の問題で，
     全ての Python 実装で利用できるとは限りません．

`settscdump(on_flag)'
     ON_FLAG が真の場合，Pentium タイムスタンプカウンタを使った VM
     計測結果のダンプ出力を有効にします．ON_FLAG をオフにすると
     ダンプ出力を無効化します．この関数は Python を `--with-tsc'
     つきでコンパイルしたときにのみ利用できます．
     ダンプの内容を理解したければ， Python ソースコード中の
     `Python/ceval.c' を読んでください． _Added in Python version 2.4_

`stdin'

`stdout'

`stderr'
     インタープリタの標準入力・標準出力・標準エラー出力に対応するファイルオ
     ブジェクト。`stdin'はスクリプトの読み込みを除く全ての入力処理で使
     用され、`input()' や`raw_input()' も`stdin'から読み込みます。`stdout'
     は、`print'や式の評価結果、`input()'・
     `raw_input()'のプロンプトの出力先となります。インタープリタの
     プロンプトは(ほとんど)`stderr'に出力されます。`stdout'と
     `stderr'は必ずしも組み込みのファイルオブジェクトである必要はな
     く、`write()'メソッドを持つオブジェクトであれば使用することがで
     きます。`stdout'と`stderr'を別のオブジェクトに置き換えても、
     `os.popen()'・`os.system()' ・`os'の
     `exec*()'などから起動されたプロセスが使用する標準I/Oストリー
     ムは変更されません。

`__stdin__'

`__stdout__'

`__stderr__'
     それぞれ起動時の`stdin'・`stderr'・`stdout'の値を保存し
     ます。終了処理時や、不正なオブジェクトが指定された場合に元の値に復旧す
     るために使用します。

`tracebacklimit'
     捕捉されない例外が発生した時、出力されるトレースバック情報の最大レベル
     数を指定する整数値(デフォルト値は`1000')。`0'以下の値が設定
     された場合、トレースバック情報は出力されず例外型と例外値のみが出力さ
     れます。

`version'
     Pythonインタープリタのバージョンとビルド番号・使用コンパイラなどの情
     報を示す文字列で、`'バージョン(#ビルド番号, ビルド日付,
     ビルド時間)[コンパイラ]''となります。先
     頭の三文字は、バージョンごとのインストール先ディレクトリ内を識別するた
     めに使用されます。例:

          >>> import sys
          >>> sys.version
          '1.5.2 (#0 Apr 13 1999, 10:51:12) [MSC 32 bit (Intel)]'


`api_version'
     使用中のインタープリタのC
     APIバージョン。Pythonと拡張モジュール間の不
     整合をデバッグする場合などに利用できます。_Added in Python version
     2.3_

`version_info'
     バージョン番号を示す５つの値のタプル:MAJOR, MINOR, MICRO,
     RELEASELEVEL, SERIAL RELEASELEVEL以外は
     全て整数です。RELEASELEVELの値は、`'alpha'', `'beta'',
     `'candidate'', or `'final''の何れかです。Python 2.0の
     `version_info'は、`(2, 0, 0, 'final', 0)'となります。 _Added in
     Python version 2.0_

`warnoptions'
     この値は、warnings
     framework内部のみ使用され、変更することはできませ
     ん。詳細は`warnings'を参照してください。

`winver'
     Windowsプラットフォームで、レジストリのキーとなるバージョン番号。
     Python DLLの文字列リソース 1000に設定されています。通常、この値は
     `version'の先頭三文字となります。この値は参照専用で、別の値を
     設定してもPythonが使用するレジストリキーを変更することはできません。
     利用可能: Windows.

See also:
     *Note site:: This describes how to use .pth files to extend
     `sys.path'.



File: python-lib-jp.info,  Node: __builtin__,  Next: __main__,  Prev: sys,  Up: Python ランタイム サービス

26.2 組み込みオブジェクト
=========================

組み込み名前空間を提供するモジュール

このモジュールはPythonの全ての「組み込み」識別子を直接アクセスするための
ものです。例えば `__builtin__.open' は`open()'関数のための
全ての組み込み関数を表示します。 第*Note 組み込みオブジェクト::章,
"組み込みオブジェクト"も参照してください。

このモジュールは通常ほとんどのアプリケーションにおいて直接名指しで
アクセスされることはありませんが、組み込みの名前と同じ名前のオブジェクトを
提供しつつ組み込みのその名前も必要であるようなモジュールにおいて有用です。
たとえば、`open()' という関数を組み込みの `open()'
をラップして実装したいというモジュールがあったとすると、
このモジュールは次のように直接的に使われます。

     import __builtin__

     def open(path):
         f = __builtin__.open(path, 'r')
         return UpperCaser(f)

     class UpperCaser:
         '''Wrapper around a file that converts output to upper-case.'''

         def __init__(self, f):
             self._f = f

         def read(self, count=-1):
             return self._f.read(count).upper()

         # ...

実装の詳細に属することですが、ほとんどのモジュールでは `__builtins__'
(`s' に注意) がグローバルの一部として
使えるようになっています。`__builtins__' の内容は通常このモジュール
そのものか、またはこのモジュールの`__dict__' 属性です。
実装の詳細部分ということで、異なる Python
の実装の下ではこのようになっていないかもしれません。


File: python-lib-jp.info,  Node: __main__,  Next: warnings,  Prev: __builtin__,  Up: Python ランタイム サービス

26.3 トップレベルのスクリプト環境
=================================

トップレベルスクリプトが実行される環境。

このモジュールはPythonインタプリタのメインプログラムがコマンドを実行す
る際の環境をあらわしています。このモジュールを利用することで、通常は無
名のこの環境にアクセスすることができます。実行されるコマンドは標準入力、
スクリプトファイルあるいは対話環境での入力プロンプトから入力されます。
この環境はPythonスクリプトをメインプログラムとして実行される際によく使
われる"条件付きスクリプト"の一節が実行される環境です。

     if __name__ == "__main__":
         main()


File: python-lib-jp.info,  Node: warnings,  Next: contextlib,  Prev: __main__,  Up: Python ランタイム サービス

26.4 警告の制御
===============

警告メッセージを送出したり、その処理方法を制御したり します。 

_Added in Python version 2.1_

警告メッセージは一般に、ユーザに警告しておいた方がよいような状況下に
プログラムが置かれているが、その状況は (通常は) 例外を送出したり
そのプログラムを終了させるほどの正当な理由がないといった状況で
発されます。例えば、プログラムが古いモジュールを使っている場合
には警告を発したくなるかもしれません。

Python プログラマは、このモジュールの `warn()' 関数を
使うことで警告を発することができます。(C 言語のプログラマは
`PyErr_Warn()' を使います; 詳細は  を参照してください)。

警告メッセージは通常 `sys.stderr' に出力されますが、その処理
方法は、全ての警告に対する無視する処理から警告を例外に変更する
処理まで、柔軟に変更することができます。警告の処理方法は 警告カテゴリ
(以下参照)、警告メッセージテキスト、そして警告を
発したソースコード上の場所に基づいて変更することができます。
ソースコード上の同じ場所に対して特定の警告が繰り返された場合、
通常は抑制されます。

警告制御には 2 つの段階 (stage) があります: 第一に、警告が発される
たびに、メッセージを出力すべきかどうか決定が行われます; 次に、
メッセージを出力するなら、メッセージはユーザによって設定が可能なフック
を使って書式化され印字されます。

警告メッセージを出力するかどうかの決定は、警告フィルタによって制御
されます。警告フィルタは一致規則 (matching
rule)と動作からなるシーケンスです。 `filterwarnings()'
を呼び出して一致規則をフィルタに追加する ことができ、`resetwarnings()'
を呼び出してフィルタを標準 設定の状態にリセットすることができます。

警告メッセージの印字は `showwarning()' を呼び出して行うことが
でき、この関数は上書きすることができます; この関数の標準の実装では、
`formatwarning()' を呼び出して警告メッセージを書式化しますが、
この関数についても自作の実装を使うことができます。

* Menu:

* 警告カテゴリ::
* 警告フィルタ::
* 利用可能な関数::


File: python-lib-jp.info,  Node: 警告カテゴリ,  Next: 警告フィルタ,  Prev: warnings,  Up: warnings

26.4.1 警告カテゴリ
-------------------

警告カテゴリを表現する組み込み例外は数多くあります。このカテゴリ化は
警告をグループごとフィルタする上で便利です。現在以下の警告カテゴリ
クラスが定義されています:

クラス                               記述
------                               -----
Warning                              全ての警告カテゴリクラスの基底クラスです。
                                     `Exception' のサブクラスです。
UserWarning                          `warn()' の標準のカテゴリです。
DeprecationWarning                   その機能が廃用化されていることを示す
                                     警告カテゴリの基底クラスです。
SyntaxWarning                        その文法機能があいまいであることを示す警告
                                     カテゴリの基底クラスです。
RuntimeWarning                       その実行時システム機能があいまいであることを
                                     示す警告カテゴリの基底クラスです。
FutureWarning                        その構文の意味付けが将来変更される予定である
                                     ことを示す警告カテゴリの基底クラスです。
PendingDeprecationWarning            将来その機能が廃用化されることを示す
                                     警告カテゴリの基底クラスです(デフォルトでは無視されます)。
ImportWarning                        モジュールのインポート処理中に引き起こされる
                                     警告カテゴリの基底クラスです(デフォルトでは無視されます)。
UnicodeWarning                       Unicode
                                     に関係した警告カテゴリの基底クラスです。

これらは技術的には組み込み例外ですが、概念的には警告メカニズムに
属しているのでここで記述されています。

標準の警告カテゴリをユーザの作成したコード上でサブクラス化することで、
さらに別の警告カテゴリを定義することができます。 警告カテゴリは常に
`Warning' クラスのサブクラスでなければ なりません。


File: python-lib-jp.info,  Node: 警告フィルタ,  Next: 利用可能な関数,  Prev: 警告カテゴリ,  Up: warnings

26.4.2 警告フィルタ
-------------------

警告フィルタは、ある警告を無視すべきか、表示すべきか、あるいは
(例外を送出する) エラーにするべきかを制御します。

概念的には、警告フィルタは複数のフィルタ仕様からなる順番付けられた
リストを維持しています; 何らかの特定の警告が生じると、フィルタ仕様の
一致するものが見つかるまで、リスト中の各フィルタとの照合が行われます;
一致したフィルタ仕様がその警告の処理方法を決定します。
フィルタの各エントリは (ACTION, MESSAGE, CATEGORY, MODULE, LINENO)
からなるタプルです。ここで:

   * ACTION は以下の文字列のうちの一つです:

     値                                 処理方法
     ------                             -----
     "error"                            一致した警告を例外に変えます
     "ignore"                           一致した警告を決して出力しません
     "always"                           一致した警告を常に出力します
     "default"                          一致した警告のうち、警告の原因になった
                                        ソースコード上の場所ごとに、最初の警告のみ出力します。
     "module"                           一致した警告のうち、警告の原因になった
                                        モジュールごとに、最初の警告のみ出力します。
     "once"                             一致した警告のうち、警告の原因になった
                                        場所にかかわらず最初の警告のみ出力します。

   * MESSAGE は正規表現を含む文字列で、メッセージはこの
     パタンに一致しなければなりません (照合時には常に大小文字の区別を
     しないようにコンパイルされます)。

   * CATEGORY はクラス (`Warning' のサブクラス) です。
     警告クラスはこのクラスのサブクラスに一致しなければなりません。

   * MODULE は正規表現を含む文字列で、モジュール名はこのパタン
     に一致しなければなりません (照合時には常に大小文字の区別を
     しないようにコンパイルされます)。

   * LINENO 整数で、警告が発生した場所の行番号に一致しなければ
     なりません、すべての行に一致する場合には `0' になります。


`Warning' クラスは組み込みの `Exception' クラスから
導出されているので、警告をエラーに変えるには単に `category(message)' を
`raise' します。

警告フィルタは Python インタプリタのコマンドラインに渡される `-W'
オプションで初期化されます。インタプリタは `-W'
オプションに渡される全ての引数を `sys.warnoptions';
に変換せずに保存します; `warnings' モジュールは最初に `import'
された際にこれらの引数を解釈します (無効なオプションは`sys.stderr'
にメッセージを出力した後 無視されます)。

デフォルトでは無視される警告を `-Wd' をインタプリタに渡すこ
とで有効にすることができます。このオプションは通常はデフォルトで無視さ
れるようなものを含む全ての警告のデフォルトでの扱いを有効化します。この
ような振る舞いは開発中のパッケージをインポートする問題をデバッグする時
にImportWarning を有効化するために使えます。ImportWarning は次のよう な
Python コードを使って明示的に有効化することもできます。

         warnings.simplefilter('default', ImportWarning)


File: python-lib-jp.info,  Node: 利用可能な関数,  Prev: 警告フィルタ,  Up: warnings

26.4.3 利用可能な関数
---------------------

`warn(message[, category[, stacklevel]])'
     警告を発するか、無視するか、あるいは例外を送出します。 CATEGORY
     引数が与えられた場合、警告カテゴリクラスでなければ なりません
     (上を参照してください); 標準の値は `UserWarning' です。MESSAGE を
     `Warning' インスタンスで代用する こともできますが、この場合
     CATEGORY は無視され、 `message.__class__' が使われ、メッセージ文は
     `str(message)'
     になります。発された例外が前述した警告フィルタによってエラーに
     変更された場合、この関数は例外を送出します。引数 STACKLEVEL は
     Python でラッパ関数を書く際に利用することができます。例えば:

          def deprecation(message):
              warnings.warn(message, DeprecationWarning, stacklevel=2)

     こうすることで、警告が参照するソースコード部分を、 `deprecation()'
     自身ではなく `deprecation()' を 呼び出した側にできます
     (というのも、前者の場合は警告メッセージ
     の目的を台無しにしてしまうからです)。

`warn_explicit(message, category, filename, lineno[, module[, registry[, module_globals]]])'
     `warn()' の機能に対する低レベルのインタフェースで、
     メッセージ、警告カテゴリ、ファイル名および行番号、そしてオプションの
     モジュール名およびレジストリ情報 (モジュールの
     `__warningregistry__' 辞書) を明示的に渡します。
     モジュール名は標準で `.py' が取り去られたファイル名になります;
     レジストリが渡されなかった場合、警告が抑制されることはありません。
     MESSAGE は文字列のとき、CATEGORY は `Warning'
     のサブクラスでなければなりません。また MESSAGE は `Warning'
     のインスタンスであってもよく、この場合 CATEGORY は無視されます。

     MODULE_GLOBALS は、もし与えられるならば、警告が発せられるコードが
     使っているグローバル名前空間でなければなりません。(この引数は
     zipfile
     やその他の非ファイルシステムのインポート元の中にあるモジュールのソース
     を表示することをサポートするためのもので、Python 2.5
     で追加されました。)

`showwarning(message, category, filename, lineno[, file])'
     警告をファイルに書き込みます。標準の実装では、
     `formatwarning(MESSAGE, CATEGORY, FILENAME, LINENO)'
     を呼び出し、返された文字列を FILE に書き込み ます。FILE は標準では
     `sys.stderr' です。 この関数は `warnings.showwarning'
     に別の実装を代入して 置き換えることができます。

`formatwarning(message, category, filename, lineno)'
     警告を通常の方法で書式化します。返される文字列内には改行が埋め込まれて
     いる可能性があり、かつ文字列は改行で終端されています。

`filterwarnings(action[, message[, category[, module[, lineno[, append]]]]])'
     警告フィルタのリストにエントリを一つ挿入します。標準ではエントリは
     先頭に挿入されます; APPEND が真ならば、末尾に挿入されます。
     この関数は引数の型をチェックし、MESSAGE および MODULE
     の正規表現をコンパイルしてから、これらをタプルにして警告フィルタ
     のリストに挿入します。二つのエントリが特定の警告に合致した場合、
     リストの先頭に近い方のエントリが後方にあるエントリに優先します。
     引数が省略されると、標準では全てにマッチする値に設定されます。

`simplefilter(action[, category[, lineno[, append]]])'
     単純なエントリを警告フィルタのリストに挿入します。引数の意味 は
     `filterwarnings()' と同じですが、この関数により挿入されるフィ
     ルタはカテゴリと行番号が一致していれば全てのモジュールの全てのメッセー
     ジに合致しますので、正規表現は必要ありません。

`resetwarnings()'
     警告フィルタをリセットします。これにより、`-W' コマンドラ
     インオプションによるもの `simplefilter()' 呼び出しによるもの
     を含め、`filterwarnings' の呼び出しによる影響はすべて無効化
     されます。


File: python-lib-jp.info,  Node: contextlib,  Next: atexit,  Prev: warnings,  Up: Python ランタイム サービス

26.5 `with'-構文 コンテキストのためのユーティリティ。
=====================================================

`with'-構文 コンテキストのためのユーティリティ。

_Added in Python version 2.5_

このモジュールは`with'文を必要とする一般的なタスクのための
ユーティリティを提供します。

用意されている関数:

`contextmanager(func)'
     この関数はデコレータであり、`with'文コンテキストマネージャのための
     ファクトリ関数の定義に利用できます。
     ファクトリ関数を定義するために、クラスあるいは
     別の`__enter__()'と`__exit__()'メソッドを作る必要はありません。

     簡単な例（実際にHTMLを生成する方法としてはお勧めできません！）:

          from __future__ import with_statement
          from contextlib import contextmanager

          @contextmanager
          def tag(name):
              print "<%s>" % name
              yield
              print "</%s>" % name

          >>> with tag("h1"):
          ...    print "foo"
          ...
          <h1>
          foo
          </h1>

     デコレートされた関数は呼び出されたときにジェネレータ-イテレータを返します。
     このイテレータは値をちょうど一つyieldしなければなりません。
     `with'文の`as'節が存在するなら、
     その値がas節のターゲットへ束縛されることになります。

     ジェネレータがyieldするところで、`with'文のネストされたブロックが実行されます。
     ジェネレータはブロックから出た後に再開されます。ブロック内で処理されない例外が発生した場合は、
     yieldが起きた場所でジェネレータ内部へ再送出されます。
     このように、（もしあれば）エラーを捕捉したり、後片付け処理を確実に実行したりするために、
     `try'...`except'...`finally'文を使うことができます。
     単に例外のログをとるためだけに、もしくは（完全に例外を抑えてしまうのではなく）
     あるアクションを実行するだけに例外を捕まえるなら、ジェネレータはその例外を再送出しなければなりません。
     そうしないと、ジェネレータコンテキストマネージャは例外が処理された`with'文を指しており、
     その`with'文のすぐ後につづく文から実行を再開します。

`nested(mgr1[, mgr2[, ...]])'
     複数のコンテキストマネージャを一つのネストされたコンテキストマネージャへ結合します。

     このようなコードは:

          from contextlib import nested

          with nested(A, B, C) as (X, Y, Z):
              do_something()

     これと同等です:

          with A as X:
              with B as Y:
                  with C as Z:
                      do_something()

     ネストされたコンテキストマネージャの一つの`__exit__()'メソッドに
     止めるべき例外がある場合は、残りの外側のコンテキストマネージャすべてに
     例外情報が渡されないということに注意してください。
     同じように、ネストされたマネージャの一つの`__exit__()'メソッドが
     例外を送出したならば、どんな以前の例外状態も失われ、
     新しい例外が残りすべての外側にあるコンテキストマネージャの
     `__exit__()'メソッドに渡されます。
     一般的に`__exit__()'メソッドが例外を送出することは避けるべきであり、
     特に渡された例外を再送出すべきではありません。

`closing(thing)'
     ブロックの完了時にTHINGを閉じるコンテキストマネージャを返します。
     これは基本的に以下と等価です:

          from contextlib import contextmanager

          @contextmanager
          def closing(thing):
              try:
                  yield thing
              finally:
                  thing.close()

     そして、明確に`page'を閉じる必要なしに、このように書くことができます:
          from __future__ import with_statement
          from contextlib import closing
          import codecs

          with closing(urllib.urlopen('http://www.python.org')) as page:
              for line in page:
                  print line

     たとえエラーが発生したとしても、`with'ブロックを出るときに
     `page.close()'が呼ばれます。

See also:
    *PEP0343 The "with" statement*
          仕様、背景、および、Python `with'文の例。



File: python-lib-jp.info,  Node: atexit,  Next: traceback,  Prev: contextlib,  Up: Python ランタイム サービス

26.6 終了ハンドラ
=================

後始末関数の登録と実行。

_Added in Python version 2.0_

`atexit' モジュールでは、後始末関数を登録するための関数を一つだ
け定義しています。この関数を使って登録した後始末関数は、インタプリタが
終了するときに自動的に実行されます。

_Note:_ プログラムがシグナルで停止させられたとき、Python の致命的な内部
エラーが検出されたとき、あるいは`os._exit()'が呼び出された
ときには、このモジュールを通して登録した関数は呼び出されません。

このモジュールは、`sys.exitfunc' 変数の提供している機能の代用とな
るインタフェースです。 

_Note:_ `sys.exitfunc'を設定する他のコードとともに使用した場合には、
このモジュールは正しく動作しないでしょう。特に、他のコア Python
モジュールでは、プログラマの意図を知らなくても`atexit'を自由に
使えます。`sys.exitfunc' を使っている人は、代わりに
`atexit'を使うコードに変換してください。 `sys.exitfunc'
を設定するコードを変換するには、`atexit' を import し、`sys.exitfunc'
へ束縛されていた関数を登録するのが 最も簡単です。

`register(func[, *args[, **kargs]])'
     終了時に実行される関数としてFUNCを登録します。すべてのFUNC
     へ渡すオプションの引数を、`register()'へ引数としてわたさなけ
     ればなりません。

     通常のプログラムの終了時、例えば`sys.exit()' が呼び出されると
     き、あるいは、メインモジュールの実行が完了したときに、登録された全ての
     関数を、最後に登録されたものから順に呼び出します。通常、より低レベルの
     モジュールはより高レベルのモジュールより前に import されるので、
     後で後始末が行われるという仮定に基づいています。

     終了ハンドラの実行中に例外が発生すると、(`SystemExit'以外の
     場合は)トレースバックを表示して、例外の情報を保存します。
     全ての終了ハンドラに動作するチャンスを与えた後に、最後に送出された
     例外を再送出します。


See also:
     *Note readline:: `readline'ヒストリファイルを読み書き
     するための`atexit'の有用な例です。

* Menu:

* atexit 例::


File: python-lib-jp.info,  Node: atexit 例,  Prev: atexit,  Up: atexit

26.6.1 `atexit' 例
------------------

次の簡単な例では、あるモジュールを import した時にカウンタを初期化し
ておき、プログラムが終了するときにアプリケーションがこのモジュールを明
示的に呼び出さなくてもカウンタが更新されるようにする方法を示しています。

     try:
         _count = int(open("/tmp/counter").read())
     except IOError:
         _count = 0

     def incrcounter(n):
         global _count
         _count = _count + n

     def savecounter():
         open("/tmp/counter", "w").write("%d" % _count)

     import atexit
     atexit.register(savecounter)

`register()' に指定した固定引数とキーワードパラメタは
登録した関数を呼び出す際に渡されます。

     def goodbye(name, adjective):
         print 'Goodbye, %s, it was %s to meet you.' % (name, adjective)

     import atexit
     atexit.register(goodbye, 'Donny', 'nice')

     # or:
     atexit.register(goodbye, adjective='nice', name='Donny')


File: python-lib-jp.info,  Node: traceback,  Next: __future__,  Prev: atexit,  Up: Python ランタイム サービス

26.7 スタックトレースの表示や取り出し
=====================================

スタックトレースの表示や取り出し。

このモジュールはPythonプログラムのスタックトレースを抽出し、書式を整え、表示するための標準インターフェースを提供します。モジュールがスタックトレースを表示するとき、Pythonインタープリタの動作を正確に模倣します。インタープリタの"ラッパー"の場合のように、プログラムの制御の元でスタックトレースを表示したいと思ったときに役に立ちます。

モジュールはtracebackオブジェクトを使います --
これは変数`sys.exc_traceback'(非推奨)と`sys.last_traceback'に保存され、`sys.exc_info()'から三番目の項目として返されるオブジェクト型です。 

モジュールは次の関数を定義します:

`print_tb(traceback[, limit[, file]])'
     TRACEBACKからLIMITまでスタックトレース項目を出力します。LIMITが省略されるか`None'の場合は、すべての項目が表示されます。FILEが省略されるか`None'の場合は、`sys.stderr'へ出力されます。それ以外の場合は、出力を受けるためのオープンしたファイルまたはファイルに類似したオブジェクトであるべきです。

`print_exception(type, value, traceback[, limit[, file]])'
     例外情報とTRACEBACKからLIMITまでスタックトレース項目をFILEへ出力します。これは次のようにすることで`print_tb()'とは異なります:
     (1) TRACEBACKが`None'でない場合は、ヘッダ`Traceback (most recent
     call last):'を出力します。 (2)
     スタックトレースの後に例外TYPEとVALUEを出力します。 (3)
     TYPEが`SyntaxError'であり、VALUEが適切な形式の場合は、エラーのおおよその位置を示すカレットを付けて構文エラーが起きた行を出力します。

`print_exc([limit[, file]])'
     これは`print_exception(sys.exc_type, sys.exc_value,
     sys.exc_traceback, LIMIT,
     FILE)'のための省略表現です。(非推奨の変数を使う代わりにスレッドセーフな方法で同じ情報を引き出すために、実際には`sys.exc_info()'を使います。)

`format_exc([limit])'
     これは、`print_exc(LIMIT)'に似ていますが、ファイルに出力す
     るかわりに文字列を返します。 _Added in Python version 2.4_

`print_last([limit[, file]])'
     これは`print_exception(sys.last_type, sys.last_value,
     sys.last_traceback, LIMIT, FILE)'の省略表現です。

`print_stack([f[, limit[, file]]])'
     この関数は呼び出された時点からのスタックトレースを出力します。オプションのF引数は代わりの最初のスタックフレームを指定するために使えます。`print_exception()'に付いて言えば、オプションのLIMITとFILE引数は同じ意味を持ちます。

`extract_tb(traceback[, limit])'
     トレースバックオブジェクトTRACEBACKからLIMITまで取り出された"前処理済み"スタックトレース項目のリストを返します。スタックトレースの代わりの書式設定を行うために役に立ちます。LIMITが省略されるか`None'の場合は、すべての項目が取り出されます。"前処理済み"スタックトレース項目とは四つの部分からなる(FILENAME,
     LINE NUMBER, FUNCTION NAME,
     TEXT)で、スタックトレースに対して通常出力される情報を表しています。TEXTは前と後ろに付いている空白を取り除いた文字列です。ソースが使えない場合は`None'です。

`extract_stack([f[, limit]])'
     現在のスタックフレームから生のトレースバックを取り出します。戻り値は`extract_tb()'と同じ形式です。`print_stack()'について言えば、オプションのFとLIMIT引数は同じ意味を持ちます。

`format_list(list)'
     `extract_tb()'または`extract_stack()'が返すタプルのリストが与えられると、出力の準備を整えた文字列のリストを返します。結果として生じるリストの中の各文字列は、引数リストの中の同じインデックスの要素に対応します。各文字列は末尾に改行が付いています。その上、ソーステキスト行が`None'でないそれらの要素に対しては、文字列は内部に改行を含んでいるかもしれません。

`format_exception_only(type, value)'
     トレースバックの例外部分の書式を設定します。引数は`sys.last_type'と`sys.last_value'のような例外の型と値です。戻り値はそれぞれが改行で終わっている文字列のリストです。通常、リストは一つの文字列を含んでいます。しかし、`SyntaxError'例外に対しては、(出力されるときに)構文エラーが起きた場所についての詳細な情報を示す行をいくつか含んでいます。どの例外が起きたのかを示すメッセージは、常にリストの最後の文字列です。

`format_exception(type, value, tb[, limit])'
     スタックトレースと例外情報の書式を設定します。引数は`print_exception()'の対応する引数と同じ意味を持ちます。戻り値は文字列のリストで、それぞれの文字列は改行で終わり、そのいくつかは内部に改行を含みます。これらの行が連結されて出力される場合は、厳密に`print_exception()'と同じテキストが出力されます。

`format_tb(tb[, limit])'
     `format_list(extract_tb(TB, LIMIT))'の省略表現。

`format_stack([f[, limit]])'
     `format_list(extract_stack(F, LIMIT))'の省略表現。

`tb_lineno(tb)'
     この関数はトレースバックオブジェクトに設定された現在の行番号をかえします。この関数は必要でした。なぜなら、`-O'フラグがPythonへ渡されたとき、Pythonの2.3より前のバージョンでは`TB.tb_lineno'が正しく更新されなかったからです。この関数は2.3以降のバージョンでは役に立ちません。

* Menu:

* トレースバックの例::


File: python-lib-jp.info,  Node: トレースバックの例,  Prev: traceback,  Up: traceback

26.7.1 トレースバックの例
-------------------------

この簡単な例では基本的なread-eval-printループを実装います。それは標準的なPythonの対話インタープリタループに似ていますが、Pythonのものより便利ではありません。インタープリタループのより完全な実装については、`code'モジュールを参照してください。

     import sys, traceback

     def run_user_code(envdir):
         source = raw_input(">>> ")
         try:
             exec source in envdir
         except:
             print "Exception in user code:"
             print '-'*60
             traceback.print_exc(file=sys.stdout)
             print '-'*60

     envdir = {}
     while 1:
         run_user_code(envdir)


File: python-lib-jp.info,  Node: __future__,  Next: gc,  Prev: traceback,  Up: Python ランタイム サービス

26.8 Future ステートメントの定義
================================

Future ステートメントの定義

`__future__' は実際にモジュールであり、3つの役割があります。

   * import ステートメントを解析する既存のツールを混乱させるのを避け、
     そのステートメントがインポートしようとしているモジュールを見つけ
     られるようにするため。

   * 2.1 以前のリリースで future ステートメントが実行されれば、最低でも
     ランタイム例外を投げるようにするため。 (`__future__'
     はインポートできません。というのも、2.1 以前
     にはそういう名前のモジュールはなかったからです。)

   * いつ互換でない変化が導入され、いつ強制的になる - あるいは、 なった
     - のか文書化するため。
     これは実行できる形式で書かれたドキュメントでなので、`__future__'
     をインポートし、その中身を調べるようプログラムすれば確かめられます。


`__future__.py' の各ステートメントは次のような形をしています:

     FeatureName = "_Feature(" OPTIONALRELEASE "," MANDATORYRELEASE ","
     COMPILERFLAG ")"

ここで、普通は、OPTIONALRELEASE は MANDATORYRELEASE より小さく、2つとも
`sys.version_info' と同じフォーマットの5つのタプルからなります。

         (PY_MAJOR_VERSION, # the 2 in 2.1.0a3; an int
          PY_MINOR_VERSION, # the 1; an int
          PY_MICRO_VERSION, # the 0; an int
          PY_RELEASE_LEVEL, # "alpha", "beta", "candidate" or "final"; string
          PY_RELEASE_SERIAL # the 3; an int
         )

OPTIONALRELEASE はその機能が導入された最初のリリースを記録します。

まだ時期が来ていない MANDATORYRELEASE の場合、MANDATORYRELEASE は
その機能が言語の一部となるリリースを記します。

その他の場合、MANDATORYRELEASE はその機能がいつ言語の一部になったのかを
記録します。
そのリリースから、あるいはそれ以降のリリースでは、この機能を使う際に
future ステートメントは必要ではありませんが、future ステートメントを
使い続けても構いません。

MANDATORYRELEASE は `None'
になるかもしれません。つまり、予定された機能が
破棄されたということです。

`_Feature' クラスのインスタンスには対応する2つのメソッド、
`getOptionalRelease()' と `getMandatoryRelease()' があります。

COMPILERFLAG
は動的にコンパイルされるコードでその機能を有効にするために、
組み込み関数 `compile()' の第4引数に渡されなければならない
(ビットフィールド)フラグです。 このフラグは `_Feature' インスタンスの
`compilier_flag' 属性に 保存されています。

`__future__' で解説されている機能のうち、削除されたものはまだ
ありません。


File: python-lib-jp.info,  Node: gc,  Next: inspect,  Prev: __future__,  Up: Python ランタイム サービス

26.9 ガベージコレクタ インターフェース
======================================

循環検出ガベージコレクタのインターフェース。

このモジュールは、循環ガベージコレクタの無効化・検出頻度の調整・デバッグ
オブションの設定などを行うインターフェースを提供します。また、検出した到
達不能オブジェクトのうち、解放する事ができないオブジェクトを参照する事も
できます。循環ガベージコレクタはPyhonの参照カウントを補うためのものです
ので、もしプログラム中で循環参照が発生しない事が明らかな場合には検出をす
る必要はありません。自動検出は、`gc.disable()'で停止する事ができま
す。メモリリークをデバッグするときには、
`gc.set_debug(gc.DEBUG_LEAK)'とします。 これは `gc.DEBUG_SAVEALL'
を含んでいることに注意しましょう。
ガベージとして検出されたオブジェクトは、インスペクション用に gc.garbage
に保存されます。

`gc'モジュールは、以下の関数を提供しています。

`enable()'
     自動ガベージコレクションを有効にします。

`disable()'
     自動ガベージコレクションを無効にします。

`isenabled()'
     自動ガベージコレクションが有効なら真を返します。

`collect([generation])'
     引数を指定しない場合は、全ての検出を行います。 オプションの引数
     GENERATION は、どの世代を検出するかを (0 から 2 までの)
     整数値で指定します。無効な世代番号を指定した場合は `ValueError'
     が発生します。検出した到達不可オブジェクトの 数を返します。

     _Changed in Python version 2.5_

`set_debug(flags)'
     ガベージコレクションのデバッグフラグを設定します。デバッグ情報は
     `sys.stderr'に出力されます。デバッグフラグは、下の値の組み合わせ
     を指定する事ができます。

`get_debug()'
     現在のデバッグフラグを返します。

`get_objects()'
     現在、追跡しているオブジェクトのリストを返します。このリストには、戻り値
     のリスト自身は含まれていません。 _Added in Python version 2.2_

`set_threshold(threshold0[, threshold1[, threshold2]])'
     ガベージコレクションの閾値（検出頻度）を指定します。THRESHOLD0を0
     にすると、検出は行われません。

     GCは、オブジェクトを、走査された回数に従って3世代に分類します。新しいオ
     ブジェクトは最も若い（`0'世代）に分類されます。もし、そのオブジェク
     トがガベージコレクションで削除されなければ、次に古い世代に分類されます。
     もっとも古い世代は`2'世代で、この世代に属するオブジェクトは他の世代
     に移動しません。ガベージコレクタは、最後に検出を行ってから生成・削除した
     オブジェクトの数をカウントしており、この数によって検出を開始します。オブ
     ジェクトの生成数 - 削除数 がTHRESHOLD0より大きくなると、検出を開始
     します。最初は`0'世代のオブジェクトのみが検査されます。`0'世代
     の検査が`threshold1'回実行されると、`1'世代のオブジェクトの検
     査を行います。同様に、`1'世代が`threshold2'回検査されると、
     `2'世代の検査を行います。

`get_count()'
     現在の検出数を、 `(COUNT0, COUNT1, COUNT2)' のタプルで返します。
     _Added in Python version 2.5_

`get_threshold()'
     現在の検出閾値を、`(THRESHOLD0, THRESHOLD1,
     THRESHOLD2)'のタプルで返します。

`get_referrers(*objs)'
     objsで指定したオブジェクトのいずれかを参照しているオブジェクトのリストを
     返します。この関数では、ガベージコレクションをサポートしているコンテナの
     みを返します。他のオブジェクトを参照していても、ガベージコレクションをサ
     ポートしていない拡張型は含まれません。

     尚、戻り値のリストには、すでに参照されなくなっているが、循環参照の一部で
     まだガベージコレクションで回収されていないオブジェクトも含まれるので注意
     が必要です。有効なオブジェクトのみを取得する場合、
     `get_referrers()'の前に`collect()'を呼び出してくださ い。

     `get_referrers()'から返されるオブジェクトは作りかけや
     利用できない状態である場合があるので、利用する際には注意が必要です。
     `get_referrers()'をデバッグ以外の目的で利用するのは避けてくだ
     さい。

     _Added in Python version 2.2_

`get_referents(*objs)'
     引数で指定したオブジェクトのいずれかから参照されている、全てのオブジェクト
     のリストを返します。参照先のオブジェクトは、引数で指定したオブジェクトの
     Cレベルメソッド`tp_traverse'で取得し、全てのオブジェクトが直接到達
     可能な全てのオブジェクトを返すわけではありません。`tp_traverse'は
     ガベージコレクションをサポートするオブジェクトのみが実装しており、ここで
     取得できるオブジェクトは循環参照の一部となる可能性のあるオブジェクトのみ
     です。従って、例えば整数オブジェクトが直接到達可能であっても、このオブジェクトは
     戻り値には含まれません。 _Added in Python version 2.3_

以下の変数は読み込み専用です。(変更することはできますが、再バインドする
事はできません。）

`garbage'
     到達不能であることが検出されたが、解放する事ができないオブジェクトのリス
     ト（回収不能オブジェクト）。デフォルトでは、`__del__()'メソッドを
     持つオブジェクトのみが格納されます。 (1)

     `__del__()'メソッドを持つオブジェクトが循環参照に含まれている場
     合、その循環参照全体と、循環参照からのみ到達する事ができるオブジェクトは
     回収不能となります。このような場合には、Pythonは安全に`__del__()'
     を呼び出す順番を決定する事ができないため、自動的に解放することはできませ
     ん。もし安全な解放順序がわかるのであれば、GARBAGEリストを参照して
     循環参照を破壊する事ができます。循環参照を破壊した後でも、そのオブジェク
     トはGARBAGEリストから参照されているため、解放されません。解放する
     ためには、循環参照を破壊した後、`del gc.garbage[:]'のように
     GARBAGEからオブジェクトを削除する必要があります。一般的には
     `__del__()'を持つオブジェクトが循環参照の一部とはならないように配
     慮し、GARBAGEはそのような循環参照が発生していない事を確認するため
     に利用する方が良いでしょう。

     `DEBUG_SAVEALL'が設定されている場合、全ての到達不能オブジェクト
     は解放されずにこのリストに格納されます。

以下は`set_debug()'に指定することのできる定数です。

`DEBUG_STATS'
     検出中に統計情報を出力します。この情報は、検出頻度を最適化する際に有益で
     す。

`DEBUG_COLLECTABLE'
     見つかった回収可能オブジェクトの情報を出力します。

`DEBUG_UNCOLLECTABLE'
     見つかった回収不能オブジェクト（到達不能だが、ガベージコレクションで解放
     する事ができないオブジェクト）の情報を出力します。回収不能オブジェクト
     は、`garbade'リストに追加されます。

`DEBUG_INSTANCES'
     `DEBUG_COLLECTABLE'か`DEBUG_UNCOLLECTABLE'が設定されて
     いる場合、見つかったインスタンスオブジェクトの情報を出力します。

`DEBUG_OBJECTS'
     `DEBUG_COLLECTABLE'か`DEBUG_UNCOLLECTABLE'が設定されて
     いる場合、見つかったインスタンスオブジェクト以外のオブジェクトの情報を出
     力します。

`DEBUG_SAVEALL'
     設定されている場合、全ての到達不能オブジェクトは解放されずに
     GARBAGEに追加されます。これはプログラムのメモリリークをデバッグす
     るときに便利です。

`DEBUG_LEAK'
     プログラムのメモリリークをデバッグするときに指定します。
     （`DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_INSTANCES |
     DEBUG_OBJECTS | DEBUG_SAVEALL'と同じ。）

---------- Footnotes ----------

(1) Python 2.2より前のバージョンでは、`__del__()'メソッドを
持つオブジェクトだけでなく、全ての到達不能オブジェクトが格納されてい
た。）


File: python-lib-jp.info,  Node: inspect,  Next: site,  Prev: gc,  Up: Python ランタイム サービス

26.10 使用中オブジェクトの情報を取得する
========================================

使用中のオブジェクトから、情報とソースコードを取得する。

_Added in Python version 2.1_

`inspect'は、モジュール・クラス・メソッド・関数・トレースバック・
フレームオブジェクト・コードオブジェクトなどのオブジェクトから情報を取得
する関数を定義しており、クラスの内容を調べる、メソッドのソースコードを取
得する、関数の引数リストを取得して整形する、トレースバックから必要な情報
だけを取得して表示する、などの処理を行う場合に利用します。

このモジュールの機能は、型チェック・ソースコードの取得・クラス／関数から
情報を取得・インタープリタのスタック情報の調査、の4種類に分類する事がで
きます。

* Menu:

* 型とメンバ::
* ソース参照::
* クラスと関数 2::
* インタープリタ スタック::


File: python-lib-jp.info,  Node: 型とメンバ,  Next: ソース参照,  Prev: inspect,  Up: inspect

26.10.1 型とメンバ
------------------

`getmembers()'は、クラスやモジュールなどのオブジェクトからメンバを取得します。
名前が"is"で始まる 11
個の関数は、`getmembers()'の2番目の引数として利用する事ができますし、以下のような特殊属性を参照できるかどうか調べる時にも使えます。

Type               Attribute          Description        Notes
------             ------             ------             ------
module             __doc__            ドキュメント文字列 
                   __file__           ファイル名(組み込みモジュールには存在しない
class              __doc__            ドキュメント文字列 
                   __module__         クラスを定義しているモジュールの名前
method             __doc__            ドキュメント文字列 
                   __name__           メソッドが定義された時の名前
                   im_class           メソッドを呼び出すために必要なクラスオブジェクト(1)
                   im_func            メソッドを実装している関数オブジェクト
                   im_self            メソッドに結合しているインスタンス、または`None'
function           __doc__            ドキュメント文字列 
                   __name__           関数が定義された時の名前
                   func_code          関数をコンパイルしたバイトコードを格納するコード
                                      オブジェクト       
                   func_defaults      引数のデフォルト値のタプル
                   func_doc           (__doc__と同じ)    
                   func_globals       関数を定義した時のグローバル名前空間
                   func_name          (__name__と同じ)   
traceback          tb_frame           このレベルのフレームオブジェクト
                   tb_lasti           最後に実行しようとしたバイトコード中のインストラク
                                      ションを示すインデックス。
                   tb_lineno          現在のPythonソースコードの行番号
                   tb_next            このオブジェクトの内側(このレベルから呼び出された)
                                      のトレースバックオブジェクト
frame              f_back             外側               
                                      (このフレームを呼び出した)のフレームオブジ
                                      ェクト             
                   f_builtins         このフレームで参照している組み込み名前空間
                   f_code             このフレームで実行しているコードオブジェクト
                   f_exc_traceback    このフレームで例外が発生した場合にはトレー
                                      スバックオブジェクト。それ以外なら`None'
                   f_exc_type         このフレームで例外が発生した場合には例外型。それ
                                      以外なら`None'     
                   f_exc_value        このフレームで例外が発生した場合には例外の値。
                                      それ以外なら`None' 
                   f_globals          このフレームで参照しているグローバル名前空間
                   f_lasti            最後に実行しようとしたバイトコードのインデックス。
                   f_lineno           現在のPythonソースコードの行番号
                   f_locals           このフレームで参照しているローカル名前空間
                   f_restricted       制限実行モードなら1、それ以外なら0
                   f_trace            このフレームのトレース関数、または`None'
code               co_argcount        引数の数(*、**引数は含まない)
                   co_code            コンパイルされたバイトコードそのままの文字列
                   co_consts          バイトコード中で使用している定数のタプル
                   co_filename        コードオブジェクトを生成したファイルのファイル名
                   co_firstlineno     Pythonソースコードの先頭行
                   co_flags           以下の値の組み合わせ:
                                      1=optimized `|'    
                                      2=newlocals  `|'   
                                      4=*arg `|'         
                                      8=**arg            
                   co_lnotab          文字列にエンコードした、行番号->バイトコード
                                      インデックスへの変換表
                   co_name            コードオブジェクトが定義されたときの名前
                   co_names           ローカル変数名のタプル
                   co_nlocals         ローカル変数の数   
                   co_stacksize       必要な仮想機械のスタックスペース
                   co_varnames        引数名とローカル変数名のタプル
builtin            __doc__            ドキュメント文字列 
                   __name__           関数、メソッドの元々の名前
                   __self__           メソッドが結合しているインスタンス、または`None'

Note:
`(1)'
     _Changed in Python version 2.2_

`getmembers(object[, predicate])'
     オブジェクトの全メンバを、(名前,
     値)の組み合わせのリストで返します。リ
     ストはメンバ名でソートされています。PREDICATEが指定されている場
     合、predicateの戻り値が真となる値のみを返します。

`getmoduleinfo(path)'
     PATHで指定したファイルがモジュールであればそのモジュールがPython
     でどのように解釈されるかを示す`(NAME, SUFFIX, MODE,
     MTYPE)'のタプルを返し、モジュールでなければ
     `None'を返します。NAMEはパッケージ名を含まないモジュール
     名、SUFFIXはファイル名からモジュール名を除いた残りの部分(ドット
     による拡張子とは限らない)、MODEは`open()'で指定されるフ
     ァイルモード(`'r''または`'rb'')、MTYPEは
     `imp'で定義している整定数のいずれかが指定されます。モジュール
     タイプに付いては`imp'を参照してください。

`getmodulename(path)'
     PATHで指定したファイルの、パッケージ名を含まないモジュール名を返
     します。この処理は、インタープリタがモジュールを検索する時と同じアルゴ
     リズムで行われます。ファイルがこのアルゴリズムで見つからない場合には
     `None'が返ります。

`ismodule(object)'
     オブジェクトがモジュールの場合は真を返します。

`isclass(object)'
     オブジェクトがクラスの場合は真を返します。

`ismethod(object)'
     オブジェクトがメソッドの場合は真を返します。

`isfunction(object)'
     オブジェクトがPythonの関数、または無名(lambda)関数の場合は真を返します。

`istraceback(object)'
     オブジェクトがトレースバックの場合は真を返します。

`isframe(object)'
     オブジェクトがフレームの場合は真を返します。

`iscode(object)'
     オブジェクトがコードの場合は真を返します。

`isbuiltin(object)'
     オブジェクトが組み込み関数の場合は真を返します。

`isroutine(object)'
     オブジェクトがユーザ定義か組み込みの関数・メソッドの場合は真を返します。

`ismethoddescriptor(object)'
     オブジェクトがメソッドデスクリプタの場合に真を返しますが、
     ismethod()、isclass() または isfunction()
     が真の場合には真を返しません。

     この機能は Python 2.2 から新たに追加されたもので、例えば
     int.__add__ は真 になります。 このテストをパスするオブジェクトは
     __get__ 属性を持ちますが __set__
     属性を持ちません。しかしそれ以上に属性のセットには様々なものがあります。
     __name__ は通常見分けることが可能ですし、__doc__ も時には可能です。

     デスクリプタを使って実装されたメソッドで、上記のいずれかのテストもパスして
     いるものは、 ismethoddescriptor() では偽を返します。これは単に
     他のテストの方がもっと確実だからです - 例えば、ismethod() をパス
     したオブジェクトは im_func 属性 (など) を持っていると期待できます。

`isdatadescriptor(object)'
     オブジェクトがデータデスクリプタの場合に真を返します。

     データデスクリプタは __get__ および __set__ 属性の両方を持ちます。
     データデスクリプタの例は (Python 上で定義された) プロパティや
     getset やメンバです。後者のふたつは C で定義されており、
     個々の型に特有のテストも行います。そのため、Python
     の実装よりもより確 実確実です。通常、データデスクリプタは __name__
     や __doc__ 属性を持ちます (プロパティ、 getset
     、メンバは両方の属性を持っています)
     が、保証されているわけではありません。 _Added in Python version
     2.3_

`isgetsetdescriptor(object)'
     オブジェクトがgetsetデスクリプタの場合に真を返します。

     getsetとは`PyGetSetDef'構造体を用いて拡張モジュールで定義されてい
     る属性のことです。Pythonの実装の場合はそのような型はないので、このメソッ
     ドは常に`False'を返します。 _Added in Python version 2.5_

`ismemberdescriptor(object)'
     オブジェクトがメンバデスクリプタの場合に真を返します。

     メンバデスクリプタとは`PyMemberDef'構造体を用いて拡張モジュールで
     定義されている属性のことです。Pythonの実装の場合はそのような型はないの
     で、このメソッドは常に`False'を返します。 _Added in Python version
     2.5_


File: python-lib-jp.info,  Node: ソース参照,  Next: クラスと関数 2,  Prev: 型とメンバ,  Up: inspect

26.10.2 ソース参照
------------------

`getdoc(object)'
     オブジェクトのドキュメンテーション文字列を取得します。タブはスペースに
     展開されます。コードブロックに合わせてインデントされているdocstringを
     整形するため、２行目以降では行頭の空白は削除されます。

`getcomments(object)'
     オブジェクトがクラス・関数・メソッドの何れかの場合は、オブジェクトの
     ソースコードの直後にあるコメント行（複数行）を、単一の文字列として返し
     ます。オブジェクトがモジュールの場合、ソースファイルの先頭にあるコメン
     トを返します。

`getfile(object)'
     オブジェクトを定義している（テキストまたはバイナリの）ファイルの名前を
     返します。オブジェクトが組み込みモジュール・クラス・関数の場合は
     `TypeError'例外が発生します。

`getmodule(object)'
     オブジェクトを定義しているモジュールを推測します。

`getsourcefile(object)'
     オブジェクトを定義しているPythonソースファイルの名前を返します。オブジ
     ェクトが組み込みのモジュール、クラス、関数の場合には、
     `TypeError'例外が発生します。

`getsourcelines(object)'
     オブジェクトのソース行のリストと開始行番号を返します。引数にはモジュー
     ル・クラス・メソッド・関数・トレースバック・フレーム・コードオブジェク
     トを指定する事ができます。戻り値は指定したオブジェクトに対応するソース
     コードのソース行リストと元のソースファイル上での開始行となります。ソー
     スコードを取得できない場合は`IOError'が発生します。

`getsource(object)'
     オブジェクトのソースコードを返します。引数にはモジュール・クラス・メソ
     ッド・関数・トレースバック・フレーム・コードオブジェクトを指定する事が
     できます。ソースコードは単一の文字列で返します。ソースコードを取得でき
     ない場合は`IOError'が発生します。


File: python-lib-jp.info,  Node: クラスと関数 2,  Next: インタープリタ スタック,  Prev: ソース参照,  Up: inspect

26.10.3 クラスと関数
--------------------

`getclasstree(classes[, unique])'
     リストで指定したクラスの継承関係から、ネストしたリストを作成します。ネ
     ストしたリストには、直前の要素から派生したクラスが格納されます。各要素
     は長さ2のタプルで、クラスと基底クラスのタプルを格納しています。
     UNIQUE が真の場合、各クラスは戻り値のリスト内に一つだけしか格納
     されません。真でなければ、多重継承を利用したクラスとその派生クラスは複
     数回格納される場合があります。

`getargspec(func)'
     関数の引数名とデフォルト値を取得します。戻り値は長さ4のタプルで、次の
     値を返します:`(ARGS, VARARGS, VARKW,
     DEFAULTS)'。ARGSは引数名のリストです（ネストしたリストが格
     納される場合があります）。VARARGSとVARKWは`*'引数と
     `**'引数の名前で、引数がなければ`None'となります。
     DEFAULTSは引数のデフォルト値のタプルか、デフォルト値がない場合
     は`None'です。このタプルにN個
     の要素があれば、各要素はARGSの後ろからN個分の引数のデフォ
     ルト値となります。

`getargvalues(frame)'
     指定したフレームに渡された引数の情報を取得します。戻り値は長さ4のタプ
     ルで、次の値を返します:`(ARGS, VARARGS, VARKW,
     LOCALS)'。ARGSは引数名のリストです（ネストしたリストが格納
     される場合があります）。VARARGSとVARKWは`*'引数と
     `**'引数の名前で、引数がなければ`None'となります。
     LOCALSは指定したフレームのローカル変数の辞書です。

`formatargspec(args[, varargs, varkw, defaults, formatarg, formatvarargs, formatvarkw, formatvalue, join])'
     `getargspec()'で取得した4つの値を読みやすく整形します。 format*
     引数はオプションで、名前と値を文字列に変換する整形関数を指定する
     事ができます。

`formatargvalues(args[, varargs, varkw, locals, formatarg, formatvarargs, formatvarkw, formatvalue, join])'
     `getargvalues()'で取得した4つの値を読みやすく整形します。 format*
     引数はオプションで、名前と値を文字列に変換する整形関数を指定する
     事ができます。

`getmro(cls)'
     CLSクラスの基底クラス（CLS自身も含む）を、メソッドの優先順
     位順に並べたタプルを返します。結果のリスト内で各クラスは一度だけ格納さ
     れます。メソッドの優先順位はクラスの型によって異なります。非常に特殊な
     ユーザ定義のメタクラスを使用していない限り、CLSが戻り値の先頭要
     素となります。


File: python-lib-jp.info,  Node: インタープリタ スタック,  Prev: クラスと関数 2,  Up: inspect

26.10.4 インタープリタ スタック
-------------------------------

以下の関数には、戻り値として"フレームレコード"を返す関数があります。"
フレームレコード"は長さ6のタプルで、以下の値を格納しています:フレームオ
ブジェクト・ファイル名・実行中の行番号・関数名・コンテキストのソース行の
リスト・ソース行リストの実行中行のインデックス。

_Notice:_ [warning]

フレームレコードの最初の要素などのフレームオブジェクトへの参照を保存する
と、循環参照になってしまう場合があります。循環参照ができると、Pythonの循
環参照検出機能を有効にしていたとしても関連するオブジェクトが参照している
すべてのオブジェクトが解放されにくくなり、明示的に参照を削除しないとメモ
リ消費量が増大する恐れがあります。

参照の削除をPythonの循環参照検出機能にまかせる事もできますが、
`finally'節で循環参照を解除すれば確実にフレーム（とそのローカル
変数）は削除されます。また、循環参照検出機能はPythonのコンパイルオプショ
ンや``gc'. disable()'で無効とされている場合があります
ので注意が必要です。例：

     def handle_stackframe_without_leak():
         frame = inspect.currentframe()
         try:
             # do something with the frame
         finally:
             del frame

以下の関数でオプション引数CONTEXTには、戻り値のソース行リストに何
行分のソースを含めるかを指定します。ソース行リストには、実行中の行を中心
として指定された行数分のリストを返します。

`getframeinfo(frame[, context])'
     フレーム又はトレースバックオブジェクトの情報を取得します。フレームレ
     コードの先頭要素を除いた、長さ5のタプルを返します。

`getouterframes(frame[, context])'
     指定したフレームと、その外側の全フレームのフレームレコードを返します。
     外側のフレームとはFRAMEが生成されるまでのすべての関数呼び出しを
     示します。戻り値のリストの先頭はFRAMEのフレームレコードで、末尾
     の要素はFRAMEのスタックにあるもっとも外側のフレームのフレームレ
     コードとなります。

`getinnerframes(traceback[, context])'
     指定したフレームと、その内側の全フレームのフレームレコードを返します。
     内のフレームとはFRAMEから続く一連の関数呼び出しを示します。戻り
     値のリストの先頭はTRACEBACKのフレームレコードで、末尾の要素は例
     外が発生した位置を示します。

`currentframe()'
     呼び出し元のフレームオブジェクトを返します。

`stack([context])'
     呼び出し元スタックのフレームレコードのリストを返します。最初の要素は呼
     び出し元のフレームレコードで、末尾の要素はスタックにあるもっとも外側の
     フレームのフレームレコードとなります。

`trace([context])'
     実行中のフレームと処理中の例外が発生したフレームの間のフレームレコード
     のリストを返します。最初の要素は呼び出し元のフレームレコードで、末尾の
     要素は例外が発生した位置を示します。


File: python-lib-jp.info,  Node: site,  Next: user,  Prev: inspect,  Up: Python ランタイム サービス

26.11 サイト固有の設定フック
============================

サイト固有のモジュールを参照する標準の方法。

*このモジュールは初期化中に自動的にインポートされます。*
自動インポートはインタプリタの`-S'オプションで禁止できます。

このモジュールをインポートすることで、サイト固有のパスをモジュール検索
パスへ付け加えます。

前部と後部からなる最大で四つまでのディレクトリを作成することから始めます。前部には、`sys.prefix'と`sys.exec_prefix'を使用します。空の前部は省略されます。
後部には、まず空文字列を使い、次に `lib/site-packages'(Windows) または
`lib/python2.5/site-packages'、 そして `lib/site-python' (UNIX と
Macintosh)を使います。
別個の前部-後部の組み合わせのそれぞれに対して、それが存在するディレクトリを参照しているかどうかを調べ、もしそうならば`sys.path'へ追加します。そして、設定ファイルを新しく追加されたパスからも検索します。 

パス設定ファイルは`PACKAGE.pth'という形式の名前をもつファイルで、上の4つのディレクトリのひとつにあります。その内容は`sys.path'に追加される追加項目(一行に一つ)です。存在しない項目は`sys.path'へは決して追加されませんが、項目が(ファイルではなく)ディレクトリを参照しているかどうかはチェックされません。項目が`sys.path'へ二回以上追加されることはありません。空行と`#'で始まる行は読み飛ばされます。`import'で始まる行は実行されます。 

例えば、`sys.prefix'と`sys.exec_prefix'が`/usr/local'に設定されていると仮定します。そのときPython
2.5
ライブラリは`/usr/local/lib/python2.5'にインストールされています(ここで、`sys.version'の最初の三文字だけがインストールパス名を作るために使われます)。ここにはサブディレクトリ`/usr/local/lib/python2.5/site-packages'があり、その中に三つのサブディレクトリ`foo'、`bar'および`spam'と二つのパス設定ファイル`foo.pth'と`bar.pth'をもつと仮定します。`foo.pth'には以下のものが記載されていると想定してください:

     # foo package configuration

     foo
     bar
     bletch

また、`bar.pth'には:

     # bar package configuration

     bar

が記載されているとします。そのとき、次のディレクトリが`sys.path'へこの順番んで追加されます:

     /usr/local/lib/python2.3/site-packages/bar
     /usr/local/lib/python2.3/site-packages/foo

`bletch'は存在しないため省略されるということに注意してください。`bar'ディレクトリは`foo'ディレクトリの前に来ます。なぜなら、`bar.pth'がアルファベット順で`foo.pth'の前に来るからです。また、`spam'はどちらのパス設定ファイルにも記載されていないため、省略されます。

これらのパス操作の後に、`sitecustomize' という名前のモジュールをインポートしようします。そのモジュールは任意のサイト固有のカスタマイゼーションを行うことができます。`ImportError'例外が発生してこのインポートに失敗した場合は、何も表示せずに無視されます。

いくつかの非UNIXシステムでは、`sys.prefix'と`sys.exec_prefix'は空で、パス操作は省略されます。しかし、`sitecustomize' のインポートはそのときでも試みられます。


File: python-lib-jp.info,  Node: user,  Next: fpectl,  Prev: site,  Up: Python ランタイム サービス

26.12 ユーザー設定のフック
==========================

ユーザー設定を参照するための標準的な方法を提供するモジュー ル

ポリシーとして、Pythonは起動時にユーザー毎の設定を行うコードを実行することは
しません(ただし対話型セッションで環境変数`PYTHONSTARTUP'が設定されて
いた場合にはそのスクリプトを実行します。)。

しかしながら、プログラムやサイトによっては、プログラムが要求した時に
ユーザーごとの設定ファイルを実行できると便利なこともあります。このモジュー
ルはそのような機構を実装しています。この機構を利用したいプログラムでは、
以下の文を実行してください。

     import user

`user'モジュールはユーザーのホームディレクトリの
`.pythonrc.py'ファイルを探し、オープンできるならグローバル名前空間
で実行します(`execfile()' を利用します)。
この段階で発生したエラーはcatchされません。`user'モジュー
ルをimportしたプログラムに影響します。ホームディレクトリは環境変数
`HOME'が仮定されていますが、もし設定されていなければカレントディ
レクトリが使われます。

ユーザーの`.pythonrc.py'ではPythonのバージョンに従って異なる動作を
行うために`sys.version'のテストを行うことが 考えられます。

ユーザーへの警告: `.pythonrc.py'ファイルに書く内容には慎重になって
ください。どのプログラムが利用しているかわからない状況で、標準のモジュール
や関数のふるまいを替えることはおすすめできません。

この機構を使おうとするプログラマへの提案:
あなたのパッケージ向けのオプションをユーザーが設定できるようにするシンプ
ルな方法は、`.pythonrc.py'ファイルで変数を定義して、あなたのプログ
ラムでテストする方法です。たとえば、`spam'モジュールで
メッセージ出力のレベルを替える `user.spam_verbose'変数を参照するに
は以下のようにします:

     import user

     verbose = bool(getattr(user, "spam_verbose", 0))

(ユーザが`spam_verbose'を
ファイル`.pythonrc.py'内で定義していない時に`getattr()'
の3引数形式は使われます。)

大規模な設定の必要があるプログラムではプログラムごとの設定ファイルを作る
といいです。

セキュリティやプライバシーに配慮するプログラムではこのモジュールをimport
し_ない_でください。このモジュールを使うと、ユーザーは
`.pythonrc.py'に任意のコードを書くことで簡単に侵入することができて
しまいます。

汎用のモジュールではこのモジュールをimportし_ない_でください。
importしたプログラムの動作にも影響してしまいます。

See also:
     *Note site:: サイト毎のカスタマイズを行う機構


File: python-lib-jp.info,  Node: fpectl,  Prev: user,  Up: Python ランタイム サービス

26.13 浮動小数点例外の制御
==========================

Provide control for floating point exception handling.
浮動小数点例外処理の制御。

ほとんどのコンピュータはいわゆるIEEE-754標準に準拠した浮動小数点演算 を実行します。実際のどんなコンピュータでも、浮動小数点演算が普通の浮動小数点数では表せない結果になることがあります。例えば、次を試してください。

     >>> import math
     >>> math.exp(1000)
     inf
     >>> math.exp(1000) / math.exp(1000)
     nan

(上の例は多くのプラットホームで動作します。DEC
Alphaは例外かもしれません。)
"Inf"は"infinity(無限)"を意味するIEEE-754における特殊な非数値の値で、"nan"は"not
a
number(数ではない)"を意味します。ここで留意すべき点は、その計算を行うようにPythonに求めたときに非数値の結果以外に特別なことは何も起きないというです。事実、それはIEEE-754標準に規定されたデフォルトのふるまいで、それで良ければここで読むのを止めてください。

いくつかの環境では、誤った演算がなされたところで例外を発生し、処理を止めることがより良いでしょう。`fpectl'モジュールはそんな状況で使うためのものです。いくつかのハードウェア製造メーカーの浮動小数点ユニットを制御できるようにします。つまり、IEEE-754例外Division
by Zero、OverflowあるいはInvalid
Operationが起きたときはいつでも`SIGFPE'が生成させるように、ユーザが切り替えられるようにします。あなたのpythonシステムを構成しているCコードの中へ挿入される一組のラッパーマクロと協力して、`SIGFPE'は捕捉され、Python
`FloatingPointError'例外へ変換されます。

`fpectl'モジュールは次の関数を定義しています。また、所定の例外を発生します:

`turnon_sigfpe()'
     `SIGFPE'を生成するように切り替え、適切なシグナルハンドラを設定します。

`turnoff_sigfpe()'
     浮動小数点例外のデフォルトの処理に再設定します。

`FloatingPointError'
     `turnon_sigfpe()'が実行された後に、IEEE-754例外であるDivision by
     Zero、OverflowまたはInvalid
     operationの一つを発生する浮動小数点演算は、次にこの標準Python例外を発生します。

* Menu:

* 例 14::
* 制限と他に考慮すべきこと::


File: python-lib-jp.info,  Node: 例 14,  Next: 制限と他に考慮すべきこと,  Prev: fpectl,  Up: fpectl

26.13.1 例
----------

以下の例は`fpectl'モジュールの使用を開始する方法とモジュールのテスト演算について示しています。

     >>> import fpectl
     >>> import fpetest
     >>> fpectl.turnon_sigfpe()
     >>> fpetest.test()
     overflow        PASS
     FloatingPointError: Overflow

     div by 0        PASS
     FloatingPointError: Division by zero
       [ more output from test elided ]
     >>> import math
     >>> math.exp(1000)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     FloatingPointError: in math_1


File: python-lib-jp.info,  Node: 制限と他に考慮すべきこと,  Prev: 例 14,  Up: fpectl

26.13.2 制限と他に考慮すべきこと
--------------------------------

特定のプロセッサをIEEE-754浮動小数点エラーを捕らえるように設定することは、現在アーキテクチャごとの基準に基づきカスタムコードを必要とします。あなたの特殊なハードウェアを制御するために`fpectl'を修正することもできます。

IEEE-754例外のPython例外への変換には、ラッパーマクロ`PyFPE_START_PROTECT'と`PyFPE_END_PROTECT'があなたのコードに適切な方法で挿入されていることが必要です。Python自身は`fpectl'モジュールをサポートするために修正されていますが、数値解析にとって興味ある多くの他のコードはそうではありません。

`fpectl'モジュールはスレッドセーフではありません。

See also:
     このモジュールがどのように動作するのかについてより学習するときに、ソースディストリビューションの中のいくつかのファイルは興味を引くものでしょう。インクルードファイル`Include/pyfpe.h'では、このモジュールの実装について同じ長さで議論されています。`Modules/fpetestmodule.c'には、いくつかの使い方の例があります。多くの追加の例が`Objects/floatobject.c'にあります。


File: python-lib-jp.info,  Node: カスタム Python インタプリタ,  Next: 制限実行 restricted execution,  Prev: Python ランタイム サービス,  Up: Top

27 カスタム Python インタプリタ
*******************************

この章で解説されるモジュールで
Pythonの対話インタプリタに似たインタフェー
スを書くことができます。もしPythonそのもの以外に何か特殊な機能をサポー
トした Pythonインタプリタを作りたければ、`code'モジュールを参照
してください。(`codeop'モジュールはより低レベルで、不完全(かもし
れない) Pythonコード断片のコンパイルをサポートするために使われます。)

この章で解説されるモジュールの完全な一覧は:

* Menu:

* code::
* codeop::


File: python-lib-jp.info,  Node: code,  Next: codeop,  Prev: カスタム Python インタプリタ,  Up: カスタム Python インタプリタ

27.1 インタプリタ基底クラス
===========================

対話的Pythonインタプリタのための基底クラス。

`code'モジュールはread-eval-print(読み込み-評価-表示)ループをPythonで実装するための機能を提供します。対話的なインタプリタプロンプトを提供するアプリケーションを作るために使える二つのクラスと便利な関数が含まれています。

`InteractiveInterpreter([locals])'
     このクラスは構文解析とインタプリタ状態(ユーザの名前空間)を取り扱います。入力バッファリングやプロンプト出力、または入力ファイル指定を扱いません(ファイル名は常に明示的に渡されます)。オプションのLOCALS引数はその中でコードが実行される辞書を指定します。その初期値は、キー`'__name__''が`'__console__''に設定され、キー`'__doc__''が`None'に設定された新しく作られた辞書です。

`InteractiveConsole([locals[, filename]])'
     対話的なPythonインタプリタの振る舞いを厳密にエミュレートします。このクラスは`InteractiveInterpreter'を元に作られていて、通常の`sys.ps1'と`sys.ps2'をつかったプロンプト出力と入力バッファリングが追加されています。

`interact([banner[, readfunc[, local]]])'
     read-eval-printループを実行するための便利な関数。これは`InteractiveConsole'の新しいインスタンスを作り、READFUNCが与えられた場合は`raw_input()'メソッドとして使われるように設定します。LOCALが与えられた場合は、インタプリタループのデフォルト名前空間として使うために`InteractiveConsole'コンストラクタへ渡されます。そして、インスタンスの`interact()'メソッドは見出しとして使うために渡されるBANNERを受け取り実行されます。コンソールオブジェクトは使われた後捨てられます。

`compile_command(source[, filename[, symbol]])'
     この関数はPythonのインタプリタメインループ(別名、read-eval-printループ)をエミュレートしようとするプログラムにとって役に立ちます。扱いにくい部分は、ユーザが(完全なコマンドや構文エラーではなく)さらにテキストを入力すれば完全になりうる不完全なコマンドを入力したときを決定することです。この関数は_ほとんど_の場合に実際のインタプリタメインループと同じ決定を行います。

     SOURCEはソース文字列です。FILENAMEはオプションのソースが読み出されたファイル名で、デフォルトで`'<input>''です。SYMBOLはオプションの文法の開始記号で、`'single''
     (デフォルト)または`'eval''のどちらかにすべきです。

     コマンドが完全で有効ならば、コードオブジェクトを返します(`compile(SOURCE,
     FILENAME,
     SYMBOL)'と同じ)。コマンドが完全でないならば、`None'を返します。コマンドが完全で構文エラーを含む場合は、`SyntaxError'を発生させます。または、コマンドが無効なリテラルを含む場合は、`OverflowError'もしくは`ValueError'を発生させます。

* Menu:

* 対話的なインタプリタオブジェクト::
* 対話的なコンソールオブジェクト::


File: python-lib-jp.info,  Node: 対話的なインタプリタオブジェクト,  Next: 対話的なコンソールオブジェクト,  Prev: code,  Up: code

27.1.1 対話的なインタプリタオブジェクト
---------------------------------------

`runsource(source[, filename[, symbol]])'
     インタプリタ内のあるソースをコンパイルし実行します。引数は`compile_command()'のものと同じです。FILENAMEのデフォルトは`'<input>''で、SYMBOLは`'single''です。あるいくつかのことが起きる可能性があります:

        *
          入力はが正しくない。`compile_command()'が例外(`SyntaxError'か`OverflowError')を起こした場合。`showsyntaxerror()'メソッドの呼び出によって、構文トレースバックが表示されるでしょう。`runsource()'は`False'を返します。

        *
          入力が完全でなく、さらに入力が必要。`compile_command()'が`None'を返した場合。`runsource()'は`True'を返します。

        *
          入力が完全。`compile_command()'がコードオブジェクトを返した場合。(`SystemExit'を除く実行時例外も処理する)`runcode()'を呼び出すことによって、コードは実行されます。`runsource()'は`False'を返します。

     次の行を要求するために`sys.ps1'か`sys.ps2'のどちらを使うかを決定するために、戻り値を利用できます。

`runcode(code)'
     コードオブジェクトを実行します。例外が生じたときは、トレースバックを表示するために`showtraceback()'が呼び出されます。伝わることが許されている`SystemExit'を除くすべての例外が捉えられます。

     `KeyboardInterrupt'についての注意。このコードの他の場所でこの例外が生じる可能性がありますし、常に捕らえることができるとは限りません。呼び出し側はそれを処理するために準備しておくべきです。

`showsyntaxerror([filename])'
     起きたばかりの構文エラーを表示します。複数の構文エラーに対して一つあるのではないため、これはスタックトレースを表示しません。FILENAMEが与えられた場合は、Pythonのパーサが与えるデフォルトのファイル名の代わりに例外の中へ入れられます。なぜなら、文字列から読み込んでいるときはパーサは常に`'<string>''を使うからです。出力は`write()'メソッドによって書き込まれます。

`showtraceback()'
     起きたばかりの例外を表示します。スタックの最初の項目を取り除きます。なぜなら、それはインタプリタオブジェクトの実装の内部にあるからです。出力は`write()'メソッドによて書き込まれます。

`write(data)'
     文字列を標準エラーストリーム(`sys.stderr')へ書き込みます。必要に応じて適切な出力処理を提供するために、導出クラスはこれをオーバーライドすべきです。


File: python-lib-jp.info,  Node: 対話的なコンソールオブジェクト,  Prev: 対話的なインタプリタオブジェクト,  Up: code

27.1.2 対話的なコンソールオブジェクト
-------------------------------------

`InteractiveConsole'クラスは`InteractiveInterpreter'のサブクラスです。以下の追加メソッドだけでなく、インタプリタオブジェクトのすべてのメソッドも提供します。

`interact([banner])'
     対話的なPythonコンソールをそっくりにエミュレートします。オプションのbanner引数は最初のやりとりの前に表示するバナーを指定します。デフォルトでは、標準Pythonインタプリタが表示するものと同じようなバナーを表示します。それに続けて、実際のインタプリタと混乱しないように(とても似ているから!)括弧の中にコンソールオブジェクトのクラス名を表示します。

`push(line)'
     ソーステキストの一行をインタプリタへ送ります。その行の末尾に改行がついていてはいけません。内部に改行を持っているかもしれません。その行はバッファへ追加され、ソースとして連結された内容が渡されインタプリタの`runsource()'メソッドが呼び出されます。コマンドが実行されたか、有効であることをこれが示している場合は、バッファはリセットされます。そうでなければ、コマンドが不完全で、その行が付加された後のままバッファは残されます。さらに入力が必要ならば、戻り値は`True'です。その行がある方法で処理されたならば、`False'です(これは`runsource()'と同じです)。

`resetbuffer()'
     入力バッファから処理されていないソーステキストを取り除きます。

`raw_input([prompt])'
     プロンプトを書き込み、一行を読み込みます。返る行は末尾に改行を含みません。ユーザが`EOF'キーシーケンスを入力したときは、`EOFError'を発生させます。基本実装では、組み込み関数`raw_input()'を使います。サブクラスはこれを異なる実装と置き換えるかもしれません。


File: python-lib-jp.info,  Node: codeop,  Prev: code,  Up: カスタム Python インタプリタ

27.2 Pythonコードをコンパイルする
=================================

(完全ではないかもしれない)Pythonコードをコンパイルする。

`code'モジュールで行われているようなPythonのread-eval-printループをエミュレートするユーティリティを`codeop'モジュールは提供します。結果的に、直接モジュールを使いたいとは思わないかもしれません。あなたのプログラムにこのようなループを含めたい場合は、代わりに`code'モジュールを使うことをおそらく望むでしょう。

この仕事には二つの部分があります:

  1. 入力の一行がPythonの文として完全であるかどうかを見分けられること:
     簡単に言えば、次が``>>>~''か、あるいは``...~''かどうかを見分けます。

  2.
     どのfuture文をユーザが入力したのかを覚えていること。したがって、実質的にそれに続く入力をこれらとともにコンパイルすることができます。

`codeop'モジュールはこうしたことのそれぞれを行う方法とそれら両方を行う方法を提供します。

前者は実行するには:

`compile_command(source[, filename[, symbol]])'
     Pythonコードの文字列であるべきSOURCEをコンパイルしてみて、SOURCEが有効なPythonコードの場合はコードオブジェクトを返します。このような場合、コードオブジェクトのファイル名属性は、デフォルトで`'<input>''であるFILENAMEでしょう。SOURCEが有効なPythonコードでは_ない_が、有効なPythonコードの接頭語である場合には、`None'を返します。

     SOURCEに問題がある場合は、例外を発生させます。無効なPython構文がある場合は、`SyntaxError'を発生させます。また、無効なリテラルがある場合は、`OverflowError'または`ValueError'を発生させます。

     SYMBOL引数はSOURCEが文としてコンパイルされるか(`'single''、デフォルト)、または式としてコンパイルされたかどうかを決定します(`'eval'')。他のどんな値も`ValueError'を発生させる原因となります。

     *警告:*
     ソースの終わりに達する前に、成功した結果をもってパーサは構文解析を止めることが(できそうではなく)できます。このような場合、後ろに続く記号はエラーとならずに無視されます。例えば、改行が後ろに付くバックスラッシュには不定のゴミが付いているかもしれません。パーサのAPIがより良くなればすぐに、これは修正されるでしょう。

`Compile()'
     このクラスのインスタンスは組み込み関数`compile()'とシグネチャが一致する`__call__()'メソッドを持っていますが、インスタンスが`__future__'文を含むプログラムテキストをコンパイルする場合は、インスタンスは有効なその文とともに続くすべてのプログラムテキストを'覚えていて'コンパイルするという違いがあります。

`CommandCompiler()'
     このクラスのインスタンスは`compile_command()'とシグネチャが一致する`__call__()'メソッドを持っています。インスタンスが`__future__'文を含むプログラムテキストをコンパイルする場合に、インスタンスは有効なその文とともにそれに続くすべてのプログラムテキストを'覚えていて'コンパイルするという違いがあります。

バージョン間の互換性についての注意:
`Compile'と`CommandCompiler'はPython
2.2で導入されました。2.2のfuture-tracking機能を有効にするだけでなく、2.1とPythonのより以前のバージョンとの互換性も保ちたい場合は、次のようにかくことができます

     try:
         from codeop import CommandCompiler
         compile_command = CommandCompiler()
         del CommandCompiler
     except ImportError:
         from codeop import compile_command

これは影響の小さい変更ですが、あなたのプログラムにおそらく望まれないグローバル状態を導入します。または、次のように書くこともできます:

     try:
         from codeop import CommandCompiler
     except ImportError:
         def CommandCompiler():
             from codeop import compile_command
             return compile_command

そして、新たなコンパイラオブジェクトが必要となるたびに`CommandCompiler'を呼び出します。


File: python-lib-jp.info,  Node: 制限実行 restricted execution,  Next: モジュールのインポート,  Prev: カスタム Python インタプリタ,  Up: Top

28 制限実行 (restricted execution)
**********************************

_Notice:_ [warning] Python 2.3
では、既知の容易に修正できないセキュリティーホール
のために、これらのモジュールは無効にされています。 `rexec' や `Bastion'
モジュールを使った古いコード
を読むときに助けになるよう、モジュールのドキュメントだけは
残されています。

_制限実行 (restricted execution)_ とは、信頼できるコード
と信頼できないコードを区別できるようにするための Python における
基本的なフレームワークです。このフレームワークは、信頼できる Python
コード (_スーパバイザ (supervisor)_) が、
パーミッションに制限のかけられた "拘束セル (padded cell)"
を生成し、このセル中で信頼のおけないコードを実行するという概念に
基づいています。信頼のおけないコードはこの拘束セルを破ることが
できず、信頼されたコードで提供され、管理されたインタフェースを
介してのみ、傷つきやすいシステムリソースとやりとりすることができます。
"制限実行" という用語は、"安全な Python (safe-Python)"
を裏から支えるものです。というのは、真の安全を定義する
ことは難しく、制限された環境を生成する方法によって決められるからです。
制限された環境は入れ子にすることができ、このとき内側のセルは
より縮小されることはあるが決して拡大されることのない特権を持った
サブセルを生成します。

Python の制限実行モデルの興味深い側面は、信頼されないコードに
提供されるインタフェースが、信頼されるコードに提供されるそれらと
同じ名前を持つということです。このため、制限された環境で動作
するよう設計されたコードを書く上で特殊なインタフェースを学ぶ
必要がありません。また、拘束セルの厳密な性質はスーパバイザによって
決められるため、アプリケーションによって異なる制限を課すことが
できます。例えば、信頼されないコードが指定したディレクトリ内の
何らかのファイルを読み出すが決して書き込まないということが "安全"
と考えられるかもしれません。この場合、スーパバイザは組み込みの `open()'
関数について、MODE パラメタが `'w''
の時に例外を送出するように再定義できます。また例えば、"安全" とは、
FILENAME パラメタに対して `chroot()' に似た
操作を施して、ルートパスがファイルシステム上の何らかの安全な "砂場
(sandbox)" 領域に対する相対パスになるようにすることかも
しれません。この場合でも、信頼されないコードは依然として、
もとの呼び出しインタフェースを持ったままの組み込みの`open()'
関数を制限環境中に見出します。ここでは、関数に対する意味付け
(semantics) は同じですが、許可されないパラメタが使われようとしている
とスーパバイザが判断した場合には `IOError' が送出されます。

Python のランタイムシステムは、特定のコードブロックが制限実行モード
かどうかを、グローバル変数の中の `__builtins__'
オブジェクトの一意性をもとに判断します: オブジェクトが 標準の
`__builtin__' モジュール (の辞書) の場合、
コードは非制限下にあるとみなされます。それ以外は制限下にあると
みなされます。

制限実行モードで動作する Python コードは、拘束セルから侵出しないように
設計された数多くの制限に直面します。例えば、関数オブジェクト 属性
`func_globals' や、クラスおよびインスタンスオブジェクトの 属性
`__dict__' は利用できません。

二つのモジュールが、制限実行環境を立ち上げるためのフレームワークを
提供しています:

See also:
     `Grail Home Page' {Python で書かれたインターネットブラウザ Grail
     です。Python
     で書かれたアプレットをサポートするために、上記のモジュールを使っています。Grail
     における Python 制限実行モードの利用に関する詳しい情報は、Web
     サイトで入手することができます。}

* Menu:

* rexec::
* Bastion::


File: python-lib-jp.info,  Node: rexec,  Next: Bastion,  Prev: 制限実行 restricted execution,  Up: 制限実行 restricted execution

28.1 制限実行のフレームワーク
=============================

基本的な制限実行フレームワーク。 _Changed in Python version 2.3_

_Notice:_ [warning]
このドキュメントは、`rexec'モジュールを使用している古い
コードを読む際の参照用として残されています。

このモジュールには `RExec' クラスが含まれています。このクラスは、
`r_eval()'、 `r_execfile()'、 `r_exec()'および `r_import()'
メソッドをサポートし、これらは標準の Python 関数 `eval()'、
`execfile()' および `exec' と `import' 文の制限されたバージョンです。
この制限された環境で実行されるコードは、安全であると見なされた
モジュールや関数だけにアクセスします；`RExec' をサブクラス化すれば、
望むように能力を追加および削除できます。

_Notice:_ [warning] `rexec'
モジュールは、下記のように動作するべく設計されては
いますが、注意深く書かれたコードなら利用できてしまうかもしれない、
既知の脆弱性がいくつかあります。従って、"製品レベル" のセキュリティ
を要する状況では、`rexec' の動作をあてにするべきではありません。
製品レベルのセキュリティを求めるなら、サブプロセスを介した実行や、
あるいは処理するコードとデータの両方に対する非常に注意深い "浄化"
が必要でしょう。上記の代わりに、`rexec' の既知の
脆弱性に対するパッチ当ての手伝いも歓迎します。

_Notice:_ `RExec' クラスは、プログラムコードによる
ディスクファイルの読み書きや TCP/IP ソケットの利用といった、
安全でない操作の実行を防ぐことができます。しかし、
プログラムコードよる非常に大量のメモリや処理時間の消費に対して
防御することはできません。

`RExec([hooks[, verbose]])'
     `RExec' クラスのインスタンスを返します。

     HOOKS は、`RHooks' クラスあるいはそのサブクラスの
     インスタンスです。HOOKS が省略されているか `None' であれば、
     デフォルトの `RHooks' クラスがインスタンス化されます。 `rexec'
     モジュールが (組み込みモジュールを含む) あるモジュールを
     探したり、あるモジュールのコードを読んだりする時は常に、 `rexec'
     がじかにファイルシステムに出て行くことはありません。
     その代わり、あらかじめ `RHooks' クラスに渡しておいたり、
     コンストラクタで生成された `RHooks' インスタンスのメソッドを
     呼び出します。

     (実際には、`RExec' オブジェクトはこれらを呼び出しません --
     呼び出しは、`RExec' オブジェクトの一部であるモジュールローダ
     オブジェクトによって行われます。
     これによって別のレベルの柔軟性が実現されます。この柔軟性は、制限された
     環境内で`import' 機構を変更する時に役に立ちます。 )

     代替の `RHooks' オブジェクトを提供することで、モジュールを
     インポートする際に行われるファイルシステムへのアクセスを制御する
     ことができます。このとき、各々のアクセスが行われる順番を制御する
     実際のアルゴリズムは変更されません。 例えば、`RHooks'
     オブジェクトを置き換えて、ILU のような ある種の RPC
     メカニズムを介することで、全てのファイルシステムの要求を
     どこかにあるファイルサーバに渡すことができます。 Grail
     のアプレットローダは、アプレットを URL からディレクトリ上に import
     する際にこの機構を使っています。

     もし VERBOSEが true であれば、追加のデバッグ出力が標準出力に
     送られます。

制限された環境で実行するコードも、やはり `sys.exit()' 関数を
呼ぶことができることを知っておくことは大事なことです。制限された
コードがインタプリタから抜けだすことを許さないためには、いつでも、
制限されたコードが、`SystemExit' 例外をキャッチする `try'/`except'
文とともに実行するように、呼び出しを防御します。 制限された環境から
`sys.exit()'関数を除去するだけでは不十分です -
制限されたコードは、やはり `raise SystemExit'
を使うことができてしまいます。
`SystemExit'を取り除くことも、合理的なオプションではありません；
いくつかのライブラリコードはこれを使っていますし、これが利用できなくなると
中断してしまうでしょう。

See also:
     `Grail のホームページ'{Grail は すべて Python で書かれた Web
     ブラウザです。これは、 `rexec'モジュールを、Python
     アプレットをサポートするのに
     使っていて、このモジュールの使用例として使うことが できます。}

* Menu:

* RExec オブジェクト::
* 制限された環境を定義する::
* 例 15::


File: python-lib-jp.info,  Node: RExec オブジェクト,  Next: 制限された環境を定義する,  Prev: rexec,  Up: rexec

28.1.1 RExec オブジェクト
-------------------------

`RExec' インスタンスは以下のメソッドをサポートします：

`r_eval(code)'
     CODE は、Python の式を含む文字列か、あるいはコンパイルされた
     コードオブジェクトのどちらかでなければなりません。そしてこれらは制限された
     環境の `__main__' モジュールで評価されます。式あるいはコード
     オブジェクトの値が返されます。

`r_exec(code)'
     CODE は、1行以上の Python コードを含む文字列か、コンパイルされた
     コードオブジェクトのどちらかでなければなりません。そしてこれらは、
     制限された環境の `__main__' モジュールで実行されます。

`r_execfile(filename)'
     ファイル FILENAME 内の Python コードを、制限された環境の
     `__main__' モジュールで実行します。

名前が `s_' で始まるメソッドは、`r_'で始まる関数と同様ですが、
そのコードは、標準 I/O ストリーム `sys.stdin'、 `sys.stderr' および
`sys.stdout' の制限されたバージョンへの アクセスが許されています。

`s_eval(code)'
     CODE は、Python 式を含む文字列でなければなりません。そして
     制限された環境で評価されます。

`s_exec(code)'
     CODE は、1行以上のPython
     コードを含む文字列でなければなりません。そして
     制限された環境で実行されます。

`s_execfile(code)'
     ファイル FILENAME に含まれた Python コードを制限された環境で
     実行します。

`RExec' オブジェクトは、制限された環境で実行されるコードによって
暗黙のうちに呼ばれる、さまざまなメソッドもサポートしなければなりません。
これらのメソッドをサブクラス内でオーバライドすることによって、制限された環境が
強制するポリシを変更します。

`r_import(modulename[, globals[, locals[, fromlist]]])'
     モジュール MODULENAME をインポートし、もしそのモジュールが
     安全でないとみなされるなら、`ImportError' 例外を発生します。

`r_open(filename[, mode[, bufsize]])'
     `open()' が制限された環境で呼ばれるとき、呼ばれるメソッドです。
     引数は `open()'のものと同じであり、ファイルオブジェクト
     (あるいはファイルオブジェクトと互換性のあるクラスインスタンス)が
     返されます。 `RExec'のデフォルトの動作は、任意のファイルを
     読み取り用にオープンすることを許可しますが、ファイルに書き込もうとする
     ことは許しません。より制限の少ない `r_open()'の実装については、
     以下の例を見て下さい。

`r_reload(module)'
     モジュールオブジェクト MODULE
     を再ロードして、それを再解析し再初期化します。

`r_unload(module)'
     モジュールオブジェクト MODULEをアンロードします
     (それを制限された環境の `sys.modules' 辞書から取りのぞきます)。

および制限された標準 I/O ストリームへのアクセスが可能な同等のもの：

`s_import(modulename[, globals[, locals[, fromlist]]])'
     モジュール MODULENAME をインポートし、もしそのモジュールが
     安全でないとみなされるなら、`ImportError' 例外を発生します。

`s_reload(module)'
     モジュールオブジェクト MODULE
     を再ロードして、それを再解析し再初期化します。

`s_unload(module)'
     モジュールオブジェクト MODULEをアンロードします。


File: python-lib-jp.info,  Node: 制限された環境を定義する,  Next: 例 15,  Prev: RExec オブジェクト,  Up: rexec

28.1.2 制限された環境を定義する
-------------------------------

`RExec' クラスには以下のクラス属性があります。それらは、 `__init__()'
メソッドが使います。それらを既存の
インスタンス上で変更しても何の効果もありません；そうする代わりに、
`RExec' のサブクラスを作成して、そのクラス定義でそれらに
新しい値を割り当てます。そうすると、新しいクラスのインスタンスは、
これらの新しい値を使用します。これらの属性のすべては、文字列のタプルです。

`nok_builtin_names'
     制限された環境で実行するプログラムでは利用でき_ない_であろう、
     組み込み関数の名前を格納しています。 `RExec'に対する値は、
     `('open', 'reload', '__import__')' です。
     (これは例外です。というのは、組み込み関数のほとんど大多数は
     無害だからです。この変数をオーバライドしたいサブクラスは、
     基本クラスからの値から始めて、 追加した許されない関数を連結して
     いかなければなりません - 危険な関数が新しく Python
     に追加された時は、 それらも、このモジュールに追加します。)

`ok_builtin_modules'
     安全にインポートできる組み込みモジュールの名前を格納しています。
     `RExec'に対する値は、 `('audioop', 'array', 'binascii', 'cmath',
     'errno', 'imageop', 'marshal', 'math', 'md5', 'operator',
     'parser', 'regex', 'select', 'sha', '_sre', 'strop', 'struct',
     'time')' です。この変数をオーバーライドする場合も、
     同様な注意が適用されます - 基本クラスからの値を使って始めます。

`ok_path'
     `import'が制限された環境で実行される時に検索される
     ディレクトリーを格納しています。
     `RExec'に対する値は、(モジュールがロードされた時は)
     制限されないコードの `sys.path' と同一です。

`ok_posix_names'
     制限された環境で実行するプログラムで利用できる、 `os'
     モジュール内の関数の名前を格納しています。 `RExec'に対する値は、
     `('error', 'fstat', 'listdir', 'lstat', 'readlink', 'stat',
     'times', 'uname', 'getpid', 'getppid', 'getcwd', 'getuid',
     'getgid', 'geteuid', 'getegid')' です。

`ok_sys_names'
     制限された環境で実行するプログラムで利用できる、 `sys'
     モジュール内の関数名と変数名を格納しています。
     `RExec'に対する値は、 `('ps1', 'ps2', 'copyright', 'version',
     'platform', 'exit', 'maxint')'です。

`ok_file_types'
     モジュールがロードすることを許されているファイルタイプを格納しています。
     各ファイルタイプは、`imp'モジュールで定義された整数定数です。
     意味のある値は、`PY_SOURCE'、`PY_COMPILED' および `C_EXTENSION'
     です。`RExec'に対する値は、`(C_EXTENSION,
     PY_SOURCE)'です。サブクラスで
     `PY_COMPILED'を追加することは推奨されません；
     攻撃者が、バイトコンパイルしたでっちあげのファイル(`.pyc')を、
     例えば、あなたの公開 FTP サーバの `/tmp' に書いたり、 `/incoming'
     にアップロードしたりして、とにかくあなたのファイルシステム内に
     置くことで、制限された実行モードから抜け出ることができるかもしれないからです。


File: python-lib-jp.info,  Node: 例 15,  Prev: 制限された環境を定義する,  Up: rexec

28.1.3 例
---------

標準の `RExec' クラスよりも、若干、もっと緩めたポリシを
望んでいるとしましょう。例えば、もし `/tmp' 内のファイルへの書き込みを
喜んで許すならば、`RExec' クラスを次のように サブクラス化できます：

     class TmpWriterRExec(rexec.RExec):
         def r_open(self, file, mode='r', buf=-1):
             if mode in ('r', 'rb'):
                 pass
             elif mode in ('w', 'wb', 'a', 'ab'):
                 # ファイル名をチェックします :  /tmp/ で始まらなければなりません
                 if file[:5]!='/tmp/':
                     raise IOError, " /tmp 以外へは書き込みできません"
                 elif (string.find(file, '/../') >= 0 or
                      file[:3] == '../' or file[-3:] == '/..'):
                     raise IOError, "ファイル名の '..' は禁じられています"
             else: raise IOError, "open() モードが正しくありません"
             return open(file, mode, buf)

上のコードは、完全に正しいファイル名でも、時には禁止する場合があることに
注意して下さい；例えば、制限された環境でのコードでは、`/tmp/foo/../bar'
というファイルはオープンできないかもしれません。これを修正するには、
`r_open()' メソッドが、そのファイル名を `/tmp/bar'に単純化
しなければなりません。そのためには、ファイル名を分割して、それにさまざまな
操作を行う必要があります。セキュリティが重大な場合には、
より複雑で、微妙なセキュリティホールを抱え込むかもしれない、一般性のある
コードよりも、 制限が余りにあり過ぎるとしても単純なコードを書く方が、
望ましいでしょう。


File: python-lib-jp.info,  Node: Bastion,  Prev: rexec,  Up: 制限実行 restricted execution

28.2 オブジェクトに対するアクセスの制限
=======================================

オブジェクトに対するアクセスの制限を提供する。

_Changed in Python version 2.3_

_Notice:_ [warning]
このドキュメントは、Bastionモジュールを使用している古いコードを読む際の
参照用として残されています。

辞書によると、バスティアン (bastion、要塞) とは、"防衛された
領域や地点"、または "最後の砦と考えられているもの" であり、
オブジェクトの特定の属性へのアクセスを禁じる方法を提供する
このモジュールにふさわしい名前です。制限モード下のプログラム
に対して、あるオブジェクトにおける特定の安全な属性へのアクセス
を許可し、かつその他の安全でない属性へのアクセスを拒否する
には、要塞オブジェクトは常に `rexec' モジュールと共に
使われなければなりません。

`Bastion(object[, filter[, name[, class]]])'
     オブジェクト OBJECT を保護し、オブジェクトに対する要塞
     オブジェクトを返します。オブジェクトの属性に対するアクセスの試みは
     全て、FILTER 関数によって認可されなければなりません; アクセス
     が拒否された場合 `AttributeError' 例外が送出されます。

     FILTER が存在する場合、この関数は属性名を含む文字列を受理
     し、その属性に対するアクセスが許可される場合には真を返さなければ
     なりません; FILTER が偽を返す場合、アクセスは拒否されます。
     標準のフィルタは、アンダースコア (`_') で始まる全ての
     関数に対するアクセスを拒否します。NAME の値が与えられた場合、
     要塞オブジェクトの文字列表現は `<Bastion for NAME>' に なります;
     そうでない場合、`repr(OBJECT)' が使われます。

     CLASS が存在する場合、`BastionClass' のサブクラスで
     なくてはなりません; 詳細は `bastion.py' のコードを参照して
     ください。稀に `BastionClass' の標準設定を上書きする必要
     ほとんどないはずです。

`BastionClass(getfunc, name)'
     実際に要塞オブジェクトを実装しているクラスです。このクラスは
     `Bastion()' によって使われる標準のクラスです。 GETFUNC
     引数は関数で、唯一の引数である属性の名前を
     与えて呼び出した際、制限された実行環境に対して、開示すべき属性の値を
     返します。NAME は `BastionClass' インスタンスの `repr()'
     を構築するために使われます。


File: python-lib-jp.info,  Node: モジュールのインポート,  Next: Python言語サービス,  Prev: 制限実行 restricted execution,  Up: Top

29 モジュールのインポート
*************************

この章で解説されるモジュールは他のPythonモジュールをインポートする新し
い方法と、インポート処理をカスタマイズするためのフックを提供しま す。

この章で解説されるモジュールの完全な一覧は:

* Menu:

* imp::
* zipimport::
* pkgutil::
* modulefinder::
* runpy::


File: python-lib-jp.info,  Node: imp,  Next: zipimport,  Prev: モジュールのインポート,  Up: モジュールのインポート

29.1 `import'内部へアクセスする
===============================

`import'文の実装へアクセスする。

この モジュールは`import'文を実装するために使われているメカニズムへのインターフェイスを提供します。次の定数と関数が定義されています:

`get_magic()'
     バイトコンパイルされたコードファイル(`.pyc'ファイル)を認識するために使われるマジック文字列値を返します。(この値はPythonの各バージョンで異なります。)

`get_suffixes()'
     三つ組みのリストを返します。それぞれはモジュールの特定の型を説明しています。各三つ組みは形式`(SUFFIX,
     MODE,
     TYPE)'を持ちます。ここで、SUFFIXは探すファイル名を作るためにモジュール名に追加する文字列です。そのファイルをオープンするために、MODEは組み込み`open()'関数へ渡されるモード文字列です(これはテキストファイル対しては`'r''、バイナリファイルに対しては`'rb''となります)。TYPEはファイル型で、以下で説明する値`PY_SOURCE'、`PY_COMPILED'、あるいは、`C_EXTENSION'の一つを取ります。

`find_module(name[, path])'
     検索パスPATH上でモジュールNAMEを見つけようとします。PATHがディレクトリ名のリストならば、上の`get_suffixes()'が返す拡張子のいずれかを伴ったファイルを各ディレクトリの中で検索します。リスト内の有効でない名前は黙って無視されます(しかし、すべてのリスト項目は文字列でなければならない)。PATHが省略されるか`None'ならば、`sys.path'のディレクトリ名のリストが検索されます。しかし、最初にいくつか特別な場所を検索します。所定の名前(`C_BUILTIN')をもつ組み込みモジュールを見つけようとします。それから、フリーズされたモジュール(`PY_FROZEN')、同様にいくつかのシステムと他の場所がみられます(Macでは、リソース(`PY_RESOURCE')を探します。Windowsでは、特定のファイルを指すレジストリの中を見ます)。

     検索が成功すれば、戻り値は三つ組み`(FILE, PATHNAME,
     DESCRIPTION)'です。ここで、FILEは先頭に位置を合わされたオープンファイルオブジェクトで、PATHNAMEは見つかったファイルのパス名です。そして、DESCRIPTIONは`get_suffixes()'が返すリストに含まれているような三つ組みで、見つかったモジュールの種類を説明しています。モジュールがファイルの中にあるならば、返されたFILEは`None'で、FILENAMEは空文字列、DESCRIPTIONタプルはその拡張子とモードに対して空文字列を含みます。モジュール型は上の括弧の中に示されます。検索が失敗すれば、`ImportError'が発生します。他の例外は引数または環境に問題があることを示唆します。

     この関数は階層的なモジュール名(ドットを含んだ名前)を扱いません。P.M、すなわち、パッケージPのサブモジュールMを見つけるためには、パッケージPを見つけてロードするために`find_module()'と`load_module()'を使い、それから`P.__path__'に設定されたPATH引数とともに`find_module()'を使ってください。P自身がドット名のときは、このレシピを再帰的に適用してください。

`load_module(name, file, filename, description)'
     `find_module()'を使って(あるいは、互換性のある結果を作り出す検索を行って)以前見つけたモジュールをロードします。この関数はモジュールをインポートするという以上のことを行います:
     モジュールが既にインポートされているならば、`reload()' と同じです!。NAME引数は(これがパッケージのサブモジュールならばパッケージ名を含む)完全なモジュール名を示します。FILE引数はオープンしたファイルで、FILENAMEは対応するファイル名です。モジュールがファイルからロードされようとしていないとき、これらはそれぞれ`None'と`'''であっても構いません。`get_suffixes()'が返すようにDESCRIPTION引数はタプルで、どの種類のモジュールがロードされなければならないかを説明するものです。

     ロードが成功したならば、戻り値はモジュールオブジェクトです。そうでなければ、例外(たいていは`ImportError')が発生します。

     *重要:*
     FILE引数が`None'でなければ、例外が発生した時でさえ呼び出し側にはそれを閉じる責任があります。これを行うには、`try'
     ... `finally'文をつかうことが最も良いです。

`new_module(name)'
     NAMEという名前の新しい空モジュールオブジェクトを返します。このオブジェクトは`sys.modules'に挿入され_ません_。

`lock_held()'
     現在インポートロックが維持されているならば、`True'を返します。そうでなければ、`False'を返します。スレッドのないプラットホームでは、常に`False'を返します。

     スレッドのあるプラットホームでは、インポートが完了するまでインポートを実行するスレッドは内部ロックを維持します。このロックは元のインポートが完了するまで他のスレッドがインポートすることを阻止します。言い換えると、元のスレッドがそのインポート(および、もしあるならば、それによって引き起こされるインポート)の途中で構築した不完全なモジュールオブジェクトを、他のスレッドが見られないようにします。

`acquire_lock()'
     実行中のスレッドでインタープリタのインポートロックを取得します。スレッドセーフ
     なインポートフックでは、インポート時にこのロックを取得します。
     スレッドのないプラットホームではこの関数は何もしません。 _Added in
     Python version 2.3_

`release_lock()'
     インタープリタのインポートロックを解放します。
     スレッドのないプラットホームではこの関数は何もしません。 _Added in
     Python version 2.3_

整数値をもつ次の定数はこのモジュールの中で定義されており、`find_module()'の検索結果を表すために使われます。

`PY_SOURCE'
     ソースファイルとしてモジュールが発見された。

`PY_COMPILED'
     コンパイルされたコードオブジェクトファイルとしてモジュールが発見された。

`C_EXTENSION'
     動的にロード可能な共有ライブラリとしてモジュールが発見された。

`PY_RESOURCE'
     モジュールがMac OS 9リソースとして発見された。この値はMac OS
     9以前のMacintoshでのみ返される。

`PKG_DIRECTORY'
     パッケージディレクトリとしてモジュールが発見された。

`C_BUILTIN'
     モジュールが組み込みモジュールとして発見された。

`PY_FROZEN'
     モジュールがフリーズされたモジュールとして発見された(`init_frozen()'を参照)。

次の定数と関数は旧式のものです。それらの機能は`find_module()'や`load_module()'を使って利用できます。後方互換性のために残されています:

`SEARCH_ERROR'
     使われていません。

`init_builtin(name)'
     NAMEという名前の組み込みモジュールを初期化し、そのモジュールオブジェクトを返します。モジュールが既に初期化されている場合は、_再度_初期化されます。いくつかのモジュールは二度初期化することができません。
     --
     これを再び初期化しようとすると、`ImportError'例外が発生します。NAMEという名前の組み込みモジュールがない場合は、`None'を返します。

`init_frozen(name)'
     NAMEという名前のフリーズされたモジュールを初期化し、モジュールオブジェクトを返します。モジュールが既に初期化されている場合は、_再度_初期化されます。NAMEという名前のフリーズされたモジュールがない場合は、`None'を返します。(フリーズされたモジュールはPythonで書かれたモジュールで、そのコンパイルされたバイトコードオブジェクトがPythonの`freeze'ユーティリティを使ってカスタムビルトPythonインタープリタへ組み込まれています。差し当たり、`Tools/freeze/'を参照してください。)

`is_builtin(name)'
     NAMEという名前の再度初期化できる組み込みモジュールがある場合は、`1'を返します。NAMEという名前の再度初期化できない組み込みモジュールがある場合は、`-1'を返します(`init_builtin()'を参照してください)。NAMEという名前の組み込みモジュールがない場合は、`0'を返します。

`is_frozen(name)'
     NAMEという名前のフリーズされたモジュール(`init_frozen()'を参照)がある場合は、`True'を返します。または、そのようなモジュールがない場合は、`False'を返します。

`load_compiled(name, pathname[, file])'
     バイトコンパイルされたコードファイルとして実装されているモジュールをロードして初期化し、そのモジュールオブジェクトを返します。モジュールが既に初期化されている場合は、_再度_初期化されます。NAME引数はモジュールオブジェクトを作ったり、アクセスするために使います。PATHNAME引数はバイトコンパイルされたコードファイルを指します。FILE引数はバイトコンパイルされたコードファイルで、バイナリモードでオープンされ、先頭からアクセスされます。現在は、ユーザ定義のファイルをエミュレートするクラスではなく、実際のファイルオブジェクトでなければなりません。

`load_dynamic(name, pathname[, file])'
     動的ロード可能な共有ライブラリとして実装されているモジュールをロードして初期化します。モジュールが既に初期化されている場合は、_再度_初期化します。いくつかのモジュールではそれができずに、例外を発生するかもしれません。PATHNAME引数は共有ライブラリを指していなければなりません。NAME引数は初期化関数の名前を作るために使われます。共有ライブラリの`initNAME()'という名前の外部C関数が呼び出されます。オプションのFILE引数は無視されます。(注意:
     共有ライブラリはシステムに大きく依存します。また、すべてのシステムがそれをサポートしているわけではありません。)

`load_source(name, pathname[, file])'
     Pythonソースファイルとして実装されているモジュールをロードして初期化し、モジュールオブジェクトを返します。モジュールが既に初期化されている場合は、_再度_初期化します。NAME引数はモジュールオブジェクトを作成したり、アクセスしたりするために使われます。PATHNAME引数はソースファイルを指します。FILE引数はソースファイルで、テキストとして読み込むためにオープンされ、先頭からアクセスされます。現在は、ユーザ定義のファイルをエミュレートするクラスではなく、実際のファイルオブジェクトでなければなりません。(拡張子`.pyc'または`.pyo'をもつ)正しく対応するバイトコンパイルされたファイルが存在する場合は、与えられたソースファイルを構文解析する代わりにそれが使われることに注意してください。

`NullImporter(path_string)'
     `NullImporter'型はPEP 302 インポートフックで、何もモジュールが見つからなかったときの非ディレクトリパス文字列を処理します。この型を既存のディレクトリや空文字列に対してコールすると`ImportError'が発生します。それ以外の場合は`NullImporter'のインスタンスが返されます。

     Pythonは、ディレクトリでなく`sys.path_hooks'のどのパスフックでも処理されていないすべてのパスエントリに対して、この型のインスタンスを`sys.path_importer_cache'に追加します。このインスタンスが持つメソッドは次のひとつです。

    `find_module(fullname [, path])'
          このメソッドは常に`None'を返し、要求されたモジュールが見つからなかったことを表します。

     _Added in Python version 2.5_

* Menu:

* 例 16::


File: python-lib-jp.info,  Node: 例 16,  Prev: imp,  Up: imp

29.1.1 例
---------

次の関数はPython
1.4までの標準import文(階層的なモジュール名がない)をエミュレートします。(この_実装_はそのバージョンでは動作しないでしょう。なぜなら、`find_module()'は拡張されており、また`load_module()'が1.4で追加されているからです。)

     import imp
     import sys

     def __import__(name, globals=None, locals=None, fromlist=None):
         # Fast path: see if the module has already been imported.
         try:
             return sys.modules[name]
         except KeyError:
             pass

         # If any of the following calls raises an exception,
         # there's a problem we can't handle -- let the caller handle it.

         fp, pathname, description = imp.find_module(name)

         try:
             return imp.load_module(name, fp, pathname, description)
         finally:
             # Since we may exit via an exception, close fp explicitly.
             if fp:
                 fp.close()

階層的なモジュール名を実装し、`reload()' 関数を含むより完全な例はモジュール`knee' にあります。`knee'モジュールはPythonのソースディストリビューションの中の`Demo/imputil/'にあります。


File: python-lib-jp.info,  Node: zipimport,  Next: pkgutil,  Prev: imp,  Up: モジュールのインポート

29.2 Zip アーカイブからモジュールを import する
===============================================

Python モジュール を ZIP アーカイブから import する機能のサポート

_Added in Python version 2.3_

このモジュールは， Python モジュール (`*.py'，`*.py[co]' やパッケージを
ZIP 形式のアーカイブから import できるように します。通常，`zipimport'
を明示的に使う必要はありません; 組み込みの `import' は，`sys.path'
の要素が ZIP
アーカイブへのパスを指している場合にこのモジュールを自動的に 使います。

普通，`sys.path' はディレクトリ名の文字列からなるリストです。
このモジュールを使うと，`sys.path' の要素に ZIP ファイル
アーカイブを示す文字列を使えるようになります。ZIP アーカイブには
サブディレクトリ構造を含めることができ，パッケージの import を
サポートさせしたり，アーカイブ内のパスを指定してサブディレクトリ 下から
import を行わせたりできます。例えば， `/tmp/example.zip/lib/'
のように指定すると，アーカイブ中の `lib/' サブディレクトリ下だけから
import を行います。

ZIP アーカイブ内にはどんなファイルを置いてもかまいませんが， import
できるのは`.py' および `.py[co]' だけです。 動的モジュール
(`.pyd'，`.so') の ZIP import は行えません。 アーカイブ内に `.py'
ファイルしか入っていない場合， Python がアーカイブを変更して， `.py'
ファイルに対応する `.pyc' や`.pyo' ファイルを追加したりはしません。
つまり，ZIP アーカイブ中に `.pyc' が入っていない 場合， import
はやや低速になるかもしれないので注意してください。

ZIP アーカイブからロードしたモジュールに対して組み込み関数 `reload()'
を呼び出すと失敗します; `reload()' が 必要になるということは，実行時に
ZIPファイルが置き換えられてしまう
ことになり，あまり起こりそうにない状況だからです。

このモジュールで使える属性を以下に示します:

`ZipImporterError'
     zipimporter オブジェクトが送出する例外です。 `ImportError'
     のサブクラスなので，`ImportError' としても捕捉できます。

`zipimporter'
     ZIP ファイルを import するためのクラスです。 コンストラクタの詳細は
     "" (*Note runpy:: 節) を参照してください。

See also:
     `PKZIP Application Note'{ZIP ファイル形式の作者であり，ZIP
     で使われて いるアルゴリズムの作者でもある Phil Katz による，ZIP
     ファイル形式 についてのドキュメントです。}

    *PEP0273 Import Modules from Zip Archives*
          このモジュールの実装も行った、James C. Ahlstrom による PEP
          です。 Python 2.3 は PEP 273 の仕様に従っていますが、 Just
          van Rossum の書いた import フックによる実装を使っています。
          import フックは PEP 302 で解説されています。

    *PEP0302 New Import Hooks*
          このモジュールを動作させる助けに なっている import
          フックの追加を提案している PEP です。


* Menu:

* zipimporter オブジェクト::
* zipimport Examples::


File: python-lib-jp.info,  Node: zipimporter オブジェクト,  Next: zipimport Examples,  Prev: zipimport,  Up: zipimport

29.2.1 zipimporter オブジェクト
-------------------------------

`zipimporter(archivepath)'
     新たな zipimporter インスタンスを生成します。ARCHIVEPATH は ZIP
     ファイルへのパスでなければなりません。 ARCHIVEPATH が 有効な ZIP
     アーカイブを指していない場合、`ZipImportError' を送出します。

`find_module(fullname[, path])'
     FULLNAME に指定したモジュールを検索します。FULLNAME は 完全指定の
     (ドット表記の) モジュール名でなければなりません。
     モジュールが見つかった場合には zipimporter インスタンス自体を返し、
     そうでない場合には `None' を返します。 PATH 引数は無視されます --
     この引数は importer プロトコルとの 互換性を保つためのものです。

`get_code(fullname)'
     FULLNAME に指定したモジュールのコードオブジェクトを返します。
     モジュールがない場合には`ZipImportError' を送出します。

`get_data(pathname)'
     PATHNAME に関連付けられたデータを返します。該当するファイルが
     見つからなかった場合には `IOError' を送出します。

`get_source(fullname)'
     FULLNAME に指定したモジュールのソースコードを返します。
     モジュールが見つからなかった場合には `ZipImportError'
     を送出します。モジュールは存在するが、ソースコードがない場合には
     `None' を返します。

`is_package(fullname)'
     FULLNAME で指定されたモジュールがパッケージの場合に `True'
     を返します。モジュールが見つからなかった場合には `ZipImportError'
     を送出します。

`load_module(fullname)'
     FULLNAME に指定したモジュールをロードします。FULLNAME は完全指定の
     (ドット表記の) モジュール名でなくてはなりません。 import
     済みのモジュールを返します。モジュールがない場合には
     `ZipImportError' を送出します。


File: python-lib-jp.info,  Node: zipimport Examples,  Prev: zipimporter オブジェクト,  Up: zipimport

29.2.2 使用例
-------------

モジュールを ZIP アーカイブから import する例を以下に示します -
`zipimport' モジュールが明示的に使われていないことに注意 してください。

     $ unzip -l /tmp/example.zip
     Archive:  /tmp/example.zip
       Length     Date   Time    Name
      --------    ----   ----    ----
          8467  11-26-02 22:30   jwzthreading.py
      --------                   -------
          8467                   1 file
     $ ./python
     Python 2.3 (#1, Aug 1 2003, 19:54:32)
     >>> import sys
     >>> sys.path.insert(0, '/tmp/example.zip')  # パス先頭に .zip ファイル追加
     >>> import jwzthreading
     >>> jwzthreading.__file__
     '/tmp/example.zip/jwzthreading.py'


File: python-lib-jp.info,  Node: pkgutil,  Next: modulefinder,  Prev: zipimport,  Up: モジュールのインポート

29.3 パッケージ拡張ユーティリティ
=================================

パッケージの拡張をサポートするユーティリティです。

_Added in Python version 2.3_

このモジュールは次の単一の関数を提供します。

`extend_path(path, name)'
     パッケージを構成するモジュールのサーチパスを拡張します。
     パッケージの `__init__.py' で次のように書くことを意図したもので
     す。

          from pkgutil import extend_path
          __path__ = extend_path(__path__, __name__)

     上記はパッケージの `__path__' に `sys.path' の全ディレクトリ
     のサブディレクトリとしてパッケージ名と同じ名前を追加します。これは1つ
     の論理的なパッケージの異なる部品を複数のディレクトリに分けて配布したい
     ときに役立ちます。

     同時に `*.pkg' の `*' の部分が NAME 引数に指定された文
     字列に一致するファイルの検索もおこないます。この機能は `import'
     で始まる特別な行がないことを除き `*.pth' ファイルに似ています
     (`site' の項を参照)。`*.pkg' は重複のチェックを除き、信
     頼できるものとして扱われます。`*.pkg' ファイルの中に見つかったエ
     ントリはファイルシステム上に実在するか否かを問わず、そのまますべてパス
     に追加されます。(このような仕様です。)

     入力パスがリストでない場合(フリーズされたパッケージのとき)は何もせずに
     リターンします。入力パスが変更されていなければ、アイテムを末尾に追加し
     ただけのコピーを返します。

     `sys.path' はシーケンスであることが前提になっています。 `sys.path'
     の要素の内、実在するディレクトリを指す(ユニコードまた
     は8ビットの)文字列となっていないものは無視されます。ファイル名として使っ
     たときにエラーが発生する `sys.path' のユニコード要素がある場合、
     この関数(`os.path.isdir()' を実行している行)で例外が発生する
     可能性があります。



File: python-lib-jp.info,  Node: modulefinder,  Next: runpy,  Prev: pkgutil,  Up: モジュールのインポート

29.4 スクリプト中で使われているモジュールを 検索する
====================================================

スクリプト中で使われているモジュールを検索します。

_Added in Python version 2.3_

このモジュールでは、スクリプト中で import されているモジュールセットを
調べるために使える `ModuleFinder' クラスを提供しています。
`modulefinder.py' はまた、Python スクリプトのファイル名を引数に
指定してスクリプトとして実行し、 import されているモジュールの
レポートを出力させることもできます。

`AddPackagePath(pkg_name, path)'
     PKG_NAME という名前のパッケージの在り処がPATH である
     ことを記録します。

`ReplacePackage(oldname, newname)'
     実際にはパッケージ内でOLDNAME という名前になっているモジュール を
     NEWNAME という名前で指定できるようにします。この関数の
     主な用途は、`_xmlplus' パッケージが `xml' パッケージ
     に置き換わっている場合の処理でしょう。

`ModuleFinder([path=None, debug=0, excludes=[], replace_paths=[]])'
     このクラスでは`run_script()' および`report()'
     メソッドを提供しています。これらのメソッドは何らかのスクリプト中で
     import されているモジュールの集合を調べます。 PATH
     はモジュールを検索する先のディレクトリ名からなるリストです。 PATH
     を指定しない場合、`sys.path' を使います。 DEBUG
     にはデバッグレベルを設定します; 値を大きくすると、
     実行している内容を表すデバッグメッセージを出力します。 EXCLUDES
     は検索から除外するモジュール名です。 REPLACE_PATHS
     には、モジュールパス内で置き換えられるパスを タプル`(OLDPATH,
     NEWPATH)' からなるリストで 指定します。

`report()'
     スクリプトで import
     しているモジュールと、そのパスからなるリストを列挙
     したレポートを標準出力に出力します。モジュールを見つけられなかったり、
     モジュールがないように見える場合にも報告します。

`run_script(pathname)'
     PATHNAME に指定したファイルの内容を解析します。ファイルには Python
     コードが入っていなければなりません。


File: python-lib-jp.info,  Node: runpy,  Prev: modulefinder,  Up: モジュールのインポート

29.5 Python モジュールの位置特定と実行
======================================

Python モジュールの位置特定とスクリプトとしての実行

_Added in Python version 2.5_

`runpy' モジュールは Python のモジュールをインポートせずに
その位置を特定したり実行したりするのに使われます。その主な目的は
ファイルシステムではなく Python
のモジュール名前空間を使って位置を特定した スクリプトの実行を可能にする
`-m' コマンドラインスイッチを 実装することです。

スクリプトとして実行されると、このモジュールは効率よく以下の操作をします。
         del sys.argv[0]  # Remove the runpy module from the arguments
         run_module(sys.argv[0], run_name="__main__", alter_sys=True)

`runpy' モジュールでは一つの関数だけ提供します。

`run_module(mod_name[, init_globals] [, run_name][, alter_sys])'
     指定されたモジュールのコードを実行し、実行後のモジュールグローバル辞書を
     返します。モジュールのコードはまず標準インポート機構(詳細は PEP
     302 を参照)
     を使ってモジュールの位置を特定され、まっさらなモジュール名前空間で実行されます。

     オプションの辞書型引数 INIT_GLOBALS
     はコードを実行する前にグローバル
     辞書に前もって必要な設定しておくのに使われます。与えられた辞書は変更されません。
     その辞書の中に以下に挙げる特別なグローバル変数が定義されていたとしても、
     それらの定義は `run_module' 関数によってオーバーライドされます。

     特別なグローバル変数 `__name__'、`__file__'、`__loader__'、
     `__builtins__'
     はモジュールコードが実行される前にグローバル辞書にセットされます。

     `__name__' は、もしオプション引数 RUN_NAME
     が与えられていればその値が、 そうでなければ MOD_NAME
     引数の値がセットされます。

     `__loader__' はモジュールのコードを取得するのに使われる PEP 302
     のモジュール
     ローダがセットされます(このローダは標準のインポート機構に対するラッパーかもしれません)。

     `__file__'
     はモジュールローダにより与えられた名前がセットされます。もし
     ローダがファイル名情報を取得可能にしなければ、この変数の値は
     `None' に なります。

     `__builtins__' は自動的に `__builtin__' モジュールのトップレベル
     名前空間への参照で初期化されます。

     引数 ALTER_SYS が与えられて `True' に評価されるならば、
     `sys.argv[0]' は `__file__' の値で更新され `sys.modules[__name__]'
     は実行されるモジュールの一時的モジュール
     オブジェクトで更新されます。 `sys.argv[0]' と
     `sys.modules[__name__]' はどちらも
     関数が処理を戻す前にもとの値に復旧します。

     この `sys'
     に対する操作はスレッドセーフではないということに注意してください。
     他のスレッドは部分的に初期化されたモジュールを見たり、入れ替えられた引数リストを
     見たりするかもしれません。この関数をスレッド化されたコードから起動するときは
     `sys' モジュールには手を触れないことが推奨されます。

See also:
    *PEP338 Executing modules as scripts*
          Nick Coghlan によって書かれ実装された PEP



File: python-lib-jp.info,  Node: Python言語サービス,  Next: Python コンパイラパッケージ,  Prev: モジュールのインポート,  Up: Top

30 Python言語サービス
*********************

PythonにはPython言語を使って作業するときに役に立つモジュールがたくさん提供されています。これらのモジュールはトークンの切り出し、パース、構文解析、バイトコードのディスアセンブリおよびその他のさまざまな機能をサポートしています。

これらのモジュールには、次のものが含まれています:

* Menu:

* parser::
* symbol::
* token::
* keyword::
* tokenize::
* tabnanny::
* pyclbr::
* py_compile::
* compileall::
* dis::
* pickletools::
* distutils::


File: python-lib-jp.info,  Node: parser,  Next: symbol,  Prev: Python言語サービス,  Up: Python言語サービス

30.1 Python解析木にアクセスする
===============================

Pythonソースコードに対する解析木へのアクセス。

`parser'モジュールはPythonの内部パーサとバイトコード・コンパイラへのインターフェイスを提供します。このインターフェイスの第一の目的は、PythonコードからPythonの式の解析木を編集したり、これから実行可能なコードを作成したりできるようにすることです。これは任意のPythonコードの断片を文字列として構文解析や変更を行うより良い方法です。なぜなら、構文解析がアプリケーションを作成するコードと同じ方法で実行されるからです。その上、高速です。

このモジュールについて注意すべきことが少しあります。それは作成したデータ構造を利用するために重要なことです。この文書はPythonコードの解析木を編集するためのチュートリアルではありませんが、`parser'モジュールを使った例をいくつか示しています。

もっとも重要なことは、内部パーサが処理するPythonの文法についてよく理解しておく必要があるということです。言語の文法に関する完全な情報については、を参照してください。標準のPythonディストリビューションに含まれるファイル`Grammar/Grammar'の中で定義されている文法仕様から、パーサ自身は作成されています。このモジュールが作成するASTオブジェクトの中に格納される解析木は、下で説明する`expr()'または`suite()'関数によって作られるときに内部パーサから実際に出力されるものです。`sequence2ast()'が作るASTオブジェクトは忠実にこれらの構造をシミュレートしています。言語の形式文法が改訂されるために、"正しい"と考えられるシーケンスの値がPythonのあるバージョンから別のバージョンで変化することがあるということに注意してください。しかし、Pythonのあるバージョンから別のバージョンへテキストのソースのままコードを移せば、目的のバージョンで正しい解析木を常に作成できます。ただし、インタープリタの古いバージョンへ移行する際に、最近の言語コンストラクトをサポートしていないことがあるという制限だけがあります。ソースコードが常に前方互換性があるのに対して、一般的に解析木はあるバージョンから別のバージョンへの互換性がありません。

`ast2list()'または`ast2tuple()'から返されるシーケンスのそれぞれの要素は単純な形式です。文法の非終端要素を表すシーケンスは常に一より大きい長さを持ちます。最初の要素は文法の生成規則を識別する整数です。これらの整数はCヘッダファイル`Include/graminit.h'とPythonモジュール`symbol'の中の特定のシンボル名です。シーケンスに付け加えられている各要素は、入力文字列の中で認識されたままの形で生成規則の構成要素を表しています:
これらは常に親と同じ形式を持つシーケンスです。この構造の注意すべき重要な側面は、`if_stmt'の中のキーワード`if'のような親ノードの型を識別するために使われるキーワードがいかなる特別な扱いもなくノードツリーに含まれているということです。例えば、`if'キーワードはタプル`(1,
'if')'と表されます。ここで、`1'は、ユーザが定義した変数名と関数名を含むすべての`NAME'トークンに対応する数値です。行番号情報が必要なときに返される別の形式では、同じトークンが`(1,
'if',
12)'のように表されます。ここでは、`12'が終端記号の見つかった行番号を表しています。

終端要素は同じ方法で表現されますが、子の要素や識別されたソーステキストの追加は全くありません。上記の`if'キーワードの例が代表的なものです。終端記号のいろいろな型は、Cヘッダファイル`Include/token.h'とPythonモジュール`token'で定義されています。

ASTオブジェクトはこのモジュールの機能をサポートするために必要ありませんが、三つの目的から提供されています:
アプリケーションが複雑な解析木を処理するコストを償却するため、Pythonのリストやタプル表現に比べてメモリ空間を保全する解析木表現を提供するため、解析木を操作する追加モジュールをCで作ることを簡単にするため。ASTオブジェクトを使っていることを隠すために、簡単な"ラッパー"クラスをPythonで作ることができます。

`parser'モジュールは二、三の別々の目的のために関数を定義しています。もっとも重要な目的はASTオブジェクトを作ることと、ASTオブジェクトを解析木とコンパイルされたコードオブジェクトのような他の表現に変換することです。しかし、ASTオブジェクトで表現された解析木の型を調べるために役に立つ関数もあります。

See also:
     *Note symbol:: 解析木の内部ノードを表す便利な定数。 *Note token::
     便利な解析木の葉のノードを表す定数とノード値をテストするための関数。

* Menu:

* ASTオブジェクトを作成する::
* ASTオブジェクトを変換する::
* ASTオブジェクトに対する問い合わせ::
* 例外とエラー処理::
* ASTオブジェクト::
* 例 17::


File: python-lib-jp.info,  Node: ASTオブジェクトを作成する,  Next: ASTオブジェクトを変換する,  Prev: parser,  Up: parser

30.1.1 ASTオブジェクトを作成する
--------------------------------

ASTオブジェクトはソースコードあるいは解析木から作られます。ASTオブジェクトをソースから作るときは、`'eval''と`'exec''形式を作成するために別々の関数が使われます。

`expr(source)'
     まるで`compile(SOURCE, 'file.py',
     'eval')'への入力であるかのように、`expr()'関数はパラメータSOURCEを構文解析します。解析が成功した場合は、ASTオブジェクトは内部解析木表現を保持するために作成されます。そうでなければ、適切な例外を発生させます。

`suite(source)'
     まるで`compile(SOURCE, 'file.py',
     'exec')'への入力であるかのように、`suite()'関数はパラメータSOURCEを構文解析します。解析が成功した場合は、ASTオブジェクトは内部解析木表現を保持するために作成されます。そうでなければ、適切な例外を発生させます。

`sequence2ast(sequence)'
     この関数はシーケンスとして表現された解析木を受け取り、可能ならば内部表現を作ります。木がPythonの文法に合っていることと、すべてのノードがPythonのホストバージョンで有効なノード型であることを確認した場合は、ASTオブジェクトが内部表現から作成されて呼び出し側へ返されます。内部表現の作成に問題があるならば、あるいは木が正しいと確認できないならば、`ParserError'例外を発生します。この方法で作られたASTオブジェクトが正しくコンパイルできると決めつけない方がよいでしょう。ASTオブジェクトが`compileast()'へ渡されたとき、コンパイルによって送出された通常の例外がまだ発生するかもしれません。これは(`MemoryError'例外のような)構文に関係していない問題を示すのかもしれないし、`del
     f(0)'を解析した結果のようなコンストラクトが原因であるかもしれません。このようなコンストラクトはPythonのパーサを逃れますが、バイトコードインタープリタによってチェックされます。

     終端トークンを表すシーケンスは、`(1,
     'name')'形式の二つの要素のリストか、または`(1, 'name',
     56)'形式の三つの要素のリストです。三番目の要素が存在する場合は、有効な行番号だとみなされます。行番号が指定されるのは、入力木の終端記号の一部に対してです。

`tuple2ast(sequence)'
     これは`sequence2ast()'と同じ関数です。このエントリポイントは後方互換性のために維持されています。


File: python-lib-jp.info,  Node: ASTオブジェクトを変換する,  Next: ASTオブジェクトに対する問い合わせ,  Prev: ASTオブジェクトを作成する,  Up: parser

30.1.2 ASTオブジェクトを変換する
--------------------------------

作成するために使われた入力に関係なく、ASTオブジェクトはリスト木またはタプル木として表される解析木へ変換されるか、または実行可能なオブジェクトへコンパイルされます。解析木は行番号情報を持って、あるいは持たずに抽出されます。

`ast2list(ast[, line_info])'
     この関数は呼び出し側からASTにASTオブジェクトを受け取り、解析木と等価なPythonのリストを返します。結果のリスト表現はインスペクションあるいはリスト形式の新しい解析木の作成に使うことができます。リスト表現を作るためにメモリが利用できる限り、この関数は失敗しません。解析木がインスペクションのためだけにつかわれるならば、メモリの消費量と断片化を減らすために`ast2tuple()'を代わりに使うべきです。リスト表現が必要とされるとき、この関数はタプル表現を取り出して入れ子のリストに変換するよりかなり高速です。

     LINE_INFOが真ならば、トークンを表すリストの三番目の要素として行番号情報がすべての終端トークンに含まれます。与えられた行番号はトークン_が終わる_行を指定していることに注意してください。フラグが偽または省略された場合は、この情報は省かれます。

`ast2tuple(ast[, line_info])'
     この関数は呼び出し側からASTにASTオブジェクトを受け取り、解析木と等価なPythonのタプルを返します。リストの代わりにタプルを返す以外は、この関数は`ast2list()'と同じです。

     LINE_INFOが真ならば、トークンを表すリストの三番目の要素として行番号情報がすべての終端トークンに含まれます。フラグが偽または省略された場合は、この情報は省かれます。

`compileast(ast[, filename` = '<ast>''])'
     `exec'文の一部として使える、あるいは、組み込み`eval()' 関数への呼び出しとして使えるコードオブジェクトを生成するために、PythonバイトコードコンパイラをASTオブジェクトに対して呼び出すことができます。この関数はコンパイラへのインターフェイスを提供し、FILENAMEパラメータで指定されるソースファイル名を使って、ASTからパーサへ内部解析木を渡します。FILENAMEに与えられるデフォルト値は、ソースがASTオブジェクトだったことを示唆しています。

     ASTオブジェクトをコンパイルすることは、コンパイルに関する例外を引き起こすことになるかもしれません。例としては、`del
     f(0)'の解析木によって発生させられる`SyntaxError'があります:
     この文はPythonの形式文法としては正しいと考えられますが、正しい言語コンストラクトではありません。この状況に対して発生する`SyntaxError'は、実際にはPythonバイトコンパイラによって通常作り出されます。これが`parser'モジュールがこの時点で例外を発生できる理由です。解析木のインスペクションを行うことで、コンパイルが失敗するほとんどの原因をプルグラムによって診断することができます。


File: python-lib-jp.info,  Node: ASTオブジェクトに対する問い合わせ,  Next: 例外とエラー処理,  Prev: ASTオブジェクトを変換する,  Up: parser

30.1.3 ASTオブジェクトに対する問い合わせ
----------------------------------------

ASTが式またはsuiteとして作成されたかどうかをアプリケーションが決定できるようにする二つの関数が提供されています。これらの関数のどちらも、ASTが`expr()'または`suite()'を通してソースコードから作られたかどうか、あるいは、`sequence2ast()'を通して解析木から作られたかどうかを決定できません。

`isexpr(ast)'
     ASTが`'eval''形式を表している場合に、この関数は真を返します。そうでなければ、偽を返します。これは役に立ちます。なぜならば、通常は既存の組み込み関数を使ってもコードオブジェクトに対してこの情報を問い合わせることができないからです。このどちらのようにも`compileast()'によって作成されたコードオブジェクトに問い合わせることはできませんし、そのコードオブジェクトは組み込み`compile()' 関数によって作成されたコードオブジェクトと同じであることに注意してください。

`issuite(ast)'
     ASTオブジェクトが(通常"suite"として知られる)`'exec''形式を表しているかどうかを報告するという点で、この関数は`isexpr()'に酷似しています。追加の構文が将来サポートされるかもしれないので、この関数が`not
     isexpr(AST)'と等価であるとみなすのは安全ではありません。


File: python-lib-jp.info,  Node: 例外とエラー処理,  Next: ASTオブジェクト,  Prev: ASTオブジェクトに対する問い合わせ,  Up: parser

30.1.4 例外とエラー処理
-----------------------

parserモジュールは例外を一つ定義していますが、Pythonランタイム環境の他の部分が提供する別の組み込み例外を発生させることもあります。各関数が発生させる例外の情報については、それぞれ関数を参照してください。

`ParserError'
     parserモジュール内部で障害が起きたときに発生する例外。普通の構文解析中に発生する組み込みの`SyntaxError'ではなく、一般的に妥当性確認が失敗した場合に引き起こされます。例外の引数としては、障害の理由を説明する文字列である場合と、`sequence2ast()'へ渡される解析木の中の障害を引き起こすシーケンスを含むタプルと説明用の文字列である場合があります。モジュール内の他の関数の呼び出しは単純な文字列値を検出すればよいだけですが、`sequence2ast()'の呼び出しはどちらの例外の型も処理できる必要があります。

普通は構文解析とコンパイル処理によって発生する例外を、関数`compileast()'、`expr()'および`suite()'が発生させることに注意してください。このような例外には組み込み例外`MemoryError'、`OverflowError'、`SyntaxError'および`SystemError'が含まれます。こうした場合には、これらの例外が通常その例外に関係する全ての意味を伝えます。詳細については、各関数の説明を参照してください。


File: python-lib-jp.info,  Node: ASTオブジェクト,  Next: 例 17,  Prev: 例外とエラー処理,  Up: parser

30.1.5 ASTオブジェクト
----------------------

ASTオブジェクト間の順序と等値性の比較がサポートされています。(`pickle'モジュールを使った)ASTオブジェクトのピクルス化もサポートされています。

`ASTType'
     `expr()'、`suite()'と`sequence2ast()'が返すオブジェクトの型。

ASTオブジェクトは次のメソッドを持っています:

`compile([filename])'
     `compileast(AST, FILENAME)'と同じ。

`isexpr()'
     `isexpr(AST)'と同じ。

`issuite()'
     `issuite(AST)'と同じ。

`tolist([line_info])'
     `ast2list(AST, LINE_INFO)'と同じ。

`totuple([line_info])'
     `ast2tuple(AST, LINE_INFO)'と同じ。


File: python-lib-jp.info,  Node: 例 17,  Prev: ASTオブジェクト,  Up: parser

30.1.6 例
---------

parserモジュールを使うと、バイトコードが生成される前にPythonのソースコードの解析木に演算を行えるようになります。また、モジュールは情報発見のために解析木のインスペクションを提供しています。例が二つあります。簡単な例では組み込み関数`compile()' のエミュレーションを行っており、複雑な例では情報を得るための解析木の使い方を示しています。

* Menu:

* compileのエミュレーション::
* 情報発見::


File: python-lib-jp.info,  Node: compileのエミュレーション,  Next: 情報発見,  Prev: 例 17,  Up: 例 17

30.1.6.1 `compile()'のエミュレーション
......................................

たくさんの有用な演算を構文解析とバイトコード生成の間に行うことができますが、もっとも単純な演算は何もしないことです。このため、`parser'モジュールを使って中間データ構造を作ることは次のコードと等価です。

     >>> code = compile('a + 5', 'file.py', 'eval')
     >>> a = 5
     >>> eval(code)
     10

`parser'モジュールを使った等価な演算はやや長くなりますが、ASTオブジェクトとして中間内部解析木が維持されるようにします:

     >>> import parser
     >>> ast = parser.expr('a + 5')
     >>> code = ast.compile('file.py')
     >>> a = 5
     >>> eval(code)
     10

ASTとコードオブジェクトの両方が必要なアプリケーションでは、このコードを簡単に利用できる関数にまとめることができます:

     import parser

     def load_suite(source_string):
         ast = parser.suite(source_string)
         return ast, ast.compile()

     def load_expression(source_string):
         ast = parser.expr(source_string)
         return ast, ast.compile()


File: python-lib-jp.info,  Node: 情報発見,  Prev: compileのエミュレーション,  Up: 例 17

30.1.6.2 情報発見
.................

あるアプリケーションでは解析木へ直接アクセスすることが役に立ちます。この節の残りでは、`import'を使って調査中のコードを実行中のインタープリタにロードする必要も無しに、解析木を使ってdocstrings に定義されたモジュールのドキュメンテーションへのアクセスを可能にする方法を示します。これは信頼性のないコードを解析するためにとても役に立ちます。

一般に、例は興味のある情報を引き出すために解析木をどのような方法でたどればよいかを示しています。二つの関数と一連のクラスが開発され、モジュールが提供する高レベルの関数とクラスの定義をプログラムから利用できるようになります。クラスは情報を解析木から引き出し、便利な意味レベルでその情報へアクセスできるようにします。一つの関数は単純な低レベルのパターンマッチング機能を提供し、もう一つの関数は呼び出し側の代わりにファイル操作を行うという点でクラスへの高レベルなインターフェイスです。ここで言及されていてPythonのインストールに必要ないすべてのソースファイルは、ディストリビューションの`Demo/parser/'ディレクトリにあります。

Pythonの動的な性質によってプログラマは非常に大きな柔軟性を得ることができます。しかし、クラス、関数およびメソッドを定義するときには、ほとんどのモジュールがこれの限られた部分しか必要としません。この例では、考察される定義だけがコンテキストのトップレベルにおいて定義されるものです。例を挙げると、モジュールのゼロ列目に`def'文によって定義される関数で、`if'
...
`else'コンストラクトの枝の中に定義されていない関数(ある状況ではそうすることにもっともな理由があるのですが)。例で開発するコードによって、定義の入れ子を扱う予定です。

より上位レベルの抽出メソッドを作るために知る必要があるのは、解析木構造がどのようなものかということと、それのどの程度まで関心を持つ必要があるのかということです。Pythonはやや深い解析木を使いますので、たくさんの中間ノードがあります。Pythonが使う形式文法を読んで理解することは重要です。これは配布物に含まれるファイル`Grammar/Grammar'に明記されています。docstringsを探すときに対象として最も単純な場合について考えてみてください:
docstringの他に何も無いモジュール。(ファイル`docstring.py'を参照してください。)

     """Some documentation.
     """

インタープリタを使って解析木を調べると、数と括弧が途方に暮れるほど多くて、ドキュメンテーションが入れ子になったタプルの深いところに埋まっていることがわかります。

     >>> import parser
     >>> import pprint
     >>> ast = parser.suite(open('docstring.py').read())
     >>> tup = ast.totuple()
     >>> pprint.pprint(tup)
     (257,
      (264,
       (265,
        (266,
         (267,
          (307,
           (287,
            (288,
             (289,
              (290,
               (292,
                (293,
                 (294,
                  (295,
                   (296,
                    (297,
                     (298,
                      (299,
                       (300, (3, '"""Some documentation.\n"""'))))))))))))))))),
        (4, ''))),
      (4, ''),
      (0, ''))

木の各ノードの最初の要素にある数はノード型です。それらは文法の終端記号と非終端記号に直接に対応します。残念なことに、それらは内部表現の整数で表されていて、生成されたPythonの構造でもそのままになっています。しかし、`symbol'と`token'モジュールはノード型の記号名と整数からノード型の記号名へマッピングする辞書を提供します。

上に示した出力の中で、最も外側のタプルは四つの要素を含んでいます:
整数`257'と三つの付加的なタプル。ノード型`257'の記号名は`file_input'です。これらの各内部タプルは最初の要素として整数を含んでいます。これらの整数`264'と`4'、`0'は、ノード型`stmt'、`NEWLINE'、`ENDMARKER'をそれぞれ表しています。これらの値はあなたが使っているPythonのバージョンに応じて変化する可能性があることに注意してください。マッピングの詳細については、`symbol.py'と`token.py'を調べてください。もっとも外側のノードがファイルの内容ではなく入力ソースに主に関係していることはほとんど明らかで、差し当たり無視しても構いません。`stmt'ノードはさらに興味深いです。特に、すべてのdocstringsは、このノードが作られるのとまったく同じように作られ、違いがあるのは文字列自身だけである部分木にあります。同様の木のdocstringと説明の対象である定義されたエンティティ(クラス、関数あるいはモジュール)の関係は、前述の構造を定義している木の内部におけるdocstring部分木の位置によって与えられます。

実際のdocstringを木の変数要素を意味する何かと置き換えることによって、簡単なパターンマッチング方法で与えられたどんな部分木でもdocstringsに対する一般的なパターンと同等かどうかを調べられるようになります。例では情報の抽出の実例を示しているので、`['variable_name']'という単純な変数表現を念頭において、リスト形式ではなくタプル形式の木を安全に要求できます。簡単な再帰関数でパターンマッチングを実装でき、その関数は真偽値と変数名から値へのマッピングの辞書を返します。(ファイル`example.py'を参照してください。)

     from types import ListType, TupleType

     def match(pattern, data, vars=None):
         if vars is None:
             vars = {}
         if type(pattern) is ListType:
             vars[pattern[0]] = data
             return 1, vars
         if type(pattern) is not TupleType:
             return (pattern == data), vars
         if len(data) != len(pattern):
             return 0, vars
         for pattern, data in map(None, pattern, data):
             same, vars = match(pattern, data, vars)
             if not same:
                 break
         return same, vars

この構文の変数用の簡単な表現と記号のノード型を使うと、docstring部分木の候補のパターンがとても読みやすくなります。(ファイル`example.py'を参照してください。)

     import symbol
     import token

     DOCSTRING_STMT_PATTERN = (
         symbol.stmt,
         (symbol.simple_stmt,
          (symbol.small_stmt,
           (symbol.expr_stmt,
            (symbol.testlist,
             (symbol.test,
              (symbol.and_test,
               (symbol.not_test,
                (symbol.comparison,
                 (symbol.expr,
                  (symbol.xor_expr,
                   (symbol.and_expr,
                    (symbol.shift_expr,
                     (symbol.arith_expr,
                      (symbol.term,
                       (symbol.factor,
                        (symbol.power,
                         (symbol.atom,
                          (token.STRING, ['docstring'])
                          )))))))))))))))),
          (token.NEWLINE, '')
          ))

このパターンと`match()'関数を使うと、前に作った解析木からモジュールのdocstringを簡単に抽出できます:

     >>> found, vars = match(DOCSTRING_STMT_PATTERN, tup[1])
     >>> found
     1
     >>> vars
     {'docstring': '"""Some documentation.\n"""'}

特定のデータを期待された位置から抽出できると、次は情報を期待できる場所はどこかという疑問に答える必要がでてきます。docstringを扱う場合、答えはとても簡単です:
docstringはコードブロック(`file_input'または`suite'ノード型)の最初の`stmt'ノードです。モジュールは一つの`file_input'ノードと、正確にはそれぞれが一つの`suite'ノードを含むクラスと関数の定義で構成されます。クラスと関数は`(stmt,
(compound_stmt, (classdef, ...'または`(stmt, (compound_stmt, (funcdef,
...'で始まるコードブロックノードの部分木として簡単に識別されます。これらの部分木は`match()'によってマッチさせることができないことに注意してください。なぜなら、数を無視して複数の兄弟ノードにマッチすることをサポートしていないからです。この限界を超えるためにより念入りにつくったマッチング関数を使うことができますが、例としてはこれで充分です。

文がdocstringかどうかを決定し、実際の文字列をその文から抽出する機能について考えると、ある作業にはモジュール全体の解析木を巡回してモジュールの各コンテキストにおいて定義される名前についての情報を抽出し、その名前とdocstringsを結び付ける必要があります。この作業を行うコードは複雑ではありませんが、説明が必要です。

そのクラスへの公開インターフェイスは簡単で、おそらく幾分かより柔軟でしょう。モジュールのそれぞれの"主要な"ブロックは、問い合わせのための幾つかのメソッドを提供するオブジェクトと、少なくともそれが表す完全な解析木の部分木を受け取るコンストラクタによって記述されます。`ModuleInfo'コンストラクタはオプションのNAMEパラメータを受け取ります。なぜなら、そうしないとモジュールの名前を決められないからです。

公開クラスには`ClassInfo'、`FunctionInfo'および`ModuleInfo'が含まれます。すべてのオブジェクトはメソッド`get_name()'、`get_docstring()'、`get_class_names()'および`get_class_info()'を提供します。`ClassInfo'オブジェクトは`get_method_names()'と`get_method_info()'をサポートしますが、他のクラスは`get_function_names()'と`get_function_info()'を提供しています。

公開クラスが表すコードブロックの形式のそれぞれにおいて、トップレベルで定義された関数が"メソッド"として参照されるという違いがクラスにはありますが、要求される情報のほとんどは同じ形式をしていて、同じ方法でアクセスされます。クラスの外側で定義される関数との実際の意味の違いを名前の付け方が違うことで反映しているため、実装はこの違いを保つ必要があります。そのため、公開クラスのほとんどの機能が共通の基底クラス`SuiteInfoBase'に実装されており、他の場所で提供される関数とメソッドの情報に対するアクセサを持っています。関数とメソッドの情報を表すクラスが一つだけであることに注意してください。これは要素の両方の型を定義するために`def'文を使うことに似ています。

アクセサ関数のほとんどは`SuiteInfoBase'で宣言されていて、サブクラスでオーバーライドする必要はありません。より重要なこととしては、解析木からのほとんどの情報抽出が`SuiteInfoBase'コンストラクタに呼び出されるメソッドを通して行われるということがあります。平行して形式文法を読めば、ほとんどのクラスのコード例は明らかです。しかし、再帰的に新しい情報オブジェクトを作るメソッドはもっと調査が必要です。`example.py'の`SuiteInfoBase'定義の関連する箇所を以下に示します:

     class SuiteInfoBase:
         _docstring = ''
         _name = ''

         def __init__(self, tree = None):
             self._class_info = {}
             self._function_info = {}
             if tree:
                 self._extract_info(tree)

         def _extract_info(self, tree):
             # extract docstring
             if len(tree) == 2:
                 found, vars = match(DOCSTRING_STMT_PATTERN[1], tree[1])
             else:
                 found, vars = match(DOCSTRING_STMT_PATTERN, tree[3])
             if found:
                 self._docstring = eval(vars['docstring'])
             # discover inner definitions
             for node in tree[1:]:
                 found, vars = match(COMPOUND_STMT_PATTERN, node)
                 if found:
                     cstmt = vars['compound']
                     if cstmt[0] == symbol.funcdef:
                         name = cstmt[2][1]
                         self._function_info[name] = FunctionInfo(cstmt)
                     elif cstmt[0] == symbol.classdef:
                         name = cstmt[2][1]
                         self._class_info[name] = ClassInfo(cstmt)

初期状態に初期化した後、コンストラクタは`_extract_info()'メソッドを呼び出します。このメソッドがこの例全体で行われる情報抽出の大部分を実行します。抽出には二つの別々の段階があります:
渡された解析木のdocstringの位置の特定、解析木が表すコードブロック内の付加的な定義の発見。

最初の`if'テストは入れ子のsuiteが"短い形式"または"長い形式"かどうかを決定します。以下のコードブロックの定義のように、コードブロックが同じ行であるときに短い形式が使われます。

     def square(x): "Square an argument."; return x ** 2

長い形式では字下げされたブロックを使い、入れ子になった定義を許しています:

     def make_power(exp):
         "Make a function that raises an argument to the exponent `exp'."
         def raiser(x, y=exp):
             return x ** y
         return raiser

短い形式が使われるとき、コードブロックはdocstringを最初の`small_stmt'要素として(ことによるとそれだけを)持っています。このようなdocstringの抽出は少し異なり、より一般的な場合に使われる完全なパターンの一部だけを必要とします。実装されているように、`simple_stmt'ノードに`small_stmt'ノードが一つだけある場合には、docstringしかないことがあります。短い形式を使うほとんどの関数とメソッドがdocstringを提供しないため、これで充分だと考えられます。docstringの抽出は前述の`match()'関数を使って進み、docstringが`SuiteInfoBase'オブジェクトの属性として保存されます。

docstringを抽出した後、簡単な定義発見アルゴリズムを`suite'ノードの`stmt'ノードに対して実行します。短い形式の特別な場合はテストされません。短い形式では`stmt'ノードが存在しないため、アルゴリズムは黙って`simple_stmt'ノードを一つスキップします。正確に言えば、どんな入れ子になった定義も発見しません。

コードブロックのそれぞれの文をクラス定義(関数またはメソッドの定義、あるいは、何か他のもの)として分類します。定義文に対しては、定義された要素の名前が抽出され、コンストラクタに引数として渡される部分木の定義とともに定義に適した代理オブジェクトが作成されます。代理オブジェクトはインスタンス変数に保存され、適切なアクセサメソッドを使って名前から取り出されます。

公開クラスは`SuiteInfoBase'クラスが提供するアクセサより具体的で、必要とされるどんなアクセサでも提供します。しかし、実際の抽出アルゴリズムはコードブロックのすべての形式に対して共通のままです。高レベルの関数をソースファイルから完全な情報のセットを抽出するために使うことができます。(ファイル`example.py'を参照してください。)

     def get_docs(fileName):
         import os
         import parser

         source = open(fileName).read()
         basename = os.path.basename(os.path.splitext(fileName)[0])
         ast = parser.suite(source)
         return ModuleInfo(ast.totuple(), basename)

これはモジュールのドキュメンテーションに対する使いやすいインターフェイスです。この例のコードで抽出されない情報が必要な場合は、機能を追加するための明確に定義されたところで、コードを拡張することができます。


File: python-lib-jp.info,  Node: symbol,  Next: token,  Prev: parser,  Up: Python言語サービス

30.2 Python解析木と共に使われる定数
===================================

Constants representing internal nodes of the parse tree.

このモジュールは解析木の内部ノードの数値を表す定数を提供します。ほとんどのPython定数とは違い、これらは小文字の名前を使います。言語の文法のコンテキストにおける名前の定義については、Pythonディストリビューションのファイル`Grammar/Grammar'を参照してください。名前がマップする特定の数値はPythonのバージョン間で変わります。

このモジュールには、データオブジェクトも一つ付け加えられています:

`sym_name'
     ディクショナリはこのモジュールで定義されている定数の数値を名前の文字列へマップし、より人が読みやすいように解析木を表現します。

See also:
     *Note parser::
     `parser'モジュールの二番目の例で、`symbol'モジュールの使い方を示しています。


File: python-lib-jp.info,  Node: token,  Next: keyword,  Prev: symbol,  Up: Python言語サービス

30.3 Python解析木と共に使われる定数
===================================

Constants representing terminal nodes of the parse tree.

このモジュールは解析木の葉ノード(終端記号)の数値を表す定数を提供します。言語の文法のコンテキストにおける名前の定義については、Pythonディストリビューションのファイル`Grammar/Grammar'を参照してください。名前がマップする特定の数値は、Pythonのバージョン間で変わります。

このモジュールは一つのデータオブジェクトといくつかの関数も提供します。関数はPythonのCヘッダファイルの定義を反映します。

`tok_name'
     辞書はこのモジュールで定義されている定数の数値を名前の文字列へマップし、より人が読みやすいように解析木を表現します。

`ISTERMINAL(x)'
     終端トークンの値に対して真を返します。

`ISNONTERMINAL(x)'
     非終端トークンの値に対して真を返します。

`ISEOF(x)'
     Xが入力の終わりを示すマーカーならば、真を返します。

See also:
     *Note parser::
     `parser'モジュールの二番目の例で、`symbol'モジュールの使い方を示しています。


File: python-lib-jp.info,  Node: keyword,  Next: tokenize,  Prev: token,  Up: Python言語サービス

30.4 Pythonキーワードチェック
=============================

文字列がPythonのキーワードか否かを調べます。

このモジュールでは、Pythonプログラムで文字列がキーワードか否かをチェック
する機能を提供します。

`iskeyword(s)'
     SがPythonのキーワードであれば真を返します。

`kwlist'
     インタープリタで定義している全てのキーワードのシーケンス。特定の
     `__future__'宣言がなければ有効ではないキーワードでもこのリストに
     は含まれます。


File: python-lib-jp.info,  Node: tokenize,  Next: tabnanny,  Prev: keyword,  Up: Python言語サービス

30.5 Pythonソースのためのトークナイザ
=====================================

Pythonソースコードのための字句解析器。

`tokenize'モジュールでは、Python で実装された Python
ソースコードの字句解析器を提供します。さらに、このモジュールの
字句解析器はコメントもトークンとして返します。このため、この
モジュールはスクリーン上で表示する際の色付け機能 (colorizers) を含む
"清書出力器 (pretty-printer)" を実装する上で便利です。

第一のエントリポイントはジェネレータです:

`generate_tokens(readline)'
     `generate_tokens()' ジェネレータは一つの引数READLINE
     を必要とします。この引数は呼び出し可能オブジェクトで、組み込みファイル
     オブジェクトにおける `readline()' メソッドと同じインタフェース
     を提供していなければなりません (~*Note ファイルオブジェクト::
     節を参照して
     ください)。この関数は呼び出しのたびに入力内の一行を文字列で返さなければ
     なりません。

     ジェネレータは 5 要素のタプルを返し、タプルは以下のメンバ:
     トークン型; トークン文字列;
     ソースコード中でトークンが始まる行と列を示す
     整数の2要素のタプル`(SROW, SCOL)'; ソースコード中で
     トークンが終わる行と列を示す整数の2要素のタプル `(SROW, SCOL)';
     そして、トークンが見つかった行、から
     なります。渡される行は_論理_行です; 連続する行は一行に含められ
     ます。 _Added in Python version 2.2_

後方互換性のために古いエントリポイントが残されています:

`tokenize(readline[, tokeneater])'
     `tokenize()'関数は二つのパラメータを取ります:
     一つは入力ストリームを表し、もう一つは`tokenize()'のための
     出力メカニズムを与えます。

     最初のパラメータ、READLINE は、組み込みファイルオブジェクト
     の`readline()'メソッドと同じインタフェイスを提供する呼び出し
     可能オブジェクトでなければなりません (~*Note
     ファイルオブジェクト:: 節を参照)。
     この関数は呼び出しのたびに入力内の一行を文字列で返さなければ
     なりません。 もしくは、READLINE を呼び出し可能オブジェクトで
     `StopIteration' を送出することで補完を知らせるものと
     することもできます。 _Changed in Python version 2.5_

     二番目のパラメータTOKENEATERも呼び出し可能オブジェクトで
     なければなりません。この関数は各トークンに対して一度だけ呼び出され、
     `generate_tokens()' が生成するタプルに対応する 5 つの引数
     をとります。

`token' モジュールの全ての定数は`tokenize' でも
公開されており、これに加え、以下の二つのトークン値が `tokenize()' の
TOKENEATER 関数に渡される可能性があります:

`COMMENT'
     コメントであることを表すために使われるトークン値です。

`NL'
     終わりではない改行を表すために使われるトークン値。NEWLINEトークンは
     Pythonコードの論理行の終わりを表します。NLトークンはコードの論理行が
     複数の物理行にわたって続いているときに作られます。

もう一つの関数がトークン化プロセスを逆転するために提供されています。
これは、スクリプトを字句解析し、トークンのストリームに変更を加え、変更された
スクリプトを書き戻すようなツールを作成する際に便利です。

`untokenize(iterable)'
     トークンの列を Python ソースコードに変換します。ITERABLE
     は少なくとも
     二つの要素、トークン型およびトークン文字列、からなるシーケンスを返します。
     その他のシーケンスの要素は無視されます。

     再構築されたスクリプトは一つの文字列として返されます。得られる結果はもう一度
     字句解析すると入力と一致することが保証されるので、変換がロスレスであり
     ラウンドトリップできることは間違いありません。この保証はトークン型および
     トークン文字列に対してのものでトークン間のスペース(コラム位置)のようなものは
     変わることがあり得ます。 _Added in Python version 2.5_

スクリプト書き換えの例で、浮動小数点数リテラルを Decimal オブジェクトに
変換します:
     def decistmt(s):
         """Substitute Decimals for floats in a string of statements.

         >>> from decimal import Decimal
         >>> s = 'print +21.3e-5*-.1234/81.7'
         >>> decistmt(s)
         "print +Decimal ('21.3e-5')*-Decimal ('.1234')/Decimal ('81.7')"

         >>> exec(s)
         -3.21716034272e-007
         >>> exec(decistmt(s))
         -3.217160342717258261933904529E-7

         """
         result = []
         g = generate_tokens(StringIO(s).readline)   # tokenize the string
         for toknum, tokval, _, _, _  in g:
             if toknum == NUMBER and '.' in tokval:  # replace NUMBER tokens
                 result.extend([
                     (NAME, 'Decimal'),
                     (OP, '('),
                     (STRING, repr(tokval)),
                     (OP, ')')
                 ])
             else:
                 result.append((toknum, tokval))
         return untokenize(result)


File: python-lib-jp.info,  Node: tabnanny,  Next: pyclbr,  Prev: tokenize,  Up: Python言語サービス

30.6 あいまいなインデントの検出
===============================

ディレクトリツリー内のPythonのソースファイルで問題となる空白を検出するツール。

差し当たり、このモジュールはスクリプトとして呼び出すことを意図しています。しかし、IDE上にインポートして下で説明する関数`check()'を使うことができます。

_このモジュールが提供するAPIを将来のリリースで変更する確率が高いです。このような変更は後方互換性がないかもしれません。_

`check(file_or_dir)'
     FILE_OR_DIRがディレクトリであってシンボリックリンクでないときに、FILE_OR_DIRという名前のディレクトリツリーを再帰的に下って行き、この通り道に沿ってすべての`.py'ファイルを変更します。FILE_OR_DIRが通常のPythonソースファイルの場合には、問題のある空白をチェックします。診断メッセージはprint文を使って標準出力に書き込まれます。

`verbose'
     冗長なメッセージをプリントするかどうかを示すフラグ。スクリプトとして呼び出された場合は、`-v'オプションによって増加します。

`filename_only'
     問題のある空白を含むファイルのファイル名のみをプリントするかどうかを示すフラグ。スクリプトとして呼び出された場合は、`-q'オプションによって真に設定されます。

`NannyNag'
     あいまいなインデントを検出した場合に`tokeneater()'によって発生させられます。`check()'で捕捉され処理されます。

`tokeneater(type, token, start, end, line)'
     この関数は関数`tokenize.tokenize()'へのコールバックパラメータとして`check()'によって使われます。

See also:
     *Note tokenize:: Pythonソースコードの字句解析器。


File: python-lib-jp.info,  Node: pyclbr,  Next: py_compile,  Prev: tabnanny,  Up: Python言語サービス

30.7 Python クラスブラウザーサポート
====================================

Pythonクラスデスクリプタの情報抽出サポート

この`pyclbr'はモジュールで定義されたクラス、メソッド、および
トップレベルの関数について、限られた量の情報を定義するのに使われます。
このクラスによって提供される情報は、伝統的な 3 ペイン形式の
クラスブラウザーを実装するのに十分なだけの量になります。
情報はモジュールのインポートによらず、ソースコードから抽出します。
このため、このモジュールは信用できないソースコードに対して利用しても
安全です。この制限から、多くの標準モジュールやオプションの拡張
モジュールを含む、Python で実装されていないモジュールに対して
利用することはできません。

`readmodule(module[, path])'
     モジュールを読み込み、辞書マッピングクラスを返し、
     クラス記述オブジェクトに名前をつけます。
     パラメタMODULEはモジュール名を表す文字列でなくてはなりません;
     パッケージ内のモジュール名でもかまいません。 PATH
     パラメタはシーケンス型でなくてはならず、 モジュールのソースコード
     がある場所を特定する際に `sys.path' の値に補完する形で使われます。

`readmodule_ex(module[, path])'
     `readmodule()' に似ていますが、返される辞書は、クラス名から
     クラス記述オブジェクトへの対応付けに加えて、トップレベル関数から
     関数記述オブジェクトへの対応付けも行っています。さらに、読み出し対象の
     モジュールがパッケージの場合、返される辞書はキー `'__path__''
     を持ち、その値はパッケージの検索パスが入ったリストになります。

* Menu:

* クラス記述オブジェクト::
* 関数記述オブジェクト Function Descriptor Object::


File: python-lib-jp.info,  Node: クラス記述オブジェクト,  Next: 関数記述オブジェクト Function Descriptor Object,  Prev: pyclbr,  Up: pyclbr

30.7.1 クラス記述オブジェクト
-----------------------------

クラス記述オブジェクトは、`readmodule()' や `readmodule()_ex'
が返す辞書の値として 使われており、以下のデータメンバを提供しています。

`module'
     クラス記述オブジェクトが記述している対象のクラスを定義している
     モジュールの名前です。

`name'
     クラスの名前です。

`super'
     クラス記述オブジェクトが記述しようとしている対象クラスの、直接の基底
     クラス群について記述しているクラス記述オブジェクトのリストです。
     スーパクラスとして挙げられているが `readmodule()' が見つけ
     られなかったクラスは、クラス記述オブジェクトではなくクラス名として
     リストに挙げられます。

`methods'
     メソッド名を行番号に対応付ける辞書です。

`file'
     クラスを定義している `class' 文が入っているファイルの名前です。

`lineno'
     `file' で指定されたファイル内にある `class' 文の数です。


File: python-lib-jp.info,  Node: 関数記述オブジェクト Function Descriptor Object,  Prev: クラス記述オブジェクト,  Up: pyclbr

30.7.2 関数記述オブジェクト (Function Descriptor Object)
--------------------------------------------------------

`readmodule_ex()' の返す辞書内でキーに対応する値として使われて
いる関数記述オブジェクトは、以下のデータメンバを提供しています:

`module'
     関数記述オブジェクトが記述している対象の関数を定義している
     モジュールの名前です。

`name'
     関数の名前です。

`file'
     関数を定義してる `def' 文が入っているファイルの名前です。

`lineno'
     `file' で指定されたファイル内にある `def' 文の数です。


File: python-lib-jp.info,  Node: py_compile,  Next: compileall,  Prev: pyclbr,  Up: Python言語サービス

30.8 Pythonソースファイルのコンパイル
=====================================

Pythonソースファイルをバイトコードファイルへコンパイル。

`py_compile'モジュールには、ソースファイルからバイトコードファイ
ルを作る関数と、モジュールのソースファイルがスクリプトとして呼び出される
時に使用される関数が定義されています。

頻繁に必要となるわけではありませんが、共有ライブラリとしてモジュールをイ
ンストールする場合や、特にソースコードのあるディレクトリにバイトコードの
キャッシュファイルを書き込む権限がないユーザがいるときには、この関数は役
に立ちます。

`PyCompileError'
     ファイルをコンパイル中にエラーが発生すると、PyCompileError例外が送出されます。

`compile(file[, cfile[, dfile[, doraise]]])'
     ソースファイルをバイトコードにコンパイルして、バイトコードのキャッシュ
     ファイルに書き出します。 ソースコードはファイル名FILEで渡します。
     バイトコードはファイルCFILEに書き込まれ、デフォルトではFILE `+'
     `'c''（使用しているインタープリタで最適化が可能なら `'o''）です。
     もしDFILEが指定されたら、FILEの代わりにソースファイルの名前
     としてエラーメッセージの中で使われます。 DORAISE が
     Trueの場合、コンパイル中にエラーが発生すると `PyCompileError'
     を送出します。DORAISE がFalseの場合(デフォルト)はエラーメッセージは
     `sys.stderr'に出力し、例外は送出しません。

`main([args])'
     いくつか複数のソースファイルをコンパイルします。
     ARGSで（あるいはARGSで指定されなかったらコマンドラインで）指
     定されたファイルをコンパイルし、できたバイトコードを通常の方法で保存しま
     す。
     この関数はソースファイルの存在するディレクトリを検索しません；指定された
     ファイルをコンパイルするだけです。

このモジュールがスクリプトとして実行されると、`main()'がコマン
ドラインで指定されたファイルを全てコンパイルします。

See also:
     *Note compileall::
     ディレクトリツリー内のPythonソースファイルを全てコンパイルするライブラリ。


File: python-lib-jp.info,  Node: compileall,  Next: dis,  Prev: py_compile,  Up: Python言語サービス

30.9 Pythonライブラリをバイトコンパイル
=======================================

ディレクトリに含まれるPythonソースファイルを、一括してバイトコンパイルします。

このモジュールは、指定したディレクトリに含まれるPythonソースをコンパイル
する関数を定義しています。Pythonライブラリをインストールする時、ソースフ
ァイルを事前にコンパイルしておく事により、ライブラリのインストール先ディ
レクトリに書き込み権限をもたないユーザでもキャッシュされたバイトコードフ
ァイルを利用する事ができるようになります。

このモジュールのソースコードは、Pytonソースファイルをコンパイルするスク
リプトとしても利用する事ができます。コンパイルするディレクトリは、
`sys.path'で指定されたディレクトリ、またはコマンドラインで指定され
たディレクトリとなります。

`compile_dir(dir[, maxlevels[, ddir[, force[,  rx[, quiet]]]]])'
     DIRで指定されたディレクトリを再帰的に下降し、見つかった
     `.py'を全てコンパイルします。MAXLEVELSは、下降する最大の深
     さ（デフォルトは`10'）を指定します。DDIRには、エラーメッ
     セージで使用されるファイル名の、親ディレクトリ名を指定する事ができま
     す。FORCEが真の場合、モジュールはファイルの更新日付に関わりなく
     再コンパイルされます。

     RXには、検索対象から除外するファイル名の正規表現式を指定します。
     絶対パス名をこの正規表現で`search'し、一致した場合にはコンパイル
     対象から除外します。

     QUIETが真の場合、通常処理では標準出力に何も表示しません。


`compile_path([skip_curdir[, maxlevels[, force]]])'
     `sys.path'に含まれる、全ての`.py'ファイルをバイトコンパイル
     します。SKIP_CURDIRが真（デフォルト）の時、カレントディレクトリ
     は検索されません。MAXLEVELSとFORCEはデフォルトでは`0'
     で、`compile_dir()'に渡されます。


`Lib/'ディレクトリ以下にある全ての`.py'ファイルを強制的にリコンパイル
するには、以下のようにします:

     import compileall

     compileall.compile_dir('Lib/', force=True)

     # .svnディレクトリにあるファイルをのぞいて同じことをするにはこのようにします。
     import re
     compileall.compile_dir('Lib/', rx=re.compile('/[.]svn'), force=True)

See also:
     *Note py_compile:: Byte-compile a single source file.


File: python-lib-jp.info,  Node: dis,  Next: pickletools,  Prev: compileall,  Up: Python言語サービス

30.10 Pythonバイトコードの逆アセンブラ
======================================

Pythonバイトコードの逆アセンブラ。

`dis'モジュールはPythonバイトコードを逆アセンブルしてバイトコードの解析を助けます。Pythonアセンブラがないため、このモジュールがPythonアセンブリ言語を定義しています。このモジュールが入力として受け取るPythonバイトコードはファイル`Include/opcode.h'に定義されており、コンパイラとインタプリタが使用しています。

例: 関数`myfunc'を考えると:

     def myfunc(alist):
         return len(alist)

次のコマンドを`myfunc()'の逆アセンブリを得るために使うことができます:

     >>> dis.dis(myfunc)
       2           0 LOAD_GLOBAL              0 (len)
                   3 LOAD_FAST                0 (alist)
                   6 CALL_FUNCTION            1
                   9 RETURN_VALUE

("2"は行番号です)。

`dis'モジュールは次の関数と定数を定義します:

`dis([bytesource])'
     BYTESOURCEオブジェクトを逆アセンブルします。BYTESOURCEはモジュール、クラス、関数、あるいはコードオブジェクトのいずれかを示します。モジュールに対しては、すべての関数を逆アセンブルします。クラスに対しては、すべてのメソッドを逆アセンブルします。単一のコードシーケンスに対しては、バイトコード命令ごとに一行をプリントします。オブジェクトが与えられない場合は、最後のトレースバックを逆アセンブルします。

`distb([tb])'
     トレースバックのスタックの先頭の関数を逆アセンブルします。Noneが渡された場合は最後のトレースバックを使います。例外を引き起こした命令が表示されます。

`disassemble(code[, lasti])'
     コードオブジェクトを逆アセンブルします。LASTIが与えられた場合は、最後の命令を示します。出力は次のようなカラムに分割されます:

       1. 各行の最初の命令に対する行番号。

       2. 現在の命令。`-->'として示されます。

       3. ラベル付けされた命令。`>>'とともに表示されます。

       4. the address of the instruction,

       5. 命令のアドレス。

       6. 演算コード名。

       7. 演算パラメータ。

       8. 括弧の中のパラメータのインタプリテーション。

     パラメータインタープリテーションはローカルおよびグルーバル変数名、定数値、分岐目標、そして比較演算子を認識します。

`disco(code[, lasti])'
     disassembleの別名。よりタイプしやすく、以前のPythonリリースと互換性があります。

`opname'
     演算名。一連のバイトコードを使ってインデキシングできます。

`opmap'
     バイトコードからオペレーション名へのマッピング辞書。

`cmp_op'
     すべての比較演算名。

`hasconst'
     定数パラメータを持つ一連のバイトコード。

`hasfree'
     自由変数にアクセスする一連のバイトコード。

`hasname'
     名前によって属性にアクセスする一連のバイトコード。

`hasjrel'
     相対ジャンプターゲットをもつ一連のバイトコード。

`hasjabs'
     絶対ジャンプターゲットをもつ一連のバイトコード。

`haslocal'
     ローカル変数にアクセスする一連のバイトコード。

`hascompare'
     ブール演算の一連のバイトコード。

* Menu:

* Pythonバイトコード命令::


File: python-lib-jp.info,  Node: Pythonバイトコード命令,  Prev: dis,  Up: dis

30.10.1 Pythonバイトコード命令
------------------------------

現在Pythonコンパイラは次のバイトコード命令を生成します。

`STOP_CODE'
     コンパイラにend-of-code(コードの終わり)を知らせます。インタプリタでは使われません。

`NOP'
     なにもしないコード。バイトコードオプティマイザでプレースホルダとして使われます。
     Do nothing code.  Used as a placeholder by the bytecode optimizer.

`POP_TOP'
     top-of-stack (TOS)(スタックの先頭)の項目を取り除きます。

`ROT_TWO'
     スタックの先頭から二つの項目を入れ替えます。

`ROT_THREE'
     スタックの二番目と三番目の項目の位置を一つ上げ、先頭を三番目へ下げます。

`ROT_FOUR'
     スタックの二番目、三番目および四番目の位置を一つ上げ、先頭を四番目に下げます。

`DUP_TOP'
     スタックの先頭に参照の複製を作ります。

一項演算はスタックの先頭を取り出して演算を適用し、結果をスタックへプッシュし戻します。

`UNARY_POSITIVE'
     `TOS = +TOS'を実行します。

`UNARY_NEGATIVE'
     `TOS = -TOS'を実行します。

`UNARY_NOT'
     `TOS = not TOS'を実行します。

`UNARY_CONVERT'
     `TOS = `TOS`'を実行します。

`UNARY_INVERT'
     `TOS = ~{}TOS'を実行します。

`GET_ITER'
     `TOS = iter(TOS)'を実行します。

二項演算はスタックからスタックの先頭(TOS)と先頭から二番目のスタック項目を取り除きます。演算を実行し、スタックへ結果をプッシュし戻します。

`BINARY_POWER'
     `TOS = TOS1 ** TOS'を実行します。

`BINARY_MULTIPLY'
     `TOS = TOS1 * TOS'を実行します。

`BINARY_DIVIDE'
     `from __future__ import division'が有効でないとき、`TOS = TOS1 /
     TOS'を実行します。

`BINARY_FLOOR_DIVIDE'
     `TOS = TOS1 // TOS'を実行します。

`BINARY_TRUE_DIVIDE'
     `from __future__ import division'が有効でないとき、`TOS = TOS1 /
     TOS'を実行します。

`BINARY_MODULO'
     `TOS = TOS1 %{} TOS'を実行します。

`BINARY_ADD'
     `TOS = TOS1 + TOS'を実行します。

`BINARY_SUBTRACT'
     `TOS = TOS1 - TOS'を実行します。

`BINARY_SUBSCR'
     `TOS = TOS1[TOS]'を実行します。

`BINARY_LSHIFT'
     `TOS = TOS1 <`'< TOS'を実行します。

`BINARY_RSHIFT'
     `TOS = TOS1 >`'> TOS'を実行します。

`BINARY_AND'
     `TOS = TOS1 & TOS'を実行します。

`BINARY_XOR'
     `TOS = TOS1 ^ TOS'を実行します。

`BINARY_OR'
     `TOS = TOS1 | TOS'を実行します。

インプレース演算はTOSとTOS1を取り除いて結果をスタックへプッシュするという点で二項演算と似ています。しかし、TOS1がインプレース演算をサポートしている場合には演算が直接TOS1に行われます。また、演算結果のTOSは元のTOS1と同じオブジェクトになることが多いですが、常に同じというわけではありません。

`INPLACE_POWER'
     インプレースに`TOS = TOS1 ** TOS'を実行します。

`INPLACE_MULTIPLY'
     インプレースに`TOS = TOS1 * TOS'を実行します。

`INPLACE_DIVIDE'
     `from __future__ import
     division'が有効でないとき、インプレースに`TOS = TOS1 /
     TOS'を実行します。

`INPLACE_FLOOR_DIVIDE'
     インプレースに`TOS = TOS1 // TOS'を実行します。

`INPLACE_TRUE_DIVIDE'
     `from __future__ import
     division'が有効でないとき、インプレースに`TOS = TOS1 /
     TOS'を実行します。

`INPLACE_MODULO'
     インプレースに`TOS = TOS1 %{} TOS'を実行します。

`INPLACE_ADD'
     インプレースに`TOS = TOS1 + TOS'を実行します。

`INPLACE_SUBTRACT'
     インプレースに`TOS = TOS1 - TOS'を実行します。

`INPLACE_LSHIFT'
     インプレースに`TOS = TOS1 <`'< TOS'を実行します。

`INPLACE_RSHIFT'
     インプレースに`TOS = TOS1 >`'> TOS'を実行します。

`INPLACE_AND'
     インプレースに`TOS = TOS1 & TOS'を実行します。

`INPLACE_XOR'
     インプレースに`TOS = TOS1 ^ TOS'を実行します。

`INPLACE_OR'
     インプレースに`TOS = TOS1 | TOS'を実行します。

スライス演算は三つまでのパラメータを取ります。

`SLICE+0'
     `TOS = TOS[:]'を実行します。

`SLICE+1'
     `TOS = TOS1[TOS:]'を実行します。

`SLICE+2'
     `TOS = TOS1[:TOS]'を実行します。

`SLICE+3'
     `TOS = TOS2[TOS1:TOS]'を実行します。

スライス代入はさらに別のパラメータを必要とします。どんな文もそうであるように、スタックに何もプッシュしません。

`STORE_SLICE+0'
     `TOS[:] = TOS1'を実行します。

`STORE_SLICE+1'
     `TOS1[TOS:] = TOS2'を実行します。

`STORE_SLICE+2'
     `TOS1[:TOS] = TOS2'を実行します。

`STORE_SLICE+3'
     `TOS2[TOS1:TOS] = TOS3'を実行します。

`DELETE_SLICE+0'
     `del TOS[:]'を実行します。

`DELETE_SLICE+1'
     `del TOS1[TOS:]'を実行します。

`DELETE_SLICE+2'
     `del TOS1[:TOS]'を実行します。

`DELETE_SLICE+3'
     `del TOS2[TOS1:TOS]'を実行します。

`STORE_SUBSCR'
     `TOS1[TOS] = TOS2'を実行します。

`DELETE_SUBSCR'
     `del TOS1[TOS]'を実行します。

その他の演算。

`PRINT_EXPR'
     対話モードのための式文を実行します。TOSはスタックから取り除かれプリントされます。非対話モードにおいては、式文は`POP_STACK'で終了しています。

`PRINT_ITEM'
     `sys.stdout'に束縛されたファイル互換のオブジェクトへTOSをプリントします。`print'文に、各項目に対するこのような命令が一つあります。

`PRINT_ITEM_TO'
     `PRINT_ITEM'と似ていますが、TOSから二番目の項目をTOSにあるファイル互換オブジェクトへプリントします。これは拡張print文で使われます。

`PRINT_NEWLINE'
     `sys.stdout'へ改行をプリントします。これは`print'文がコンマで終わっていない場合に`print'文の最後の演算として生成されます。

`PRINT_NEWLINE_TO'
     `PRINT_NEWLINE'と似ていますが、TOSのファイル互換オブジェクトに改行をプリントします。これは拡張print文で使われます。

`BREAK_LOOP'
     `break'文があるためループを終了します。

`CONTINUE_LOOP target'
     `continue'文があるためループを継続します。TARGETはジャンプするアドレスです(アドレスは`FOR_ITER'命令であるべきです)。

`LIST_APPEND'
     `list.append(TOS1, TOS)'を呼びます。
     リスト内包表記を実装するために使われます。

`LOAD_LOCALS'
     現在のスコープのローカルな名前空間(locals)への参照をスタックにプッシュします。これはクラス定義のためのコードで使われます:
     クラス本体が評価された後、localsはクラス定義へ渡されます。

`RETURN_VALUE'
     関数の呼び出し元へTOSを返します。

`YIELD_VALUE'
     `TOS'をポップし、それをジェネレータからyieldします。

`IMPORT_STAR'
     `_'で始まっていないすべてのシンボルをモジュールTOSから直接ローカル名前空間へロードします。モジュールはすべての名前をロードした後にポップされます。この演算コードは`from
     module import *'を実行します。

`EXEC_STMT'
     `exec
     TOS2,TOS1,TOS'を実行します。コンパイラは見つからないオプションのパラメータを`None'で埋めます。

`POP_BLOCK'
     ブロックスタックからブロックを一つ取り除きます。フレームごとにブロックのスタックがあり、ネストしたループ、try文などを意味しています。

`END_FINALLY'
     `finally'節を終わらせます。インタプリタは例外を再び発生させなければならないかどうか、あるいは、関数が返り外側の次のブロックに続くかどうかを思い出します。

`BUILD_CLASS'
     新しいクラスオブジェクトを作成します。TOSはメソッド辞書、TOS1は基底クラスの名前のタプル、TOS2はクラス名です。

次の演算コードはすべて引数を要求します。引数はより重要なバイトを下位にもつ2バイトです。

`STORE_NAME namei'
     `name =
     TOS'を実行します。NAMEIはコードオブジェクトの属性`co_names'におけるNAMEのインデックスです。コンパイラは可能ならば`STORE_LOCAL'または`STORE_GLOBAL'を使おうとします。

`DELETE_NAME namei'
     `del
     name'を実行します。ここで、NAMEIはコードオブジェクトの`co_names'属性へのインデックスです。

`UNPACK_SEQUENCE count'
     TOSをCOUNT個のへ個別の値に分け、右から左にスタックに置かれます。

`DUP_TOPX count'
     COUNT個の項目を同じ順番を保ちながら複製します。実装上の制限から、COUNTは1から5の間(5を含む)でなければいけません。

`STORE_ATTR namei'
     `TOS.name =
     TOS1'を実行します。ここで、NAMEIは`co_names'における名前のインデックスです。

`DELETE_ATTR namei'
     `co_names'へのインデックスとしてNAMEIを使い、`del
     TOS.name'を実行します。

`STORE_GLOBAL namei'
     `STORE_NAME'として機能しますが、グローバルとして名前を記憶します。

`DELETE_GLOBAL namei'
     `DELETE_NAME'として機能しますが、グルーバル名を削除します。

`LOAD_CONST consti'
     `co_consts[CONSTI]'をスタックにプッシュします。

`LOAD_NAME namei'
     `co_names[NAMEI]'に関連付けられた値をスタックにプッシュします。

`BUILD_TUPLE count'
     スタックからCOUNT個の項目を消費するタプルを作り出し、できたタプルをスタックにプッシュします。

`BUILD_LIST count'
     `BUILD_TUPLE'として機能しますが、リストを作り出します。

`BUILD_MAP zero'
     スタックに新しい空の辞書オブジェクトをプッシュします。引数は無視され、コンパイラによってゼロに設定されます。

`LOAD_ATTR namei'
     TOSを`getattr(TOS, co_names[NAMEI])'と入れ替えます。

`COMPARE_OP opname'
     ブール演算を実行します。演算名は`cmp_op[OPNAME]'にあります。

`IMPORT_NAME namei'
     モジュール`co_names[NAMEI]'をインポートします。モジュールオブジェクトはスタックへプッシュされます。現在の名前空間は影響されません:
     適切なimport文に対して、それに続く`STORE_FAST'命令が名前空間を変更します。

`IMPORT_FROM namei'
     属性`co_names[NAMEI]'をTOSに見つかるモジュールからロードします。作成されたオブジェクトはスタックにプッシュされ、その後`STORE_FAST'命令によって記憶されます。

`JUMP_FORWARD delta'
     バイトコードカウンタをDELTAだけ増加させます。

`JUMP_IF_TRUE delta'
     TOSが真ならば、DELTAだけバイトコードカウンタを増加させます。TOSはスタックに残されます。

`JUMP_IF_FALSE delta'
     TOSが偽ならば、DELTAだけバイトコードカウンタを増加させます。TOSは変更されません。

`JUMP_ABSOLUTE target'
     バイトコードカウンタをTARGETに設定します。

`FOR_ITER delta'
     `TOS'はイテレータです。その`next()'メソッドを呼び出します。これが新しい値を作り出すならば、それを(その下にイテレータを残したまま)スタックにプッシュします。イテレータが尽きたことを示した場合は、`TOS'がポップされます。そして、バイトコードカウンタがDELTAだけ増やされます。

`LOAD_GLOBAL namei'
     グルーバル名`co_names[NAMEI]'をスタック上にロードします。

`SETUP_LOOP delta'
     ブロックスタックにループのためのブロックをプッシュします。ブロックは現在の命令からDELTAバイトの大きさを占めます。

`SETUP_EXCEPT delta'
     try-except節からtryブロックをブロックスタックにプッシュします。DELTAは最初のexceptブロックを指します。

`SETUP_FINALLY delta'
     try-except節からtryブロックをブロックスタックにプッシュします。DELTAはfinallyブロックを指します。

`LOAD_FAST var_num'
     ローカルな`co_varnames[VAR_NUM]'への参照をスタックにプッシュします。

`STORE_FAST var_num'
     TOSをローカルな`co_varnames[VAR_NUM]'の中に保存します。

`DELETE_FAST var_num'
     ローカルな`co_varnames[VAR_NUM]'を削除します。

`LOAD_CLOSURE i'
     セルと自由変数記憶領域のスロットIに含まれるセルへの参照をプッシュします。IがCO_CELLVARSの長さより小さければ、変数の名前は`co_cellvars[I]'です。そうでなければ、それは`co_freevars[I
     - len(co_cellvars)]'です。


`LOAD_DEREF i'
     セルと自由変数記憶領域のスロットIに含まれるセルをロードします。セルが持つオブジェクトへの参照をスタックにプッシュします。

`STORE_DEREF i'
     セルと自由変数記憶領域のスロットIに含まれるセルへTOSを保存します。

`SET_LINENO lineno'
     このペコードは廃止されました。

`RAISE_VARARGS argc'
     例外を発生させます。ARGCはraise文へ与えるパラメータの数を0から3の範囲で示します。ハンドラはTOS2としてトレースバック、TOS1としてパラメータ、そしてTOSとして例外を見つけられます。

`CALL_FUNCTION argc'
     関数を呼び出します。ARGCの低位バイトは位置パラメータを示し、高位バイトはキーワードパラメータの数を示します。オペコードは最初にキーワードパラメータをスタック上に見つけます。それぞれのキーワード引数に対して、その値はキーの上にあります。スタック上のキーワードパラメータの下に位置パラメータはあり、先頭に最も右のパラメータがあります。スタック上のパラメータの下には、呼び出す関数オブジェクトがあります。


`MAKE_FUNCTION argc'
     新しい関数オブジェクトをスタックにプッシュします。TOSは関数に関連付けられたコードです。関数オブジェクトはTOSの下にあるARGCデフォルトパラメータをもつように定義されます。

`MAKE_CLOSURE argc'
     新しい関数オブジェクトを作り出し、そのFUNC_CLOSUREスロットを設定し、それをスタックにプッシュします。TOSは関数に関連付けられたコードです。コードオブジェクトがN個の自由変数を持っているならば、スタック上の次のN個の項目はこれらの変数に対するセルです。関数はセルの前にあるARGCデフォルトパラメータも持っています。

`BUILD_SLICE argc'
     スライスオブジェクトをスタックにプッシュします。ARGCは2あるいは3でなければなりません。2ならば`slice(TOS1,
     TOS)'がプッシュされます。3ならば`slice(TOS2, TOS1,
     TOS)'がプッシュされます。これ以上の情報については、`slice()' 組み込み関数を参照してください。

`EXTENDED_ARG ext'
     大きすぎてデフォルトの二バイトに当てはめることができない引数をもつあらゆるオペコードの前に置かれます。EXTは二つの追加バイトを保持し、その後ろのオペコードの引数と一緒になって取られます。それらは四バイト引数を構成し、EXTはその最上位バイトです。

`CALL_FUNCTION_VAR argc'
     関数を呼び出します。ARGCは`CALL_FUNCTION'のように解釈実行されます。スタックの先頭の要素は変数引数リストを含んでおり、その後にキーワードと位置引数が続きます。

`CALL_FUNCTION_KW argc'
     関数を呼び出します。ARGCは`CALL_FUNCTION'のように解釈実行されます。スタックの先頭の要素はキーワード引数辞書を含んでおり、その後に明示的なキーワードと位置引数が続きます。

`CALL_FUNCTION_VAR_KW argc'
     関数を呼び出します。ARGCは`CALL_FUNCTION'のように解釈実行されます。スタックの先頭の要素はキーワード引数辞書を含んでおり、その後に変数引数のタプルが続き、さらに明示的なキーワードと位置引数が続きます。

`HAVE_ARGUMENT'
     これはオペコードではありません。引数をとらないオペコード`<
     HAVE_ARGUMENT' と、 とるオペコード `>= HAVE_ARGUMENT'
     を分割する行です。


File: python-lib-jp.info,  Node: pickletools,  Next: distutils,  Prev: dis,  Up: Python言語サービス

30.11 pickle 開発者のためのツール群
===================================

_Added in Python version 2.3_

pickle プロトコルと pickle マシン opcode に関する詳しい
コメントと、有用な関数がいくつかが入っています。

このモジュールには、`pickle' モジュールの詳細に関わる
様々な定数や実装に関する長大なコメント、そして pickle 化されたデータ
を解析する上で有用な関数をいくつか定義しています。このモジュールの内容は
`pickle' および `cPickle' の実装に関わっている Python core
開発者にとって有用なものです; 普通の `pickle' 利用者に
とっては、`pickletools' モジュールはおそらく関係ないものでしょう。

`dis(pickle[, out=None, memo=None, indentlevel=4])'
     pickle をシンボル分解 (symbolic disassembly) した内容を
     ファイル類似オブジェクトOUT (デフォルトでは`sys.stdout')
     に出力します。PICKLE は文字列にもファイル類似オブジェクトにも
     できます。MEMO は Python 辞書型で、 pickle のメモに使われます。
     同じ pickler の生成した複数の pickle 間にわたってシンボル分解を行う
     場合に使われます。ストリーム中で`MARK' opcode で表される
     継続レベル (successive level) はINDENTLEVEL に指定したスペース
     分インデントされます。

`genops(pickle)'
     pickle 内の全ての opcode
     を取り出すイテレータを返します。このイテレータは `(OPCODE, ARG,
     POS)' の三つ組みからなる配列を 返します。 OPCODE は `OpcodeInfo'
     クラスのインスタンスのクラスです。 ARG は OPCODE
     の引数としてデコードされた Python オブジェクトの 値です。POS は
     OPCODE の場所を表す値です。 PICKLE
     は文字列でもファイル類似オブジェクトでもかまいません。


File: python-lib-jp.info,  Node: distutils,  Prev: pickletools,  Up: Python言語サービス

30.12 Python モジュールの構築とインストール
===========================================

現在インストールされている Python に追加するためのモジュール構築、
および実際のインストールを支援する。

`distutils' パッケージは、現在インストールされている Python に
追加するためのモジュール構築、および実際のインストールを支援します。
新規のモジュールは 100%{}-pure Python でも、C
で書かれた拡張モジュールでも、 あるいは Python と C
両方のコードが入っているモジュールからなる Python
パッケージでもかまいません。

このパッケージは、Python ドキュメンテーション パッケージに含まれている
これとは別の 2つのドキュメントで詳しく説明されています。`distutils'
の機能を使って新しいモジュールを配布する方法は、  に書かれています。
このドキュメントには distutils を拡張する方法も含まれています。 Python
モジュールをインストールする方法は、 モジュールの作者が `distutils'
パッケージを使っている場合でもいない場合でも、  に書かれています。

See also:
     `Python モジュールを配布する'{このマニュアルは Python
     モジュールの開発者およびパッケージ担当に向けたものです。
     ここでは、現在インストールされている Python に簡単に追加できる
     `distutils'ベースのパッケージをどうやって用意するかについて
     説明しています。}

     `Python モジュールをインストールする'{ 現在インストールされている
     Python にモジュールを追加するための 情報が書かれた "管理者"
     向けのマニュアルです。 この文書を読むのに Python
     プログラマである必要はありません。}


File: python-lib-jp.info,  Node: Python コンパイラパッケージ,  Next: 抽象構文木,  Prev: Python言語サービス,  Up: Top

31 Python コンパイラパッケージ
******************************

Python compiler パッケージは Python のソースコードを分析したり Python
バイトコードを生成するためのツールです。compiler は Python
のソースコードから抽象的な構文木を生成し、その構文木から Python
バイトコードを生成するライブラリをそなえています。

`compiler' パッケージは、Python で書かれた Python
ソースコードからバイトコードへの変換プログラムです。
これは組み込みの構文解析器をつかい、そこで得られた
具体的な構文木に対して標準的な `parser' モジュールを使用します。
この構文木から抽象構文木 AST (Abstract Syntax Tree) が生成され、 その後
Python バイトコードが得られます。

このパッケージの機能は、Python インタプリタに内蔵されている
組み込みのコンパイラがすべて含んでいるものです。これはその機能と
正確に同じものになるよう意図してつくられています。なぜ同じことをする
コンパイラをもうひとつ作る必要があるのでしょうか? このパッケージは
いろいろな目的に使うことができるからです。これは組み込みのコンパイラよりも
簡単に変更できますし、これが生成する AST は Python ソースコードを
解析するのに有用です。

この章では `compiler' パッケージのいろいろなコンポーネントが
どのように動作するのかを説明します。そのため説明はリファレンスマニュアル的なものと、
チュートリアル的な要素がまざったものになっています。

以下のモジュールは `compiler' パッケージの一部です:

* Menu:

* 基本的なインターフェイス::
* 制限::
* Python 抽象構文::
* Visitor を使って AST をわたり歩く::
* バイトコード生成::


File: python-lib-jp.info,  Node: 基本的なインターフェイス,  Next: 制限,  Prev: Python コンパイラパッケージ,  Up: Python コンパイラパッケージ

31.1 基本的なインターフェイス
=============================

このパッケージのトップレベルでは 4つの関数が定義されています。
`compiler' モジュールを import すると、これらの関数および
このパッケージに含まれている一連のモジュールが使用可能になります。

`parse(buf)'
     BUF 中の Python ソースコードから得られた抽象構文木 AST を返します。
     ソースコード中にエラーがある場合、この関数は `SyntaxError'
     を発生させます。 返り値は `compiler.ast.Module'
     インスタンスであり、 この中に構文木が格納されています。

`parseFile(path)'
     PATH で指定されたファイル中の Python ソースコードから得られた
     抽象構文木 AST を返します。これは `parse(open(PATH).read())'
     と等価な働きをします。

`walk(ast, visitor[, verbose])'
     AST に格納された抽象構文木の各ノードを先行順序 (pre-order) で
     たどっていきます。各ノードごとに VISITOR インスタンスの
     該当するメソッドが呼ばれます。

`compile(source, filename, mode, flags=None,  dont_inherit=None)'
     文字列 SOURCE、Python モジュール、文あるいは式を exec 文あるいは
     `eval()' 関数で実行可能なバイトコードオブジェクトに
     コンパイルします。この関数は組み込みの `compile()' 関数を
     置き換えるものです。

     FILENAME は実行時のエラーメッセージに使用されます。

     MODE は、モジュールをコンパイルする場合は 'exec'、
     (対話的に実行される) 単一の文をコンパイルする場合は 'single'、
     式をコンパイルする場合には 'eval' を渡します。

     引数 FLAGS および DONT_INHERIT は将来的に使用される文に
     影響しますが、いまのところはサポートされていません。

`compileFile(source)'
     ファイル SOURCE をコンパイルし、.pyc ファイルを生成します。

`compiler' パッケージは以下のモジュールを含んでいます: `ast'、
`consts',、 `future'、 `misc'、 `pyassem'、 `pycodegen'、 `symbols'、
`transformer'、 そして `visitor'。


File: python-lib-jp.info,  Node: 制限,  Next: Python 抽象構文,  Prev: 基本的なインターフェイス,  Up: Python コンパイラパッケージ

31.2 制限
=========

compiler パッケージにはエラーチェックにいくつか問題が存在します。
構文エラーはインタープリタの 2つの別々のフェーズによって認識されます。
ひとつはインタープリタのパーザによって認識されるもので、
もうひとつはコンパイラによって認識されるものです。 compiler
パッケージはインタープリタのパーザに依存しているので、
最初の段階のエラーチェックは労せずして実現できています。
しかしその次の段階は、実装されてはいますが、その実装は不完全です。
たとえば compiler パッケージは引数に同じ名前が 2度以上出てきていても
エラーを出しません: `def f(x, x): ...'

compiler の将来のバージョンでは、これらの問題は修正される予定です。


File: python-lib-jp.info,  Node: Python 抽象構文,  Next: Visitor を使って AST をわたり歩く,  Prev: 制限,  Up: Python コンパイラパッケージ

31.3 Python 抽象構文
====================

`compiler.ast' モジュールは Python の抽象構文木 AST を定義します。 AST
では各ノードがそれぞれの構文要素をあらわします。 木の根は `Module'
オブジェクトです。

抽象構文木 AST は、パーズされた Python ソースコードに対する
高水準のインターフェイスを提供します。Python インタプリタにおける
`parser' モジュールと コンパイラは C
で書かれおり、具体的な構文木を使っています。 具体的な構文木は Python
のパーザ中で使われている構文と密接に関連しています。
ひとつの要素に単一のノードを割り当てる代わりに、ここでは Python の
優先順位に従って、何層にもわたるネストしたノードがしばしば使われています。

抽象構文木 AST は、`compiler.transformer' (変換器) モジュールに
よって生成されます。transformer は組み込みの Python
パーザに依存しており、
これを使って具体的な構文木をまず生成します。つぎにそこから抽象構文木
AST を 生成します。

`transformer' モジュールは、実験的な Python-to-C コンパイラ用に Greg
Stein  と Bill Tutt  によって作られました。
現行のバージョンではいくつもの修正と改良がなされていますが、 抽象構文木
AST と transformer の基本的な構造は Stein と Tutt によるものです。

* Menu:

* AST ノード::
* 代入ノード::
* サンプル::

