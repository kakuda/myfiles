これは python-lib-jp.info、python-lib-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-lib-jp.info,  Node: asynchat 使用例,  Prev: asynchat - 補助クラスと関数,  Up: asynchat

17.6.2 asynchat 使用例
----------------------

以下のサンプルは、`async_chat'でHTTPリクエストを読み込む処理の一部
です。Webサーバは、クライアントからの接続毎に
`http_request_handler'オブジェクトを作成します。最初はチャネルの終
了条件に空行を指定してHTTPヘッダの末尾までを検出し、その後ヘッダ読み込み
済みを示すフラグを立てています。

ヘッダ読み込んだ後、リクエストの種類がPOSTであればデータが入力ストリーム
に流れるため、`Content-Length:'ヘッダの値を数値として終了条件に指定
し、適切な長さのデータをチャネルから読み込みます。

必要な入力データを全て入手したら、チャネルの終了条件に`None'を指定
して残りのデータを無視するようにしています。この後、
`handle_request()'が呼び出されます。

     class http_request_handler(asynchat.async_chat):

         def __init__(self, conn, addr, sessions, log):
             asynchat.async_chat.__init__(self, conn=conn)
             self.addr = addr
             self.sessions = sessions
             self.ibuffer = []
             self.obuffer = ""
             self.set_terminator("\r\n\r\n")
             self.reading_headers = True
             self.handling = False
             self.cgi_data = None
             self.log = log

         def collect_incoming_data(self, data):
             """Buffer the data"""
             self.ibuffer.append(data)

         def found_terminator(self):
             if self.reading_headers:
                 self.reading_headers = False
                 self.parse_headers("".join(self.ibuffer))
                 self.ibuffer = []
                 if self.op.upper() == "POST":
                     clen = self.headers.getheader("content-length")
                     self.set_terminator(int(clen))
                 else:
                     self.handling = True
                     self.set_terminator(None)
                     self.handle_request()
             elif not self.handling:
                 self.set_terminator(None) # browsers sometimes over-send
                 self.cgi_data = parse(self.headers, "".join(self.ibuffer))
                 self.handling = True
                 self.ibuffer = []
                 self.handle_request()


File: python-lib-jp.info,  Node: インターネットプロトコルとその支援,  Next: マルチメディアサービス,  Prev: プロセス間通信とネットワーク,  Up: Top

18 インターネットプロトコルとその支援
*************************************

この章で記述されるモジュールは、インターネットプロトコルと
関連技術の支援を実装します。それらは全てPythonで実装されています。
これらのモジュールの大部分は、システム依存のモジュール `socket' が存在することが必要ですが、
これは現在ではほとんどの一般的なプラットフォーム上でサポート
されています。ここに概観を示します。

* Menu:

* webbrowser::
* cgi::
* cgitb::
* wsgiref::
* urllib::
* urllib2::
* httplib::
* ftplib::
* gopherlib::
* poplib::
* imaplib::
* nntplib::
* smtplib::
* smtpd::
* telnetlib::
* uuid::
* urlparse::
* SocketServer::
* BaseHTTPServer::
* SimpleHTTPServer::
* CGIHTTPServer::
* cookielib::
* Cookie::
* xmlrpclib::
* SimpleXMLRPCServer::
* DocXMLRPCServer::


File: python-lib-jp.info,  Node: webbrowser,  Next: cgi,  Prev: インターネットプロトコルとその支援,  Up: インターネットプロトコルとその支援

18.1 便利なウェブブラウザコントローラー
=======================================

ウェウブブラウザーのための使い易いコントローラー

`webbrowser'モジュールにはウェブベースのドキュメントを表示するた
めの、とてもハイレベルなインターフェースが定義されています。たいていの
環境では、このモジュールの`open()'を呼び出すだけで正しく動作し ます。

UNIXでは、X11上でグラフィカルなブラウザが選択されますが、グラフィカルなブ
ラウザが利用できなかったり、X11が利用できない場合はテキストモードのブラウザ
が使われます。
もしテキストモードのブラウザが使われたら、ユーザがブラウザから抜け出すまでプ
ロセスの呼び出しはブロックされます。

環境変数`BROWSER'が存在するならプラットフォームのデフォ
ルトであるブラウザのリストをオーバーライドし、os.pathsepで区切られたリストの順に
ブラウザの起動を試みます。
リストの中の値に`%s'が含まれていたら、テキストモードのブラウザのコマン
ドラインとして`%s'の代わりにURLが引数として解釈されます；
もし`%s'が含まれなければ、起動するブラウザの名前として単純に解釈されま
す。

非UNIXプラットフォームあるいはUNIX上でリモートブラウザが利用可能な場合、制
御プロセスはユーザがブラウザを終了するのを待ちませんが、ディスプレイにブラウ
ザのウィンドウを表示させたままにします。UNIX上でリモートブラウザが利用可能
でない場合、制御プロセスは新しいブラウザを立ち上げ、待ちます。

`webbrowser'
スクリプトをこのモジュールのコマンドラインインタフェースとして
使うことができます。スクリプトは引数に一つの URL
を受け付けます。また次のオプション 引数を受け付けます。 `-n'
により可能ならば新しいブラウザウィンドウで 指定された URL
を開きます。一方、`-t' では新しいブラウザのページ(「タブ」)
で開きます。当然ながらこれらのオプションは排他的です。

以下の例外が定義されています：

`Error'
     ブラウザのコントロールエラーが起こると発生する例外。

以下の関数が定義されています：

`open(url[, new=0[, autoraise=1]])'
     デフォルトのブラウザでURLを表示します。 NEWが 0
     なら、URLはブラウザの今までと同じウィンドウで開きます。 NEWが 1
     なら、可能であればブラウザの新しいウィンドウが開きます。 NEWが 2
     なら、可能であればブラウザの新しいタブが開きます。
     AUTORAISEがtrueなら、可能であればウィンドウが前面に表示されます（多く
     のウィンドウマネージャではこの変数の設定に関わらず、前面に表示されます）。
     _Changed in Python version 2.5_

`open_new(url)'
     可能であれば、デフォルトブラウザの新しいウィンドウでURLを開きますが、
     そうでない場合はブラウザのただ１つのウィンドウでURLを開きます。

`open_new_tab(url)'
     可能であれば、デフォルトブラウザの新しいページ(「タブ」)でURLを開きますが、
     そうでない場合は`open_new'と同様に振る舞います。 _Added in Python
     version 2.5_

`get([name])'
     ブラウザの種類NAMEのコントローラーオブジェクトを返します。
     もしNAMEが空文字列なら、呼び出した環境に適したデフォルトブラウザのコン
     トローラーを返します。

`register(name, constructor[, instance])'
     ブラウザの種類NAMEを登録します。
     ブラウザの種類が登録されたら、`get()'でそのブラウザのコントローラー
     を呼び出すことができます。
     INSTANCEが指定されなかったり、`None'なら、インスタンスが必要な時
     にはCONSTRUCTORがパラメータなしに呼び出されて作られます。
     INSTANCEが指定されたら、CONSTRUCTORは呼び出されないので、
     `None'でかまいません。

     この登録は、変数`BROWSER'を設定するか、`get'を空文字列でな
     く、宣言したハンドラの名前と一致する引数とともに呼び出すときだけ、役に立ちま
     す。

いくつかの種類のブラウザがあらかじめ定義されています。
このモジュールで定義されている、関数`get()'に与えるブラウザの名前
と、それぞれのコントローラークラスのインスタンスを以下の表に示します。

Type Name                Class Name               Notes
------                   -----                    -----
'mozilla'                `Mozilla('mozilla')'     
'firefox'                `Mozilla('mozilla')'     
'netscape'               `Mozilla('netscape')'    
'galeon'                 `Galeon('galeon')'       
'epiphany'               `Galeon('epiphany')'     
'skipstone'              `BackgroundBrowser('skipstone')'
'kfmclient'              `Konqueror()'            (1)
'konqueror'              `Konqueror()'            (1)
'kfm'                    `Konqueror()'            (1)
'mosaic'                 `BackgroundBrowser('mosaic')'
'opera'                  `Opera()'                
'grail'                  `Grail()'                
'links'                  `GenericBrowser('links')'
'elinks'                 `Elinks('elinks')'       
'lynx'                   `GenericBrowser('lynx')' 
'w3m'                    `GenericBrowser('w3m')'  
'windows-default'        `WindowsDefault'         (2)
'internet-config'        `InternetConfig'         (3)
'macosx'                 `MacOSX('default')'      (4)

Notes:

`(1)'
     "Konqueror"はUNIXのKDEデスクトップ環境のファイルマネージャで、KDEが動作
     している時にだけ意味を持ちます。
     何か信頼できる方法でKDEを検出するのがいいでしょう；変数`KDEDIR'では十
     分ではありません。 また、KDE
     2で`konqueror'コマンドを使うときにも、"kfm"が使われます --
     Konquerorを動作させるのに最も良い方法が実装によって選択されます。

`(2)'
     Windowsプラットフォームのみ。

`(3)'
     MacOSプラットフォームのみ；マニュアルに解説されている標準MacPythonモジュール`ic'
     を必要とします。

`(4)'
     MacOS X プラットフォームのみ。

簡単な例を示します。

     url = 'http://www.python.org'

     # Open URL in a new tab, if a browser window is already open.
     webbrowser.open_new_tab(url + '/doc')

     # Open URL in new window, raising the window if possible.
     webbrowser.open_new(url)

* Menu:

* ブラウザコントローラーオブジェクト::


File: python-lib-jp.info,  Node: ブラウザコントローラーオブジェクト,  Prev: webbrowser,  Up: webbrowser

18.1.1 ブラウザコントローラーオブジェクト
-----------------------------------------

ブラウザコントローラーには２つのメソッドが定義されていて、モジュールレベルの
便利な２つの関数に相当します：

`open(url[, new[, autoraise=1]])'
     このコントローラーでハンドルされたブラウザでURLを表示します。
     NEWが 1 なら、可能であればブラウザの新しいウィンドウが開きます。
     NEWが 2
     なら、可能であればブラウザの新しいページ(「タブ」)が開きます。

`open_new(url)'
     可能であれば、このコントローラーでハンドルされたブラウザの新しいウィンドウで
     URLを開きますが、そうでない場合はブラウザのただ１つのウィンドウで
     URLを開きます。`open_new' の別名。

`open_new_tab(url)'
     可能であれば、このコントローラーでハンドルされたブラウザの新しいページ(「タブ」)で
     URLを開きますが、そうでない場合は `open_new' と同じです。 _Added
     in Python version 2.5_


File: python-lib-jp.info,  Node: cgi,  Next: cgitb,  Prev: webbrowser,  Up: インターネットプロトコルとその支援

18.2 CGI (ゲートウェイインタフェース規格) のサポート
====================================================

サーバ側で動作するスクリプトがフォームの内容を
解釈するために使うゲートウェイインタフェース規格のサポート。

ゲートウェイインタフェース規格 (CGI) に準拠したスクリプトを
サポートするためのモジュールです。

このモジュールでは、 Python で CGI スクリプトを書く際に使える
様々なユーティリティを定義しています。

* Menu:

* cgi-intro::
* Using the cgi module::
* 高水準インタフェース::
* 古いクラス群::
* Functions in cgi module::
* セキュリティへの配慮::
* CGI スクリプトを UNIX システムにインストールする::
* CGI スクリプトをテストする::
* CGI スクリプトをデバッグする::
* よくある問題と解決法::


File: python-lib-jp.info,  Node: cgi-intro,  Next: Using the cgi module,  Prev: cgi,  Up: cgi

18.2.1 はじめに
---------------

CGI スクリプトは、HTTP サーバによって起動され、 通常は HTML の`<FORM>'
または `<ISINDEX>' エレメントを 通じてユーザが入力した内容を処理します。

ほとんどの場合、CGI スクリプトはサーバ上の特殊なディレクトリ `cgi-bin'
の下に置きます。HTTP サーバは、まずスクリプトを
駆動するためのシェルの環境変数に、リクエストの全ての情報
(クライアントのホスト名、リクエストされている URL、クエリ文字列、
その他諸々) を設定し、スクリプトを実行した後、スクリプトの出力を
クライアントに送信します。

スクリプトの入力端もクライアントに接続されていて、この経路を通じて
フォームデータを読み込むこともあります。それ以外の場合には、
フォームデータは URL の一部分である 「クエリ文字列」を介して
渡されます。このモジュールでは、上記のケースの違いに注意しつつ、 Python
スクリプトに対しては単純なインタフェースを提供しています。
このモジュールではまた、スクリプトをデバッグするための
ユーティリティも多数提供しています。また、最近はフォームを
経由したファイルのアップロードをサポートしています (ブラウザ側
がサポートしていればです)。

CGI スクリプトの出力は 2 つのセクションからなり、空行で分割
されています。最初のセクションは複数のヘッダからなり、
後続するデータがどのようなものかをクライアントに通知します。
最小のヘッダセクションを生成するための Python のコードは
以下のようなものです:

     print "Content-Type: text/html"     # 以降のデータが HTML であることを示す行
     print                               # ヘッダ部の終了を示す空行

二つ目のセクションは通常、ヘッダやインラインイメージ等の付属した
テキストをうまくフォーマットして表示できるようにした HTML です。
以下に単純な HTML を出力する Python コードを示します:

     print "<TITLE>CGI script output</TITLE>"
     print "<H1>This is my first CGI script</H1>"
     print "Hello, world!"


File: python-lib-jp.info,  Node: Using the cgi module,  Next: 高水準インタフェース,  Prev: cgi-intro,  Up: cgi

18.2.2 cgi モジュールを使う
---------------------------

先頭には `import cgi' と書いてください。`from cgi import *'
と書いてはなりません -- このモジュールでは、以前のバージョンとの
互換性を持たせるため、内部で呼び出す名前を多数定義しており、それらを
ユーザの名前空間に存在させる必要はないからです。

新たにスクリプトを書く際には、以下の一行を付加するかどうか検討してください:

     import cgitb; cgitb.enable()

これによって、特別な例外処理が有効にされ、エラーが発生した際にブラウザ
上に詳細なレポートを出力するようになります。ユーザにスクリプトの内部を
見せたくないのなら、以下のようにしてレポートをファイルに保存できます:

     import cgitb; cgitb.enable(display=0, logdir="/tmp")

スクリプトを開発する際には、この機能はとても役に立ちます。 `cgitb'
が生成する報告はバグを追跡するためにかかる
時間を大幅に減らせるような情報を提供してくれます。スクリプトを
テストし終わり、正確に動作することを確認したら、いつでも `cgitb'
の行を削除できます。

入力されたフォームデータを取得するには、 `FieldStorage' クラス
を使うのが最良の方法です。このモジュールで定義されている他のクラスの
ほとんどは以前のバージョンとの互換性のためのものです。
インスタンス生成は引数なしで必ず 1 度だけ行います。これにより、
標準入力または環境変数からフォームの内容を読み出します
(どちらから読み出すかは、複数の環境変数の値が CGI 標準に従って
どう設定されているかで決まります)。インスタンスが標準入力を
使うかもしれないので、インスタンス生成を行うのは一度だけにしなければ
なりません。

`FieldStorage' のインスタンスは Python の辞書のようにインデクス
を使って参照でき、標準の辞書に対するメソッド `has_key()' と `keys()'
をサポートしています。組み込みの関数 `len()'
もサポートしています。空の文字列を含むフォームのフィールドは
無視され、辞書には入りません; そういった値を保持するには、
`FieldStorage' のインスタンスを生成する時にオプションの
KEEP_BLANK_VALUES キーワード引数を true に設定してください。

例えば、以下のコード (`Content-Type' ヘッダと空行は
すでに出力された後とします) は `name' および `addr'
フィールドが両方とも空の文字列に設定されていないか調べます:

     form = cgi.FieldStorage()
     if not (form.has_key("name") and form.has_key("addr")):
         print "<H1>Error</H1>"
         print "Please fill in the name and addr fields."
         return
     print "<p>name:", form["name"].value
     print "<p>addr:", form["addr"].value
     ...further form processing here...

ここで、`form[KEY]' で参照される各フィールドは それ自体が
`FieldStorage' (または `MiniFieldStorage'　。
フォームのエンコードによって変わります) のインスタンスです。
インスタンスの属性 `value' の内容は対応するフィールドの値で、
文字列になります。 `getvalue()' メソッドはこの文字列値を直接返します。
`getvalue()' の 2 つめの引数にオプションの値を与えると、
リクエストされたキーが存在しない場合に返すデフォルトの値になります。

入力されたフォームデータに同じ名前のフィールドが二つ以上あれば、
`form[KEY]' で得られるオブジェクトは `FieldStorage' や
`MiniFieldStorage' のインスタンスではなく、そうしたインスタンスの
リストになります。この場合、`form.getvalue(KEY)' も同様に、
文字列からなるリストを返します。 もしこうした状況が起きうると思うなら
(HTML のフォームに同じ名前をもったフィールドが複数含まれているのなら) 、
組み込み関数 `isinstance()'
を使って、返された値が単一のインスタンスかインスタンスのリストかどうか
調べてください。例えば、以下のコードは任意の数のユーザ名フィールドを
結合し、コンマで分割された文字列にします:

     value = form.getvalue("username", "")
     if isinstance(value, list):
         # Multiple username fields specified
         usernames = ",".join(value)
     else:
         # Single or no username field specified
         usernames = value

フィールドがアップロードされたファイルを表している場合、`value' 属性や
`getvalue()' メソッドを使ってフィールドの値にアクセス
すると、ファイルの内容を全て文字列としてメモリ上に読み込んでしまいます。
これは望ましくない機能かもしれません。アップロードされたファイルが
あるかどうかは `filename' 属性および `file' 属性の
いずれかで調べられます。その後、以下のようにして`file' 属性から
落ち着いてデータを読み出せます:

     fileitem = form["userfile"]
     if fileitem.file:
         # It's an uploaded file; count lines
         linecount = 0
         while 1:
             line = fileitem.file.readline()
             if not line: break
             linecount = linecount + 1

現在ドラフトとなっているファイルアップロードの標準仕様では、一つの
フィールドから (再帰的な `multipart/*' エンコーディングを 使って)
複数のファイルがアップロードされる可能性を受け入れています。
この場合、アイテムは辞書形式の `FieldStorage' アイテムと
なります。複数ファイルかどうかは `type' 属性が `multipart/form-data'
(または `multipart/*' に マッチする他の MIME 型)
になっているかどうかを調べれば判別できます。
この場合、トップレベルのフォームオブジェクトと同様にして再帰的に
個別処理できます。

フォームが 「古い」 形式で入力された場合 (クエリ文字列または
単一の`application/x-www-form-urlencoded' データで入力
された場合)、データ要素の実体は `MiniFieldStorage' クラスの
インスタンスになります。この場合、`list' 、`file' 、および `filename'
属性は常に `None' になります。


File: python-lib-jp.info,  Node: 高水準インタフェース,  Next: 古いクラス群,  Prev: Using the cgi module,  Up: cgi

18.2.3 高水準インタフェース
---------------------------

_Added in Python version 2.2_ 前節では CGI フォームデータを
`FieldStorage' クラスを使って
読み出す方法について解説しました。この節では、フォームデータを
分かりやすく直感的な方法で読み出せるようにするために追加された、
より高水準のインタフェースについて記述します。
このインタフェースは前節で説明した技術を撤廃するものでは ありません --
例えば、前節の技術は依然としてファイルのアップロードを
効率的に行う上で便利です。

このインタフェースは 2 つの単純なメソッドからなります。このメソッドを
使えば、一般的な方法でフォームデータを処理でき、ある名前のフィールドに
入力された値が一つなのかそれ以上なのかを心配する必要がなくなります。

前節では、一つのフィールド名に対して二つ以上の値が入力される
かもしれない場合には、常に以下のようなコードを書くよう学びました:

     item = form.getvalue("item")
     if isinstance(item, list):
         # The user is requesting more than one item.
     else:
         # The user is requesting only one item.

こういった状況は、例えば以下のように、同じ名前を持った複数の
チェックボックスからなるグループがフォームに入っているような場合に
よく起きます:

     <input type="checkbox" name="item" value="1" />
     <input type="checkbox" name="item" value="2" />

しかしながら、ほとんどの場合、あるフォーム中で特定の名前を持った
コントロールはただ一つしかないので、その名前に関連付けられた値は
ただ一つしかないはずだと考えるでしょう。そこで、スクリプトには例えば
以下のようなコードを書くでしょう:

     user = form.getvalue("user").upper()

このコードの問題点は、クライアント側がスクリプトにとって常に有効な
入力を提供するとは期待できないところにあります。
例えば、もし好奇心旺盛なユーザがもう一つの `user=foo' ペア
をクエリ文字列に追加したら、`getvalue(``'user')' メソッドは
文字列ではなくリストを返すため、このスクリプトはクラッシュするでしょう。
リストに対して `upper()' メソッドを呼び出すと、引数が 有効でない
(リスト型はその名前のメソッドを持っていない) ため、例外
`AttributeError' を送出します。

従って、フォームデータの値を読み出しには、得られた値が
単一の値なのか値のリストなのかを常に調べるコードを使うのが適切
でした。これでは煩わしく、より読みにくいスクリプトになってしまいます。

ここで述べる高水準のインタフェースで提供している `getfirst()' や
`getlist()' メソッドを使うと、もっと便利にアプローチできます。

`getfirst(name[, default])'
     フォームフィールド NAME に関連付けられた値をつねに一つだけ
     返す軽量メソッドです。同じ名前で 1
     つ以上の値がポストされている場合、
     このメソッドは最初の値だけを返します。フォームから値を受信する
     際の値の並び順はブラウザ間で異なる可能性があり、特定の順番であるとは
     期待できないので注意してください。 (1)

     指定したフォームフィールドや値がない場合、このメソッドはオプションの引数
     DEFAULT を返します。このパラメタを指定しない場合、標準の 値は
     `None' に設定されます。

`getlist(name)'
     このメソッドはフォームフィールド NAME に関連付けられた値を
     常にリストにして返します。NAME に指定したフォームフィールドや値が
     存在しない場合、このメソッドは空のリストを返します。値が一つだけ
     存在する場合、要素を一つだけ含むリストを返します。

これらのメソッドを使うことで、以下のようにナイスでコンパクトに
コードを書けます:

     import cgi
     form = cgi.FieldStorage()
     user = form.getfirst("user", "").upper()    # This way it's safe.
     for item in form.getlist("item"):
         do_something(item)

---------- Footnotes ----------

(1) 最近のバージョンの HTML 仕様ではフィールドの値を供給する
順番を取り決めてはいますが、ある HTTP リクエストがその取り決めに
準拠したブラウザから受信したものかどうか、そもそもブラウザから送信
されたものかどうかの判別は退屈で間違いやすいので注意してください。


File: python-lib-jp.info,  Node: 古いクラス群,  Next: Functions in cgi module,  Prev: 高水準インタフェース,  Up: cgi

18.2.4 古いクラス群
-------------------

これらのクラスは、`cgi' モジュールの以前のバージョンに入って
おり、以前のバージョンとの互換性のために現在もサポートされています。
新しいアプリケーションでは `FieldStorage' クラスを使うべきです。

`SvFormContentDict' は単一の値しか持たないフォームデータの内容
を辞書として記憶します; このクラスでは、各フィールド名はフォーム中に
一度しか現れないと仮定しています。

`FormContentDict' は複数の値を持つフォームデータの内容
を辞書として記憶します (フォーム要素は値のリストです);
フォームが同じ名前を持ったフィールドを複数含む場合に便利です。

他のクラス (`FormContent'、`InterpFormContentDict') は
非常に古いアプリケーションとの後方互換性のために存在します。
これらのクラスをいまだに使っていて、このモジュールの次のバージョンで
消えてしまったら非常に不便な場合は、作者まで連絡を下さい。


File: python-lib-jp.info,  Node: Functions in cgi module,  Next: セキュリティへの配慮,  Prev: 古いクラス群,  Up: cgi

18.2.5 関数
-----------

より細かく CGI をコントロールしたり、このモジュールで実装されている
アルゴリズムを他の状況で利用したい場合には、以下の関数が便利です。

`parse(fp[, keep_blank_values[, strict_parsing]])'
     環境変数、またはファイルからからクエリを解釈します (ファイルは
     標準で `sys.stdin' になります) KEEP_BLANK_VALUES および
     STRICT_PARSING パラメタはそのまま `parse_qs()' に 渡されます。

`parse_qs(qs[, keep_blank_values[, strict_parsing]])'
     文字列引数として渡されたクエリ文字列
     (`application/x-www-form-urlencoded' 型のデータ) を
     解釈します。解釈されたデータを辞書として返します。
     辞書のキーは一意なクエリ変数名で、値は各変数名に対する値からなる
     リストです。

     オプションの引数 KEEP_BLANK_VALUES は、 URL エンコード
     されたクエリ中で値の入っていないものを空文字列と見なすかどうか
     を示すフラグです。値が真であれば、値の入っていないフィールド
     は空文字列のままになります。標準では偽で、値の入っていない
     フィールドを無視し、そのフィールドはクエリに含まれていない
     ものとして扱います。

     オプションの引数 STRICT_PASING はパース時のエラーをどう
     扱うかを決めるフラグです。値が偽なら (標準の設定です)、
     エラーは暗黙のうちに無視します。値が真なら`ValueError'
     例外を送出します。

     辞書等をクエリ文字列に変換する場合は``urllib'.
     urlencode()'関数を使用してください。

`parse_qsl(qs[, keep_blank_values[, strict_parsing]])'
     文字列引数として渡されたクエリ文字列
     (`application/x-www-form-urlencoded' 型のデータ) を
     解釈します。解釈されたデータは名前と値のペアからなるリストです。

     オプションの引数 KEEP_BLANK_VALUES は、 URL エンコード
     されたクエリ中で値の入っていないものを空文字列と見なすかどうか
     を示すフラグです。値が真であれば、値の入っていないフィールド
     は空文字列のままになります。標準では偽で、値の入っていない
     フィールドを無視し、そのフィールドはクエリに含まれていない
     ものとして扱います。

     オプションの引数 STRICT_PASING はパース時のエラーをどう
     扱うかを決めるフラグです。値が偽なら (標準の設定です)、
     エラーは暗黙のうちに無視します。値が真なら`ValueError'
     例外を送出します。

     ペアのリストからクエリ文字列を生成する場合には
     {`urllib'.urlencode()} 関数を使用します。

`parse_multipart(fp, pdict)'
     (ファイル入力のための) `multipart/form-data' 型の入力を
     解釈します。引数は入力ファイルを示す FP と `Content-Type'
     ヘッダ内の他のパラメタを含む辞書 PDICT です。

     `parse_qs()' と同じく辞書を返します。辞書のキーは
     フィールド名で、対応する値は各フィールドの値でできたリストです。
     この関数は簡単に使えますが、数メガバイトのデータがアップロードされる
     と考えられる場合にはあまり適していません -- その場合、
     より柔軟性のある `FieldStorage' を代りに使ってください。

     マルチパートデータがネストしている場合、各パートを解釈できないので
     注意してください -- 代りに `FieldStorage' を使ってください。

`parse_header(string)'
     (`Content-Type' のような) MIME ヘッダを解釈し、ヘッダの
     主要値と各パラメタからなる辞書にします。

`test()'
     メインプログラムから利用できる堅牢性テストを行う CGI
     スクリプトです。 最小の HTTP ヘッダと、HTML
     フォームからスクリプトに供給された全ての
     情報を書式化して出力します。

`print_environ()'
     シェル変数を HTML に書式化して出力します。

`print_form(form)'
     フォームを HTML に初期化して出力します。

`print_directory()'
     現在のディレクトリを HTML に書式化して出力します。 Format the
     current directory in HTML.

`print_environ_usage()'
     意味のある (CGI の使う) 環境変数を HTML で出力します。

`escape(s[, quote])'
     文字列 S 中の文字 `&'、 `<'、 および `>' を HTML
     で正しく表示できる文字列に変換します。
     それらの文字が中に入っているかもしれないようなテキストを出力
     する必要があるときに使ってください。 オプションの引数 QUOTE
     の値が真であれば、二重引用符文字 (`"') も変換します;
     この機能は、例えば `<A HREF="...">' といったような HTML
     の属性値を出力に含めるのに
     役立ちます。クオートされる値が単引用符か二重引用符、またはその両方
     を含む可能性がある場合は、代りに `xml.sax.saxutils' の
     `quoteattr()' 関数を検討してください。



File: python-lib-jp.info,  Node: セキュリティへの配慮,  Next: CGI スクリプトを UNIX システムにインストールする,  Prev: Functions in cgi module,  Up: cgi

18.2.6 セキュリティへの配慮
---------------------------

重要なルールが一つあります: ( 関数 `os.system()' または `os.popen()'
、またはその他の同様の機能によって )
外部プログラムを呼び出すなら、クライアントから受信した任意の
文字列をシェルに渡していないことをよく確かめてください。
これはよく知られているセキュリティホールであり、これによって Web
のどこかにいる悪賢いハッカーが、だまされやすい CGI スクリプトに任意の
シェルコマンドを実行させてしまえます。URL の一部や
フィールド名でさえも信用してはいけません。CGI へのリクエストは
あなたの作ったフォームから送信されるとは限らないからです！

安全な方法をとるために、フォームから入力された文字をシェルに
渡す場合、文字列に入っているのが英数文字、ダッシュ、アンダースコア、
およびピリオドだけかどうかを確認してください。


File: python-lib-jp.info,  Node: CGI スクリプトを UNIX システムにインストールする,  Next: CGI スクリプトをテストする,  Prev: セキュリティへの配慮,  Up: cgi

18.2.7 CGI スクリプトを UNIX システムにインストールする
-------------------------------------------------------

あなたの使っている HTTP サーバのドキュメントを読んでください。そして
ローカルシステムの管理者と一緒にどのディレクトリに CGI スクリプト
をインストールすべきかを調べてください; 通常これはサーバのファイル
システムツリー内の `cgi-bin' ディレクトリです。

あなたのスクリプトが "others" によって読み取り可能および実行可能
であることを確認してください; UNIX ファイルモードは 8 進表記で `0755'
です (`chmod 0755 FILENAME' を使ってください)。 スクリプトの最初の行の
1 カラム目が、 `#!' で開始し、その後に Python
インタプリタへのパス名が続いていることを確認してください。 例えば:

     #!/usr/local/bin/python

Python インタプリタが存在し、"others" によって実行可能であることを
確かめてください。

あなたのスクリプトが読み書きしなければならないファイルが全て "others"
によって読み出しや書き込み可能である ことを確かめてください --
読み出し可能のファイルモードは `0644'
で、書き込み可能のファイルモードは `0666'
になるはずです。これは、セキュリティ上の理由から、 HTTP サーバが
あなたのスクリプトを特権を全く持たないユーザ "nobody" の権限で
実行するからです。この権限下では、誰でもが読める (書ける、実行できる)
ファイルしか読み出し (書き込み、実行) できません。
スクリプト実行時のディレクトリや環境変数のセットもあなたがログイン
したときの設定と異なります。特に、実行ファイルに対するシェルの 検索パス
(`PATH') や Python のモジュール検索パス
(`PYTHONPATH')が何らかの値に設定されていると期待しては いけません。

モジュールを Python の標準設定におけるモジュール検索パス上にない
ディレクトリからロードする必要がある場合、他のモジュールを取り込む
前にスクリプト内で検索パスを変更できます。例えば:

     import sys
     sys.path.insert(0, "/usr/home/joe/lib/python")
     sys.path.insert(0, "/usr/local/lib/python")

(この方法では、最後に挿入されたディレクトリが最初に検索されます！)

非 UNIX システムにおける説明は変わるでしょう; あなたの使っている HTTP
サーバのドキュメントを調べてください (普通は CGI スクリプトに
関する節があります)。


File: python-lib-jp.info,  Node: CGI スクリプトをテストする,  Next: CGI スクリプトをデバッグする,  Prev: CGI スクリプトを UNIX システムにインストールする,  Up: cgi

18.2.8 CGI スクリプトをテストする
---------------------------------

残念ながら、 CGI スクリプトは普通、コマンドラインから起動しよう
としても動きません。また、コマンドラインから起動した場合には完璧に
動作するスクリプトが、不思議なことにサーバからの起動では失敗することが
あります。しかし、スクリプトをコマンドラインから実行してみなければ
ならない理由が一つあります: もしスクリプトが文法エラーを含んで
いれば、Python インタプリタはそのプログラムを全く実行しないため、 HTTP
サーバはほとんどの場合クライアントに謎めいたエラーを送信 するからです。

スクリプトが構文エラーを含まないのにうまく動作しないなら、次の
節に読み進むしかありません。


File: python-lib-jp.info,  Node: CGI スクリプトをデバッグする,  Next: よくある問題と解決法,  Prev: CGI スクリプトをテストする,  Up: cgi

18.2.9 CGI スクリプトをデバッグする
-----------------------------------

何よりもまず、些細なインストール関連のエラーでないか確認してください --
上の CGI スクリプトのインストールに関する節を注意深く読めば
時間を大いに節約できます。もしインストールの手続きを正しく理解
しているか不安なら、このモジュールのファイル (`cgi.py')
をコピーして、CGI スクリプトとしてインストールしてみてください。
このファイルはスクリプトとして呼び出すと、スクリプトの実行環境と
フォームの内容を HTML フォームに出力します。
正しいモードなどをフォームに与えて、リクエストを送ってみてください。
標準的な `cgi-bin' ディレクトリにインストールされていれば、
以下のような URL をブラウザに入力してリクエストを送信できるはずです:

     http://yourhostname/cgi-bin/cgi.py?name=Joe+Blow&addr=At+Home

もしタイプ 404 のエラーになるなら、サーバはスクリプトを発見
できないでいます - おそらくあなたはスクリプトを別のディレクトリ
に入れる必要があるのでしょう。他のエラーになるなら、先に進む前に
解決しなければならないインストール上の問題があります。
もし実行環境の情報とフォーム内容 (この例では、
各フィールドはフィールド名 "addr" に対して値 "At Home"、および
フィールド名 "name" に対して "Joe Blow" ) が綺麗にフォーマット
されて表示されるなら、 `cgi.py'
スクリプトは正しくインストールされています。
同じ操作をあなたの自作スクリプトに対して行えば、スクリプトをデバッグ
できるようになるはずです。

次のステップでは `cgi' モジュールの `test()' 関数を
呼び出すことになります: メインプログラムコードを以下の 1 行、

     cgi.test()

と置き換えてください。この操作で `cgi.py' ファイル自体を
インストールした時と同じ結果を出力するはずです。

通常の Python スクリプトが例外を処理しきれずに送出した場合 (様々な理由:
モジュール名のタイプミス、ファイルが開けなかった、など)、 Python
インタプリタはナイスなトレースバックを出力して終了します。 Python
インタプリタはあなたの CGI スクリプトが例外を送出した場合
にも同様に振舞うので、トレースバックは大抵HTTP サーバのいずれかの
ログファイルに残るかまったく無視されるかです。

幸運なことに、あなたが自作のスクリプトで _何らかの_ コードを
実行できるようになったら、`cgitb' モジュールを使って
簡単にトレースバックをブラウザに送信できます。まだそうでないなら、
以下の一行:

     import cgitb; cgitb.enable()

をスクリプトの先頭に追加してください。そしてスクリプトを再度
走らせます; 問題が発生すれば、クラッシュの原因を見出せるような
詳細な報告を読めます。

`cgitb' モジュールのインポートに問題がありそうだと
思うなら、(組み込みモジュールだけを使った) もっと堅牢なアプローチを
取れます:

     import sys
     sys.stderr = sys.stdout
     print "Content-Type: text/plain"
     print
     ...your code here...

このコードは Python インタプリタがトレースバックを出力することに
依存しています。出力のコンテント型はプレーンテキストに設定されて
おり、全ての HTML 処理を無効にしています。スクリプトがうまく動作
する場合、生の HTML コードがクライアントに表示されます。スクリプト
が例外を送出する場合、最初の 2 行が出力された後、トレースバックが
表示されます。HTML の解釈は行われないので、トレースバックを
読めるはずです。


File: python-lib-jp.info,  Node: よくある問題と解決法,  Prev: CGI スクリプトをデバッグする,  Up: cgi

18.2.10 よくある問題と解決法
----------------------------

   * ほとんどの HTTP サーバはスクリプトの実行が完了するまで CGI からの
     出力をバッファします。このことは、スクリプトの実行中にクライアントが
     進捗状況報告を表示できないことを意味します。

   * 上のインストールに関する説明を調べましょう。

   * HTTP サーバのログファイルを調べましょう。(別のウィンドウで `tail
     -f logfile' を実行すると便利かもしれません！)

   * 常に `python script.py' などとして、スクリプトが構文エラーで
     ないか調べましょう。

   * スクリプトに構文エラーがないなら、`import cgitb; cgitb.enable()'
     をスクリプトの先頭に追加してみましょう。

   * 外部プログラムを起動するときには、スクリプトがそのプログラムを
     見つけられるようにしましょう。これは通常、絶対パス名を使うことを
     意味します -- `PATH' は普通、あまり CGI スクリプトにとって
     便利でない値に設定されています。

   * 外部のファイルを読み書きする際には、CGI スクリプトを動作
     させるときに使われる userid でファイルを読み書きできるように
     なっているか確認しましょう: userid は通常、Web サーバを動作させて
     いる userid か、Web サーバの `suexec' 機能で明示的に指定 している
     userid になります。

   * CGI スクリプトを set-uid モードにしてはいけません。これはほとんど
     のシステムで動作せず、セキュリティ上の信頼性もありません。


File: python-lib-jp.info,  Node: cgitb,  Next: wsgiref,  Prev: cgi,  Up: インターネットプロトコルとその支援

18.3 CGI スクリプトのトレースバック管理機構
===========================================

設定可能な、CGI スクリプトのトレースバック処理機構です。

_Added in Python version 2.2_ 

`cgitb' モジュールでは、Python スクリプトのための特殊な例外処理を
提供します。(実はこの説明は少し的外れです。このモジュールはもともと
徹底的なトレースバック情報を CGI スクリプトで生成した HTML 内に表示
するための設計されました。その後この情報を平文テキストでも
表示できるように一般化されています。)
このモジュールの有効化後に捕捉されない例外が生じた場合、
詳細で書式化された報告が Web ブラウザに送信されます。この報告には
各レベルにおけるソースコードの抜粋が示されたトレースバックと、現在動作
している関数の引数やローカルな変数が収められており、問題のデバッグを
助けます。オプションとして、この情報をブラウザに送信する代わりに
ファイルに保存することもできます。

この機能を有効化するためには、単に自作の CGI
スクリプトの最初に以下の一行を 追加します:

     import cgitb; cgitb.enable()

`enable()' 関数のオプションは、報告をブラウザに表示するか
どうかと、後で解析するためにファイルに報告をログ記録するかどうかを
制御します。

`enable([display[, logdir[, context [, format]]]])'
     この関数は、``sys'.excepthook' を設定することで、
     インタプリタの標準の例外処理を `cgitb' モジュールに肩代わり
     させるようにします。 

     オプションの引数 DISPLAY は標準で `1' になっており、 この値は `0'
     にしてトレースバックをブラウザに送らないように抑制する
     こともできます。引数 LOGDIR はログファイルを配置する
     ディレクトリです。オプションの引数 CONTEXT は、トレースバック
     の中で現在の行の周辺の何行を表示するかです; この値は標準で `5'
     です。 オプションの引数 FORMAT が `"html"' の場合、出力は HTML
     に書式化されます。その他の値を指定すると平文テキストの出力を
     強制します。デフォルトの値は `"html"' です。

`handler([info])'
     この関数は標準の設定 (ブラウザに報告を表示しますがファイルには
     ログを書き込みません) を使って例外を処理します。
     この関数は、例外を捕捉した際に `cgitb' を使って報告
     したい場合に使うことができます。 オプションの INFO
     引数は、例外の型、例外の値、トレースバック オブジェクトからなる 3
     要素のタプルでなければなりません。これは ``sys'.exc_info()'
     によって返される値と全く 同じです。INFO
     引数が与えられていない場合、現在の 例外は ``sys'.exc_info()'
     から取得されます。


File: python-lib-jp.info,  Node: wsgiref,  Next: urllib,  Prev: cgitb,  Up: インターネットプロトコルとその支援

18.4 WSGI ユーティリティとリファレンス実装
==========================================

WSGI ユーティリティとリファレンス実装

_Added in Python version 2.5_

Web Server Gateway Interface (WSGI) は、Web サーバソフトウェアと Python
で記述された Web アプリケーションとの標準インターフェースです。
標準インターフェースを持つことで、WSGI をサポートするアプリケーションを
幾つもの異なる Web サーバで使うことが容易になります。

Web サーバとプログラミングフレームワークの作者だけが、WSGI デザインの
あらゆる細部や特例などを知る必要があります。WSGI アプリケーションを
インストールしたり、既存のフレームワークを使ったアプリケーションを記述する
だけの皆さんは、全てについて理解する必要はありません。

`wsgiref' は WSGI 仕様のリファレンス実装で、これは Web サーバや
フレームワークに WSGI サポートを加えるのに利用できます。 これは WSGI
環境変数やレスポンスヘッダを操作するユーティリティ、 WSGI
サーバ実装時のベースクラス、WSGI アプリケーションを提供する デモ用 HTTP
サーバ、それと WSGI サーバとアプリケーションの WSGI 仕様 (PEP 333 )
準拠のバリデーションツールを提供します。

`http://www.wsgi.org'に、WSGIに関するさらなる情報と、チュートリアルや
その他のリソースへのリンクがあります。

* Menu:

* wsgirefutil - WSGI 環境のユーティリティ::
* wsgirefheaders - WSGI レスポンスヘッダツール群::
* wsgirefsimple_server - シンプルな WSGI HTTP サーバ::
* wsgirefvalidate - WSGI 準拠チェッカ::
* wsgirefhandlers - サーバ／ゲートウェイのベースクラス::


File: python-lib-jp.info,  Node: wsgirefutil - WSGI 環境のユーティリティ,  Next: wsgirefheaders - WSGI レスポンスヘッダツール群,  Prev: wsgiref,  Up: wsgiref

18.4.1 `wsgiref.util' - WSGI 環境のユーティリティ
-------------------------------------------------

このモジュールは WSGI 環境で使う様々なユーティリティ関数を提供します。
WSGI 環境は PEP 333 で記述されているような HTTP リクエスト変数を含む
辞書です。全ての ENVIRON パラメタを取る関数は WSGI 準拠の
辞書を与えられることを期待しています；細かい仕様については PEP 333 を
参照してください。

`guess_scheme(environ)'
     `wsgi.url_scheme' が "http" か "https" かについて、ENVIRON 辞書の
     `HTTPS' 環境変数を調べることでその推測を返します。
     戻り値は文字列(string)です。

     この関数は、CGI や FastCGI のような CGI
     に似たプロトコルをラップする
     ゲートウェイを作成する場合に便利です。典型的には、それらのプロトコルを
     提供するサーバが SSL 経由でリクエストを受け取った場合には `HTTPS'
     変数に 値 "1" "yes"、または "on"
     を持つでしょう。ですので、この関数はそのような値が
     見つかった場合には "https" を返し、そうでなければ "http"
     を返します。

`request_uri(environ [, include_query=1])'
     クエリ文字列をオプションで含むリクエスト URI 全体を、 PEP 333 の
     "URL 再構築(URL Reconstruction)"
     にあるアルゴリズムを使って返します。 INCLUDE_QUERY が false
     の場合、クエリ文字列は結果となる文字列には 含まれません。

`application_uri(environ)'
     `request_url' に似ていて、`PATH_INFO' と `QUERY_STRING' 変数は
     無視されます。結果はリクエストによって指定されたアプリケーションオブジェクトの
     ベース URI です。

`shift_path_info(environ)'
     `PATH_INFO' から`SCRIPT_NAME' まで一つの名前をシフトして
     その名前を返します。ENVIRON 辞書は_変更されます_；`PATH_INFO' や
     `SCRIPT_NAME'
     のオリジナルをそのまま残したい場合にはコピーを使ってください。

     `PATH_INFO' にパスセグメントが何も残っていなければ、`None'
     が返されます。

     典型的なこのルーチンの使い方はリクエスト URI
     のそれぞれの要素の処理で、
     例えばパスを一連の辞書のキーとして取り扱う場合です。
     このルーチンは、渡された環境を、ターゲット URL で示される別の WSGI
     アプリケーション の呼び出しに合うように調整します。 例えば、`/foo'
     に WSGI アプリケーションがあったとして、そして リクエスト URL
     パスが `/foo/bar/baz' で、`/foo' の WSGI アプリケーションが
     `shift_path_info' を呼んだ場合、これは "bar" 文字列を受け取り、
     環境は `/foo/bar' の WSGI
     アプリケーションへの受け渡しに適するように
     更新されます。つまり、`SCRIPT_NAME' は `/foo' から `/foo/bar'
     に変わって、 `PATH_INFO' は `/bar/baz' から `/baz'
     に変化するのです。

     `PATH_INFO' が単に "/" の場合、このルーチンは空の文字列を返し、
     `SCRIPT_NAME' の末尾にスラッシュを加えます、これはたとえ
     空のパスセグメントが通常は無視され、そして `SCRIPT_NAME' は通常
     スラッシュで終わる事が無かったとしてもです。これは意図的な振る舞いで、
     このルーチンでオブジェクト巡回(object traversal) をした場合に `/x'
     で終わる URI と `/x/' で終わるものを
     アプリケーションが識別できることを保証するためのものです。

`setup_testing_defaults(environ)'
     テスト目的で、ENVIRON を自明なデフォルト値 (trivial defaults)
     で更新します。

     このルーチンは WSGI に必要な様々なパラメタを追加し、それには
     `HTTP_HOST'、`SERVER_NAME'、`SERVER_PORT'、
     `REQUEST_METHOD'、`SCRIPT_NAME'、`PATH_INFO'、あとは PEP 333 で定義されている
     `wsgi.*' 変数群を含みます。これは
     デフォルト値のみを追加し、これらの変数の既存設定は一切置きかえません。

     このルーチンは、ダミー環境をセットアップすることによって WSGI
     サーバと
     アプリケーションのユニットテストを容易にすることを意図しています。
     これは実際の WSGI
     サーバやアプリケーションで使うべきではありません。
     なぜならこのデータは偽物なのです！

上記の環境用関数に加えて、`wsgiref.util' モジュールも
以下のようなその他のユーティリティを提供します：

`is_hop_by_hop(header_name)'
     'header_name' が RFC 2616 で定義されている HTTP/1.1 の
     "Hop-by-Hop" ヘッダの 場合に true を返します。

`FileWrapper(filelike [, blksize=8192])'
     ファイルライクオブジェクトをイテレータに変換するラッパです。
     結果のオブジェクトは `__getitem__' と `__iter__' 両方を
     サポートしますが、これは Python 2.1 と Jython の互換性のためです。
     オブジェクトがイテレートされる間、オプションの BLKSIZE パラメタが
     くり返し FILELIKE オブジェクトの `read()' メソッドに渡されて
     受け渡す文字列を取得します。`read()' が空文字列を返した場合
     イテレーションは終了して、再開されることはありません。

     FILELIKE に `close()' メソッドがある場合、返されたオブジェクトも
     `close()' メソッドを持ち、これが呼ばれた場合には FILELIKE
     オブジェクトの `close()' メソッドを呼び出します。


File: python-lib-jp.info,  Node: wsgirefheaders - WSGI レスポンスヘッダツール群,  Next: wsgirefsimple_server - シンプルな WSGI HTTP サーバ,  Prev: wsgirefutil - WSGI 環境のユーティリティ,  Up: wsgiref

18.4.2 `wsgiref.headers' - WSGI レスポンスヘッダツール群
--------------------------------------------------------

このモジュールは単一のクラス、`Headers' を提供し、WSGI
レスポンスヘッダの 操作をマップに似たインターフェースで便利にします。

`Headers(headers)'
     HEADERS をラップするマップに似たオブジェクトを生成します。これは
     PEP 333 に定義されるようなヘッダの名前／値のタプルのリストです。
     新しい `Headers' オブジェクトに与えられた変更は、一緒に作成された
     HEADERS リストを直接更新します。

     `Headers'
     オブジェクトは典型的なマッピング操作をサポートし、これには
     `__getitem__'、`get'、`__setitem__'、
     `setdefault'、`__delitem__'、`__contains__' と `has_key'
     を含みます。これらメソッドのそれぞれにおいて、キーは
     ヘッダ名で（大文字小文字は区別しません）、値はそのヘッダ名に関連づけられた
     最初の値です。ヘッダを設定すると既存のヘッダ値は削除され、ラップされた
     ヘッダのリストの末尾に新しい値が加えられます。既存のヘッダの順番は
     一般的に整えられていて、ラップされたリストの最後に新しいヘッダが追加されます。

     辞書とは違って、`Headers' オブジェクトはラップされたヘッダリストに
     存在しないキーを取得または削除しようとした場合にもエラーを発生しません。
     単に、存在しないヘッダの取得は `None'
     を返し、存在しないヘッダの削除は 何もしません。

     `Headers' オブジェクトは `keys()'、`values()'、 `items()'
     メソッドもサポートします。`keys()' と `items()' で
     返されるリストは、同じキーを一回以上含むことがあり、これは複数の値を持つヘッダの場合です。
     `Header' オブジェクトの `len()' は、その `items()'
     の長さと同じであり、
     ラップされたヘッダリストの長さと同じです。事実、`items()'
     メソッドは
     単にラップされたヘッダリストのコピーを返しているだけです。

     `Headers' オブジェクトに対して `str()' を呼ぶと、HTTP
     レスポンスヘッダとして
     送信するのに適した形に整形された文字列を返します。それぞれのヘッダはコロンとスペースで
     区切られた値と共に一列に並んでいます。
     それぞれの行はキャリッジリターンとラインフィードで終了し、文字列は空行で終了しています。

     これらのマッピングインターフェースと整形機能に加えて、`Headers'
     オブジェクトは 複数の値を持つヘッダの取得と追加、MIME
     パラメタでヘッダを追加するための
     以下のようなメソッド群も持っています：

    `get_all(name)'
          指定されたヘッダの全ての値のリストを返します。

          返されるリストは、元々のヘッダリストに現れる順、またはこのインスタンスに
          追加された順に並んでいて、複製を含む場合があります。削除されて加えられた
          フィールドは全てヘッダリストの末尾に付きます。ある名前のフィールドが何もなければ、
          空のリストが返ります。

    `add_header(name, value, **_params)'
          ヘッダ（複数の値かもしれません）を、キーワード引数を通じて指定する
          オプションの MIME パラメタと共に追加します。

          NAME は追加するヘッダフィールドです。このヘッダフィールドに
          MIME パラメタを
          設定するためにキーワード引数を使うことができます。それぞれのパラメタは文字列か
          `None' で
          なければいけません。パラメタ中のアンダースコアはダッシュに変換されます、これはダッシュが
          Python の識別子としては不正なのですが、多くの MIME
          パラメタはダッシュを含むためです。
          パラメタ値が文字列の場合、これはヘッダ値のパラメタに
          `name="value"' の形で追加されます。 これがもし `None'
          の場合、パラメタ名だけが追加されます。（これは値なしの MIME
          パラメタの 場合に使われます。）使い方の例は：

               h.add_header('content-disposition', 'attachment', filename='bud.gif')

          上記はこのようなヘッダを追加します：

               Content-Disposition: attachment; filename="bud.gif"




File: python-lib-jp.info,  Node: wsgirefsimple_server - シンプルな WSGI HTTP サーバ,  Next: wsgirefvalidate - WSGI 準拠チェッカ,  Prev: wsgirefheaders - WSGI レスポンスヘッダツール群,  Up: wsgiref

18.4.3 `wsgiref.simple_server' - シンプルな WSGI HTTP サーバ
------------------------------------------------------------

このモジュールは WSGI アプリケーションを提供する シンプルな HTTP
サーバです（`BaseHTTPServer' がベースです）。
個々のサーバインスタンスは単一の WSGI
アプリケーションを、特定のホストとポート上で
提供します。もし一つのホストとポート上で複数のアプリケーションを提供したいならば、
`PATH_INFO'
をパースして個々のリクエストでどのアプリケーションを呼び出すか
選択するような WSGI アプリケーションを作るべきです。（例えば、
`wsgiref.util' から `shift_path_info()' を利用します。）

`make_server(host, port, app [, server_class=`WSGIServer' [, handler_class=`WSGIRequestHandler']])'
     HOST と PORT 上で待機し、 APP へのコネクションを受け付ける WSGI
     サーバを作成します。戻り値は与えられた SERVER_CLASS
     のインスタンスで、 指定された HANDLER_CLASS
     を使ってリクエストを処理します。APP は PEP 333 で
     定義されるところの WSGI アプリケーションでなければいけません。

     使用例：
          from wsgiref.simple_server import make_server, demo_app

          httpd = make_server('', 8000, demo_app)
          print "Serving HTTP on port 8000..."

          # プロセスが死ぬまでリクエストに答える
          httpd.serve_forever()

          # 代替：１つのリクエストを受けて終了する
          ##httpd.handle_request()


`demo_app(environ, start_response)'
     この関数は小規模ながら完全な WSGI アプリケーションで、 "Hello
     world!" メッセージと、ENVIRON パラメタに提供されている
     キー／値のペアをを含むテキストページを返します。 これは WSGI
     サーバ（`wsgiref.simple_server' のような）が シンプルな WSGI
     アプリケーションを正しく実行できるかを確かめるのに便利です。

`WSGIServer(server_address, RequestHandlerClass)'
     `WSGIServer' インスタンスを作成します。SERVER_ADDRESS は
     `(host,port)' のタプル、そして REQUESTHANDLERCLASS は
     リクエストの処理に使われる `BaseHTTPServer.BaseHTTPRequestHandler'
     の サブクラスでなければいけません。

     `make_server' が細かい調整をやってくれるので、
     通常はこのコンストラクタを呼ぶ必要はありません。

     `WSGIServer' は `BaseHTTPServer.HTTPServer' のサブクラスですので、
     この全てのメソッド（`serve_forever()' や `handle_request()'
     のような）が 利用できます。 `WSGIServer' も以下のような WSGI
     固有メソッドを提供します：

    `set_app(application)'
          呼び出し可能（callable）な APPLICATION を
          リクエストを受け取る WSGI アプリケーションとして設定します。

    `get_app()'
          現在設定されている呼び出し可能（callable）アプリケーションを返します。

     しかしながら、通常はこれらの追加されたメソッドを使う必要はありません。
     `set_app()' は普通は `make_server()' によって呼ばれ、 `get_app()'
     は主にリクエストハンドラインスタンスの便宜上存在する からです。

`WSGIRequestHandler(request, client_address, server)'
     与えられた REQUEST（すなわちソケット）の HTTP ハンドラ、
     CLIENT_ADDRESS（`HOST,PORT)' のタプル）、 SERVER（`WSGIServer'
     インスタンス）の HTTP ハンドラを作成します。

     このクラスのインスタンスを直接生成する必要はありません；これらは
     必要に応じて `WSGIServer'
     オブジェクトによって自動的に生成されます。
     しかしながら、このクラスをサブクラス化し、`make_server()' 関数に
     HANDLER_CLASS として与えることは可能でしょう。サブクラスにおいて
     オーバーライドする意味のありそうなものは：

    `get_environ()'
          リクエストに対する WSGI
          環境を含む辞書を返します。デフォルト実装では `WSGIServer'
          オブジェクトの `base_environ' 辞書属性のコンテンツを
          コピーし、それから HTTP
          リクエスト由来の様々なヘッダを追加しています。
          このメソッド呼び出し毎に、PEP 333 に指定されている関連する
          CGI 環境変数を 全て含む新規の辞書を返さなければいけません。

    `get_stderr()'
          `wsgi.errors' ストリームとして使われるオブジェクトを返します。
          デフォルト実装では単に `sys.stderr' を返します。

    `handle()'
          HTTP リクエストを処理します。デフォルト実装では実際の WGI
          アプリケーション インターフェースを実装するのに
          `wsgiref.handlers' クラスを使って
          ハンドラインスタンスを作成します。



File: python-lib-jp.info,  Node: wsgirefvalidate - WSGI 準拠チェッカ,  Next: wsgirefhandlers - サーバ／ゲートウェイのベースクラス,  Prev: wsgirefsimple_server - シンプルな WSGI HTTP サーバ,  Up: wsgiref

18.4.4 `wsgiref.validate' - WSGI 準拠チェッカ
---------------------------------------------

WSGI
アプリケーションのオブジェクト、フレームワーク、サーバ又はミドルウェアの
作成時には、その新規のコードを `wsgiref.validate'
を使って準拠の検証をする と便利です。このモジュールは WSGI
サーバやゲートウェイと WSGI アプリケーション
オブジェクト間の通信を検証する WSGI
アプリケーションオブジェクトを作成する
関数を提供し、双方のプロトコル準拠をチェックします。

このユーティリティは完全な PEP 333 準拠を保証するものでないことは注意してください；
このモジュールでエラーが出ないことは必ずしもエラーが存在しないことを意味しません。
しかしこのモジュールがエラーを出したならば、サーバかアプリケーションの
どちらかが 100 このモジュールは lan Bicking の "Python Paste"
ライブラリの `paste.lint' モジュールをベースにしています。

`validator(application)'
     APPLICATION をラップし、新しい WSGI
     アプリケーションオブジェクトを返します。
     返されたアプリケーションは全てのリクエストを元々の APPLICATION に
     フォワードし、APPLICATION とそれを呼び出すサーバの両方が WSGI
     仕様と RFC 2616 の両方に準拠しているかをチェックします。

     検出された非準拠は、投げられる `AssertionError' の中に入ります；
     しかし、このエラーがどう扱われるかはサーバ依存であることに注意してください。
     例えば、`wsgiref.simple_server' とその他 `wsgiref.handlers'
     ベースの
     サーバ（エラー処理メソッドが他のことをするようにオーバライドしていないもの）は
     単純にエラーが発生したというメッセージとトラックバックのダンプを
     `sys.stderr' や その他のエラーストリームに出力します。

     このラッパは`warnings' モジュールを使って出力を生成し、
     疑問の余地はあるが実際には PEP 333 で禁止はされていないかもしれない挙動を
     指摘します。これらは Python のコマンドラインオプションや
     `warnings' API で
     抑制されなければ、`sys.stderr'（たまたま同一のオブジェクトで無い限り
     `wsgi.errors' では_ない_）に書き出されます。


File: python-lib-jp.info,  Node: wsgirefhandlers - サーバ／ゲートウェイのベースクラス,  Prev: wsgirefvalidate - WSGI 準拠チェッカ,  Up: wsgiref

18.4.5 `wsgiref.handlers' - サーバ／ゲートウェイのベースクラス
--------------------------------------------------------------

このモジュールは WSGI サーバとゲートウェイ実装のベースハンドラクラスを
提供します。これらのベースクラスは CGI ライクの環境を与えられれば
入力、出力そしてエラーストリームと共に WSGI アプリケーションとの
通信の大部分を処理します。

`CGIHandler()'
     `sys.stdin'、`sys.stdout'、`stderr' そして `os.environ' 経由での
     CGI ベースの呼び出しです。これは、もしあなたが WSGI
     アプリケーションを持っていて、 これを CGI
     スクリプトとして実行したい場合に有用です。単に
     `CGIHandler().run(app)' を 起動してください。`app'
     はあなたが起動したい WSGI アプリケーションオブジェクトです。

     このクラスは `BaseCGIHandler' のサブクラスで、これは
     `wsgi.run_once' を true、 `wsgi.multithread' を false、そして
     `wsgi.multiprocess' を true にセットし、 常に `sys' と `os'
     を、必要な CGI ストリームと環境を取得するために使用します。

`BaseCGIHandler(stdin, stdout, stderr, environ [, multithread=True [, multiprocess=False]])'
     `CGIHandler' に似ていますが、`sys' と `os' モジュールを
     使う代わりに CGI 環境と I/O
     ストリームを明示的に指定します。MULTITHREAD と MULTIPROCESS
     の値は、ハンドラインスタンスにより実行されるアプリケーションの
     `wsgi.multithread' と `wsgi.multiprocess'
     フラグの設定に使われます。

     このクラスは `SimpleHandler' のサブクラスで、HTTP の "本サーバ"
     でない ソフトウェアと使うことを意図しています。もしあなたが
     `Status:' ヘッダを HTTP ステータスを送信するのに使うような
     ゲートウェイプロトコルの実装（CGI、FastCGI、SCGIなど）を
     書いているとして、おそらく `SimpleHandler'
     でなくこれをサブクラス化したいことでしょう。

`SimpleHandler(stdin, stdout, stderr, environ [,multithread=True [, multiprocess=False]])'
     `BaseCGIHandler' と似ていますが、HTTP
     の本サーバと使うためにデザインされています。 もしあなたが HTTP
     サーバ実装を書いている場合、おそらく `BaseCGIHandler' でなく
     これをサブクラス化したいことでしょう。

     このクラスは `BaseHandler' のサブクラスです。これは `__init__()'、
     `get_stdin()'、`get_stderr()'、`add_cgi_vars()'、`_write()'、
     `_flush()'
     をオーバーライドして、コンストラクタから明示的に環境とストリームを
     設定するようにしています。与えられた環境とストリームは
     `stdin'、`stdout'、 `stderr' それに `environ'
     属性に保存されています。

`BaseHandler()'
     これは WSGI アプリケーションを実行するための抽象ベースクラスです。
     原理上は複数のリクエスト用に再利用可能なサブクラスを作成することが
     できますが、それぞれのインスタンスは一つの HTTP
     リクエストを処理します。

     `BaseHandler'
     インスタンスは外部からの利用にたった一つのメソッドを持ちます：

    `run(app)'
          指定された WSGI アプリケーション、APP を実行します。

     その他の全ての `BaseHandler'
     のメソッドはアプリケーション実行プロセスで
     このメソッドから呼ばれます。ですので、主にそのプロセスのカスタマイズのために
     存在しています。

     以下のメソッドはサブクラスでオーバーライドされなければいけません：

    `_write(data)'
          文字列の DATA をクライアントへの転送用にバッファします。
          このメソッドが実際にデータを転送しても OK です：
          下部システムが実際にそのような区別をしている場合に効率をより良くするために、
          `BaseHandler' は書き出しとフラッシュ操作を分けているからです。

    `_flush()'
          バッファされたデータをクライアントに強制的に転送します。このメソッドは
          何もしなくても OK です（すなわち、`_write()'
          が実際にデータを送る場合）。

    `get_stdin()'
          現在処理中のリクエストの `wsgi.input' としての利用に適当な
          入力ストリームオブジェクトを返します。

    `get_stderr()'
          現在処理中のリクエストの `wsgi.errors' としての利用に適当な
          出力ストリームオブジェクトを返します。

    `add_cgi_vars()'
          現在のリクエストの CGI 変数を `environ' 属性に追加します。

     これらがオーバーライドするであろうメソッド及び属性です。
     しかしながら、このリストは単にサマリであり、オーバーライド可能な全てのメソッドは
     含んでいません。カスタマイズした `BaseHandler'
     サブクラスを作成しようとする前に ドキュメント文字列 (docstrings)
     やソースコードでさらなる情報を調べてください。

     WSGI 環境のカスタマイズのための属性とメソッド：

    `wsgi_multithread'
          `wsgi.multithread' 環境変数で使われる値。デフォルトは
          `BaseHandler' では true
          ですが、別のサブクラスではデフォルトで（またはコンストラクタによって設定されて）
          異なる値を持つことがあります。

    `wsgi_multiprocess'
          `wsgi.multiprocess' 環境変数で使われる値。デフォルトは
          `BaseHandler' では true
          ですが、別のサブクラスではデフォルトで（またはコンストラクタによって設定されて）
          異なる値を持つことがあります。

    `wsgi_run_once'
          `wsgi.run_once' 環境変数で使われる値。デフォルトは
          `BaseHandler' では false ですが、`CGIHandler'
          はデフォルトでこれを true に設定します。

    `os_environ'
          全てのリクエストの WSGI 環境に含まれるデフォルトの環境変数。
          デフォルトでは、`wsgiref.handlers' がインポートされた時点では
          これは `os.environ' のコピーですが、サブクラスはクラスまたは
          インスタンスレベルでそれら自身のものを作ることができます。
          デフォルト値は複数のクラスとインスタンスで共有されるため、
          この辞書は読み取り専用と考えるべきだという点に注意してください。

    `server_software'
          `origin_server'
          属性が設定されている場合、この属性の値がデフォルトの
          `SERVER_SOFTWARE' WSGI 環境変数の設定や HTTP レスポンス中の
          デフォルトの `Server:'
          ヘッダの設定に使われます。これは（`BaseCGIHandler' や
          `CGIHandler' のような）HTTP
          オリジンサーバでないハンドラでは無視されます。

    `get_scheme()'
          現在のリクエストで使われている URL
          スキームを返します。デフォルト実装は `wsgiref.util' の
          `guess_scheme()' を使い、 現在のリクエストの `envion'
          変数に基づいて スキームが"http" か "https" かを推測します。

    `setup_environ()'
          `environ' 属性を、全てを導入済みの WSGI 環境に設定します。
          デフォルトの実装は、上記全てのメソッドと属性、加えて
          `get_stdin()'、 `get_stderr()'、`add_cgi_vars()' メソッドと
          `wsgi_file_wrapper' 属性を
          利用します。これは、キーが存在せず、`origin_server' 属性が
          true 値で `server_software' 属性も設定されている場合に
          `SERVER_SOFTWARE' を挿入します。

     例外処理のカスタマイズのためのメソッドと属性：

    `log_exception(exc_info)'
          EXEC_INFO タプルをサーバログに記録します。EXC_INFO は `(TYPE,
          VALUE, TRACEBACK)' のタプルです。
          デフォルトの実装は単純にトレースバックをリクエストの
          `wsgi.errors' ストリームに
          書き出してフラッシュします。サブクラスはこのメソッドをオーバーライドして
          フォーマットを変更したり出力先の変更、トレースバックを管理者にメールしたり
          その他適切と思われるいかなるアクションも取ることができます。

    `traceback_limit'
          デフォルトの `log_exception()' メソッドで出力される
          トレースバック出力に含まれる最大のフレーム数です。`None'
          ならば、 全てのフレームが含まれます。

    `error_output(environ, start_response)'
          このメソッドは、ユーザに対してエラーページを出力する WSGI
          アプリケーションです。
          これはクライアントにヘッダが送出される前にエラーが発生した場合にのみ
          呼び出されます。

          このメソッドは `sys.exc_info()' を使って現在のエラー情報に
          アクセスでき、その情報はこれを呼ぶときに START_RESPONSE に
          渡すべきです（PEP 333 の "Error Handling"
          セクションに記述があります）。

          デフォルト実装は単に `error_status'、`error_headers'、そして
          `error_body' 属性を出力ページの生成に使います。サブクラスでは
          これをオーバーライドしてもっと動的なエラー出力をすることが出来ます。

          しかし、セキュリティの観点からは診断をあらゆる老練ユーザに吐き出すことは
          推奨されないことに気をつけてください；理想的には、診断的な出力を有効に
          するには何らかの特別なことをする必要があるようにすべきで、これが
          デフォルト実装では何も含まれていない理由です。

    `error_status'
          エラーレスポンスで使われる HTTP ステータスです。これは PEP 333 で
          定義されているステータス文字列です；デフォルトは 500
          コードとメッセージです。

    `error_headers'
          エラーレスポンスで使われる HTTP ヘッダです。これは PEP 333 で述べられているような、
          WSGI レスポンスヘッダ（`(NAME, VALUE)'
          タプル）のリストであるべきです。
          デフォルトのリストはコンテントタイプを `text/plain'
          にセットしているだけです。

    `error_body'
          エラーレスポンスボディ。これは HTTP
          レスポンスのボディ文字列であるべきです。
          これはデフォルトではプレーンテキストで "A server error
          occurred.  Please contact the administrator." です。

     PEP 333 の
     "オプションのプラットフォーム固有のファイルハンドリング"
     機能のための メソッドと属性：

    `wsgi_file_wrapper'
          `wsgi.file_wrapper' ファクトリ、または `None' です。
          この属性のデフォルト値は `wsgiref.util' の `FileWrapper'
          クラスです。

    `sendfile()'
          オーバーライドしてプラットフォーム固有のファイル転送を実装します。
          このメソッドはアプリケーションの戻り値が `wsgi_file_wrapper'
          属性で
          指定されたクラスのインスタンスの場合にのみ呼ばれます。これは
          ファイルの転送が成功できた場合には true
          を返して、デフォルトの転送コードが
          実行されないようにするべきです。このデフォルトの実装は単に
          false 値を返します。

     その他のメソッドと属性：

    `origin_server'
          この属性はハンドラの `_write()' と `_flush()' が、 特別に
          `Status:' ヘッダに HTTP ステータスを求めるような CGI
          状のゲートウェイプロトコル経由でなく、クライアントと
          直接通信をするような場合には true 値に設定されているべきです。

          この属性のデフォルト値は `BaseHandler' では true ですが、
          `BaseCGIHandler' と `CGIHandler' では false です。

    `http_version'
          `origin_server' が true
          の場合、この文字列属性はクライアントへの レスポンスセットの
          HTTP バージョンの設定に使われます。デフォルトは `"1.0"' です。



File: python-lib-jp.info,  Node: urllib,  Next: urllib2,  Prev: wsgiref,  Up: インターネットプロトコルとその支援

18.5 URL による任意のリソースへのアクセス
=========================================

URL による任意のネットワークリソースへのアクセス (socket が必要です)。

このモジュールはワールドワイドウェブ (World Wide Web) を介してデータを
取り寄せるための高レベルのインタフェースを提供する。特に、関数
`urlopen()' は組み込み関数 `open()' と同様に動作し、
ファイル名の代わりにファイルユニバーサルリソースロケータ (URL) を
指定することができます。いくつかの制限はあります -- URL は読み出し
専用でしか開けませんし、seek 操作を行うことはできません。

このモジュールでは、以下の public な関数を定義します。

`urlopen(url[, data[, proxies]])'
     URL で表されるネットワーク上のオブジェクトを読み込み用に開きます。
     URL がスキーム識別子を持たないか、スキーム識別子が `file:'
     である場合、ローカルシステムのファイルが (広範囲の改行サポート
     なしで) 開かれます。それ以外の場合は
     ネットワーク上のどこかにあるサーバへのソケットを開きます。
     接続を作ることができない場合、 例外 `IOError'
     が送出されます。全ての処理がうまくいけば、
     ファイル類似のオブジェクトが返されます。このオブジェクトは以下の
     メソッド:  `read()' 、 `readline()' 、 `readlines()' 、 `fileno()'
     、 `close()' 、 `info()' そして `geturl()' をサポートします。
     また、イテレータプロトコルも正しくサポートしています。 注意:
     `read()'の引数を省略または負の値を指定しても、データスト
     リームの最後まで読みこむ訳ではありません。ソケットからすべてのストリーム
     を読み込んだことを決定する一般的な方法は存在しません。

     `info()' および `geturl()' メソッドを除き、
     これらのメソッドはファイルオブジェクトと同じインタフェースを持って
     います -- このマニュアルの *Note ファイルオブジェクト::
     セクションを 参照してください。
     (ですが、このオブジェクトは組み込みのファイル
     オブジェクトではないので、まれに真の組み込みファイルオブジェクトが
     必要な場所では使うことができません)

     `info()' メソッドは開いた URL に関連付けられたメタ情報 を含む
     `mimetools.Message' クラスのインスタンスを返します。 URL
     へのアクセスメソッドが HTTP である場合、メタ情報中の
     ヘッダ情報はサーバが HTML ページを返すときに先頭に付加するヘッダ
     情報です (Content-Length および Content-Type を含みます) 。
     アクセスメソッドが FTP の場合、ファイル取得リクエストに応答
     してサーバがファイルの長さを返したときには (これは現在では普通に
     なりましたが) Content-Length ヘッダがメタ情報に含められます。
     Content-type ヘッダは MIME タイプが推測可能なときにメタ情報に
     含められます。アクセスメソッドがローカルファイルの場合、
     返されるヘッダ情報にはファイルの最終更新日時を表す Date エントリ、
     ファイルのサイズを示す Content-Length エントリ、そして推測される
     ファイル形式の Content-Type エントリが含まれます。 `mimetools'  モジュールを
     参照してください。

     `geturl()' メソッドはページの実際の URL を返します。場合に
     よっては、HTTP サーバはクライアントの要求を他の URL に振り向け
     (redirect 、リダイレクト  ) します。 関数 `urlopen()'
     はユーザに対してリダイレクトを透過的に
     行いますが、呼び出し側にとってクライアントがどの URL にリダイレクト
     されたかを知りたいときがあります。`geturl()' メソッドを
     使うと、このリダイレクトされた URL を取得できます。

     URL に `http:' スキーム識別子を使う場合、DATA 引数を 与えて `POST'
     形式のリクエストを行うことができます (通常リクエストの 形式は
     `GET' です)。引数 DATA は標準の
     `application/x-www-form-urlencoded' 形式でなければなりません;
     以下の `urlencode()' 関数を参照してください。

     `urlopen()' 関数は認証を必要としないプロキシ (proxy) に対して
     透過的に動作します。UNIX または Windows 環境では、 Python を起動
     する前に、環境変数 `http_proxy'、 `ftp_proxy' 、および
     `gopher_proxy' にそれぞれのプロキシサーバを指定する URL を
     設定してください。 例えば (`%' はコマンドプロンプトです):

          % http_proxy="http://www.someproxy.com:3128"
          % export http_proxy
          % python
          ...

     Windows
     環境では、プロキシを指定する環境変数が設定されていない場合、
     プロキシの設定値はレジストリの Internet Settings セクションから取得
     されます。

     Macintosh 環境では、`urlopen()' は 「インターネットの設定」
     (Internet  Config) からプロキシ情報を取得します。

     別の方法として、オプション引数 PROXIES を使って明示的にプロキシを
     設定することができます。この引数はスキーム名をプロキシの URL
     にマップする
     辞書型のオブジェクトでなくてはなりません。空の辞書を指定するとプロキシを
     使いません。`None' (デフォルトの値です) を指定すると、上で述べた
     ように環境変数で指定されたプロキシ設定を使います。例えば:

          # http://www.someproxy.com:3128 を http プロキシに使う
          proxies = {'http': 'http://www.someproxy.com:3128'}
          filehandle = urllib.urlopen(some_url, proxies=proxies)
          # プロキシを使わない
          filehandle = urllib.urlopen(some_url, proxies={})
          # 環境変数からプロキシを使う - 両方の表記とも同じ意味です。
          filehandle = urllib.urlopen(some_url, proxies=None)
          filehandle = urllib.urlopen(some_url)

     (訳注:
     上記と矛盾する内容です。おそらく旧バージョンのドキュメントです)
     関数 `urlopen()' は明示的なプロキシ指定をサポートしていません。
     環境変数のプロキシ設定を上書きしたい場合には `URLopener' を使う
     か、`FancyURLopener' などのサブクラスを使ってください。

     認証を必要とするプロキシは現在のところサポートされていません。
     これは実装上の制限 (implementation limitation) と考えています。

     _Changed in Python version 2.3_

`urlretrieve(url[, filename[, reporthook[, data]]])'
     URL
     で表されるネットワーク上のオブジェクトを、必要に応じてローカルな
     ファイルにコピーします。URL がローカルなファイルを指定していたり、
     オブジェクトのコピーが正しくキャッシュされていれば、そのオブジェクトは
     コピーされません。タプル `(FILENAME, HEADERS)' を 返し、FILENAME
     はローカルで見つかったオブジェクトに対する ファイル名で、HEADERS
     は `urlopen()' が返した (おそらくキャッシュされているリモートの)
     オブジェクトに `info()' を適用して得られるものになります。
     `urlopen()' と同じ例外を送出します。

     2
     つめの引数がある場合、オブジェクトのコピー先となるファイルの位置を
     指定します (もしなければ、ファイルの場所は一時ファイル (tmpfile) の
     置き場になり、名前は適当につけられます)。 3
     つめの引数がある場合、ネットワークとの接続が確立された際に一度
     呼び出され、以降データのブロックが読み出されるたびに呼び出されるフック
     関数 (hook function) を指定します。フック関数には 3
     つの引数が渡され ます;
     これまで転送されたブロック数のカウント、バイト単位で表された
     ブロックサイズ、ファイルの総サイズです。3 つ目のファイルの総サイズ
     は、ファイル取得の際の応答時にファイルサイズを返さない古い FTP
     サーバ では `-1' になります。

     URL が `http:' スキーム識別子を使っていた場合、オプション 引数
     DATA を与えることで `POST' リクエストを行うよう
     指定することができます (通常リクエストの形式は `GET' です)。 DATA
     引数は標準の `application/x-www-form-urlencoded'
     形式でなくてはなりません; 以下の `urlencode()' 関数を参照して
     ください。

     _Changed in Python version 2.5_

`_urlopener'
     パブリック関数 `urlopen()' および `urlretrieve()' は
     `FancyURLopener' クラスのインスタンスを生成します。
     インスタンスは要求された動作に応じて使用されます。
     この機能をオーバライドするために、プログラマは `URLopener' または
     `FancyURLopener' のサブクラスを作り、そのクラスから
     生成したインスタンスを変数 `urllib._urlopener' に代入した
     後、呼び出したい関数を呼ぶことができます。
     例えば、アプリケーションが `URLopener' が定義しているのとは
     異なった `User-Agent' ヘッダを指定したい場合があるかも
     しれません。この機能は以下のコードで実現できます:

          import urllib

          class AppURLopener(urllib.FancyURLopener):
              version = "App/1.7"

          urllib._urlopener = AppURLopener()


`urlcleanup()'
     以前の `urlretrieve()' で生成された可能性のあるキャッシュを
     消去します。

`quote(string[, safe])'
     STRING に含まれる特殊文字を `%xx' エスケープで置換
     （quote）します。 アルファベット、数字、および文字 `_.-' は quote
     処理 を行いません。オプションのパラメタ SAFE は quote 処理しない
     追加の文字を指定します -- デフォルトの値は `'/'' です。

     例: `quote('/~{}connolly/')' は `'/%7econnolly/'' になります。

`quote_plus(string[, safe])'
     `quote()' と似ていますが、加えて空白文字をプラス記号 ("+") に
     置き換えます。これは HTML フォームの値を quote 処理する際に
     必要な機能です。もとの文字列におけるプラス記号は SAFE に含まれて
     いない限りエスケープ置換されます。上と同様に、SAFE の
     デフォルトの値は `'/'' です。

`unquote(string)'
     `%xx' エスケープをエスケープが表す 1 文字に置き換えます。

     例: `unquote('/%7Econnolly/')' は `'/~{}connolly/'' になります。

`unquote_plus(string)'
     `unquote()' と似ていますが、加えてプラス記号を空白文字に置き換
     えます。これは quote 処理された HTML
     フォームの値を元に戻すのに必要な 機能です。

`urlencode(query[, doseq])'
     マップ型オブジェクト、または 2
     つの要素をもったタプルからなるシーケンス を、 "URL
     にエンコードされた (url-encoded)" に変換して、 上述の `urlopen()'
     のオプション引数 DATA に適した
     形式にします。この関数はフォームのフィールド値でできた辞書を
     `POST' 型のリクエストに渡すときに便利です。 返される文字列は
     `KEY=VALUE' のペアを `&' で区切ったシーケンスで、KEY と VALUE
     の双方は上の `quote_plus()' で quote 処理されます。
     オプションのパラメタ DOSEQ が与えられていて、その評価結果が真
     であった場合、シーケンス DOSEQ の個々の要素について `KEY=VALUE'
     のペアが生成されます。 2
     つの要素をもったタプルからなるシーケンスが引数 QUERY として使われた
     場合、各タプルの最初の値が key で、2 番目の値が value になります。
     このときエンコードされた文字列中のパラメタの順番はシーケンス中のタプルの順番
     と同じになります。 `cgi' モジュールでは、関数 `parse_qs()' および
     `parse_qsl()' を提供しており、クエリ文字列を解析して Python
     のデータ構造にするのに利用できます。

`pathname2url(path)'
     ローカルシステムにおける記法で表されたパス名 PATH を、URL に
     おけるパス部分の形式に変換します。この関数は完全な URL
     を生成するわけ ではありません。返される値は常に `quote()' を使って
     quote 処理 されたものになります。

`url2pathname(path)'
     URL のパスの部分 PATH をエンコードされた URL の形式からローカル
     システムにおけるパス記法に変換します。この関数は PATH をデコード
     するために `unquote()' を使います。

`URLopener([proxies[, **x509]])'
     URL をオープンし、読み出すためのクラスの基礎クラス (base
     class)です。 `http:' 、 `ftp:' 、`gopher:' または `file:'
     以外のスキームを使ったオブジェクトのオープンをサポートしたいのでない
     かぎり、`FancyURLopener' を使おうと思うことになるでしょう。

     デフォルトでは、 `URLopener' クラスは `User-Agent' ヘッダとして
     `urllib/VVV' を送信します。ここで VVV は `urllib'
     のバージョン番号です。アプリケーションで独自の `User-Agent'
     ヘッダを送信したい場合は、`URLopener' かまたは `FancyURLopener'
     のサブクラスを作成し、 サブクラス定義においてクラス属性 `version'
     を適切な 文字列値に設定することで行うことができます。

     オプションのパラメタ PROXIES はスキーム名をプロキシの URL に
     マップする辞書でなくてはなりません。空の辞書はプロキシ機能を完全に
     オフにします。デフォルトの値は `None' で、この場合、 `urlopen()'
     の定義で述べたように、プロキシを設定する環境変数が
     存在するならそれを使います。

     追加のキーワードパラメタは X509 に集められますが、これは `https:'
     スキームを使った際のクライアント認証に使われることがあります。
     キーワード引数 KEY_FILE および CERT_FILE が SSL 鍵と証明書を
     設定するためにサポートされています;
     クライアント認証をするには両方が必要です。

     `URLopener' オブジェクトは、サーバがエラーコードを 返した時には
     `IOError' を発生します。

`FancyURLopener(...)'
     `FancyURLopener' は `URLopener' のサブクラスで、 以下の HTTP
     レスポンスコード: 301、302、303、 307、および 401
     を取り扱う機能を提供します。 レスポンスコード 30x に対しては、
     `Location' ヘッダを使って実際の URL を取得します。
     レスポンスコード 401 (認証が要求されていることを示す) に対しては、
     ベーシック認証 (basic HTTP authintication) が行われます。
     レスポンスコード 30x に対しては、最大で MAXTRIES
     属性に指定された数だけ再帰呼び出しを行うように
     なっています。この値はデフォルトで 10 です。

     その他のレスポンスコードについては、`http_error_default()' が
     呼ばれます。これはサブクラスでエラーを適切に処理するように
     オーバーライドすることができます。

     _Note:_ RFC 2616 によると、 POST 要求に対する 301 および 302
     応答はユーザの承認無しに自動的にリダイレクトしてはなりません。
     実際は、これらの応答に対して自動リダイレクトを許すブラウザでは
     POST を GET に変更しており、`urllib' でもこの動作を 再現します。

     コンストラクタに与えるパラメタは `URLopener' と同じです。

     _Note:_ 基本的な HTTP 認証を行う際、 `FancyURLopener'
     インスタンスは `prompt_user_passwd()'
     メソッドを呼び出します。このメソッドは
     デフォルトでは実行を制御している端末上で認証に必要な情報を要求する
     ように実装されています。必要ならば、このクラスのサブクラスにおいて
     より適切な動作をサポートするために `prompt_user_passwd()'
     メソッドをオーバライドしてもかまいません。

`ContentTooShortError(msg[, content])'
     この例外は `urlretrieve()' 関数が、ダウンロードされたデータの
     量が予期した量 (CONTENT-LENGTH ヘッダで与えられる) よりも少ない
     ことを検知した際に発生します。`content' 属性には (恐らく途中までの)
     ダウンロードされたデータが格納されています。 _Added in Python
     version 2.5_

制限:

   * 現在のところ、以下のプロトコルだけがサポートされています: HTTP、
     (バージョン 0.9 および 1.0)、 Gopher (Gopher-+ を除く)、 FTP、
     およびローカルファイル。 

   * `urlretrieve()' のキャッシュ機能は、有効期限ヘッダ (Expiration
     time header) を正しく処理できるようにハックするための
     時間を取れるまで、無効にしてあります。

   * ある URL がキャッシュにあるかどうか調べるような関数があればと思って
     います。。

   * 後方互換性のため、 URL がローカルシステム上のファイルを指している
     ように見えるにも関わらずファイルを開くことができなければ、 URL は
     FTP プロトコルを使って再解釈されます。この機能は時として混乱を招く
     エラーメッセージを引き起こします。

   * 関数 `urlopen()' および `urlretrieve()' は、
     ネットワーク接続が確立されるまでの間、一定でない長さの遅延を引き起こす
     ことがあります。このことは、これらの関数を使ってインタラクティブな
     Web
     クライアントを構築するのはスレッドなしには難しいことを意味します。

   * `urlopen()' または `urlretrieve()' が返すデータは
     サーバが返す生のデータです。このデータはバイナリデータ
     (画像データ等) 、 生テキスト (plain text)、または (例えば) HTML でもかまいません。HTTP  プロトコルはリプライ
     ヘッダ (reply header) にデータのタイプに関する情報を返します。
     タイプは `Content-Type' ヘッダを見ることで推測できます。

     Gopher  プロトコルでは、データのタイプに 関する情報は URL
     にエンコードされます; これを展開することは簡単
     ではありません。返されたデータが HTML であれば、 `htmllib'  を使ってパースすることが
     できます。

     FTP  プロトコルを扱うコードでは、ファイルとディレクトリ
     を区別できません。このことから、アクセスできないファイルを指している
     URL からデータを読み出そうとすると、予期しない動作を引き起こす
     場合があります。 URL が`/' で終わっていれば、ディレクトリを
     指しているものとみなして、それに適した処理を行います。
     しかし、ファイルの読み出し操作が 550 エラー (URL が存在しないか、
     主にパーミッションの理由でアクセスできない) になった場合、 URL
     がディレクトリを指していて、末尾の `/' を忘れたケース
     を処理するため、パスをディレクトリとして扱います。
     このために、パーミッションのためにアクセスできないファイルを fetch
     しようとすると、FTP コードはそのファイルを開こうとして 550
     エラーに陥り、次にディレクトリ一覧を表示しようとするため、
     誤解を生むような結果を引き起こす可能性があるのです。
     よく調整された制御が必要なら、`ftplib' モジュールを使うか、
     `FancyURLOpener' をサブクラス化するか、 _URLOPENER
     を変更して目的に合わせるよう検討してください。

   * このモジュールは認証を必要とするプロキシをサポートしません。
     将来実装されるかもしれません。

   * `urllib' モジュールは URL 文字列を解釈したり構築したりする
     (ドキュメント化されていない) ルーチンを含んでいますが、URL
     を操作するためのインタフェースとしては、 `urlparse'  モジュールをお勧めします。


* Menu:

* URLopener オブジェクト::
* Urllib Examples::


File: python-lib-jp.info,  Node: URLopener オブジェクト,  Next: Urllib Examples,  Prev: urllib,  Up: urllib

18.5.1 URLopener オブジェクト
-----------------------------

`URLopener' および `FancyURLopener' クラスのオブジェクトは
以下の属性を持っています。

`open(fullurl[, data])'
     適切なプロトコルを使って FULLURL を開きます。このメソッドは
     キャッシュとプロキシ情報を設定し、その後適切な open
     メソッドを入力引数
     つきで呼び出します。認識できないスキームが与えられた場合、
     `open_unknown()' が呼び出されます。 DATA 引数は `urlopen()' の引数
     DATA と同じ意味を持っています。

`open_unknown(fullurl[, data])'
     オーバライド可能な、未知のタイプの URL
     を開くためのインタフェースです。

`retrieve(url[, filename[, reporthook[, data]]])'
     URL のコンテンツを取得し、FILENAME に書き込みます。
     返り値はタプルで、ローカルシステムにおけるファイル名と、
     応答ヘッダ (URL がリモートを指している場合)  または `None' (URL
     がローカルを指している場合) からなります。呼び出し側の処理は
     その後 FILENAME を開いて内容を読み出さなくてはなりません。
     FILENAME が与えられており、かつ URL がローカルシステム上の
     ファイルを示しているばあい、入力ファイル名が返されます。URL が
     ローカルのファイルを示しておらず、かつ FILENAME が与えられて
     いない場合、ファイル名は入力 URL
     の最後のパス構成要素につけられた拡張子と 同じ拡張子を
     `tempfile.mktemp()' につけたものになります。 REPORTHOOK
     を与える場合、この変数は 3 つの数値パラメタを受け取る
     関数でなくてはなりません。この関数はデータの塊 (chunk)
     がネットワークから 読み込まれるたびに呼び出されます。ローカルの
     URL を与えた場合 REPORTHOOK は無視されます。

     URL が `http:' スキーム識別子を使っている場合、オプションの 引数
     DATA を与えて `POST' リクエストを行うよう指定できます
     (通常のリクエストの形式は `GET' です) 。 引数 DATA は標準の
     `application/x-www-form-urlencoded' 形式でなくてはなりません; 上の
     `urlencode()' を参照して下さい。

`version'
     URL をオープンするオブジェクトのユーザエージェントを指定する
     変数です。`urllib' を特定のユーザエージェントであると
     サーバに通知するには、サブクラスの中でこの値をクラス変数として
     値を設定するか、コンストラクタの中でベースクラスを呼び出す前に
     値を設定してください。

`FancyURLopener' クラスはオーバライド可能な追加のメソッドを提供
しており、適切な振る舞いをさせることができます:

`prompt_user_passwd(host, realm)'
     指定されたセキュリティ領域 (security realm)
     下にある与えられたホスト
     において、ユーザ認証に必要な情報を返すための関数です。この関数が
     返す値は `(USER, PASSWORD)' 、からなるタプルなくて
     はなりません。値はベーシック認証 (basic authentication)
     で使われます。

     このクラスでの実装では、端末に情報を入力するようプロンプトを出します;
     ローカルの環境において適切な形で対話型モデルを使うには、このメソッドを
     オーバライドしなければなりません。


File: python-lib-jp.info,  Node: Urllib Examples,  Prev: URLopener オブジェクト,  Up: urllib

18.5.2 使用例
-------------

以下は `GET' メソッドを使ってパラメタを含む URL を取得するセッション
の例です:

     >>> import urllib
     >>> params = urllib.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})
     >>> f = urllib.urlopen("http://www.musi-cal.com/cgi-bin/query?%s" % params)
     >>> print f.read()

以下は `POST' メソッドを代わりに使った例です:

     >>> import urllib
     >>> params = urllib.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})
     >>> f = urllib.urlopen("http://www.musi-cal.com/cgi-bin/query", params)
     >>> print f.read()

以下の例では、環境変数による設定内容に対して上書きする形で HTTP
プロキシを 明示的に設定しています:

     >>> import urllib
     >>> proxies = {'http': 'http://proxy.example.com:8080/'}
     >>> opener = urllib.FancyURLopener(proxies)
     >>> f = opener.open("http://www.python.org")
     >>> f.read()

以下の例では、環境変数による設定内容に対して上書きする形で、まったく
プロキシを使わないよう設定しています:

     >>> import urllib
     >>> opener = urllib.FancyURLopener({})
     >>> f = opener.open("http://www.python.org/")
     >>> f.read()


File: python-lib-jp.info,  Node: urllib2,  Next: httplib,  Prev: urllib,  Up: インターネットプロトコルとその支援

18.6 URL を開くための拡張可能なライブラリ
=========================================

様々なプロトコルで URL を開くための拡張可能なライブラリ

`urllib2' モジュールは基本的な認証、暗号化認証、リダイレクション、
クッキー、その他の介在する複雑なアクセス環境において (大抵は HTTP で)
URL を開くための関数とクラスを定義します。

`urllib2' モジュールでは以下の関数を定義しています:

`urlopen(url[, data])'
     URL URL を開きます。URL は文字列でも `Request'
     オブジェクトでもかまいません 。

     DATA はサーバに送信する追加のデータを示す文字列か、
     そのようなデータが無ければNONEを指定します。 現時点でHTTP
     リクエストは DATA をサポートする唯一のリクエスト形式 です; DATA
     パラメタが指定が指定された場合、HTTP リクエストは GET でなく POST
     に なります。 DATA は標準的な `application/x-www-form-urlencoded'
     形式の バッファでなくてはなりません。 `urllib.urlencode()' 関数は
     マップ型か2タプルのシーケンスを取り、この形式の文字列を返します。

     この関数は以下の 2
     つのメソッドを持つファイル類似のオブジェクトを返します:

        * `geturl()' -- 取得されたリソースの URL を返します。

        * `info()' -- 取得されたページのメタ情報を辞書形式の
          オブジェクトで返します。

     エラーが発生した場合 `URLError' を送出します。

     どのハンドラもリクエストを処理しなかった場合には `None' を
     返すことがあるので注意してください (デフォルトでインストールされる
     グローバルハンドラの `OpenerDirector' は、`UnknownHandler'
     を使って上記の問題が起きないようにしています)。

`install_opener(opener)'
     標準で URL を開くオブジェクトとして `OpenerDirector' のインスタンス
     をインストールします。このコードは引数が本当に `OpenerDirector'
     のインスタンスであるかどうかはチェックしないので、適切なインタフェース
     を持ったクラスは何でも動作します。

`build_opener([handler, ...])'
     与えられた順番に URL ハンドラを連鎖させる `OpenerDirector'
     のインスタンスを返します。HANDLER は `BaseHandler' または
     `BaseHandler' のサブクラスのインスタンスのどちらか です
     (どちらの場合も、コンストラクトは引数無しで呼び出せるように
     なっていなければなりません) 。以下のクラス:

     `ProxyHandler', `UnknownHandler', `HTTPHandler',
     `HTTPDefaultErrorHandler', `HTTPRedirectHandler', `FTPHandler',
     `FileHandler', `HTTPErrorProcessor'

     については、そのクラスの
     インスタンスか、そのサブクラスのインスタンスが HANDLER
     に含まれていない限り、HANDLER よりも先に連鎖します。

     Python が SSL をサポートするように設定してインストールされている
     場合 (`socket.ssl()' が存在する場合) 、 `HTTPSHandler'
     も追加されます。

     Python 2.3 からは、`BaseHandler' サブクラスでも `handler_order'
     メンバ変数を変更して、ハンドラリスト
     内での場所を変更できるようになりました。

状況に応じて、以下の例外が送出されます:

`URLError'
     ハンドラが何らかの問題に遭遇した場合、この例外 (またはこの例外から
     導出された例外)を送出します。この例外は `IOError'
     のサブクラスです。

`HTTPError'
     `URLError' のサブクラスです。このオブジェクトは例外でない
     ファイル類似のオブジェクトとして返り値に使うことができます
     (`urlopen()' が返すのと同じものです)。この機能は、例えば
     サーバからの認証リクエストのように、変わった HTTP エラーを処理する
     のに役立ちます。

`GopherError'
     `URLError' のサブクラスです。この例外は Gopher ハンドラに
     よって送出されます。

以下のクラスが提供されています:

`Request(url[, data][, headers] [, origin_req_host][, unverifiable])'
     このクラスは URL リクエストを抽象化したものです。

     URL は有効な URL を指す文字列でなくてはなりません。

     DATA はサーバに送信する追加のデータを示す文字列か、
     そのようなデータが無ければNONEを指定します。 現時点でHTTP
     リクエストは DATA をサポートする唯一のリクエスト形式 です; DATA
     パラメタが指定が指定された場合、HTTP リクエストは GET でなく POST
     に なります。 DATA は標準的な `application/x-www-form-urlencoded'
     形式の バッファでなくてはなりません。 `urllib.urlencode()' 関数は
     マップ型か2タプルのシーケンスを取り、この形式の文字列を返します。

     HEADERS は辞書でなくてはなりません。 この辞書は `add_header()'
     を辞書のキーおよび値を引数として呼び出した時と
     同じように扱われます。

     最後の二つの引数は、サードパーティの HTTP クッキーを正しく扱いたい
     場合にのみ関係してきます:

     ORIGIN_REQ_HOST は、RFC 2965 で定義されている
     元のトランザクションにおけるリクエストホスト (request-host of the
     origin transaction) です。デフォルトの値は
     `cookielib.request_host(self)' です。
     この値は、ユーザによって開始された元々のリクエストにおける
     ホスト名や IP アドレスです。例えば、もしリクエストがある HTML
     ドキュメント内の画像を指していれば、この値は
     画像を含んでいるページへのリクエストにおけるリクエストホストに
     なるはずです。

     UNVERIFIABLE は、RFC 2965 の定義において、該当するリクエストが
     証明不能 (unverifiable) であるかどうかを示します。デフォルトの値は
     False です。証明不能なリクエストとは、ユーザが受け入れの可否を選択
     できないような URL を持つリクエストのことです。例えば、リクエストが
     HTML
     ドキュメント中の画像であり、ユーザがこの画像を自動的に取得するか
     どうかを選択できない場合には、証明不能フラグは True になります。

`OpenerDirector()'
     `OpenerDirector' クラスは、`BaseHandler' の連鎖的に 呼び出して URL
     を開きます。このクラスはハンドラをどのように連鎖
     させるか、またどのようにエラーをリカバリするかを管理します。

`BaseHandler()'
     このクラスはハンドラ連鎖に登録される全てのハンドラがベースとしている
     クラスです -
     このクラスでは登録のための単純なメカニズムだけを扱います。

`HTTPDefaultErrorHandler()'
     HTTP エラー応答のための標準のハンドラを定義します;
     全てのレスポンスに 対して、例外 `HTTPError' を送出します。

`HTTPRedirectHandler()'
     リダイレクションを扱うクラスです。

`HTTPCookieProcessor([cookiejar])'
     HTTP Cookie を扱うためのクラスです。

`ProxyHandler([proxies])'
     このクラスはプロキシを通過してリクエストを送らせます。 引数
     PROXIES を与える場合、プロトコル名からプロキシの URL
     へ対応付ける辞書でなくてはなりません。
     標準では、プロキシのリストを環境変数 <PROTOCOL>_PROXY
     から読み出します。

`HTTPPasswordMgr()'
     `(REALM, URI) -> (USER, PASSWORD)'
     の対応付けデータベースを保持します。

`HTTPPasswordMgrWithDefaultRealm()'
     `(REALM, URI) -> (USER, PASSWORD)'
     の対応付けデータベースを保持します。 レルム `None'
     はその他諸々のレルムを表し、他のレルムが
     該当しない場合に検索されます。

`AbstractBasicAuthHandler([password_mgr])'
     このクラスはHTTP 認証を補助するための混ぜ込みクラス (mixin class)
     です。 遠隔ホストとプロキシの両方に対応しています。 PASSWORD_MGR
     を与える場合、`HTTPPasswordMgr' と互換性が なければなりません;
     互換性のためにサポートしなければならないインタフェースについての
     情報はセクション~*Note HTTPPasswordMgr オブジェクト::
     を参照してください。

`HTTPBasicAuthHandler([password_mgr])'
     遠隔ホストとの間での認証を扱います。 PASSWORD_MGR
     を与える場合、`HTTPPasswordMgr' と互換性が なければなりません;
     互換性のためにサポートしなければならないインタフェースについての
     情報はセクション~*Note HTTPPasswordMgr オブジェクト::
     を参照してください。

`ProxyBasicAuthHandler([password_mgr])'
     プロキシとの間での認証を扱います。 PASSWORD_MGR
     を与える場合、`HTTPPasswordMgr' と互換性が なければなりません;
     互換性のためにサポートしなければならないインタフェースについての
     情報はセクション~*Note HTTPPasswordMgr オブジェクト::
     を参照してください。

`AbstractDigestAuthHandler([password_mgr])'
     このクラスはHTTP 認証を補助するための混ぜ込みクラス (mixin class)
     です。 遠隔ホストとプロキシの両方に対応しています。 PASSWORD_MGR
     を与える場合、`HTTPPasswordMgr' と互換性が なければなりません;
     互換性のためにサポートしなければならないインタフェースについての
     情報はセクション~*Note HTTPPasswordMgr オブジェクト::
     を参照してください。

`HTTPDigestAuthHandler([password_mgr])'
     遠隔ホストとの間での認証を扱います。 PASSWORD_MGR
     を与える場合、`HTTPPasswordMgr' と互換性が なければなりません;
     互換性のためにサポートしなければならないインタフェースについての
     情報はセクション~*Note HTTPPasswordMgr オブジェクト::
     を参照してください。

`ProxyDigestAuthHandler([password_mgr])'
     プロキシとの間での認証を扱います。 PASSWORD_MGR
     を与える場合、`HTTPPasswordMgr' と互換性が なければなりません;
     互換性のためにサポートしなければならないインタフェースについての
     情報はセクション~*Note HTTPPasswordMgr オブジェクト::
     を参照してください。

`HTTPHandler()'
     HTTP の URL を開きます。

`HTTPSHandler()'
     HTTPS の URL を開きます。

`FileHandler()'
     ローカルファイルを開きます。

`FTPHandler()'
     FTP の URL を開きます。

`CacheFTPHandler()'
     FTP の URL を開きます。遅延を最小限にするために、開かれている FTP
     接続に対するキャッシュを保持します。

`GopherHandler()'
     gopher の URL を開きます。

`UnknownHandler()'
     その他諸々のためのクラスで、未知のプロトコルの URL を開きます。

* Menu:

* Request オブジェクト::
* OpenerDirector オブジェクト::
* BaseHandler オブジェクト::
* HTTPRedirectHandler オブジェクト::
* HTTPCookieProcessor オブジェクト::
* ProxyHandler オブジェクト::
* HTTPPasswordMgr オブジェクト::
* AbstractBasicAuthHandler オブジェクト::
* HTTPBasicAuthHandler オブジェクト::
* ProxyBasicAuthHandler オブジェクト::
* AbstractDigestAuthHandler オブジェクト::
* HTTPDigestAuthHandler オブジェクト::
* ProxyDigestAuthHandler オブジェクト::
* HTTPHandler オブジェクト::
* HTTPSHandler オブジェクト::
* FileHandler オブジェクト::
* FTPHandler オブジェクト::
* CacheFTPHandler オブジェクト::
* GopherHandler オブジェクト::
* UnknownHandler オブジェクト::
* HTTPErrorProcessor オブジェクト::
* 例 10::


File: python-lib-jp.info,  Node: Request オブジェクト,  Next: OpenerDirector オブジェクト,  Prev: urllib2,  Up: urllib2

18.6.1 Request オブジェクト
---------------------------

以下のメソッドは `Request' の全ての公開インタフェースを記述します。
従ってサブクラスではこれら全てのメソッドをオーバライドしなければなりません。

`add_data(data)'
     `Request' のデータを DATA に設定します。この値は HTTP
     ハンドラ以外のハンドラでは無視されます。HTTP ハンドラでは、データは
     バイト文字列でなくてはなりません。このメソッドを使うとリクエストの形式が
     `GET' から `POST' に変更されます。

`get_method()'
     HTTP リクエストメソッドを示す文字列を返します。このメソッドは HTTP
     リクエストだけに対して意味があり、現状では常に `'GET'' か `'POST''
     のいずれかの値を返します。

`has_data()'
     インスタンスが `None' でないデータを持つかどうかを返します。

`get_data()'
     インスタンスのデータを返します。

`add_header(key, val)'
     リクエストに新たなヘッダを追加します。ヘッダは HTTP ハンドラ以外の
     ハンドラでは無視されます。HTTP
     ハンドラでは、引数はサーバに送信される
     ヘッダのリストに追加されます。同じ名前を持つヘッダを 2 つ以上持つ
     ことはできず、KEY の衝突が生じた場合、後で追加したヘッダが前に
     追加したヘッダを上書きします。現時点では、この機能は HTTP の機能を
     損ねることはありません。というのは、複数回呼び出したときに意味を
     持つようなヘッダには、どれもただ一つのヘッダを使って同じ機能を果たす
     ための (ヘッダ特有の) 方法があるからです。

`add_unredirected_header(key, header)'
     リダイレクトされたリクエストには追加されないヘッダを追加します。
     _Added in Python version 2.4_

`has_header(header)'
     インスタンスが名前つきヘッダであるかどうかを (通常のヘッダと
     非リダイレクトヘッダの両方を調べて) 返します。 _Added in Python
     version 2.4_

`get_full_url()'
     コンストラクタで与えられた URL を返します。

`get_type()'
     URL のタイプ -- いわゆるスキーム (scheme) -- を返します。

`get_host()'
     接続を行う先のホスト名を返します。

`get_selector()'
     セレクタ -- サーバに送られる URL の一部分 -- を返します。

`set_proxy(host, type)'
     リクエストがプロキシサーバを経由するように準備します。 HOST および
     TYPE はインスタンスのもとの設定と置き換えられ
     ます。インスタンスのセレクタはコンストラクタに与えたもともとの URL
     に なります。

`get_origin_req_host()'
     RFC 2965 の定義よる、始原トランザクションのリクエストホスト
     を返します。`Request' コンストラクタのドキュメントを
     参照してください。

`is_unverifiable()'
     リクエストが RFC 2965 の定義における証明不能リクエストであるか
     どうかを返します。`Request' コンストラクタのドキュメントを
     参照してください。


File: python-lib-jp.info,  Node: OpenerDirector オブジェクト,  Next: BaseHandler オブジェクト,  Prev: Request オブジェクト,  Up: urllib2

18.6.2 OpenerDirector オブジェクト
----------------------------------

`OpenerDirector' インスタンスは以下のメソッドを持っています:

`add_handler(handler)'
     HANDLER は `BaseHandler' のインスタンスでなければ
     なりません。以下のメソッドを使った検索が行われ、URL
     を取り扱うことが 可能なハンドラの連鎖が追加されます (HTTP
     エラーは特別扱いされている ので注意してください)。

        * `PROTOCOL_open()' -- ハンドラが PROTOCOL の URL
          を開く方法を知っているかどうかを 調べます。

        * `http_error_TYPE()' -- ハンドラが HTTP エラーコード TYPE
          の処理方法を知っていることを 示すシグナルです。

        * `PROTOCOL_error()' -- ハンドラが (`http' でない) PROTOCOL
          のエラー を処理する方法を知っていることを示すシグナルです。

        * `PROTOCOL_request()' -- ハンドラが PROTOCOL
          リクエストのプリプロセス方法
          を知っていることを示すシグナルです。

        * `PROTOCOL_response()' -- ハンドラが PROTOCOL
          リクエストのポストプロセス方法
          を知っていることを示すシグナルです。


`open(url[, data])'
     与えられた URL (リクエストオブジェクトでも文字列でも かまいません)
     を開きます。オプションとして DATA を与えることが できます。
     引数、返り値、および送出される例外は `urlopen()' と同じ です
     (`urlopen()' の場合、標準でインストールされている グローバルな
     `OpenerDirector' の `open()' メソッドを 呼び出します) 。

`error(proto[, arg[, ...]])'
     与えられたプロトコルにおけるエラーを処理します。このメソッドは
     与えられたプロトコルにおける登録済みのエラーハンドラを
     (プロトコル固有の) 引数で呼び出します。 HTTP プロトコルは特殊な
     ケースで、特定のエラーハンドラを選び出すのに HTTP レスポンスコード
     を使います; ハンドラクラスの `http_error_*()' メソッドを
     参照してください。

     返り値および送出される例外は `urlopen()' と同じものです。

OpenerDirector オブジェクトは、以下の 3 つのステージに分けて URL
を開きます:

各ステージで OpenerDirector オブジェクトのメソッドがどのような
順で呼び出されるかは、ハンドラインスタンスの並び方で決まります。

  1. `PROTOCOL_request()' 形式のメソッドを持つ
     全てのハンドラに対してそのメソッドを呼び出し、リクエストの
     プリプロセスを行います。

  2. `PROTOCOL_open()' 形式のメソッドを持つ
     ハンドラを呼び出し、リクエストを処理します。
     このステージは、ハンドラが`None' でない値 (すなわち レスポンス)
     を返すか、例外 (通常は `URLError') を送出した時点で
     終了します。例外は伝播 (propagate) できます。

     実際には、上のアルゴリズムではまず `default_open' という名前の
     メソッドを呼び出します。このメソッドが全て `None' を返す場合、
     同じアルゴリズムを繰り返して、今度は `PROTOCOL_open()'
     形式のメソッドを試します。メソッドが全て `None' を返すと、
     さらに同じアルゴリズムを繰り返して `unknown_open()'
     を呼び出します。

     これらのメソッドの実装には、親となる `OpenerDirector'
     インスタンスの `.open()' や`.error()' といったメソッド
     呼び出しが入る場合があるので注意してください。

  3. `PROTOCOL_response()' 形式のメソッドを持つ
     全てのハンドラに対してそのメソッドを呼び出し、リクエストの
     ポストプロセスを行います。



File: python-lib-jp.info,  Node: BaseHandler オブジェクト,  Next: HTTPRedirectHandler オブジェクト,  Prev: OpenerDirector オブジェクト,  Up: urllib2

18.6.3 BaseHandler オブジェクト
-------------------------------

`BaseHandler' オブジェクトは直接的に役に立つ 2 つのメソッド
と、その他として導出クラスで使われることを想定したメソッドを
提供します。以下は直接的に使うためのメソッドです:

`add_parent(director)'
     親オブジェクトとして、`director' を追加します。

`close()'
     全ての親オブジェクトを削除します。

以下のメンバおよびメソッドは `BaseHandler' から導出された
クラスでのみ使われます: _Note:_ 慣習的に、`PROTOCOL_request()' や
`PROTOCOL_response()' といったメソッドを定義している
サブクラスは`*Processor' と名づけ、その他は`*Handler'
と名づけることになっています

`parent'
     有効な `OpenerDirector' です。この値は違うプロトコルを 使って URL
     を開く場合やエラーを処理する際に使われます。

`default_open(req)'
     このメソッドは `BaseHandler' では定義されて _いません_。
     しかし、全ての URL をキャッチさせたいなら、サブクラスで定義する
     必要があります。

     このメソッドが定義されていた場合、`OpenerDirector' から
     呼び出されます。このメソッドは `OpenerDirector' の メソッド
     `open()' が返す値について記述されているようなファイル類似の
     オブジェクトか、`None' を返さなくてはなりません。
     このメソッドが送出する例外は、真に例外的なことが起きない限り、
     `URLError' を送出しなければなりません (例えば、 `MemoryError' を
     `URLError' をマップしては いけません)。

     このメソッドはプロトコル固有のオープンメソッドが呼び出される前に
     呼び出されます。

`PROTOCOL_open(req)'
     このメソッドは `BaseHandler' では定義されて _いません_。
     しかしプロトコルの指定された URL をキャッチしたいなら、サブクラスで
     定義する必要があります。

     このメソッドが定義されていた場合、`OpenerDirector' から
     呼び出されます。戻り値は `default_open' と同じでなければ
     なりません。

`unknown_open(req)'
     このメソッドは `BaseHandler' では定義されて _いません_。 しかし
     URL を開くための特定のハンドラが登録されていないような URL を
     キャッチしたいなら、サブクラスで定義する必要があります。

     このメソッドが定義されていた場合、`OpenerDirector' から
     呼び出されます。戻り値は `default_open' と同じでなければ
     なりません。

`http_error_default(req, fp, code, msg, hdrs)'
     このメソッドは `BaseHandler' では定義されて _いません_。
     しかしその他の処理されなかった HTTP
     エラーを処理する機能をもたせたいなら、
     サブクラスで定義する必要があります。このメソッドはエラーに遭遇した
     `OpenerDirector' から自動的に呼び出されます。その他の状況では
     普通呼び出すべきではありません。

     REQ は `Request' オブジェクトで、 FP は HTTP
     エラー本体を読み出せるようなファイル類似のオブジェクトに
     なります。CODE は 3 桁の 10 進数からなるエラーコードで、 MSG
     ユーザ向けのエラーコード解説です。HDRS は
     エラー応答のヘッダをマップしたオブジェクトです。

     返される値および送出される例外は `urlopen()' と同じ
     ものでなければなりません。

`http_error_NNN(req, fp, code, msg, hdrs)'
     NNN は 3 桁の 10 進数からなる HTTP エラーコードでなくては
     なりません。このメソッドも `BaseHandler' では定義されていませんが、
     サブクラスのインスタンスで定義されていた場合、エラーコード NNN の
     HTTP エラーが発生した際に呼び出されます。

     特定の HTTP
     エラーに対する処理を行うためには、このメソッドをサブクラスで
     オーバライドする必要があります。

     引数、返される値、および送出される例外は `http_error_default()'
     と同じものでなければなりません。

`PROTOCOL_request(req)'
     このメソッドは`BaseHandler' では_定義されていません_ が、
     サブクラスで特定のプロトコルリクエストのプリプロセスを行いたい
     場合には定義せねばなりません。

     このメソッドが定義されていると、親となる `OpenerDirector' から
     呼び出されます。その際、REQ は`Request' オブジェクトに
     なります。戻り値は`Request' オブジェクトでなければなりません。

`PROTOCOL_response(req, response)'
     このメソッドは`BaseHandler' では_定義されていません_ が、
     サブクラスで特定のプロトコルリクエストのポストプロセスを行いたい
     場合には定義せねばなりません。

     このメソッドが定義されていると、親となる `OpenerDirector' から
     呼び出されます。その際、REQ は`Request' オブジェクトに なります。
     RESPONSE は `urlopen()' の戻り値と同じインタフェースを
     実装したオブジェクトになります。 戻り値もまた、`urlopen()'
     の戻り値と同じインタフェースを
     実装したオブジェクトでなければなりません。


File: python-lib-jp.info,  Node: HTTPRedirectHandler オブジェクト,  Next: HTTPCookieProcessor オブジェクト,  Prev: BaseHandler オブジェクト,  Up: urllib2

18.6.4 HTTPRedirectHandler オブジェクト
---------------------------------------

_Note:_ HTTP リダイレクトによっては、このモジュールのクライアントコード
側での処理を必要とします。その場合、 `HTTPError' が送出されます。
様々なリダイレクトコードの厳密な意味に関する詳細は RFC 2616 を
参照してください。

`redirect_request(req, fp, code, msg, hdrs)'
     リダイレクトの通知に応じて、 `Request' または `None'
     を返します。このメソッドは `http_error_30*()' メソッドに
     おいて、リダイレクトの通知をサーバから受信した際に、
     デフォルトの実装として呼び出されます。
     リダイレクトを起こす場合、新たな `Request' を生成して、
     `http_error_30*()' がリダイレクトを実行できるようにします。
     そうでない場合、他のどのハンドラにもこの URL を
     処理させたくなければ `HTTPError' を送出し、
     リダイレクト処理を行うことはできないが他のハンドラ
     なら可能かもしれない場合には `None' を返します。

     _Notice:_ このメソッドのデフォルトの実装は、RFC 2616 に厳密に従ったものでは
     ありません。 RFC 2616 では、`POST' リクエストに対する 301 および
     302 応答が、
     ユーザの承認なく自動的にリダイレクトされてはならないと述べています。
     現実には、ブラウザは POST を `GET' に変更することで、これらの
     応答に対して自動的にリダイレクトを行えるようにしています。
     デフォルトの実装でも、この挙動を再現しています。


`http_error_301(req, fp, code, msg, hdrs)'
     `Location:' URL にリダイレクトします。このメソッドは HTTP における
     `moved permanently' レスポンスを取得した際に 親オブジェクトとなる
     `OpenerDirector' によって呼び出されます。

`http_error_302(req, fp, code, msg, hdrs)'
     `http_error_301()' と同じですが、`found' レスポンスに対して
     呼び出されます。

`http_error_303(req, fp, code, msg, hdrs)'
     `http_error_301()' と同じですが、`see other' レスポンスに対して
     呼び出されます。

`http_error_307(req, fp, code, msg, hdrs)'
     `http_error_301()' と同じですが、`temporary redirect'
     レスポンスに対して呼び出されます。


File: python-lib-jp.info,  Node: HTTPCookieProcessor オブジェクト,  Next: ProxyHandler オブジェクト,  Prev: HTTPRedirectHandler オブジェクト,  Up: urllib2

18.6.5 HTTPCookieProcessor オブジェクト
---------------------------------------

_Added in Python version 2.4_

`HTTPCookieProcessor' インスタンスは属性をひとつだけ持ちます:

`cookiejar'
     クッキーの入っている`cookielib.CookieJar' オブジェクトです。


File: python-lib-jp.info,  Node: ProxyHandler オブジェクト,  Next: HTTPPasswordMgr オブジェクト,  Prev: HTTPCookieProcessor オブジェクト,  Up: urllib2

18.6.6 ProxyHandler オブジェクト
--------------------------------

`PROTOCOL_open(request)'
     `ProxyHandler' は、 コンストラクタで与えた辞書 PROXIES
     にプロキシが設定されている ような PROTOCOL 全てについて、メソッド
     `PROTOCOL_open()' を持つことになります。 このメソッドは
     `request.set_proxy()' を呼び出して、
     リクエストがプロキシを通過できるように修正します。その後
     連鎖するハンドラの中から次のハンドラを呼び出して実際に
     プロトコルを実行します。


File: python-lib-jp.info,  Node: HTTPPasswordMgr オブジェクト,  Next: AbstractBasicAuthHandler オブジェクト,  Prev: ProxyHandler オブジェクト,  Up: urllib2

18.6.7 HTTPPasswordMgr オブジェクト
-----------------------------------

以下のメソッドは `HTTPPasswordMgr' および
`HTTPPasswordMgrWithDefaultRealm' オブジェクトで利用できます。

`add_password(realm, uri, user, passwd)'
     URI は単一の URI でも複数の URI
     からなるシーケンスでもかまいません。 REALM 、USER および PASSWD
     は文字列でなくてはなりません。 このメソッドによって、REALM
     と与えられた URI の上位 URI に対して `(USER, PASSWD)'
     が認証トークンとして使われるようになります。

`find_user_password(realm, authuri)'
     与えられたレルムおよび URI に対するユーザ名またはパスワードがあれば
     それを取得します。該当するユーザ名／パスワードが存在しない場合、
     このメソッドは `(None, None)' を返します。

     `HTTPPasswordMgrWithDefaultRealm' オブジェクトでは、与えられた
     REALM に対して該当するユーザ名/パスワードが存在しない場合、 レルム
     `None' が検索されます。


File: python-lib-jp.info,  Node: AbstractBasicAuthHandler オブジェクト,  Next: HTTPBasicAuthHandler オブジェクト,  Prev: HTTPPasswordMgr オブジェクト,  Up: urllib2

18.6.8 AbstractBasicAuthHandler オブジェクト
--------------------------------------------

`http_error_auth_reqed(authreq, host, req, headers)'
     ユーザ名／パスワードを取得し、再度サーバへのリクエストを試みることで、
     サーバからの認証リクエストを処理します。 AUTHREQ
     はリクエストにおいて レルムに関する情報が含まれているヘッダの名前、
     HOST は認証を行う対象の URL とパスを指定します、 REQ は (失敗した)
     `Request' オブジェクト、そして HEADERS は
     エラーヘッダでなくてはなりません。

     HOST は、オーソリティ (例 `"python.org"') か、
     オーソリティコンポーネント を含む URL (例 `"http://python.org"')
     です。
     どちらの場合も、オーソリティはユーザ情報コンポーネントを含んではいけません
     (なので、`"python.org"' や `"python.org:80"' は正しく、
     `"joe:password@python.org"' は不正です) 。


File: python-lib-jp.info,  Node: HTTPBasicAuthHandler オブジェクト,  Next: ProxyBasicAuthHandler オブジェクト,  Prev: AbstractBasicAuthHandler オブジェクト,  Up: urllib2

18.6.9 HTTPBasicAuthHandler オブジェクト
----------------------------------------

`http_error_401(req, fp, code,  msg, hdrs)'
     認証情報がある場合、認証情報付きで再度リクエストを試みます。


File: python-lib-jp.info,  Node: ProxyBasicAuthHandler オブジェクト,  Next: AbstractDigestAuthHandler オブジェクト,  Prev: HTTPBasicAuthHandler オブジェクト,  Up: urllib2

18.6.10 ProxyBasicAuthHandler オブジェクト
------------------------------------------

`http_error_407(req, fp, code,  msg, hdrs)'
     認証情報がある場合、認証情報付きで再度リクエストを試みます。


File: python-lib-jp.info,  Node: AbstractDigestAuthHandler オブジェクト,  Next: HTTPDigestAuthHandler オブジェクト,  Prev: ProxyBasicAuthHandler オブジェクト,  Up: urllib2

18.6.11 AbstractDigestAuthHandler オブジェクト
----------------------------------------------

`http_error_auth_reqed(authreq, host, req, headers)'
     AUTHREQ はリクエストにおいてレルムに関する情報が含まれている
     ヘッダの名前、HOST は認証を行う対象のホスト名、REQ は (失敗した)
     `Request' オブジェクト、そして HEADERS は
     エラーヘッダでなくてはなりません。


File: python-lib-jp.info,  Node: HTTPDigestAuthHandler オブジェクト,  Next: ProxyDigestAuthHandler オブジェクト,  Prev: AbstractDigestAuthHandler オブジェクト,  Up: urllib2

18.6.12 HTTPDigestAuthHandler オブジェクト
------------------------------------------

`http_error_401(req, fp, code,  msg, hdrs)'
     認証情報がある場合、認証情報付きで再度リクエストを試みます。


File: python-lib-jp.info,  Node: ProxyDigestAuthHandler オブジェクト,  Next: HTTPHandler オブジェクト,  Prev: HTTPDigestAuthHandler オブジェクト,  Up: urllib2

18.6.13 ProxyDigestAuthHandler オブジェクト
-------------------------------------------

`http_error_407(req, fp, code,  msg, hdrs)'
     認証情報がある場合、認証情報付きで再度リクエストを試みます。


File: python-lib-jp.info,  Node: HTTPHandler オブジェクト,  Next: HTTPSHandler オブジェクト,  Prev: ProxyDigestAuthHandler オブジェクト,  Up: urllib2

18.6.14 HTTPHandler オブジェクト
--------------------------------

`http_open(req)'
     HTTP リクエストを送ります。`REQ.has_data()' に応じて、 GET または
     POST のどちらでも送ることができます。


File: python-lib-jp.info,  Node: HTTPSHandler オブジェクト,  Next: FileHandler オブジェクト,  Prev: HTTPHandler オブジェクト,  Up: urllib2

18.6.15 HTTPSHandler オブジェクト
---------------------------------

`https_open(req)'
     HTTPS リクエストを送ります。`REQ.has_data()' に応じて、 GET または
     POST のどちらでも送ることができます。


File: python-lib-jp.info,  Node: FileHandler オブジェクト,  Next: FTPHandler オブジェクト,  Prev: HTTPSHandler オブジェクト,  Up: urllib2

18.6.16 FileHandler オブジェクト
--------------------------------

`file_open(req)'
     ホスト名がない場合、またはホスト名が `'localhost'' の場合に
     ファイルをローカルでオープンします。そうでない場合、プロトコルを
     `ftp' に切り替え、`parent' を使って再度オープンを 試みます。


File: python-lib-jp.info,  Node: FTPHandler オブジェクト,  Next: CacheFTPHandler オブジェクト,  Prev: FileHandler オブジェクト,  Up: urllib2

18.6.17 FTPHandler オブジェクト
-------------------------------

`ftp_open(req)'
     REQ で表されるファイルを FTP 越しにオープンします。
     ログインは常に空のユーザネームおよびパスワードで行われます。


File: python-lib-jp.info,  Node: CacheFTPHandler オブジェクト,  Next: GopherHandler オブジェクト,  Prev: FTPHandler オブジェクト,  Up: urllib2

18.6.18 CacheFTPHandler オブジェクト
------------------------------------

`CacheFTPHandler' オブジェクトは `FTPHandler' オブジェクトに
以下のメソッドを追加したものです:

`setTimeout(t)'
     接続のタイムアウトを T 秒に設定します。

`setMaxConns(m)'
     キャッシュ付き接続の最大接続数を M に設定します。


File: python-lib-jp.info,  Node: GopherHandler オブジェクト,  Next: UnknownHandler オブジェクト,  Prev: CacheFTPHandler オブジェクト,  Up: urllib2

18.6.19 GopherHandler オブジェクト
----------------------------------

`gopher_open(req)'
     REQ で表される gopher 上のリソースをオープンします。


File: python-lib-jp.info,  Node: UnknownHandler オブジェクト,  Next: HTTPErrorProcessor オブジェクト,  Prev: GopherHandler オブジェクト,  Up: urllib2

18.6.20 UnknownHandler オブジェクト
-----------------------------------

`unknown_open()'
     例外 `URLError' を送出します。


File: python-lib-jp.info,  Node: HTTPErrorProcessor オブジェクト,  Next: 例 10,  Prev: UnknownHandler オブジェクト,  Up: urllib2

18.6.21 HTTPErrorProcessor オブジェクト
---------------------------------------

_Added in Python version 2.4_

`unknown_open()'
     HTTP エラーレスポンスを処理します。

     エラーコード 200 の場合、レスポンスオブジェクトを即座に返します。

     200 以外のエラーコードの場合、`OpenerDirector.error()'
     を介して`PROTOCOL_error_CODE()' メソッドに
     仕事を引き渡します。最終的にどのハンドラもエラーを処理しなかった
     場合、`urllib2.HTTPDefaultErrorHandler' が `HTTPError'
     を送出します。


File: python-lib-jp.info,  Node: 例 10,  Prev: HTTPErrorProcessor オブジェクト,  Up: urllib2

18.6.22 例
----------

以下の例では、 python.org のメインページを取得して、その最初の 100
バイト分を表示します:

     >>> import urllib2
     >>> f = urllib2.urlopen('http://www.python.org/')
     >>> print f.read(100)
     <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
     <?xml-stylesheet href="./css/ht2html

今度は CGI の標準入力にデータストリームを送信し、CGI が返すデータ
を読み出します。この例は Python が SSL をサポートしている場合にのみ
動作することに注意してください。

     >>> import urllib2
     >>> req = urllib2.Request(url='https://localhost/cgi-bin/test.cgi',
     ...                       data='This data is passed to stdin of the CGI')
     >>> f = urllib2.urlopen(req)
     >>> print f.read()
     Got Data: "This data is passed to stdin of the CGI"

上の例で使われているサンプルの CGI は以下のようになっています:

     #!/usr/bin/env python
     import sys
     data = sys.stdin.read()
     print 'Content-type: text-plain\n\nGot Data: "%s"' % data

以下はベーシック HTTP 認証の例です:

     import urllib2
     # ベーシック HTTP 認証をサポートする OpenerDirector を作成する...
     auth_handler = urllib2.HTTPBasicAuthHandler()
     auth_handler.add_password('realm', 'host', 'username', 'password')
     opener = urllib2.build_opener(auth_handler)
     # ...urlopen から利用できるよう、グローバルにインストールする
     urllib2.install_opener(opener)
     urllib2.urlopen('http://www.example.com/login.html')

`build_opener()' はデフォルトで沢山のハンドラを提供しており、
その中に`ProxyHandler' があります。デフォルトでは、 `ProxyHandler'
は`<scheme>_proxy' という環境変数を使います。 ここで`<scheme>' は URL
スキームです。例えば、 HTTP プロキシの URL
を得るには、環境変数`http_proxy' を読み出します。

この例では、デフォルトの `ProxyHandler' を置き換えて
プログラム的に作成したプロキシ URL を使うようにし、
`ProxyBasicAuthHandler' でプロキシ認証サポートを追加します。

     proxy_handler = urllib2.ProxyHandler({'http': 'http://www.example.com:3128/'})
     proxy_auth_handler = urllib2.HTTPBasicAuthHandler()
     proxy_auth_handler.add_password('realm', 'host', 'username', 'password')

     opener = build_opener(proxy_handler, proxy_auth_handler)
     # 今回は OpenerDirector をインストールするのではなく直接使います:
     opener.open('http://www.example.com/login.html')

以下は HTTP ヘッダを追加する例です:

HEADERS 引数を使って`Request' コンストラクタを呼び出す方法
の他に、以下のようにできます:

     import urllib2
     req = urllib2.Request('http://www.example.com/')
     req.add_header('Referer', 'http://www.python.org/')
     r = urllib2.urlopen(req)

`OpenerDirector' は全ての `Request' に `User-Agent'
ヘッダを自動的に追加します。これを変更するには:

     import urllib2
     opener = urllib2.build_opener()
     opener.addheaders = [('User-agent', 'Mozilla/5.0')]
     opener.open('http://www.example.com/')

のようにします。

また、`Request' が`urlopen()' (や `OpenerDirector.open()')
に渡される際には、いくつかの標準ヘッダ (`Content-Length',
`Content-Type' および `Host') も追加されることを忘れないでください。


File: python-lib-jp.info,  Node: httplib,  Next: ftplib,  Prev: urllib2,  Up: インターネットプロトコルとその支援

18.7 HTTP プロトコルクライアント
================================

HTTP および HTTPS プロトコルのクライアント  (ソケットを必要とします) 。

このモジュールでは HTTP および HTTPS プロトコルのクライアント側
を実装しているクラスを定義しています。通常、このモジュールは直接
使いません -- `urllib'  モジュールが HTTP や HTTPS を使った URL
を扱う上でこのモジュールを使います。 _Note:_ HTTPS のサポートは、SSL
をサポートするように `socket'
モジュールをコンパイルした場合にのみ利用できます。

このモジュールでは以下のクラスを提供しています:

`HTTPConnection(host[, port])'
     `HTTPConnection' インスタンスは、HTTP サーバとの一回の
     トランザクションを表現します。インスタンスの生成はホスト名と
     オプションのポート番号を与えて行います。ポート番号を指定しなかった
     場合、ホスト名文字列が `HOST:PORT'
     の形式であれば、ホスト名からポート番号を導き、そうでない
     場合には標準の HTTP ポート番号 (80) を使います。例えば、
     以下の呼び出しは全て同じサーバの同じポートに接続するインスタンス
     を生成します:

          >>> h1 = httplib.HTTPConnection('www.cwi.nl')
          >>> h2 = httplib.HTTPConnection('www.cwi.nl:80')
          >>> h3 = httplib.HTTPConnection('www.cwi.nl', 80)


`HTTPSConnection(host[, port, key_file, cert_file])'
     `HTTPConnection' のサブクラスで、セキュアなサーバと 通信するために
     SSL を使います。標準のポート番号は `443' です。
     KEY_FILEには、秘密鍵を格納したPEM形式ファイルのファイル名を指定します。CERT_FILEには、PEM形式の証明書チェーンファイルを指定します。

     _この関数は証明書の検査を行いません！_

必要に応じて以下の例外が送出されます:

`HTTPException'
     このモジュールにおける他の例外クラスの基底クラスです。 `Exception'
     のサブクラスです。

`NotConnected'
     `HTTPException' サブクラスです。

`InvalidURL'
     `HTTPException' のサブクラスです。ポート番号を指定した
     ものの、その値が数字でなかったり空のオブジェクトであった場合に送出されます。

`UnknownProtocol'
     `HTTPException' のサブクラスです。

`UnknownTransferEncoding'
     `HTTPException' のサブクラスです。

`IllegalKeywordArgument'
     `HTTPException' のサブクラスです。

`UnimplementedFileMode'
     `HTTPException' のサブクラスです。

`IncompleteRead'
     `HTTPException' のサブクラスです。

`ImproperConnectionState'
     `HTTPException' のサブクラスです。

`CannotSendRequest'
     `ImproperConnectionState' のサブクラスです。

`CannotSendHeader'
     `ImproperConnectionState' のサブクラスです。

`ResponseNotReady'
     `ImproperConnectionState' のサブクラスです。

`BadStatusLine'
     `HTTPException' のサブクラスです。 サーバが理解できない HTTP
     状態コードで応答した場合に送出されます。

このモジュールで定義されている定数は以下の通りです:

`HTTP_PORT'
     HTTP プロトコルの標準のポート (通常は `80') です。

`HTTPS_PORT'
     HTTPS プロトコルの標準のポート (通常は `443') です。

また、整数の状態コードについて以下の定数が定義されています:

Constant                 Value                    Definition
------                   -----                    -----
CONTINUE                 `100'                    HTTP/1.1, RFC 2616,
                                                  Section 10.1.1
SWITCHING_PROTOCOLS      `101'                    HTTP/1.1, RFC 2616,
                                                  Section 10.1.2
PROCESSING               `102'                    WEBDAV, RFC 2518,
                                                  Section 10.1
OK                       `200'                    HTTP/1.1, RFC 2616,
                                                  Section 10.2.1
CREATED                  `201'                    HTTP/1.1, RFC 2616,
                                                  Section 10.2.2
ACCEPTED                 `202'                    HTTP/1.1, RFC 2616,
                                                  Section 10.2.3
NON_AUTHORITATIVE_INFORMATION`203'                    HTTP/1.1, RFC 2616,
                                                  Section 10.2.4
NO_CONTENT               `204'                    HTTP/1.1, RFC 2616,
                                                  Section 10.2.5
RESET_CONTENT            `205'                    HTTP/1.1, RFC 2616,
                                                  Section 10.2.6
PARTIAL_CONTENT          `206'                    HTTP/1.1, RFC 2616,
                                                  Section 10.2.7
MULTI_STATUS             `207'                    WEBDAV RFC 2518,
                                                  Section 10.2
IM_USED                  `226'                    Delta encoding in HTTP,
                                                  RFC 3229 , Section
                                                  10.4.1
MULTIPLE_CHOICES         `300'                    HTTP/1.1, RFC 2616,
                                                  Section 10.3.1
MOVED_PERMANENTLY        `301'                    HTTP/1.1, RFC 2616,
                                                  Section 10.3.2
FOUND                    `302'                    HTTP/1.1, RFC 2616,
                                                  Section 10.3.3
SEE_OTHER                `303'                    HTTP/1.1, RFC 2616,
                                                  Section 10.3.4
NOT_MODIFIED             `304'                    HTTP/1.1, RFC 2616,
                                                  Section 10.3.5
USE_PROXY                `305'                    HTTP/1.1, RFC 2616,
                                                  Section 10.3.6
TEMPORARY_REDIRECT       `307'                    HTTP/1.1, RFC 2616,
                                                  Section 10.3.8
BAD_REQUEST              `400'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.1
UNAUTHORIZED             `401'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.2
PAYMENT_REQUIRED         `402'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.3
FORBIDDEN                `403'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.4
NOT_FOUND                `404'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.5
METHOD_NOT_ALLOWED       `405'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.6
NOT_ACCEPTABLE           `406'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.7
PROXY_AUTHENTICATION_REQUIRED`407'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.8
REQUEST_TIMEOUT          `408'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.9
CONFLICT                 `409'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.10
GONE                     `410'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.11
LENGTH_REQUIRED          `411'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.12
PRECONDITION_FAILED      `412'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.13
REQUEST_ENTITY_TOO_LARGE `413'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.14
REQUEST_URI_TOO_LONG     `414'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.15
UNSUPPORTED_MEDIA_TYPE   `415'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.16
REQUESTED_RANGE_NOT_SATISFIABLE`416'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.17
EXPECTATION_FAILED       `417'                    HTTP/1.1, RFC 2616,
                                                  Section 10.4.18
UNPROCESSABLE_ENTITY     `422'                    WEBDAV, RFC 2518,
                                                  Section 10.3
LOCKED                   `423'                    WEBDAV RFC 2518,
                                                  Section 10.4
FAILED_DEPENDENCY        `424'                    WEBDAV, RFC 2518,
                                                  Section 10.5
UPGRADE_REQUIRED         `426'                    HTTP Upgrade to TLS,
                                                  RFC 2817 , Section 6
INTERNAL_SERVER_ERROR    `500'                    HTTP/1.1, RFC 2616,
                                                  Section 10.5.1
NOT_IMPLEMENTED          `501'                    HTTP/1.1, RFC 2616,
                                                  Section 10.5.2
BAD_GATEWAY              `502'                    HTTP/1.1 RFC 2616,
                                                  Section 10.5.3
SERVICE_UNAVAILABLE      `503'                    HTTP/1.1, RFC 2616,
                                                  Section 10.5.4
GATEWAY_TIMEOUT          `504'                    HTTP/1.1 RFC 2616,
                                                  Section 10.5.5
HTTP_VERSION_NOT_SUPPORTED`505'                    HTTP/1.1, RFC 2616,
                                                  Section 10.5.6
INSUFFICIENT_STORAGE     `507'                    WEBDAV, RFC 2518,
                                                  Section 10.6
NOT_EXTENDED             `510'                    An HTTP Extension
                                                  Framework, RFC 2774 ,
                                                  Section 7

`responses'
     このディクショナリは、HTTP
     1.1ステータスコードをW3Cの名前にマップしたものです。

     たとえば `httplib.responses[httplib.NOT_FOUND]' は `'Not Found''
     となります。 _Added in Python version 2.5_

* Menu:

* HTTPConnection オブジェクト::
* HTTPResponse オブジェクト::
* 例 11::


File: python-lib-jp.info,  Node: HTTPConnection オブジェクト,  Next: HTTPResponse オブジェクト,  Prev: httplib,  Up: httplib

18.7.1 HTTPConnection オブジェクト
----------------------------------

`HTTPConnection' インスタンスには以下のメソッドがあります:

`request(method, url[, body[, headers]])'
     このメソッドは、 HTTP 要求メソッド METHOD およびセレクタ URL
     を使って、要求をサーバに送ります。BODY 引数を指定する場合、
     ヘッダが終了した後に送信する文字列データでなければなりません。
     ヘッダの Content-Length は自動的に正しい値に設定されます。 HEADERS
     引数は要求と同時に送信される拡張 HTTP ヘッダの内容からなる
     マップ型でなくてはなりません。

`getresponse()'
     サーバに対して HTTP
     要求を送り出した後に呼び出されなければりません。
     要求に対する応答を取得します。`HTTPResponse' インスタンスを
     返します。 _Note:_
     すべての応答を読み込んでからでなければ新しい要求をサーバに送ること
     はできないことに注意しましょう。

`set_debuglevel(level)'
     デバッグレベル (印字されるデバッグ出力の量) を設定します。
     標準のデバッグレベルは `0' で、デバッグ出力を全く印字 しません。

`connect()'
     オブジェクトを生成するときに指定したサーバに接続します。

`close()'
     サーバへの接続を閉じます。

上で説明した`request()'メソッドを使うかわりに、以下の4つの関数を
使用して要求をステップバイステップで送信することもできます。

`putrequest(request, selector[, skip_host[, skip_accept_encoding]])'
     サーバへの接続が確立したら、最初にこのメソッドを呼び出さなくては
     なりません。このメソッドは REQUEST 文字列、SELECTOR 文字列、
     そして HTTP バージョン (`HTTP/1.1') からなる一行を送信します。
     `Host:' や`Accept-Encoding:' ヘッダの自動送信を無効にしたい 場合
     (例えば別のコンテンツエンコーディングを受け入れたい場合) には、
     SKIP_HOST や SKIP_ACCEPT_ENCODING を偽でない値に設定 してください。

`putheader(header, argument[, ...])'
     RFC 822 形式のヘッダをサーバに送ります。この処理では、HEADER、
     コロンとスペース、そして最初の引数からなる 1 行をサーバに送ります。
     追加の引数を指定した場合、継続して各行にタブ一つと引数の入った引数行が
     送信されます。

`endheaders()'
     サーバに空行を送り、ヘッダ部が終了したことを通知します。

`send(data)'
     サーバにデータを送ります。このメソッドは `endheaders()'
     が呼び出された直後で、かつ `getreply()' が呼び出される
     前に使わなければなりません。


File: python-lib-jp.info,  Node: HTTPResponse オブジェクト,  Next: 例 11,  Prev: HTTPConnection オブジェクト,  Up: httplib

18.7.2 HTTPResponse オブジェクト
--------------------------------

`HTTPResponse' インスタンスは以下のメソッドと属性を持ちます:

`read([amt])'
     応答の本体全体か、AMT バイトまで読み出して返します。

`getheader(name[, default])'
     ヘッダ NAME の内容を取得して返すか、該当するヘッダがない場合には
     DEFAULT を返します。

`getheaders()'
     (header, value) のタプルからなるリストを返します。 _Added in
     Python version 2.4_

`msg'
     応答ヘッダを含む `mimetools.Message' インスタンスです。

`version'
     サーバが使用した HTTP プロトコルバージョンです。10 は HTTP/1.0 を、
     11 は HTTP/1.1 を表します。

`status'
     サーバから返される状態コードです。

`reason'
     サーバから返される応答の理由文です。


File: python-lib-jp.info,  Node: 例 11,  Prev: HTTPResponse オブジェクト,  Up: httplib

18.7.3 例
---------

以下は`GET' リクエストの送信方法を示した例です:

     >>> import httplib
     >>> conn = httplib.HTTPConnection("www.python.org")
     >>> conn.request("GET", "/index.html")
     >>> r1 = conn.getresponse()
     >>> print r1.status, r1.reason
     200 OK
     >>> data1 = r1.read()
     >>> conn.request("GET", "/parrot.spam")
     >>> r2 = conn.getresponse()
     >>> print r2.status, r2.reason
     404 Not Found
     >>> data2 = r2.read()
     >>> conn.close()

以下は `POST' リクエストの送信方法を示した例です:

     >>> import httplib, urllib
     >>> params = urllib.urlencode({'spam': 1, 'eggs': 2, 'bacon': 0})
     >>> headers = {"Content-type": "application/x-www-form-urlencoded",
     ...            "Accept": "text/plain"}
     >>> conn = httplib.HTTPConnection("musi-cal.mojam.com:80")
     >>> conn.request("POST", "/cgi-bin/query", params, headers)
     >>> response = conn.getresponse()
     >>> print response.status, response.reason
     200 OK
     >>> data = response.read()
     >>> conn.close()


File: python-lib-jp.info,  Node: ftplib,  Next: gopherlib,  Prev: httplib,  Up: インターネットプロトコルとその支援

18.8 FTPプロトコルクライアント
==============================

FTPプロトコルクライアント(ソケットを必要とします)。

このモジュールでは`FTP'クラスと、それに関連するいくつかの項目を定
義しています。
`FTP'クラスは、FTPプロトコルのクライアント側の機能を備えています。
このクラスを使うとFTPのいろいろな機能の自動化、例えば他のFTPサーバのミ
ラーリングといったことを実行するPythonプログラムを書くことができます。
また、`urllib'モジュールもFTPを使うURLを操作するのにこのクラス
を使っています。 FTP (File Transfer
Protocol)についての詳しい情報はInternet RFC 959 を参 照して下さい。

`ftplib'モジュールを使ったサンプルを以下に示します：

     >>> from ftplib import FTP
     >>> ftp = FTP('ftp.cwi.nl')   # ホストのデフォルトポートへ接続
     >>> ftp.login()               # ユーザ名 anonymous、パスワード anonyumou
     s@
     >>> ftp.retrlines('LIST')     # ディレクトリの内容をリストアップ
     total 24418
     drwxrwsr-x   5 ftp-usr  pdmaint     1536 Mar 20 09:48 .
     dr-xr-srwt 105 ftp-usr  pdmaint     1536 Mar 21 14:32 ..
     -rw-r--r--   1 ftp-usr  pdmaint     5305 Mar 20 09:48 INDEX
      .
      .
      .
     >>> ftp.retrbinary('RETR README', open('README', 'wb').write)
     '226 Transfer complete.'
     >>> ftp.quit()

このモジュールは以下の項目を定義しています：

`FTP([host[, user[, passwd[, acct]]]])'
     `FTP'クラスの新しいインスタンスを返します。
     HOSTが与えられると、`connect(HOST)'メソッドが実行されま す。
     USERが与えられると、さらに`login(USER, PASSWD,
     ACCT)'メソッドが実行されます（このPASSWDとACCTは指定され
     なければデフォルトでは空文字列です）。

`all_errors'
     `FTP'インスタンスのメソッドの結果、FTP接続で（プログラミングのエ
     ラーと考えられるメソッドの実行によって）発生する全ての例外（タプル形
     式）。 この例外には以下の４つのエラーはもちろん、`socket.error'と
     `IOError'も含まれます。

`error_reply'
     サーバから想定外の応答があった時に発生する例外。

`error_temp'
     400-499の範囲のエラー応答コードを受け取った時に発生する例外。

`error_perm'
     500-599の範囲のエラー応答コードを受け取った時に発生する例外。

`error_proto'
     1-5の数字で始まらない応答コードをサーバから受け取った時に発生する例外。

See also:
     *Note netrc:: `.netrc'ファイルフォーマットのパーザ。
     `.netrc'ファイルは、FTPクライアントがユーザにプロンプトを出す前に、
     ユーザ認証情報をロードするのによく使われます。
     Pythonのソースディストリビューションの`Tools/scripts/ftpmi rror.py' ファイルは、FTPサイトあるいはその一部をミ
     ラーリングするスクリプトで、`ftplib'モジュールを使っています。こ
     のモジュールを適用した応用例として使うことができます。

* Menu:

* FTP オブジェクト::


File: python-lib-jp.info,  Node: FTP オブジェクト,  Prev: ftplib,  Up: ftplib

18.8.1 FTP オブジェクト
-----------------------

いくつかのコマンドは２つのタイプについて実行します：１つはテキストファイ
ルで、もう１つはバイナリファイルを扱います。
これらのメソッドのテキストバージョンでは`lines'、バイナリバージョン
では`binary'の語がメソッド名の終わりについています。

`FTP'インスタンスには以下のメソッドがあります：

`set_debuglevel(level)'
     インスタンスのデバッグレベルを設定します。
     この設定によってデバッグ時に出力される量を調節します。
     デフォルトは`0'で、何も出力されません。
     `1'なら、一般的に１つのコマンドあたり１行の適当な量のデバッグ出力を
     行います。
     `2'以上なら、コントロール接続で受信した各行を出力して、最大のデバッ
     グ出力をします。

`connect(host[, port])'
     指定されたホストとポートに接続します。
     ポート番号のデフォルト値はFTPプロトコルの仕様で定められた`21'です。
     他のポート番号を指定する必要はめったにありません。
     この関数はひとつのインスタンスに対して一度だけ実行すべきです；
     インスタンスが作られた時にホスト名が与えられていたら、呼び出すべきではあ
     りません。
     これ以外の他の全てのメソッドは接続された後で実行可能となります。

`getwelcome()'
     接続して最初にサーバから送られてくるウェルカムメッセージを返します。
     （このメッセージには、ユーザにとって適切な注意書きやヘルプ情報が含まれる
     ことがあります。）

`login([user[, passwd[, ac ct]]])'
     与えられたUSERでログインします。
     PASSWDとACCTのパラメータは省略可能で、デフォルトでは空文字列 です。
     もしUSERが指定されないなら、デフォルトで`'anonymous''になりま す。
     もしUSERが`'anonymous''なら、デフォルトのPASSWDは`
     'anonymous@''になります。
     このfunctionは各インスタンスについて一度だけ、接続が確立した後に呼び出さ
     なければなりません；
     インスタンスが作られた時にホスト名とユーザ名が与えられていたら、このメ
     ソッドを実行すべきではありません。
     ほとんどのFTPコマンドはクライアントがログインした後に実行可能になりま
     す。

`abort()'
     実行中のファイル転送を中止します。
     これはいつも機能するわけではありませんが、やってみる価値はあります。

`sendcmd(command)'
     シンプルなコマンド文字列をサーバに送信して、受信した文字列を返します。

`voidcmd(command)'
     シンプルなコマンド文字列をサーバに送信して、その応答を扱います。
     応答コードが200-299の範囲にあれば何も返しません。
     それ以外は例外を発生します。

`retrbinary(command, callback[, maxblocksize[, rest]])'
     バイナリ転送モードでファイルを受信します。
     COMMANDは適切な`RETR'コマンド： `'RETR
     FILENAME''でなければなりません。
     関数CALLBACKは、受信したデータブロックのそれぞれに対して、データブ
     ロックを１つの文字列の引数として呼び出されます。
     省略可能な引数MAXBLOCKSIZEは、実際の転送を行うのに作られた低レベル
     のソケットオブジェクトから読み込む最大のチャンクサイズを指定します（これ
     はCALLBACKに与えられるデータブロックの最大サイズにもなります）。
     妥当なデフォルト値が設定されます。
     RESTは、`transfercmd()'メソッドと同じものです。

`retrlines(command[, callback])'
     ASCII転送モードでファイルとディレクトリのリストを受信します。
     COMMANDは、適切な`RETR'コマンド（`retrbinary()'を参
     照）あるいは`LIST'コマンド（通常は文字列`'LIST''）でなければな
     りません。
     関数CALLBACKは末尾のCRLFを取り除いた各行に対して実行されます。
     デフォルトではCALLBACKは`sys.stdout'に各行を印字します。

`set_pasv(boolean)'
     BOOLEANがtrueなら"パッシブモード"をオンにし、そうでないならパッ
     シブモードをオフにします。 （Python
     2.0以前ではデフォルトでパッシブモードはオフにされていましたが、
     Python 2.1以後ではデフォルトでオンになっています。）

`storbinary(command, file[, blocksize])'
     バイナリ転送モードでファイルを転送します。
     COMMANDは適切な`STOR'コマンド：`"STOR FILENAME"'で
     なければなりません。
     FILEは開かれたファイルオブジェクトで、`read()'メソッドで
     `EOF'まで読み込まれ、ブロックサイズBLOCKSIZEでデータが転送されま
     す。 引数BLOCKSIZEのデフォルト値は8192です。 _Changed in Python
     version 2.1_

`storlines(command, file)'
     ASCII転送モードでファイルを転送します。
     COMMANDは適切な`STOR'コマンドでなければなりません（`st
     orbinary()'を参照）。
     FILEは開かれたファイルオブジェクトで、`readline()'メソッド
     で`EOF'まで読み込まれ、各行がデータが転送されます。

`transfercmd(cmd[, rest])'
     データ接続中に転送を初期化します。
     もし転送中なら、`EPRT'あるいは`PORT'コマンドと、CMDで指
     定したコマンドを送信し、接続を続けます。
     サーバがパッシブなら、`EPSV'あるいは`PASV'コマンドを送信して接
     続し、転送コマンドを開始します。
     どちらの場合も、接続のためのソケットを返します。

     省略可能なRESTが与えられたら、`REST'コマンドがサーバに送信さ
     れ、RESTを引数として与えます。
     RESTは普通、要求したファイルのバイトオフセット値で、最初のバイトを
     とばして指定したオフセット値からファイルのバイト転送を再開するよう伝えま
     す。 しかし、RFC
     959ではRESTが印字可能なASCIIコード33から126の範囲の文
     字列からなることを要求していることに注意して下さい。
     したがって、`transfercmd()'メソッドはRESTを文字列に変換しま
     すが、文字列の内容についてチェックしません。
     もし`REST'コマンドをサーバが認識しないなら、例外`error_re
     ply'が発生します。
     この例外が発生したら、引数RESTなしに`transfercmd()'を実行し ます。

`ntransfercmd(cmd[, rest])'
     `transfercmd()'と同様ですが、データと予想されるサイズとのタプルを
     返します。
     もしサイズが計算できないなら、サイズの代わりに`None'が返されます。
     CMDとRESTは`transfercmd()'のものと同じです。

`nlst(argument[, ...])'
     `NLST'コマンドで返されるファイルのリストを返します。
     省略可能なARGUMENTは、リストアップするディレクトリです（デフォルト
     ではサーバのカレントディレクトリです）。
     `NLST'コマンドに非標準である複数の引数を渡すことができます。

`dir(argument[, ...])'
     `LIST'コマンドで返されるディレクトリ内のリストを作り、標準出力へ出
     力します。
     省略可能なARGUMENTは、リストアップするディレクトリです（デフォルト
     ではサーバのカレントディレクトリです）。
     `LIST'コマンドに非標準である複数の引数を渡すことができます。
     もし最後の引数が関数なら、`retrlines()'のようにCALLBACKとし
     て使われます；デフォルトでは`sys.stdout'に印字します。
     このメソッドは`None'を返します。

`rename(fromname, toname)'
     サーバ上のファイルのファイル名FROMNAMEをTONAMEへ変更します。

`delete(filename)'
     サーバからファイルFILENAMEを削除します。
     成功したら応答のテキストを返し、そうでないならパーミッションエラーでは
     `error_perm'を、他のエラーでは`error_reply'を返しま す。

`cwd(pathname)'
     サーバのカレントディレクトリを設定します。

`mkd(pathname)'
     サーバ上に新たにディレクトリを作ります。

`pwd()'
     サーバ上のカレントディレクトリのパスを返します。

`rmd(dirname)'
     サーバ上のディレクトリDIRNAMEを削除します。

`size(filename)'
     サーバ上のファイルFILENAMEのサイズを尋ねます。
     成功したらファイルサイズが整数で返され、そうでないなら`None'が返さ
     れます。
     `SIZE'コマンドは標準化されていませんが、多くの普通のサーバで実装さ
     れていることに注意して下さい。

`quit()'
     サーバに`QUIT'コマンドを送信し、接続を閉じます。
     これは接続を閉じるのに"礼儀正しい"方法ですが、`QUIT'コマンドに反
     応してサーバの例外が発生するかもしれません。
     この例外は、`close()'メソッドによって`FTP'インスタンスに対
     するその後のコマンド使用が不可になっていることを示しています（下記参
     照）。

`close()'
     接続を一方的に閉じます。
     既に閉じた接続に対して実行すべきではありません（例えば`quit()'を
     呼び出して成功した後など）。
     この実行の後、`FTP'インスタンスはもう使用すべきではありません
     （`close()'あるいは`quit()'を呼び出した後で、
     `login()'メソッドをもう一度実行して再び接続を開くことはできませ
     ん）。


File: python-lib-jp.info,  Node: gopherlib,  Next: poplib,  Prev: ftplib,  Up: インターネットプロトコルとその支援

18.9 gopher プロトコルのクライアント
====================================

gopher プロトコルのクライアント (ソケットを必要とします)。

_This is deprecated in Python 2.5.   `gopher'
プロトコルはあまり利用されていません。_

このモジュールでは、gopher プロトコルのクライアント側について最小限の
実装を提供しています。このモジュールは `urllib' モジュールで gopher
プロトコルを使う URL を扱うために用いられます。

このモジュールでは以下の関数を定義しています:

`send_selector(selector, host[, port])'
     SELECTOR 文字列を HOST および PORT (標準の値は `70' です) の
     gopher サーバに送信します。
     返信されたドキュメントデータを読み出すための、開かれた状態のファイル
     オブジェクトを返します。

`send_query(selector, query, host[, port])'
     SELECTOR 文字列、および QUERY 文字列を HOST および PORT
     (標準の値は `70' です) の gopher サーバに送信します。
     返信されたドキュメントデータを読み出すための、開かれた状態のファイル
     オブジェクトを返します。

gopher サーバから返されるデータは任意の形式であり、セレクタ (selector)
文字列の最初の文字に依存するので注意してください。データがテキスト
(セレクタの最初の文字が `0') の場合、各行は CRLF で終端
され、データ全体は `.' 一個だけからなる行で終端されます。 `..'
で始まる行の先頭は `.' に置き換えられます。 ディレクトリリスト
(セレクタの最初の文字が `1') の場合にも、 同じプロトコルで転送されます。


File: python-lib-jp.info,  Node: poplib,  Next: imaplib,  Prev: gopherlib,  Up: インターネットプロトコルとその支援

18.10 POP3 プロトコルクライアント
=================================

POP3 プロトコルクライアント (socketsを必要とする)

このモジュールは、 `POP3' クラスを定義します。これはPOP3サーバへの
接続と、 RFC 1725 に定められたプロトコルを実装します。 `POP3' クラスは
minimalとoptinalという2つのコマンドセットをサポートします。
モジュールは`POP3_SSL'クラスも提供します。このクラスは下位の
プロトコルレイヤーにSSLを使ったPOP3サーバへの接続を提供します。

POP3についての注意事項は、それが広くサポートされているにもかかわらず、
既に時代遅れだということです。幾つも実装されているPOP3サーバーの品質は、
貧弱なものが多数を占めています。もし、お使いのメールサーバーがIMAPを
サポートしているなら、 ``imaplib' や `IMAP4'' が 使えます。
IMAPサーバーは、より良く実装されている傾向があります。

`poplib'  モジュールでは、ひとつのクラスが提供されています。

`POP3(host[, port])'
     このクラスが、実際にPOP3プロトコルを実装します。インスタンスが初期化
     されるときに、コネクションが作成されます。 PORT
     が省略されると、POP3標準のポート(110)が使われます。

`POP3_SSL(host[, port[, keyfile[, certfile]]])'
     `POP3' クラスのサブクラスで、SSLでカプセル化されたソケットによる
     POPサーバへの接続を提供します。 PORT が指定されていない場合、
     POP3-over-SSL標準の995番ポートが使われます。 KEYFILE と CERTFILE
     もオプションで - SSL接続に使われる
     PEMフォーマットの秘密鍵と信頼された＃＃を含みます。

     _Added in Python version 2.4_

1つの例外が、 `poplib'
モジュールのアトリビュートとして定義されています。

`error_proto'
     例外は、すべてのエラーで発生します。例外の理由は文字列としてコンストラクタに
     渡されます。

See also:
     *Note imaplib:: The standard Python IMAP module.  `Frequently
     Asked Questions About Fetchmail' {POP/IMAPクライアント `fetchmail'
     のFAQ。POPプロトコルを
     ベースにしたアプリケーションを書くときに有用な、POP3サーバの種類や
     RFCへの適合度といった情報を収集しています。}

* Menu:

* POP3 オブジェクト::
* POP3 の例::


File: python-lib-jp.info,  Node: POP3 オブジェクト,  Next: POP3 の例,  Prev: poplib,  Up: poplib

18.10.1 POP3 オブジェクト
-------------------------

POP3コマンドはすべて、それと同じ名前のメソッドとしてlower-caseで
表現されます。そしてそのほとんどは、サーバからのレスポンスとなる
テキストを返します。

`POP3' クラスのインスタンスは以下のメソッドを持ちます。

`set_debuglevel(level)'
     インスタンスのデバッグレベルを指定します。これはデバッギングアウトプット
     の表示量をコントロールします。デフォルト値の `0' は、デバッギング
     アウトプットを表示しません。値を `1' とすると、デバッギングアウト
     プットの表示量を適当な量にします。これは大体、リクエストごと1行になります。
     値を `2'
     以上にすると、デバッギングアウトプットの表示量を最大にします。
     コントロール中の接続で送受信される各行をログに出力します。

`getwelcome()'
     POP3サーバーから送られるグリーティングメッセージを返します。

`user(username)'
     userコマンドを送出します。応答はパスワード要求を表示します。

`pass_(password)'
     パスワードを送出します。応答は、メッセージ数とメールボックスのサイズを
     含みます。 注：サーバー上のメールボックスは `quit()'
     が呼ばれるまでロックされます。

`apop(user, secret)'
     POP3サーバーにログオンするのに、よりセキュアなAPOP認証を使用します。

`rpop(user)'
     POP3サーバーにログオンするのに、（UNIXのr-コマンドと同様の）RPOP認証を使用します。

`stat()'
     メールボックスの状態を得ます。結果は2つのintegerからなるタプルとなります。
     `(MESSAGE COUNT, MAILBOX SIZE)'.

`list([which])'
     メッセージのリストを要求します。結果は以下のような形式で表されます。
     `(RESPONSE, ['mesg_num octets', ...], OCTETS)' WHICH
     が与えられると、それによりメッセージを指定します。

`retr(which)'
     WHICH 番のメッセージ全体を取り出し、そのメッセージに既読フラグを
     立てます。結果は `(RESPONSE, ['line', ...], OCTETS)'
     という形式で表されます。

`dele(which)'
     WHICH 番のメッセージに削除のためのフラグを立てます。ほとんどの
     サーバで、QUITコマンドが実行されるまでは実際の削除は行われません
     （もっとも良く知られた例外は Eudora
     QPOPで、その配送メカニズムはRFCに
     違反しており、どんな切断状況でも削除操作を未解決にしています）。

`rset()'
     メールボックスの削除マークすべてを取り消します。

`noop()'
     何もしません。接続保持のために使われます。

`quit()'
     Signoff:  commit changes, unlock mailbox, drop connection.
     サインオフ：変更をコミットし、メールボックスをアンロックして、接続を破棄します。

`top(which, howmuch)'
     メッセージヘッダと HOWMUCH で指定した行数のメッセージを、
     WHICHで指定したメッセージ分取り出します。結果は以下のような
     形式となります。 `(RESPONSE, ['line', ...], OCTETS)'.

     このメソッドはPOP3のTOPコマンドを利用し、RETRコマンドのように、メッセージに
     既読フラグをセットしません。残念ながら、TOPコマンドはRFCでは貧弱な仕様しか
     定義されておらず、しばしばノーブランドのサーバーでは（その仕様が）守られて
     いません。このメソッドを信用してしまう前に、実際に使用するPOPサーバーで
     テストをしてください。

`uidl([which])'
     （ユニークIDによる）メッセージダイジェストのリストを返します。
     WHICH が設定されている場合、結果はユニークIDを含みます。それは
     `'RESPONSE MESGNUM UID'という形式のメッセージ、 または`(RESPONSE,
     ['mesgnum uid', ...],OCTETS)'という 形式のリストとなります。

`POP3_SSL' クラスのインスタンスは追加のメソッドを持ちません。
このサブクラスのインターフェイスは親クラスと同じです。


File: python-lib-jp.info,  Node: POP3 の例,  Prev: POP3 オブジェクト,  Up: poplib

18.10.2 POP3 の例
-----------------

これは（エラーチェックもない）最も小さなサンプルで、メールボックスを
開いて、すべてのメッセージを取り出し、プリントします。

     import getpass, poplib

     M = poplib.POP3('localhost')
     M.user(getpass.getuser())
     M.pass_(getpass.getpass())
     numMessages = len(M.list()[1])
     for i in range(numMessages):
         for j in M.retr(i+1)[1]:
             print j

モジュールの末尾に、より広い範囲の使用例となるtestセクションがあります。


File: python-lib-jp.info,  Node: imaplib,  Next: nntplib,  Prev: poplib,  Up: インターネットプロトコルとその支援

18.11 IMAP4 プロトコルクライアント
==================================

IMAP4 protocol client (requires sockets).

このモジュールでは三つのクラス、`IMAP4', `IMAP4_SSL' と `IMAP4_stream'
を定義します。これらのクラスは IMAP4 サーバへの接続をカプセル化し、 RFC
2060 に定義されている IMAP4rev1 クライアントプロトコルの大規模な
サブセットを実装しています。このクラスは IMAP4 (RFC 1730 ) 準拠の
サーバと後方互換性がありますが、`STATUS' コマンドは IMAP4 では
サポートされていないので注意してください。

`imaplib' モジュール内では三つのクラスを提供しており、 `IMAP4'
は基底クラスとなります:

`IMAP4([host[, port]])'
     このクラスは実際の IMAP4 プロトコルを実装しています。
     インスタンスが初期化された際に接続が生成され、プロトコルバージョン
     (IMAP4 または IMAP4rev1) が決定されます。HOST が指定されて
     いない場合、 `''' (ローカルホスト) が用いられます。 PORT
     が省略された場合、標準の IMAP4 ポート番号 (143) が用いられます。

例外は `IMAP4' クラスの属性として定義されています:

`IMAP4.error'
     何らかのエラー発生の際に送出される例外です。例外の理由は
     文字列としてコンストラクタに渡されます。

`IMAP4.abort'
     IMAP4 サーバのエラーが生じると、この例外が送出されます。
     この例外は `IMAP4.error' のサブクラスです。
     通常、インスタンスを閉じ、新たなインスタンスを再び生成することで、
     この例外から復旧できます。

`IMAP4.readonly'
     この例外は書き込み可能なメイルボックスの状態がサーバによって変更された
     際に送出されます。 この例外は `IMAP4.error' のサブクラスです。
     他の何らかのクライアントが現在書き込み権限を獲得しており、
     メイルボックスを開きなおして書き込み権限を再獲得する必要があります。

このモジュールではもう一つ、安全 (secure) な接続を使ったサブクラスが
あります:

`IMAP4_SSL([host[, port[, keyfile[, certfile]]]])'
     `IMAP4' から導出されたサブクラスで、SSL 暗号化ソケットを
     介して接続を行います (このクラスを利用するためには SSL
     サポート付きで コンパイルされた socket モジュールが必要です) 。
     HOST が指定されて いない場合、 `''' (ローカルホスト)
     が用いられます。 PORT が省略された場合、標準の IMAP4-over-SSL
     ポート番号 (993) が用いられます。 KEYFILE および CERTFILE
     もオプションです - これらは SSL 接続のための PEM 形式の秘密鍵
     (private key) と認証チェイン (certificate chain) ファイルです。

さらにもう一つのサブクラスは、子プロセスで確立した接続を使用する
場合に使用します。

`IMAP4_stream(command)'
     `IMAP4' から導出されたサブクラスで、COMMANDを
     `os.popen2()'に渡して作成される `stdin/stdout'
     ディスクリプタと接続します。 _Added in Python version 2.3_

以下のユーティリティ関数が定義されています:

`Internaldate2tuple(datestr)'
     IMAP4 INTERNALDATE 文字列を標準世界時 (Coordinated Universal Time)
     に変換します。`time' モジュール形式のタプルを返します。

`Int2AP(num)'
     整数を [`A' .. `P'] からなる文字集合を用いて表現した
     文字列に変換します。

`ParseFlags(flagstr)'
     IMAP4 `FLAGS' 応答を個々のフラグからなるタプルに変換します。

`Time2Internaldate(date_time)'
     `time' モジュールタプルを IMAP4 `INTERNALDATE'
     表現形式に変換します。文字列形式: `"DD-Mmm-YYYY HH:MM:SS +HHMM"'
     (二重引用符含む) を返します。

IMAP4 メッセージ番号は、メイルボックスに対する変更が行われた
後には変化します; 特に、 `EXPUNGE' 命令はメッセージの削除を
行いますが、残ったメッセージには再度番号を振りなおします。従って、
メッセージ番号ではなく、 UID 命令を使い、その UID を利用するよう
強く勧めます。

モジュールの末尾に、より拡張的な使用例が収められたテストセクションが
あります。

See also:
     プロトコルに関する記述、およびプロトコルを実装したサーバの
     ソースとバイナリは、全て ワシントン大学の _IMAP Information
     Center_ (`http://www.cac.washington.edu/imap/') にあります。

* Menu:

* IMAP4 オブジェクト::
* IMAP4 の使用例::


File: python-lib-jp.info,  Node: IMAP4 オブジェクト,  Next: IMAP4 の使用例,  Prev: imaplib,  Up: imaplib

18.11.1 IMAP4 オブジェクト
--------------------------

全ての IMAP4rev1 命令は、同じ名前のメソッドで表されており、大文字の
ものも小文字のものもあります。

命令に対する引数は全て文字列に変換されます。例外は `AUTHENTICATE'
の引数と `APPEND' の最後の引数で、これは IMAP4 リテラルとして
渡されます。必要に応じて (IMAP4 プロトコルが感知対象としている
文字が文字列に入っており、かつ丸括弧か二重引用符で囲われていなかった
場合) 文字列はクオートされます。しかし、`LOGIN' 命令の PASSWORD
引数は常にクオートされます。文字列がクオートされない ようにしたい
(例えば `STORE' 命令の FLAGS 引数) 場合、
文字列を丸括弧で囲んでください (例: `r'(\Deleted)'')。

各命令はタプル: `(TYPE, [DATA, ...])' を返し、 TYPE は通常 `'OK''
または `'NO'' です。 DATA
は命令に対する応答をテキストにしたものか、命令に対する 実行結果です。各
DATA は文字列かタプルとなります。タプルの場合、
最初の要素はレスポンスのヘッダで、次の要素にはデータが格納されます。
(ie: 'literal' value)

以下のコマンドにおける MESSAGE_SET オプションは、操作の対象とな
るひとつあるいは複数のメッセージを指す文字列です。単一のメッセージ番号
(`'1'') かメッセージ番号の範囲 (`'2:4'')、あるいは連続してい
ないメッセージをカンマでつなげたもの (`'1:3,6:9'') となります。範
囲指定でアスタリスクを使用すると、上限を無限とすることができます
(`'3:*'')。

`IMAP4' のインスタンスは以下のメソッドを持っています:

`append(mailbox, flags, date_time, message)'
     指定された名前のメイルボックスに MESSAGE を追加します。

`authenticate(mechanism, authobject)'
     認証命令です -- 応答の処理が必要です。

     MECHANISMは利用する認証メカニズムを与えます。
     認証メカニズムはインスタンス変数`capabilities' の中に
     `AUTH=mechanism'という形式で現れる必要があります。

     AUTHOBJECTは呼び出し可能なオブジェクトである必要があります。

          data = authobject(response)

     これはサーバで継続応答を処理するためによばれます。
     これは(おそらく)暗号化されて、サーバへ送られた `data' を返します。
     もしクライアントが中断応答 `*' を送信した場合にはこれは `None'
     を返します。

`check()'
     サーバ上のメイルボックスにチェックポイントを設定します。
     Checkpoint mailbox on server.

`close()'
     現在選択されているメイルボックスを閉じます。削除されたメッセージは
     書き込み可能メイルボックスから除去されます。`LOGOUT' 前に
     実行することを勧めます。

`copy(message_set, new_mailbox)'
     MESSAGE_SET で指定したメッセージ群を NEW_MAILBOX の
     末尾にコピーします。

`create(mailbox)'
     MAILBOX と名づけられた新たなメイルボックスを生成します。

`delete(mailbox)'
     MAILBOX と名づけられた古いメイルボックスを削除します。

`deleteacl(mailbox, who)'
     mailbox における who についてのACLを削除(権限を削除)します。
     _Added in Python version 2.4_

`expunge()'
     選択されたメイルボックスから削除された要素を永久に除去します。
     各々の削除されたメッセージに対して、`EXPUNGE' 応答を
     生成します。返されるデータには `EXPUNGE' メッセージ番号を
     受信した順番に並べたリストが入っています。

`fetch(message_set, message_parts)'
     メッセージ (の一部) を取りよせます。MESSAGE_PARTS
     はメッセージパートの名前を表す文字列を丸括弧で囲ったもので、
     例えば: `"(UID BODY[TEXT])"' のようになります。
     返されるデータはメッセージパートのエンベロープ情報とデータ
     からなるタプルです。

`getacl(mailbox)'
     MAILBOX に対する `ACL' を取得します。 このメソッドは非標準ですが、
     `Cyrus' サーバでサポートされています。

`getannotation(mailbox, entry, attribute)'
     MAILBOX に対する `ANNOTATION' を取得します。
     このメソッドは非標準ですが、 `Cyrus' サーバでサポートされています。
     _Added in Python version 2.5_

`getquota(root)'
     `quota' ROOT により、リソース使用状況と制限値を取得します。
     このメソッドは RFC 2087 で定義されている IMAP4 QUOTA
     拡張の一部です。 _Added in Python version 2.3_

`getquotaroot(mailbox)'
     MAILBOX に対して `quota' ROOT を実行した結果のリストを 取得します。
     このメソッドは RFC 2087 で定義されている IMAP4 QUOTA
     拡張の一部です。 _Added in Python version 2.3_

`list([directory[, pattern]])'
     PATTERN にマッチする DIRECTORYメイルボックス名を列挙します。
     DIRECTORY の標準の設定値は最上レベルのメイルフォルダで、 PATTERN
     は標準の設定では全てにマッチします。返されるデータには `LIST'
     応答のリストが入っています。

`login(user, password)'
     平文パスワードを使ってクライアントを照合します。 PASSWORD
     はクオートされます。

`login_cram_md5(user, password)'
     パスワードの保護のため、クライアント認証時に`CRAM-MD5'だけを使用します。
     これは、`CAPABILITY'レスポンスに `AUTH=CRAM-MD5' が含まれる場合のみ
     有効です。 _Added in Python version 2.3_

`logout()'
     サーバへの接続を遮断します。サーバからの `BYE' 応答を返します。

`lsub([directory[, pattern]])'
     購読しているメイルボックス名のうち、ディレクトリ内でパターンにマッチ
     するものを列挙します。 DIRECTORY
     の標準の設定値は最上レベルのメイルフォルダで、 PATTERN
     は標準の設定では全てにマッチします。返されるデータには
     返されるデータはメッセージパートエンベロープ情報とデータからなるタプルです。

`myrights(mailbox)'
     mailboxにおける自分のACLを返します。(すなわち自分がmailboxで持って
     いる権限を返します。) _Added in Python version 2.4_

`namespace()'
     RFC2342で定義されるIMAP名前空間を返します。 _Added in Python
     version 2.3_

`noop()'
     サーバに `NOOP' を送信します。

`open(host, port)'
     HOST 上の PORT に対するソケットを開きます。
     このメソッドで確立された接続オブジェクトは `read'、
     `readline'、`send'、および`shutdown' メソッドで
     使われます。このメソッドはオーバライドすることができます。

`partial(message_num, message_part, start, length)'
     メッセージの後略された部分を取り寄せます。
     返されるデータはメッセージパートエンベロープ情報とデータからなるタプルです。

`proxyauth(user)'
     USERとして認証されたものとします。
     認証された管理者がユーザの代理としてメイルボックスにアクセス
     する際に使用します。 _Added in Python version 2.3_

`read(size)'
     遠隔のサーバから SIZE バイト読み出します。
     このメソッドはオーバライドすることができます。

`readline()'
     遠隔のサーバから一行読み出します。
     このメソッドはオーバライドすることができます。

`recent()'
     サーバに更新を促します。新たなメッセージがない場合応答は `None'
     になり、そうでない場合 `RECENT' 応答の値になります。

`rename(oldmailbox, newmailbox)'
     OLDMAILBOX という名前のメイルボックスを NEWMAILBOX
     に名称変更します。

`response(code)'
     応答 CODE を受信していれば、そのデータを返し、そうでなければ
     `None' を返します。通常の形式 (usual type) ではなく指定したコード
     を返します。

`search(charset, criterion[, ...])'
     条件に合致するメッセージをメイルボックスから検索します。 CHARSET
     は `None' でもよく、この場合にはサーバ への要求内に `CHARSET'
     は指定されません。IMAP プロトコルは 少なくとも一つの条件
     (criterion) が指定されるよう要求しています;
     サーバがエラーを返した場合、例外が送出されます。

     例:

          # M is a connected IMAP4 instance...
          typ, msgnums = M.search(None, 'FROM', '"LDJ"')

          # or:
          typ, msgnums = M.search(None, '(FROM "LDJ")')


`select([mailbox[, readonly]])'
     メイルボックスを選択します。返されるデータは MAILBOX 内の
     メッセージ数 (`EXISTS' 応答) です。標準の設定では MAILBOX は
     `'INBOX'' です。READONLY が設定された
     場合、メイルボックスに対する変更はできません。

`send(data)'
     遠隔のサーバに `data' を送信します。
     このメソッドはオーバライドすることができます。

`setacl(mailbox, who, what)'
     `ACL' を MAILBOX に設定します。 このメソッドは非標準ですが、
     `Cyrus' サーバでサポートされています。

`setannotation(mailbox, entry, attribute[, ...])'
     `ANNOTATION' を MAILBOX に設定します。
     このメソッドは非標準ですが、 `Cyrus' サーバでサポートされています。
     _Added in Python version 2.5_

`setquota(root, limits)'
     `quota' ROOT のリソースを LIMITS に設定します。 このメソッドは RFC
     2087 で定義されている IMAP4 QUOTA 拡張の一部です。 _Added in
     Python version 2.3_

`shutdown()'
     `open' で確立された接続を閉じます。
     このメソッドはオーバライドすることができます。

`socket()'
     サーバへの接続に使われているソケットインスタンスを返します。

`sort(sort_criteria, charset, search_criterion[, ...])'
     `sort' 命令は `search' に結果の並べ替え (sort) 機能をつけた
     変種です。返されるデータには、条件に合致するメッセージ番号をスペースで
     分割したリストが入っています。 sort 命令は SEARCH_CRITERIUM
     の前に二つの引数を持ちます; SORT_CRITERIA
     のリストを丸括弧で囲ったものと、検索時の CHARSET です。 `search'
     と違って、検索時の CHARSET は必須です。 `uid sort'
     命令もあり、`search' に対する `uid search' と同じように `sort'
     命令に対応します。 `sort' 命令はまず、charset 引数の指定に従って
     searching criteria
     の文字列を解釈し、メイルボックスから与えられた検索条件に合致する
     メッセージを探します。次に、合致したメッセージの数を返します。

     `IMAP4rev1' 拡張命令です。

`status(mailbox, names)'
     MAILBOX の指定ステータス名の状態情報を要求します。

`store(message_set, command, flag_list)'
     メイルボックス内のメッセージ群のフラグ設定を変更します。 COMMAND
     は RFC 2060 のセクション 6.4.6 で指定されているもので、 "FLAGS",
     "+FLAGS", あるいは "-FLAGS" のいずれかとなります。オプション
     で末尾に ".SILENT" がつくこともあります。

     たとえば、すべてのメッセージに削除フラグを設定するには次のようにします。

          typ, data = M.search(None, 'ALL')
          for num in data[0].split():
             M.store(num, '+FLAGS', '\\Deleted')
          M.expunge()


`subscribe(mailbox)'
     新たなメイルボックスを購読 (subscribe) します。

`thread(threading_algorithm, charset, search_criterion[, ...])'
     `thread'コマンドは`search'にスレッドの概念を加えた変形版で
     ス。返されるデータは空白で区切られたスレッドメンバのリストを含んでい
     ます。

     各スレッドメンバは0以上のメッセージ番号からなり、空白で区切られ て
     おり、親子関係を示しています。

     `thread'コマンドはSEARCH_CRITERION引数の前に2つの引数を持っています。
     THREADING_ALGORITHMとCHARSETです。
     `search'コマンドとは違い、CHARSETは必須です。 `search'に対する
     `uid search'と同様に、 `thread'にも `uid thread'があります。

     `thread'コマンドはまずメールボックス中のメッセージを、charsetを
     用いた検索条件で検索します。その後マッチしたメッセージを指定された
     スレッドアルゴリズムでスレッド化して返します.

     これは `IMAP4rev1' の拡張コマンドです。 _Added in Python version
     2.4_

`uid(command, arg[, ...])'
     command args を、メッセージ番号ではなく UID
     で指定されたメッセージ群に
     対して実行します。命令内容に応じた応答を返します。少なくとも
     一つの引数を与えなくてはなりません; 何も与えない場合、サーバは
     エラーを返し、例外が送出されます。

`unsubscribe(mailbox)'
     古いメイルボックスの購読を解除 (unsubscribe) します。

`xatom(name[, arg[, ...]])'
     サーバから `CAPABILITY' 応答で通知された単純な拡張命令を 許容
     (allow) します。

`IMAP4_SSL' のインスタンスは追加のメソッドを一つだけ持ちます:

`ssl()'
     サーバへの安全な接続に使われる SSLObject インスタンスを返します。

以下の属性が `IMAP4' のインスタンス上で定義されています:

`PROTOCOL_VERSION'
     サーバから返された `CAPABILITY' 応答にある、サポートされている
     最新のプロトコルです。

`debug'
     デバッグ出力を制御するための整数値です。初期値はモジュール変数
     `Debug' から取られます。3 以上の値にすると各命令をトレースします。


File: python-lib-jp.info,  Node: IMAP4 の使用例,  Prev: IMAP4 オブジェクト,  Up: imaplib

18.11.2 IMAP4 の使用例
----------------------

以下にメイルボックスを開き、全てのメッセージを取得して印刷する 最小の
(エラーチェックをしない) 使用例を示します:

     import getpass, imaplib

     M = imaplib.IMAP4()
     M.login(getpass.getuser(), getpass.getpass())
     M.select()
     typ, data = M.search(None, 'ALL')
     for num in data[0].split():
         typ, data = M.fetch(num, '(RFC822)')
         print 'Message %s\n%s\n' % (num, data[0][1])
     M.close()
     M.logout()


File: python-lib-jp.info,  Node: nntplib,  Next: smtplib,  Prev: imaplib,  Up: インターネットプロトコルとその支援

18.12 NNTP プロトコルクライアント
=================================

NNTP プロトコルクライアント (ソケットを必要とします)。

このモジュールでは、 クラス `NNTP' を定義しています。このクラス は NNTP
プロトコルのクライアント側を実装しています。このモジュールを
使えば、ニュースリーダや記事投稿プログラム、または自動的にニュース記事を
処理するプログラムを実装することができます。NNTP (Network News Transfer
Protocol、ネットニュース転送プロトコル) の詳細については、
インターネット RFC 977 を参照してください。

以下にこのモジュールの使い方の小さな例を二つ示します。
ニュースグループに関する統計情報を列挙し、最新 10 件の記事を出力
するには以下のようにします:

     >>> s = NNTP('news.cwi.nl')
     >>> resp, count, first, last, name = s.group('comp.lang.python')
     >>> print 'Group', name, 'has', count, 'articles, range', first, 'to', last
     Group comp.lang.python has 59 articles, range 3742 to 3803
     >>> resp, subs = s.xhdr('subject', first + '-' + last)
     >>> for id, sub in subs[-10:]: print id, sub
     ...
     3792 Re: Removing elements from a list while iterating...
     3793 Re: Who likes Info files?
     3794 Emacs and doc strings
     3795 a few questions about the Mac implementation
     3796 Re: executable python scripts
     3797 Re: executable python scripts
     3798 Re: a few questions about the Mac implementation
     3799 Re: PROPOSAL: A Generic Python Object Interface for Python C Modules
     3802 Re: executable python scripts
     3803 Re: \POSIX{} wait and SIGCHLD
     >>> s.quit()
     '205 news.cwi.nl closing connection.  Goodbye.'

ファイルから記事を投稿するには、以下のようにします
(この例では記事番号は有効な番号を指定していると仮定しています):

     >>> s = NNTP('news.cwi.nl')
     >>> f = open('/tmp/article')
     >>> s.post(f)
     '240 Article posted successfully.'
     >>> s.quit()
     '205 news.cwi.nl closing connection.  Goodbye.'

このモジュール自体では以下の内容を定義しています:

`NNTP(host[, port [, user[, password [, readermode] [, usenetrc]]]])'
     ホスト HOST 上で動作し、ポート番号 PORT で要求待ちを している NNTP
     サーバとの接続を表現する新たな `NNTP' クラスの
     インスタンスを返します。標準のPORT は 119 です。オプションの USER
     および PASSWORD が与えられているか、
     または`~/.netrc'に適切な認証情報が指定されていてUSENETRC が真
     (デフォルト) の場合、 `AUTHINFO USER' および `AUTHINFO PASS'
     命令を使って
     サーバに対して身元証明および認証を行います。オプションのフラグ
     READERMODE が真の場合、認証の実行に先立って `mode reader'
     命令が送信されます。reader モードは、ローカルマシン上の NNTP サーバ
     に接続していて、`group' のような reader 特有の命令を呼び出し
     たい場合に便利なことがあります。予期せず `NNTPPermanentError'
     に遭遇したなら、READERMODE を設定する必要があるかもしれません。
     READERMODE のデフォルト値は `None' です。 USENETRC
     のデフォルト値は `True' です。

     _Changed in Python version 2.4_

`NNTPError'
     {} 標準の例外 `Exception' から導出されており、`nntplib'
     モジュールが送出する全ての例外の基底クラスです。

`NNTPReplyError'
     {} 期待はずれの応答がサーバから返された場合に送出される例外です。
     以前のバージョンとの互換性のために、`error_reply'
     はこのクラスと等価になっています。

`NNTPTemporaryError'
     {} エラーコードの範囲が 400-499
     のエラーを受信した場合に送出される例外です。
     以前のバージョンとの互換性のために、`error_temp'
     はこのクラスと等価になっています。

`NNTPPermanentError'
     {} エラーコードの範囲が 500-599
     のエラーを受信した場合に送出される例外です。
     以前のバージョンとの互換性のために、`error_perm'
     はこのクラスと等価になっています。

`NNTPProtocolError'
     {} サーバから返される応答が 1-5 の範囲の数字で始まっていない場合に
     送出される例外です。
     以前のバージョンとの互換性のために、`error_proto'
     はこのクラスと等価になっています。

`NNTPDataError'
     {} 応答データ中に何らかのエラーが存在する場合に送出される例外です。
     以前のバージョンとの互換性のために、`error_data'
     はこのクラスと等価になっています。

* Menu:

* NNTP オブジェクト::


File: python-lib-jp.info,  Node: NNTP オブジェクト,  Prev: nntplib,  Up: nntplib

18.12.1 NNTP オブジェクト
-------------------------

NNTP インスタンスは以下のメソッドを持っています。全てのメソッドにおける
戻り値のタプルで最初の要素となる RESPONSE は、サーバの応答 です:
この文字列は 3 桁の数字からなるコードで始まります。
サーバの応答がエラーを示す場合、上記のいずれかの例外が送出されます。

`getwelcome()'
     サーバに最初に接続した際に送信される応答中のウェルカムメッセージを
     返します。(このメッセージには時に、ユーザにとって重要な免責事項や
     ヘルプ情報が入っています。)

`set_debuglevel(level)'
     インスタンスのデバッグレベルを設定します。このメソッドは印字される
     デバッグ出力の量を制御します。標準では `0' に設定されていて、
     これはデバッグ出力を全く印字しません。`1' はそこそこの量、 一般に
     NNTP 要求や応答あたり 1 行のデバッグ出力を生成します。 値が `2'
     やそれ以上の場合、(メッセージテキストを含めて) NNTP
     接続上で送受信された全ての内容を一行ごとにログ出力する、
     最大限のデバッグ出力を生成します。

`newgroups(date, time, [file])'
     `NEWSGROUPS' 命令を送信します。DATE 引数は `'YYMMDD''
     の形式を取り、日付を表します。 TIME 引数は `'HHMMSS''
     の形式をとり、
     時刻を表します。与えられた日付および時刻以後新たに出現した
     ニュースグループ名のリストを GROUPS として、 `(RESPONSE, GROUPS)'
     を返します。
     FILE引数が指定されている場合、`NEWGROUPS'コマンドの出力結果は
     ファイルに格納されます。FILEが文字列の場合、この文字列をファイル名
     としてファイルをオープンし、書き込み後にクローズします。FILEがファ
     イルオブジェクトの場合、オブジェクトの`write()'メソッドを呼び出し
     て出力結果を格納します。FILEが指定されている場合は戻り値として空の
     リストを返します。

`newnews(group, date, time, [file])'
     `NEWNEWS' 命令を送信します。ここで、GROUP はグループ名 または
     `'*'' で、 DATE および TIME は `newsgrups()'
     における引数と同じ意味を持ちます。 `(RESPONSE, ARTICLES)'
     からなるペアを返し、 ARTICLES はメッセージ ID のリストです。
     FILE引数が指定されている場合、`NEWNEWS'コマンドの出力結果は
     ファイルに格納されます。FILEが文字列の場合、この文字列をファイル名
     としてファイルをオープンし、書き込み後にクローズします。FILEがファ
     イルオブジェクトの場合、オブジェクトの`write()'メソッドを呼び出し
     て出力結果を格納します。FILEが指定されている場合は戻り値として空の
     リストを返します。

`list([file])'
     `LIST' 命令を送信します。`(RESPONSE, LIST)'
     からなるペアを返します。LIST はタプルからなるリストです。
     各タプルは `(GROUP, LAST, FIRST, FLAG)' の形式をとり、GROUP
     がグループ名、LAST および FIRST
     はそれぞれ最新および最初の記事の記事番号 (を表す文字列)、そして
     FLAG は投稿が可能な場合には `'y''、そうでない場合には
     `'n''、グループがモデレート (moderated) されている場合には `'m''
     となります。(順番に注意してください: LAST、 FIRST の順です。)
     FILE引数が指定されている場合、`LIST'コマンドの出力結果は
     ファイルに格納されます。FILEが文字列の場合、この文字列をファイル名
     としてファイルをオープンし、書き込み後にクローズします。FILEがファ
     イルオブジェクトの場合、オブジェクトの`write()'メソッドを呼び出し
     て出力結果を格納します。FILEが指定されている場合は戻り値として空の
     リストを返します。

`descriptions(grouppattern)'
     `LIST NEWSGROUPS' 命令を送信します。GROUPPATTERN は RFC2980
     の定義に従う wildmat 文字列です (実際には、 DOS や UNIX の
     シェルワイルドカード文字列と同じです)。 `(RESPONSE,LIST)'
     からなるペアを返し、LIST はタプル`(NAME, TITLE)' リストになります。
     _Added in Python version 2.4_

`description(group)'
     単一のグループGROUP から説明文字列を取り出します。 ('group'
     が実際には wildmat 文字列で) 複数のグループがマッチした場合、
     最初にマッチしたものを返します。何もマッチしなければ空文字列を返します。

     このメソッドはサーバからの応答コードを省略します。応答コードが
     必要なら、`descriptions()' を使ってください。

     _Added in Python version 2.4_

`group(name)'
     `GROUP' 命令を送信します。NAME はグループ名です。タプル
     `(RESPONSE, COUNT, FIRST, LAST, NAME)' を返します。COUNT
     はグループ中の記事数 (の推定値) で、 FIRST
     はグループ中の最初の記事番号、LAST はグループ中の
     最新の記事番号、NAME はグループ名です。記事番号は文字列で
     返されます。

`help([file])'
     `HELP' 命令を送信します。`(RESPONSE, LIST)'
     からなるペアを返します。LIST はヘルプ文字列からなるリストです。
     FILE引数が指定されている場合、`HELP'コマンドの出力結果は
     ファイルに格納されます。FILEが文字列の場合、この文字列をファイル名
     としてファイルをオープンし、書き込み後にクローズします。FILEがファ
     イルオブジェクトの場合、オブジェクトの`write()'メソッドを呼び出し
     て出力結果を格納します。FILEが指定されている場合は戻り値として空の
     リストを返します。

`stat(id)'
     `STAT' 命令を送信します。ID は (`<' と `>' に囲まれた形式の)
     メッセージ ID か、 (文字列の) 記事番号です。 三つ組み `(RESPONSE,
     NUMBER, ID)' を返します。 NUMBER は (文字列の) 記事番号で、ID は
     (`<' と `>' に囲まれた形式の) メッセージ ID です。

`next()'
     `NEXT' 命令を送信します。`stat()' のような応答を返します。

`last()'
     `LAST' 命令を送信します。`stat()' のような応答を返します。

`head(id)'
     `HEAD' 命令を送信します。ID は `stat()' における
     のと同じ意味を持ちます。 `(RESPONSE, NUMBER, ID, LIST)'
     からなるタプルを返します。最初の 3 要素は `stat()' と
     同じもので、LIST は記事のヘッダからなるリスト
     (まだ解析されておらず、末尾の改行が取り去られたヘッダ行のリスト)
     です。

`body(id,[file])'
     `BODY' 命令を送信します。ID は `stat()' における
     のと同じ意味を持ちます。FILE 引数が与えられている場合、 記事本体
     (body) はファイルに保存されます。FILE が文字列
     の場合、このメソッドはその名前を持つファイルオブジェクトを
     開き、記事を書き込んで閉じます。FILE がファイルオブジェクトの
     場合、`write()' を呼び出して記事本体を記録します。 `head()'
     のような戻り値を返します。FILE が与えられて いた場合、 返される
     LIST は空のリストになります。

`article(id)'
     `ARTICLE' 命令を送信します。ID は `stat()' における
     のと同じ意味を持ちます。`head()' のような戻り値を返します。

`slave()'
     `SLAVE' 命令を送信します。サーバの RESPONSE を返します。

`xhdr(header, string, [file])'
     `XHDR' 命令を送信します、この命令は RFC には定義されていませんが、
     一般に広まっている拡張です。HEADER 引数は、例えば `'subject''
     といったヘッダキーワードです。STRING 引数は `'FIRST-LAST''
     の形式でなければならず、ここで FIRST および LAST
     は検索の対象とする記事範囲の最初と最後の 記事番号です。`(RESPONSE,
     LIST)' のペアを返します。 LIST は `(ID, TEXT)'
     のペアからなるリストで、 ID が (文字列で表した) 記事番号、TEXT
     がその記事の ヘッダテキストです。
     FILE引数が指定されている場合、`XHDR'コマンドの出力結果は
     ファイルに格納されます。FILEが文字列の場合、この文字列をファイル名
     としてファイルをオープンし、書き込み後にクローズします。FILEがファ
     イルオブジェクトの場合、オブジェクトの`write()'メソッドを呼び出し
     て出力結果を格納します。FILEが指定されている場合は戻り値として空の
     リストを返します。

`post(file)'
     `POST' 命令を使って記事をポストします。FILE
     引数は開かれているファイルオブジェクトで、その内容は `readline()'
     メソッドを使って EOF まで読み出されます。
     内容は必要なヘッダを含め、正しい形式のニュース記事で
     なければなりません。`post()' メソッドは `.'
     で始まる行を自動的にエスケープします。

`ihave(id, file)'
     `IHAVE' 命令を送信します。 ID は (`<' と `>' に囲まれた)
     メッセージ ID です。 応答がエラーでない場合、FILE を `post()'
     と全く同じように 扱います。

`date()'
     タプル `(RESPONSE, DATE, TIME)' を返します。 このタプルには
     `newnews()' および `newgroups()' メソッド
     に合った形式の、現在の日付および時刻が入っています。
     これはオプションの NNTP
     拡張なので、全てのサーバでサポートされている とは限りません。

`xgtitle(name, [file])'
     `XGTITLE' 命令を処理し、`(RESPONSE, LIST)'
     からなるペアを返します。LIST は `(NAME, TITLE)'
     を含むタプルのリストです。
     FILE引数が指定されている場合、`XHDR'コマンドの出力結果は
     ファイルに格納されます。FILEが文字列の場合、この文字列をファイル名
     としてファイルをオープンし、書き込み後にクローズします。FILEがファ
     イルオブジェクトの場合、オブジェクトの`write()'メソッドを呼び出し
     て出力結果を格納します。FILEが指定されている場合は戻り値として空の
     リストを返します。 これはオプションの NNTP
     拡張なので、全てのサーバでサポートされている とは限りません。

     RFC2980 では、 "この拡張は撤廃すべきである" と主張しています。
     `descriptions()' または `description()' を使うように してください。

`xover(start, end, [file])'
     `(RESP, LIST)' からなるペアを返します。 LIST
     はタプルからなるリストで、各タプルは記事番号 START および END
     の間に区切られた記事です。各タプルは `(ARTICLE NUMBER, SUBJECT,
     POSTER, DATE, ID, REFERENCES, SIZE, LINES)' の形式をとります。
     FILE引数が指定されている場合、`XHDR'コマンドの出力結果は
     ファイルに格納されます。FILEが文字列の場合、この文字列をファイル名
     としてファイルをオープンし、書き込み後にクローズします。FILEがファ
     イルオブジェクトの場合、オブジェクトの`write()'メソッドを呼び出し
     て出力結果を格納します。FILEが指定されている場合は戻り値として空の
     リストを返します。 これはオプションの NNTP
     拡張なので、全てのサーバでサポートされている とは限りません。

`xpath(id)'
     `(RESP, PATH)' からなるペアを返します。 PATH は メッセージ ID が
     ID である記事のディレクトリパスです。 これはオプションの NNTP
     拡張なので、全てのサーバでサポートされている とは限りません。

`quit()'
     `QUIT' 命令を送信し、接続を閉じます。このメソッドを呼び出した
     後は、NTTP
     オブジェクトの他のいかなるメソッドも呼び出してはいけません。


File: python-lib-jp.info,  Node: smtplib,  Next: smtpd,  Prev: nntplib,  Up: インターネットプロトコルとその支援

18.13 SMTP プロトコル クライアント
==================================

SMTP プロトコル クライアント (ソケットが必要です)。

`smtplib'モジュールは、SMTPまたはESMTPのリスナーデーモンを備えた
任意のインターネット上のホストにメイルを送るために使用することができる
SMTPクライアント・セッション・オブジェクトを定義します。
SMTPおよびESMTPオペレーションの詳細は、 RFC 821 () や RFC 1869 

()を調べてください。

`SMTP([host[, port[, local_hostname]]])'
     `SMTP'インスタンスはSMTPコネクションをカプセル化し、
     SMTPとESMTPの命令をサポートをします。
     オプションであるhostとportを与えた場合は、
     SMTPクラスのインスタンスが作成されると同時に、
     `connect()'メソッドを呼び出し初期化されます。
     また、ホストから応答が無い場合は、`SMTPConnectError'が上げられます。

     普通に使う場合は、初期化と接続を行ってから、
     `sendmail()'と`quit()'メソッドを呼びます。
     使用例は先の方で記載しています。

このモジュールの例外には次のものがあります:

`SMTPException'
     このモジュールの例外クラスのベースクラスです。

`SMTPServerDisconnected'
     この例外はサーバが突然コネクションを切断するか、
     もしくは`SMTP'インスタンスを生成する前にコネクションを張ろうと
     した場合に上げられます。

`SMTPResponseException'
     SMTPのエラーコードを含んだ例外のクラスです。
     これらの例外はSMTPサーバがエラーコードを返すときに生成されます。
     エラーコードは`smtp_code'属性に格納されます。
     また、`smtp_error'属性にはエラーメッセージが格納されます。

`SMTPSenderRefused'
     送信者のアドレスが弾かれたときに上げられる例外です。
     全ての`SMTPResponseException'例外に、
     SMTPサーバが弾いた`sender'アドレスの文字列がセットされます。

`SMTPRecipientsRefused'
     全ての受取人アドレスが弾かれたときに上げられる例外です。
     各受取人のエラーは属性`recipients'によってアクセス可能で、
     `SMTP.sendmail()'が返す辞書と同じ並びの辞書になっています。

`SMTPDataError'
     SMTPサーバが、メッセージのデータを受け入れることを拒絶した時に
     上げられる例外です。

`SMTPConnectError'
     サーバへの接続時にエラーが 発生した時に上げられる例外です。

`SMTPHeloError'
     サーバーが`HELO'メッセージを弾いた時に上げられる例外です。

See also:
    *RFC821 Simple Mail Transfer Protocol*
          SMTP のプロトコル定義 です。このドキュメントでは SMTP
          のモデル、操作手順、プロトコルの
          詳細についてカバーしています。

    *RFC1869 SMTP Service Extensions*
          SMTP に対する ESMTP 拡張の定義です。このドキュメントでは、
          新たな命令による SMTP の拡張、サーバによって提供される命令を
          動的に発見する機能のサポート、およびいくつかの追加命令定義
          について記述しています。


* Menu:

* SMTP オブジェクト::
* SMTP 使用例::


File: python-lib-jp.info,  Node: SMTP オブジェクト,  Next: SMTP 使用例,  Prev: smtplib,  Up: smtplib

18.13.1 SMTP オブジェクト
-------------------------

`SMTP'クラスインスタンスは次のメソッドを提供します:

`set_debuglevel(level)'
     コネクション間でやりとりされるメッセージ出力のレベルをセットします。
     メッセージの冗長さはLEVELに応じて決まります。

`connect([host[, port]])'
     ホスト名とポート番号をもとに接続します。デフォルトはlocalhostの
     標準的なSMTPポート(25番)に接続します。
     もしホスト名の末尾がコロン(`:')で、後に番号がついている場合は、
     「ホスト名:ポート番号」として扱われます。
     このメソッドはコンストラクタにホスト名及びポート番号が指定されている場合、
     自動的に呼び出されます。

`docmd(cmd, [, argstring])'
     サーバへコマンドCMDを送信します。
     オプション引数ARGSTRINGはスペース文字でコマンドに連結します。
     戻り値は、整数値のレスポンスコードと、サーバからの応答の値をタプルで返します。
     (サーバからの応答が数行に渡る場合でも一つの大きな文字列で返します。)

     通常、この命令を明示的に使う必要はありませんが、
     自分で拡張するする時に使用するときに役立つかもしれません。

     応答待ちのときに、サーバへのコネクションが失われると、
     `SMTPServerDisconnected'が上がります。

`helo([hostname])'
     SMTPサーバに`HELO'コマンドで身元を示します。
     デフォルトではhostname引数はローカルホストを指します。

     通常は`sendmail()'が呼びだすため、
     これを明示的に呼び出す必要はありません。

`ehlo([hostname])'
     `EHLO'を利用し、ESMTPサーバに身元を明かします。
     デフォルトではhostname引数はローカルホストを指します。

     また、ESMTPオプションのために応答を調べたものは、
     `has_extn()'に備えて保存されます。

     `has_extn()'をメールを送信する前に使わない限り、
     明示的にこのメソッドを呼び出す必要があるべきではなく、
     `sendmail()'が必要とした場合に呼ばれます。、

`has_extn(name)'
     NAMEが拡張SMTPサービスセットに含まれている場合には`True'を返し、
     そうでなければ`False'を返します。大小文字は区別されません。

`verify(address)'
     `VRFY'を利用してSMTPサーバにアドレスの妥当性をチェックします。
     妥当である場合はコード250と完全なRFC 822 アドレス(人名)のタプルを返します。
     それ以外の場合は、400以上のエラーコードとエラー文字列を返します。

     _Note:_ ほとんどのサイトはスパマーの裏をかくためにSMTPの`VRFY'は
     使用不可になっています。

`login(user, password)'
     認証が必要なSMTPサーバにログインします。
     認証に使用する引数はユーザ名とパスワードです。
     まだセッションが無い場合は、`EHLO'または`HELO'コマンドで
     セッションを作ります。ESMTPの場合は`EHLO'が先に試されます。
     認証が成功した場合は通常このメソッドは戻りますが、
     例外が起こった場合は以下の例外が上がります:

    ``SMTPHeloError''
          サーバが`HELO'に返答できなかった。

    ``SMTPAuthenticationError''
          サーバがユーザ名/パスワードでの認証に失敗した。

    ``SMTPError''
          どんな認証方法も見付からなかった。


`starttls([keyfile[, certfile]])'
     TLS(Transport Layer Security)モードでSMTPコネクションを出し、
     全てのSMTPコマンドは暗号化されます。
     これは`ehlo()'をもう一度呼びだすときにするべきです。

     KEYFILEとCERTFILEが提供された場合に、
     `socket'モジュールの`ssl()'関数が通るようになります。

`sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options])'
     メールを送信します。必要な引数はRFC 822 のfromアドレス文字列、 RFC
     822 のtoアドレス文字列またはアドレス文字列のリスト、
     メッセージ文字列です。 送信側は`MAIL
     FROM'コマンドで使用されるMAIL_OPTIONSの
     ESMTPオプション(`8bitmime'のような)のリストを得るかもしれません。

     全ての`RCPT'コマンドで使われるべきESMTPオプション
     (例えば`DSN'コマンド)は、RCPT_OPTIONSを通して
     利用することができます。(もし送信先別にESMTPオプションを使う必要があれば、
     メッセージを送るために`mail'、`rcpt'、`data'
     といった下位レベルのメソッドを使う必要があります。)

     _Note:_ 配送エージェントはFROM_ADDR、TO_ADDRS引数を使い、
     メッセージのエンベロープを構成します。
     `SMTP'はメッセージヘッダを修正しません。

     まだセッションが無い場合は、`EHLO'または`HELO'コマンドで
     セッションを作ります。ESMTPの場合は`EHLO'が先に試されます。
     また、サーバがESMTP対応ならば、メッセージサイズとそれぞれ指定された
     オプションも渡します。(featureオプションがあればサーバの広告をセットします)
     `EHLO'が失敗した場合は、ESMTPオプションの無い`HELO'が試されます。

     このメソッドはメールが受け入れられたときは普通に戻りますが、
     そうでない場合は例外を投げます。このメソッドが例外を投げられなければ、
     誰かが送信したメールを得るべきです。また、例外を投げれなかった場合は、
     拒絶された受取人ごとへの1つのエントリーと共に、辞書を返します。
     各エントリーは、サーバーによって送られたSMTPエラーコードおよび
     エラーメッセージのタプルを含んでいます。

     このメソッドは次の例外を上げることがあります:

    ``SMTPRecipientsRefused''
          全ての受信を拒否され、誰にもメールが届けられませんでした。
          例外オブジェクトの`recipients'属性は、
          受信拒否についての情報の入った辞書オブジェクトです。
          (辞書は少なくとも一つは受信されたときに似ています)。

    ``SMTPHeloError''
          サーバが`HELP'に返答しませんでした。

    ``SMTPSenderRefused''
          サーバがFROM_ADDRを弾きました。

    ``SMTPDataError''
          サーバが予期しないエラーコードを返しました。(受信拒否以外)

     また、この他の注意として、例外が上がった後も
     コネクションは開いたままになっています。


`quit()'
     SMTPセッションを終了し、コネクションを閉じます。

下位レベルのメソッドは標準SMTP/ESMTPコマンド`HELP'、 `RSET'、
`NOOP'、`MAIL'、`RCPT'、`DATA'に対応しています。
通常これらは直接呼ぶ必要はなく、また、ドキュメントもありません。
詳細はモジュールのコードを調べてください。


File: python-lib-jp.info,  Node: SMTP 使用例,  Prev: SMTP オブジェクト,  Up: smtplib

18.13.2 SMTP 使用例
-------------------

次の例は最低限必要なメールアドレス(`To' と `From')を含んだ
メッセージを送信するものです。この例ではRFC 822 ヘッダの加工もしていません。
メッセージに含まれるヘッダは、メッセージに含まれる必要があり、
特に、明確な'To'、と'From'アドレスはメッセージヘッダに
含まれている必要があります。

     import smtplib
     import string

     def prompt(prompt):
         return raw_input(prompt).strip()

     fromaddr = prompt("From: ")
     toaddrs  = prompt("To: ").split()
     print "Enter message, end with ^D (Unix) or ^Z (Windows):"

     # Add the From: and To: headers at the start!
     msg = ("From: %s\r\nTo: %s\r\n\r\n"
            % (fromaddr, ", ".join(toaddrs, ", ")))
     while 1:
         try:
             line = raw_input()
         except EOFError:
             break
         if not line:
             break
         msg = msg + line

     print "Message length is " + repr(len(msg))

     server = smtplib.SMTP('localhost')
     server.set_debuglevel(1)
     server.sendmail(fromaddr, toaddrs, msg)
     server.quit()


File: python-lib-jp.info,  Node: smtpd,  Next: telnetlib,  Prev: smtplib,  Up: インターネットプロトコルとその支援

18.14 SMTP サーバ
=================

柔軟性のある SMTP サーバの実装

このモジュールでは、 SMTP サーバを実装するためのクラスをいくつか提供
しています。一つは何も行わない、オーバライドできる汎用のサーバで、
その他の二つでは特定のメール送信ストラテジを提供しています。

* Menu:

* SMTPServer オブジェクト::
* DebuggingServer オブジェクト::
* PureProxy オブジェクト::
* MailmanProxy Objects::


File: python-lib-jp.info,  Node: SMTPServer オブジェクト,  Next: DebuggingServer オブジェクト,  Prev: smtpd,  Up: smtpd

18.14.1 SMTPServer オブジェクト
-------------------------------

`SMTPServer(localaddr, remoteaddr)'
     新たな`SMTPServer' オブジェクトを作成します。このオブジェクトは
     ローカルのアドレスLOCALADDR に関連づけ (bind) されます。
     オブジェクトは REMOTEADDR を上流の SMTP リレー先にします。
     このクラスは`asyncore.dispatcher'
     を継承しており、インスタンス化時に 自身を `asyncore'
     のイベントループに登録します。

`process_message(peer, mailfrom, rcpttos, data)'
     このクラスでは`NotImplementedError'例外を送出します。
     受信したメッセージを使って何か意味のある処理をしたい場合にはこのメソッドを
     オーバライドしてください。 コンストラクタのREMOTEADDR
     に渡した値は`_remoteaddr' 属性で 参照できます。PEER
     はリモートホストのアドレスで、MAILFROM
     はメッセージエンベロープの発信元 (envelope originator) 、RCPTTOS
     はメッセージエンベロープの受信対象、そして DATA は電子メールの内容
     が入った(RFC 2822 形式の)文字列です。


File: python-lib-jp.info,  Node: DebuggingServer オブジェクト,  Next: PureProxy オブジェクト,  Prev: SMTPServer オブジェクト,  Up: smtpd

18.14.2 DebuggingServer オブジェクト
------------------------------------

`DebuggingServer(localaddr, remoteaddr)'
     新たなデバッグ用サーバを生成します。引数は`SMTPServer' と
     同じです。メッセージが届いても無視し、標準出力に出力します。


File: python-lib-jp.info,  Node: PureProxy オブジェクト,  Next: MailmanProxy Objects,  Prev: DebuggingServer オブジェクト,  Up: smtpd

18.14.3 PureProxy オブジェクト
------------------------------

`PureProxy(localaddr, remoteaddr)'
     新たな単純プロキシ (pure proxy)
     サーバを生成します。引数は`SMTPServer'
     と同じです。全てのメッセージを REMOTEADDR にリレーします。
     このオブジェクトを動作させるとオープンリレーを作成してしまう可能性が
     多分にあります。注意してください。


File: python-lib-jp.info,  Node: MailmanProxy Objects,  Prev: PureProxy オブジェクト,  Up: smtpd

18.14.4 MailmanProxy Objects
----------------------------

`MailmanProxy(localaddr, remoteaddr)'
     新たな単純プロキシサーバを生成します。引数は`SMTPServer'
     と同じです。全てのメッセージを REMOTEADDR にリレーしますが、
     ローカルの mailman の設定にREMOTEADDR がある場合には mailman
     を使って処理します。このオブジェクトを動作させるとオープンリレーを
     作成してしまう可能性が多分にあります。注意してください。


File: python-lib-jp.info,  Node: telnetlib,  Next: uuid,  Prev: smtpd,  Up: インターネットプロトコルとその支援

18.15 Telnet クライアント
=========================

Telnet クライアントクラス

`telnetlib' モジュールでは、Telnet プロトコルを実装している `Telnet'
クラスを提供します。Telnet プロトコルについての詳細は RFC 854 を参照してください。加えて、このモジュールでは
Telnet プロトコルにおける制御文字 (下を参照してください) と、telnet
オプション に対するシンボル定数を提供しています。telnet
オプションに対する シンボル名は `arpa/telnet.h' の `TELOPT_' がない状態
での定義に従います。伝統的に `arpa/telnet.h' に含められて いない telnet
オプションのシンボル名については、このモジュールの
ソースコード自体を参照してください。

telnet コマンドのシンボル定数は、IAC、DONT、DO、WONT、WILL、SE
(サブネゴシエーション終了)、NOP (何もしない)、DM (データマーク)、 BRK
(ブレーク)、IP (プロセス割り込み)、AO (出力中断)、 AYT (応答確認)、EC
(文字削除)、EL (行削除)、GA (進め)、SB ( サブネゴシエーション開始)
です。

`Telnet([host[, port]])'
     `Telnet' は Telnet サーバへの接続を表現します。 標準では、`Telnet'
     クラスのインスタンスは最初はサーバに 接続していません;
     接続を確立するには `open()' を使わなければ
     なりません。別の方法として、コンストラクタにホスト名とオプションの
     ポート番号を渡すことができます。この場合はコンストラクタの呼び出し
     が返る以前にサーバへの接続が確立されます。

     すでに接続の開かれているンスタンスを再度開いてはいけません。

     このクラスは多くの `read_*()' メソッドを持っています。
     これらのメソッドのいくつかは、接続の終端を示す文字を読み込んだ場合に
     `EOFError' を送出するので注意してください。例外を送出する
     のは、これらの関数が終端に到達しなくても空の文字列を返す可能性
     があるからです。詳しくは下記の個々の説明を参照してください。

See also:
    *RFC854 Telnet プロトコル仕様 (Telnet Protocol Specification)*
          Telnet プロトコルの定義。


* Menu:

* Telnet オブジェクト::
* Telnet Example::


File: python-lib-jp.info,  Node: Telnet オブジェクト,  Next: Telnet Example,  Prev: telnetlib,  Up: telnetlib

18.15.1 Telnet オブジェクト
---------------------------

`Telnet' インスタンスは以下のメソッドを持っています:

`read_until(expected[, timeout])'
     EXPECTEDで指定された文字列を読み込むか、TIMEOUTで指定された
     秒数が経過するまで読み込みます。

     与えられた文字列に一致する部分が見つからなかった場合、読み込む
     ことができたもの全てを返します。これは空の文字列になる可能性が
     あります。接続が閉じられ、転送処理済みのデータが得られない場合
     には `EOFError' が送出されます。

`read_all()'
     `EOF'に到達するまでの全てのデータを読み込みます; 接続が
     閉じられるまでブロックします。

`read_some()'
     `EOF' に到達しない限り、少なくとも 1 バイトの転送処理済みデータ
     を読み込みます。`EOF' に到達した場合は `''' を返します。
     すぐに読み出せるデータが存在しない場合にはブロックします。

`read_very_eager()'
     I/O によるブロックを起こさずに読み出せる全てのデータを読み込み
     ます (eager モード)。

     接続が閉じられており、転送処理済みのデータとして読み出せるもの
     がない場合には `EOFError' が送出されます。それ以外の
     場合で、単に読み出せるデータがない場合には `''' を返します。 IAC
     シーケンス操作中でないかぎりブロックしません。

`read_eager()'
     現在すぐに読み出せるデータを読み出します。

     接続が閉じられており、転送処理済みのデータとして読み出せるものが
     ない場合には `EOFError' が送出されます。それ以外の
     場合で、単に読み出せるデータがない場合には `''' を返します。 IAC
     シーケンス操作中でないかぎりブロックしません。

`read_lazy()'
     すでにキューに入っているデータを処理して返します (lazy モード)。

     接続が閉じられており、読み出せるデータがない場合には `EOFError'
     を送出します。それ以外の場合で、転送処理済みの
     データで読み出せるものがない場合には `''' を返します。 IAC
     シーケンス操作中でないかぎりブロックしません。

`read_very_lazy()'
     すでに処理済みキューに入っているデータを処理して返します (very
     lazy モード)。

     接続が閉じられており、読み出せるデータがない場合には `EOFError'
     を送出します。それ以外の場合で、転送処理済みの
     データで読み出せるものがない場合には `''' を返します。
     このメソッドは決してブロックしません。

`read_sb_data()'
     SB/SE ペア (サブオプション開始／終了)
     の間に収集されたデータを返します。 `SE'
     コマンドによって起動されたコールバック関数はこれらのデータ
     にアクセスしなければなりません。

     このメソッドはけっしてブロックしません。 _Added in Python version
     2.3_

`open(host[, port])'
     サーバホストに接続します。
     第二引数はオプションで、ポート番号を指定します。 標準の値は通常の
     Telnet ポート番号 (23) です。

     すでに接続しているインスタンスで再接続を試みてはいけません。

`msg(msg[, *args])'
     デバッグレベルが `>' 0 のとき、デバッグ用のメッセージを
     出力します。追加の引数が存在する場合、標準の 文字列書式化演算子
     `%' を使って MSG 中の 書式指定子に代入されます。

`set_debuglevel(debuglevel)'
     デバッグレベルを設定します。DEBUGLEVEL が大きくなるほど、
     (`sys.stdout' に) デバッグメッセージがたくさん出力されます。

`close()'
     接続を閉じます。

`get_socket()'
     内部的に使われているソケットオブジェクトです。

`fileno()'
     内部的に使われているソケットオブジェクトのファイル記述子です。

`write(buffer)'
     ソケットに文字列を書き込みます。このとき IAC 文字については 2
     度送信します。接続がブロックした場合、書き込みがブロックする
     可能性があります。接続が閉じられた場合、`socket.error'
     が送出されるかもしれません。

`interact()'
     非常に低機能の telnet クライアントをエミュレートする対話 関数です。

`mt_interact()'
     `interact()' のマルチスレッド版です。

`expect(list[, timeout])'
     正規表現のリストのうちどれか一つにマッチするまでデータを読みます。

     第一引数は正規表現のリストです。コンパイルされたもの
     (`re.RegexObject' のインスタンス) でも、コンパイルされて
     いないもの (文字列) でもかまいません。オプションの第二引数は
     タイムアウトで、単位は秒です; 標準の値は無期限に設定されています。

     3 つの要素からなるタプル: 最初にマッチした正規表現のインデクス;
     返されたマッチオブジェクト;
     マッチ部分を含む、マッチするまでに読み込まれたテキストデータ、
     を返します。

     ファイル終了子が見つかり、かつ何もテキストデータが読み込まれ
     なかった場合、`EOFError' が送出されます。そうでない
     場合で何もマッチしなかった場合には `(-1, None, TEXT)'
     が返されます。ここで TEXT はこれまで受信したテキストデータ です
     (タイムアウトが発生した場合には空の文字列になる場合もあります)。

     正規表現の末尾が (".*" のような) 貪欲マッチングになっている
     場合や、入力に対して 1 つ以上の正規表現がマッチする場合には、
     その結果は決定不能で、I/O のタイミングに依存するでしょう。

`set_option_negotiation_callback(callback)'
     telnet オプションが入力フローから読み込まれるたびに、 CALLBACK が
     (設定されていれば) 以下の引数形式: callback(telnet socket, command
     (DO/DONT/WILL/WONT), option) で呼び出されます。その後 telnet
     オプションに対しては telnetlib は何も行いません。


File: python-lib-jp.info,  Node: Telnet Example,  Prev: Telnet オブジェクト,  Up: telnetlib

18.15.2 Telnet Example
----------------------

典型的な使い方を表す単純な例を示します:

     import getpass
     import sys
     import telnetlib

     HOST = "localhost"
     user = raw_input("Enter your remote account: ")
     password = getpass.getpass()

     tn = telnetlib.Telnet(HOST)

     tn.read_until("login: ")
     tn.write(user + "\n")
     if password:
         tn.read_until("Password: ")
         tn.write(password + "\n")

     tn.write("ls\n")
     tn.write("exit\n")

     print tn.read_all()


File: python-lib-jp.info,  Node: uuid,  Next: urlparse,  Prev: telnetlib,  Up: インターネットプロトコルとその支援

18.16 RFC 4122 に準拠した UUID オブジェクト
===========================================

RFC 4122 に準拠した UUID オブジェクト（汎用一意識別子）

_Added in Python version 2.5_ このモジュールでは
immutable（変更不能）な `UUID' オブジェクト（`UUID' クラス）と RFC 4122 の定めるバージョン
1、3、4、5 の UUID を生成するための`uuid1()' 、 `uuid2()' 、`uuid3()'
、`uuid4()' 、`uuid()' が提供されています。

もしユニークな ID が必要なだけであれば、おそらく `uuid1()' か
`uuid4()'をコールすれば良いでしょう。 `uuid1()'
はコンピュータのネットワークアドレスを含む UUID を生成するために
プライバシーを侵害するかもしれない点に注意してください。`uuid4()'
はランダムな UUID を生成します。

`UUID([hex[, bytes[, bytes_le[, fields[, int[, version]]]]]])'
     32 桁の 16 進数文字列、BYTES に 16 バイトの文字列、BYTES_LE 引数に
     16 バイトのリトルエンディアンの文字列、FIELD 引数に 6
     つの整数のタプル（32ビットTIME_LOW、 16 ビット TIME_MID、16ビット
     TIME_HI_VERSION, 8ビット CLOCK_SEQ_HI_VARIANT, 8ビット
     CLOCK_SEQ_LOW, 48ビット NODE）、または INT に一つの 128
     ビット整数の いずれかから UUID を生成します。16
     進数が与えられた時、波括弧、ハイフン、それと URN
     接頭辞は無視されます。 例えば、これらの表現は全て同じ UUID
     を払い出します。

          UUID('{12345678-1234-5678-1234-567812345678}')
          UUID('12345678123456781234567812345678')
          UUID('urn:uuid:12345678-1234-5678-1234-567812345678')
          UUID(bytes='\x12\x34\x56\x78'*4)
          UUID(bytes_le='\x78\x56\x34\x12\x34\x12\x78\x56' +
                        '\x12\x34\x56\x78\x12\x34\x56\x78')
          UUID(fields=(0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678))
          UUID(int=0x12345678123456781234567812345678)

     HEX、BYTES、BYTES_LE、FIELDS、または INT
     のうち、どれかただ一つだけが与えられなければいけません。 VERSION
     引数は オプションです；与えられた場合、結果の UUID は与えられた
     HEX、BYTES、 BYTES_LE、FIELDS、または INT をオーバーライドして、
     RFC 4122 に準拠した variant と version
     ナンバーのセットを持つことになります。 BYTES_LE, FIELDS, or INT.


`UUID' インスタンスは以下の読み取り専用属性を持ちます：

`bytes'
     16 バイト文字列（バイトオーダーがビッグエンディアンの 6
     つの整数フィールドを持つ）のUUID。

`bytes_le'
     16 バイト文字列（TIME_LOW、TIME_MID、TIME_HI_VERSION を
     リトルエンディアンで持つ）の UUID。

`fields'
     UUID の 6 つの整数フィールドを持つタプルで、これは 6
     つの個別の属性と 2 つの派生した属性としても取得可能です。

     フィールド                         意味
     ------                             -----
     time_low                           UUID の最初の 32 ビット
     time_mid                           UUID の次の 16 ビット
     time_hi_version                    UUID の次の 16 ビット
     clock_seq_hi_variant               UUID の次の 8 ビット
     clock_seq_low                      UUID の次の 8 ビット
     node                               UUID の最後の 48 ビット
     time                               60 ビットのタイムスタンプ
     clock_seq                          14 ビットのシーケンス番号


`hex'
     32 文字の 16 進数文字列での UUID。

`int'
     128 ビット整数での UUID。

`urn'
     RFC 4122 で規定される URN での UUID。

`variant'
     UUID の内部レイアウトを決定する UUID の variant。 これは整数の定数
     The UUID variant, which determines the internal layout of the UUID.
     This will be one of the integer constants `RESERVED_NCS'、
     `RFC_4122'、 `RESERVED_MICROSOFT'、又は `RESERVED_FUTURE'
     のいずれかになります。

`version'
     UUID の version 番号（1 から 5、variant が `RFC_4122' である
     場合だけ意味があります）。

The `uuid' モジュールには以下の関数があります：

`getnode()'
     48 ビットの正の整数としてハードウェアアドレスを取得します。
     最初にこれを起動すると、別個のプログラムが立ち上がって非常に遅くなることがあります。
     もしハードウェアを取得する試みが全て失敗すると、ランダムな 48
     ビットに RFC 4122 で推奨されているように 8 番目のビットを 1
     に設定した数を使います。 "ハードウェアアドレス"
     とはネットワークインターフェースの MAC アドレスを指し、
     複数のネットワークインターフェースを持つマシンの場合、それらのどれか一つの
     MAC アドレスが返るでしょう。

`uuid1([node[, clock_seq]])'
     UUID をホスト ID、シーケンス番号、現在時刻から生成します。 NODE
     が与えられなければ、`getnode()' がハードウェアアドレス
     取得のために使われます。 CLOCK_SEQ
     が与えられると、これはシーケンス番号として使われます； さもなくば
     14 ビットのランダムなシーケンス番号が選ばれます。

`uuid3(namespace, name)'
     UUID を名前空間識別子（これは UUID です）と名前（文字列です）の
     MD5 ハッシュから生成します。

`uuid4()'
     ランダムな UUID を生成します。

`uuid5(namespace, name)'
     名前空間識別子（これは UUID です）と名前（文字列です）の SHA-1
     ハッシュから生成します。

`uuid' モジュールは `uuid3()' または `uuid5()' で利用するために
次の名前空間識別子を定義しています。

`NAMESPACE_DNS'
     この名前空間が指定された場合、 NAME
     文字列は完全修飾ドメイン名です。

`NAMESPACE_URL'
     この名前空間が指定された場合、 NAME 文字列は URL です。

`NAMESPACE_OID'
     この名前空間が指定された場合、 NAME 文字列は ISO OID です。

`NAMESPACE_X500'
     この名前空間が指定された場合、 NAME 文字列は X.500 DN の DER
     またはテキスト出力形式です。

The `uuid' モジュールは以下の定数を `variant'
属性が取りうる値として定義しています：

`RESERVED_NCS'
     NCS 互換性のために予約されています。

`RFC_4122'
     RFC 4122 で与えられた UUID レイアウトを指定します。

`RESERVED_MICROSOFT'
     Microsoft の互換性のために予約されています。

`RESERVED_FUTURE'
     将来のために予約されています。

See also:
    *RFC4122 A Universally Unique IDentifier (UUID) URN Namespace*
          この仕様は UUID のための Uniform Resource Name 名前空間、
          UUID の内部フォーマットと UUID の生成方法を定義しています。


* Menu:

* 例 12::


File: python-lib-jp.info,  Node: 例 12,  Prev: uuid,  Up: uuid

18.16.1 例
----------

典型的な `uuid' モジュールの利用方法を示します：
     >>> import uuid

     # UUID をホスト ID と現在時刻に基づいて生成します
     >>> uuid.uuid1()
     UUID('a8098c1a-f86e-11da-bd1a-00112444be1e')

     # 名前空間 UUID と名前の MD5 ハッシュを使って UUID を生成します
     >>> uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org')
     UUID('6fa459ea-ee8a-3ca4-894e-db77e160355e')

     # ランダムな UUID を作成します
     >>> uuid.uuid4()
     UUID('16fd2706-8baf-433b-82eb-8c7fada847da')

     # 名前空間 UUID と名前の SHA-1 ハッシュを使って UUID を生成します
     >>> uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org')
     UUID('886313e1-3b8a-5372-9b90-0c9aee199e5d')

     # 16 進数文字列から UUID を生成します（波括弧とハイフンは無視されます）
     >>> x = uuid.UUID('{00010203-0405-0607-0809-0a0b0c0d0e0f}')

     # UUID を標準的な 16 進数の文字列に変換します
     >>> str(x)
     '00010203-0405-0607-0809-0a0b0c0d0e0f'

     # 生の 16 バイトの UUID を取得します
     >>> x.bytes
     '\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'

     # 16 バイトの文字列から UUID を生成します
     >>> uuid.UUID(bytes=x.bytes)
     UUID('00010203-0405-0607-0809-0a0b0c0d0e0f')


File: python-lib-jp.info,  Node: urlparse,  Next: SocketServer,  Prev: uuid,  Up: インターネットプロトコルとその支援

18.17 URL を解析して構成要素にする
==================================

URL を解析して構成要素にします。

このモジュールでは URL (Uniform Resource Locator) 文字列をその構成要素
(アドレススキーム、ネットワーク上の位置、パスその他) に分解したり、
構成要素を URL に組みなおしたり、"相対 URL (relative URL)" を指定した
"基底 URL (base URL)" に基づいて絶対 URL に変換するための標準的な
インタフェースを定義しています。

このモジュールは相対 URL のインターネット RFC に対応するように設計
されました (そして RFC の初期ドラフトのバグを発見しました！)。
サポートされる URL スキームは以下の通りです: `file', `ftp', `gopher',
`hdl', `http', `https', `imap', `mailto', `mms', `news', `nntp',
`prospero', `rsync', `rtsp', `rtspu', `sftp', `shttp', `sip', `sips',
`snews', `svn', `svn+ssh', `telnet', `wais'。

_Added in Python version 2.5_

`urlparse' モジュールには以下の関数が定義されています:

`urlparse(urlstring[, default_scheme[, allow_fragments]])'
     URL を解釈して 6 つの構成要素にし、6 要素のタプルを返します。
     このタプルは URL の一般的な構造:
     `SCHEME://NETLOC/PATH;PARAMETERS?QUERY#FRAGMENT' に対応しています。
     各タプル要素は文字列で、空の場合もあります。
     構成要素がさらに小さい要素に分解されることはありません (例えば
     ネットワーク上の位置は単一の文字列になります)。また %
     によるエスケープ
     は展開されません。上で示された区切り文字がタプルの各要素の一部分
     として含まれることはありませんが、PATH 要素の先頭のスラッシュ
     がある場合には例外です。たとえば以下のようになります。

          >>> from urlparse import urlparse
          >>> o = urlparse('http://www.cwi.nl:80/%7Eguido/Python.html')
          >>> o
          ('http', 'www.cwi.nl:80', '/%7Eguido/Python.html', '', '', '')
          >>> o.scheme
          'http'
          >>> o.port
          80
          >>> o.geturl()
          'http://www.cwi.nl:80/%7Eguido/Python.html'

     DEFAULT_SCHEME 引数が指定されている場合、標準のアドレススキーム
     を表し、アドレススキームを指定していない URL に対してのみ
     使われます。この引数の標準の値は空文字列です。

     ALLOW_FRAGMENTS 引数が偽の場合、URL のアドレススキームが
     フラグメント指定をサポートしていても指定できなくなります。
     この引数の標準の値は `True' です。

     戻り値は実際には `tuple' のサブクラスのインスタンスです。
     このクラスには以下の読み出し専用の便利な属性が追加されています。

     属性              インデクス        値                指定されなかった場合の値
     ------            ------            ------            ------
     scheme            0                 URL スキーム      空文字列
     netloc            1                 ネットワーク上の位置空文字列
     path              2                 階層的パス        空文字列
     params            3                 最後のパス要素に対するパラメータ空文字列
     query             4                 クエリ要素        空文字列
     fragment          5                 フラグメント指定子空文字列
     username                            ユーザ名          `None'
     password                            パスワード        `None'
     hostname                            ホスト名          `None'
                                         (小文字)          
     port                                ポート番号を表わす整数`None'
                                         (もしあれば)      

     結果オブジェクトのより詳しい情報は*Note cookielib::節
     "`urlparse()' および `urlsplit()' の結果" を参照してください。

     _Changed in Python version 2.5_

`urlunparse(parts)'
     `urlparse()' が返すような形式のタプルから URL を構築します。 PARTS
     引数は任意の 6 要素イテラブルで構いません。 解析された元の URL
     が、不要な区切り文字 を持っていた場合には、多少違いはあるが等価な
     URL になるかもしれません。 (例えばクエリ内容が空の ?
     のようなもので、RFC はこれらを等価だと述べています。)

`urlsplit(urlstring[, default_scheme[, allow_fragments]])'
     `urlparse()' に似ていますが、URL から params を切り離し
     ません。このメソッドは通常、URL の PATH 部分において、各セグメント
     にパラメタ指定をできるようにした最近の URL 構文 (RFC 2396 参照)
     が必要な 場合に、`urlparse()' の代わりに使われます。
     パスセグメントとパラメタを分割するためには分割用の関数が必要
     です。この関数は 5 要素のタプル:
     (アドレススキーム、ネットワーク上の位置、パス、クエリ、フラグメント指定子)
     を返します。

     戻り値は実際には `tuple' のサブクラスのインスタンスです。
     このクラスには以下の読み出し専用の便利な属性が追加されています。

     属性              インデクス        値                指定されなかった場合の値
     ------            ------            ------            ------
     scheme            0                 URL スキーム      空文字列
     netloc            1                 ネットワーク上の位置空文字列
     path              2                 階層的パス        空文字列
     query             3                 クエリ要素        空文字列
     fragment          4                 フラグメント指定子空文字列
     username                            ユーザ名          `None'
     password                            パスワード        `None'
     hostname                            ホスト名          `None'
                                         (小文字)          
     port                                ポート番号を表わす整数`None'
                                         (もしあれば)      

     結果オブジェクトのより詳しい情報は*Note cookielib::節
     "`urlparse()' および `urlsplit()' の結果" を参照してください。

     _Added in Python version 2.2_ _Changed in Python version 2.5_

`urlunsplit(parts)'
     `urlsplit()' が返すような形式のタプル中のエレメントを組み合わせ
     て、文字列の完全な URL にします。 PARTS 引数は任意の 5
     要素イテラブルで構いません。 解析された元の URL
     が、不要な区切り文字 を持っていた場合には、多少違いはあるが等価な
     URL になるかもしれません。 (例えばクエリ内容が空の ?
     のようなもので、RFC はこれらを等価だと述べています。) _Added in
     Python version 2.2_

`urljoin(base, url[, allow_fragments])'
     "基底 URL" (BASE) と "相対 URL" (URL) を組み合わせて、 完全な URL
     ("絶対 URL") を構成します。 ぶっちゃけ、この関数は 基底 URL
     の要素、特にアドレススキーム、 ネットワーク上の位置、およびパス
     (の一部) を使って、相対 URL に
     ない要素を提供します。以下の例のようになります。

          >>> from urlparse import urljoin
          >>> urljoin('http://www.cwi.nl/%7Eguido/Python.html', 'FAQ.html')
          'http://www.cwi.nl/%7Eguido/FAQ.html'

     ALLOW_FRAGMENTS 引数は `urlparse()' における引数と同じ意味
     とデフォルトを持ちます。

`urldefrag(url)'
     URL がフラグメント指定子を含む場合、フラグメント指定子
     を持たないバージョンに修正された URL と、別の文字列に分割
     されたフラグメント指定子を返します。URL 中にフラグメント
     指定子がない場合、そのままの URL と空文字列を返します。

See also:
    *RFC1738 Uniform Resource Locators (URL)*
          この RFC では絶対 URL
          の形式的な文法と意味付けを仕様化しています。

    *RFC1808 Relative Uniform Resource Locators*
          この RFC には絶対 URL と相対 URL を結合するための規則が
          ボーダケースの取扱い方を決定する "異常な例" つきで
          収められています。

    *RFC2396 Uniform Resource Identifiers (URI): Generic Syntax*
          この RFC では Uniform Resource Name (URN) と Uniform Resource
          Locator (URL)
          の両方に対する一般的な文法的要求事項を記述しています。


* Menu:

* urlparse および urlsplit の結果::


File: python-lib-jp.info,  Node: urlparse および urlsplit の結果,  Prev: urlparse,  Up: urlparse

18.17.1 `urlparse()' および `urlsplit()' の結果
-----------------------------------------------

`urlparse()' および `urlsplit()' から得られる結果オブジェクト
はそれぞれ `tuple' 型のサブクラスです。これらのクラスは
それぞれの関数の説明の中で述べたような属性とともに、追加のメソッドを
一つ提供しています。

`geturl()'
     再結合された形で元の URL の文字列を返します。 この文字列は元の URL
     とは次のような点で異なるかもしれません。
     スキームは常に小文字に正規化されます。 また空の要素は省略されます。
     特に、空のパラメータ、クエリ、フラグメント識別子は取り除かれます。

     このメソッドの結果は再び解析に回されたとしても不動点となります。

          >>> import urlparse
          >>> url = 'HTTP://www.Python.org/doc/#'

          >>> r1 = urlparse.urlsplit(url)
          >>> r1.geturl()
          'http://www.Python.org/doc/'

          >>> r2 = urlparse.urlsplit(r1.geturl())
          >>> r2.geturl()
          'http://www.Python.org/doc/'

     _Added in Python version 2.5_

以下のクラスが解析結果の実装を提供します。

`BaseResult'
     具体的な結果クラスたちの基底クラスです。このクラスがほとんどの属性の
     定義を与えます。しかし `geturl()' メソッドは提供しません。この
     クラスは `tuple' から派生しています が、`__init__()' や
     `__new__()' をオーバーライドしませ ん。

`ParseResult(scheme, netloc, path, params, query, fragment)'
     `urlparse()' の結果のための具体クラスで す。`__new__()'
     メソッドをオーバーライドして正しい個数の引数が
     引き渡されたことを確認するようにしています。

`SplitResult(scheme, netloc, path, query, fragment)'
     `urlsplit()' の結果のための具体クラスで す。`__new__()'
     メソッドをオーバーライドして正しい個数の引数が
     引き渡されたことを確認するようにしています。


File: python-lib-jp.info,  Node: SocketServer,  Next: BaseHTTPServer,  Prev: urlparse,  Up: インターネットプロトコルとその支援

18.18 ネットワークサーバ構築のための フレームワーク
===================================================

ネットワークサーバ構築のためのフレームワーク。

`SocketServer' モジュールはネットワークサーバを実装するタスクを
単純化します。

このモジュールには 4 つのサーバクラスがあります: `TCPServer'
は、クライアントとサーバ間に継続的なデータ流路を提供
する、インターネット TCP プロトコルを使います。 `UDPServer'
は、順序通りに到着しなかったり、転送中に喪失して
しまってもかまわない情報の断続的なパケットである、データグラムを使います。
`UnixStreamServer' および `UnixDatagramServer' クラスも
同様ですが、UNIX ドメインソケットを使います; 従って非 UNIX
プラットフォームでは利用できません。ネットワークプログラミングに
ついての詳細は、W. Richard Steven 著 や、 Ralph Davis 著  のような
書籍を参照してください。

これらの 4 つのクラスは要求を "同期的に (synchronously)" 処理します;
各要求は次の要求を開始する前に完結していなければなりません。
同期的な処理は、サーバで大量の計算を必要とする、あるいはクライアントが
処理するには時間がかかりすぎるような大量のデータを返す、といった理由に
よってリクエストに長い時間がかかる状況には向いていません。
こうした状況の解決方法は別のプロセスを生成するか、個々の要求を
扱うスレッドを生成することです; `ForkingMixIn' および `ThreadingMixIn'
配合クラス (mix-in classes) を使えば、非同期的な動作をサポートできます。

サーバの作成にはいくつかのステップがあります。最初に、
`BaseRequestHandler' クラスをサブクラス化して 要求処理クラス (request
hander class) を生成し、その `handle()'
メソッドを上書きしなければなりません; このメソッドで入力される
要求を処理します。次に、サーバクラスのうち一つをインスタンス化して、
サーバのアドレスと要求処理クラスを渡さなければなりません。最後に、
サーバオブジェクトの `handle_request()' または `serve_forever()'
メソッドを呼び出して、単一または多数の 要求を処理します。

`ThreadingMixIn' から継承してスレッドを利用した接続を行う場合、
突発的な通信切断時の処理を明示的に指定する必要があります。
`ThreadingMixIn' クラスには DAEMON_THREADS 属性があり、
サーバがスレッドの終了を待ち合わせるかどうかを指定する事ができます。
スレッドが独自の処理を行う場合は、このフラグを明示的に指定します。
デフォルトは`False'で、Pythonは`ThreadingMixIn'クラス
が起動した全てのスレッドが終了するまで実行し続けます。

サーバクラス群は使用するネットワークプロトコルに関わらず、同じ外部
メソッドおよび属性を持ちます:

* Menu:

* サーバ生成に関するノート::
* Serverオブジェクト::
* RequestHandlerオブジェクト::


File: python-lib-jp.info,  Node: サーバ生成に関するノート,  Next: Serverオブジェクト,  Prev: SocketServer,  Up: SocketServer

18.18.1 サーバ生成に関するノート
--------------------------------

継承図にある五つのクラスのうち四つは四種類の同期サーバを表わしています。

             +------------+
             | BaseServer |
             +------------+
                   |
                   v
             +-----------+        +------------------+
             | TCPServer |------->| UnixStreamServer |
             +-----------+        +------------------+
                   |
                   v
             +-----------+        +--------------------+
             | UDPServer |------->| UnixDatagramServer |
             +-----------+        +--------------------+

`UnixDatagramServer' は `UDPServer' から派生していて、
`UnixStreamServer' からではないことに注意してください -- IP と UNIX
ストリームサーバの唯一の違いはアドレスファミリーで それは両方の UNIX
サーバクラスで単純に繰り返されています。

それぞれのタイプのサーバのフォークしたりスレッド実行したりするバージョンは
`ForkingMixIn' および `ThreadingMixIn' ミクシン(mix-in)クラスを使って
作ることができます。たとえば、スレッド実行する UDP
サーバクラスは以下のようにして 作られます。

         class ThreadingUDPServer(ThreadingMixIn, UDPServer): pass

ミクシンクラスは `UDPServer'
で定義されるメソッドをオーバライドするために、
先に来なければなりません。様々なメンバ変数を設定することで元になるサーバ機構の
振る舞いを変えられます。

サービスの実装には、`BaseRequestHandler' からクラスを派生させて その
`handle()' メソッドを再定義しなければなりません。このようにすれば、
サーバクラスと要求処理クラスを結合して様々なバージョンのサービスを
実行することができます。要求処理クラスはデータグラムサービスかストリームサービスかで
異なることでしょう。この違いは処理サブクラス `StreamRequestHandler'
または `DatagramRequestHandler' を使うという形で隠蔽できます。

もちろん、まだ頭を使わなければなりません!
たとえば、サービスがリクエストによっては
書き換えられるようなメモリ上の状態を使うならば、フォークするサーバを使うのは馬鹿げています。
というのも子プロセスでの書き換えは親プロセスで保存されている初期状態にも
親プロセスから分配される各子プロセスの状態にも届かないからです。この場合、
スレッド実行するサーバを使うことはできますが、共有データの一貫性を保つために
ロックを使わなければならなくなるでしょう。

一方、全てのデータが外部に(たとえばファイルシステムに)保存される HTTP
サーバを
作っているのだとすると、同期クラスではどうしても一つの要求が処理されている間
サービスが「耳の聞こえない」状態を呈することになります -- この状態はもし
クライアントが要求した全てのデータをゆっくり受け取るととても長い時間続きかねません。
こういう場合にはサーバをスレッド実行したりフォークすることが適切です。

ある場合には、要求の一部を同期的に処理する一方で、要求データに依って子プロセスを
フォークして処理を終了させる、といった方法も適当かもしれません。こうした処理方法
は同期サーバを使って要求処理クラスの `handle()' メソッドの中で自分で
フォークするようにして実装することができます。

スレッドも `fork()' もサポートされない環境で
(もしくはサービスにとってそれらがあまりに高価についたり不適切な場合に)
多数の同時要求を捌くもう一つのアプローチは、部分的に処理し終えた要求のテーブルを
自分で管理し、次にどの要求に対処するか
(または新しく入ってきた要求を扱うかどうか)を決めるのに `select()'
を使う方法です。
これは(もしスレッドやサブプロセスが使えなければ)特にストリームサービスに対して重要で、
そのようなサービスでは各クライアントが潜在的に長く接続し続けます。


File: python-lib-jp.info,  Node: Serverオブジェクト,  Next: RequestHandlerオブジェクト,  Prev: サーバ生成に関するノート,  Up: SocketServer

18.18.2 Serverオブジェクト
--------------------------

`fileno()'
     サーバが要求待ちを行っているソケットのファイル記述子を整数で返します。
     この関数は一般的に、同じプロセス中の複数のサーバを監視できるように
     するために、 `select.select()' に渡されます。

`handle_request()'
     単一の要求を処理します。この関数は以下のメソッド:
     `get_request()'、 `verify_request()'、および `process_request()'
     を順番に呼び出します。 ハンドラ中でユーザによって提供された
     `handle()' が例外 を送出した場合、サーバの `handle_error()'
     メソッドが 呼び出されます。

`serve_forever()'
     無限個の要求を処理します。この関数は単に無限ループ内で
     `handle_request()' を呼び出します。

`address_family'
     サーバのソケットが属しているプロトコルファミリです。 取りえる値は
     `socket.AF_INET' および `socket.AF_UNIX' です。

`RequestHandlerClass'
     ユーザが提供する要求処理クラスです;
     要求ごとにこのクラスのインスタンス が生成されます。

`server_address'
     サーバが要求待ちを行うアドレスです。アドレスの形式はプロトコルファミリ
     によって異なります。詳細は `socket' モジュールを参照してください。
     インターネットプロトコルでは、この値は例えば`('127.0.0.1', 80)'の
     ようにアドレスを与える文字列と整数のポート番号を含むタプルです。

`socket'
     サーバが入力の要求待ちを行うためのソケットオブジェクトです。

サーバクラスは以下のクラス変数をサポートします:

`allow_reuse_address'
     サーバがアドレスの再使用を許すかどうかを示す値です。この値は標準
     で `False' で、サブクラスで再使用ポリシを変更するために
     設定することができます。

`request_queue_size'
     要求待ち行列 (queue) のサイズです。単一の要求を処理するのに長時間
     かかる場合には、サーバが処理中に届いた要求は最大
     `request_queue_size' 個まで待ち行列に置かれます。
     待ち行列が一杯になると、それ以降のクライアントからの要求は
     "接続拒否 (Connection denied)" エラーになります。標準の値は 通常 5
     ですが、この値はサブクラスで上書きすることができます。

`socket_type'
     サーバが使うソケットの型です; 取りえる値は 2 つで、
     `socket.SOCK_STREAM' と `socket.SOCK_DGRAM' です。

`TCPServer' のような基底クラスのサブクラスで上書きできる
サーバメソッドは多数あります; これらのメソッドはサーバオブジェクトの
外部のユーザにとっては役にたたないものです。

`finish_request()'
     `RequestHandlerClass' をインスタンス化し、`handle()'
     メソッドを呼び出して、実際に要求を処理します。

`get_request()'
     ソケットから要求を受理して、 クライアントとの通信に使われる
     _新しい_
     ソケットオブジェクト、およびクライアントのアドレスからなる、 2
     要素のタプルを返します。

`handle_error(request, client_address)'
     この関数は `RequestHandlerClass' の `handle()'
     メソッドが例外を送出した際に呼び出されます。標準の動作では
     標準出力へトレースバックを出力し、後続する要求を継続して処理します。

`process_request(request, client_address)'
     `finish_request()' を呼び出して、`RequestHandlerClass'
     のインスタンスを生成します。必要なら、この関数から
     新たなプロセスかスレッドを生成して要求を処理することができます;
     その処理は `ForkingMixIn' または `ThreadingMixIn'
     クラスが行います。

`server_activate()'
     サーバのコンストラクタによって呼び出され、サーバを活動状態に
     します。デフォルトではサーバのソケットを `listen' するだけです。
     このメソッドは上書きできます。

`server_bind()'
     サーバのコンストラクタによって呼び出され、適切なアドレスにソケットを
     バインドします。 このメソッドは上書きできます。

`verify_request(request, client_address)'
     ブール値を返さなければなりません;
     値が`True'の場合には要求が処理され、
     `False'の場合には要求は拒否されます。
     サーバへのアクセス制御を実装するためにこの関数を上書きすることが
     できます。標準の実装では常に`True'を返します。


File: python-lib-jp.info,  Node: RequestHandlerオブジェクト,  Prev: Serverオブジェクト,  Up: SocketServer

18.18.3 RequestHandlerオブジェクト
----------------------------------

要求処理クラスでは、新たな `handle()' メソッドを定義
しなくてはならず、また以下のメソッドのいずれかを上書きすることができます。
各要求ごとに新たなインスタンスが生成されます。

`finish()'
     `handle()' メソッドが呼び出された後、何らかの後始末を行うために
     呼び出されます。標準の実装では何も行いません。`setup()' または
     `handle()' が例外を送出した場合には、この関数は呼び出されません。

`handle()'
     この関数では、クライアントからの要求を実現するために必要な全ての作業を
     行わなければなりません。デフォルト実装では何もしません。
     この作業の上で、いくつかのインスタンス属性を
     利用することができます; クライアントからの要求は `self.request'
     です; クライアントのアドレスは `self.client_address' です;
     そしてサーバごとの情報にアクセスする場合には、サーバインスタンスを
     `self.server' で取得できます。

     `self.request' の型はサービスがデータグラム型かストリーム型かで
     異なります。ストリーム型では、`self.request' はソケットオブジェクト
     です; データグラムサービスでは、`self.request' は文字列になります。
     しかし、この違いは要求処理サブクラスの`StreamRequestHandler' や
     `DatagramRequestHandler'を使うことで隠蔽することができます。
     これらのクラスでは `setup()' および `finish()' メソッド
     を上書きしており、`self.rfile' および `self.wfile' 属性を
     提供しています。 `self.rfile' および `self.wfile'
     は、要求データを取得したり
     クライアントにデータを返すために、それぞれ読み出し、書き込みを行うことが
     できます。

`setup()'
     `handle()'	 メソッドより前に呼び出され、何らかの必要な
     初期化処理を行います。標準の実装では何も行いません。


File: python-lib-jp.info,  Node: BaseHTTPServer,  Next: SimpleHTTPServer,  Prev: SocketServer,  Up: インターネットプロトコルとその支援

18.19 基本的な機能を持つ HTTP サーバ
====================================

基本的な機能を持つ HTTP サーバ  (`SimpleHTTPServer' および
`CGIHTTPServer' の基底クラス)。

このモジュールでは、 HTTP サーバ (Web サーバ) を実装するための
二つののクラスを定義しています。通常、このモジュールが直接使用
されることはなく、特定の機能を持つ Web サーバを構築するために
使われます。 `SimpleHTTPServer'  および `CGIHTTPServer'  モジュール
を参照してください。

最初のクラス、`HTTPServer' は `SocketServer.TCPServer'
のサブクラスです。`HTTPServer' は HTTP ソケットを生成して
リクエスト待ち (listen) を行い、リクエストをハンドラに渡します。
サーバを作成して動作させるためのコードは以下のようになります:

     def run(server_class=BaseHTTPServer.HTTPServer,
             handler_class=BaseHTTPServer.BaseHTTPRequestHandler):
         server_address = ('', 8000)
         httpd = server_class(server_address, handler_class)
         httpd.serve_forever()

`HTTPServer(server_address, RequestHandlerClass)'
     このクラスは `TCPServer' 型のクラスの上に構築されており、
     サーバのアドレスをインスタンス変数 `server_name' および
     `server_port' に記憶します。サーバはハンドラから
     アクセス可能で、通常 `server' インスタンス変数でアクセス します。

`BaseHTTPRequestHandler(request, client_address, server)'
     このクラスはサーバに到着したリクエストを処理します。このメソッド
     自体では、実際のリクエストに応答することはできません; (GET や POST
     のような) 各リクエストメソッドを処理するためには
     サブクラス化しなければなりません。 `BaseHTTPRequestHandler'
     では、サブクラスで使うための
     クラスやインスタンス変数、メソッド群を数多く提供しています。

     このハンドラはリクエストを解釈し、次いでリクエスト形式ごとに固有の
     メソッドを呼び出します。メソッド名はリクエストの名称から構成
     されます。例えば、リクエストメソッド `SPAM' に対しては、
     `do_SPAM()' メソッドが引数なしで呼び出されます。
     リクエストに関連する情報は全て、ハンドラのインスタンス変数
     に記憶されています。サブクラスでは `__init__()' メソッドを
     上書きしたり拡張したりする必要はありません。

`BaseHTTPRequestHandler' は以下のインスタンス変数を持っています:

`client_address'
     HTTP クライアントのアドレスを参照している、 `(HOST, PORT)'
     の形式をとるタプルが入っています。

`command'
     HTTP 命令 (リクエスト形式) が入っています。例えば `'GET'' です。

`path'
     リクエストされたパスが入っています。

`request_version'
     リクエストのバージョン文字列が入っています。例えば `'HTTP/1.0''
     です。

`headers'
     `MessageClass' クラス変数で指定されたクラスのインスタンス
     を保持しています。このインスタンスは HTTP リクエストのヘッダを
     解釈し、管理しています。

`rfile'
     入力ストリームが入っており、そのファイルポインタはオプション
     入力データ部の先頭を指しています。

`wfile'
     クライアントに返送する応答を書き込むための出力ストリームが
     入っています。このストリームに書き込む際には、HTTP プロトコル
     に従った形式をとらなければなりません。

`BaseHTTPRequestHandler' は以下のクラス変数を持っています:

`server_version'
     サーバのソフトウェアバージョンを指定します。
     この値は上書きする必要が生じるかもしれません。
     書式は複数の文字列を空白で分割したもので、各文字列は
     ソフトウェア名[/バージョン] の形式をとります。
     例えば、`'BaseHTTP/0.2'' です。

`sys_version'
     Python 処理系のバージョンが、`version_string' メソッドや
     `server_version' クラス変数で利用可能な形式で入っています。 例えば
     `'Python/1.4'' です。

`error_message_format'
     クライアントに返すエラー応答を構築するための書式化文字列を指定
     します。この文字列は丸括弧で囲ったキー文字列で指定する形式を
     使うので、書式化の対象となる値は辞書でなければなりません。 キー
     CODE は整数で、HTTP エラーコードを特定する数値です。 MESSAGE
     は文字列で、何が発生したかを表す (詳細な)
     エラーメッセージが入ります。EXPLAIN はエラーコード番号
     の説明です。MESSAGE および EXPLAIN の標準の値は RESPONSE
     クラス変数でみつけることができます。

`protocol_version'
     この値には応答に使われる HTTP プロトコルのバージョンを指定します。
     `'HTTP/1.1'' に設定されると、サーバは持続的 HTTP 接続を
     許可します; しかしその場合、サーバは全てのクライアントに対する
     応答に、正確な値を持つ `Content-Length' ヘッダを (`send_header()'
     を使って) 含め _なければなりません_。
     以前のバージョンとの互換性を保つため、標準の設定値は `'HTTP/1.0''
     です。

`MessageClass'
     HTTP ヘッダを解釈するための `rfc822.Message' 類似のクラスを
     指定します。通常この値が上書きされることはなく、標準の値
     `mimetools.Message' になっています。 

`responses'
     この変数はエラーコードを表す整数を二つの要素をもつタプルに対応付け
     ます。タプルには短いメッセージと長いメッセージが入っています。
     例えば、 `{CODE: (SHORTMESSAGE, LONGMESSAGE)}'
     といったようになります。SHORTMESSAGE は通常、エラー応答に おける
     MESSAGE キーの値として使われ、LONGMESSAGE は EXPLAIN
     キーの値として使われます (`error_message_format'
     クラス変数を参照してください) 。

`BaseHTTPRequestHandler' インスタンスは以下のメソッドを持っています:

`handle()'
     `handle_one_request()' を一度だけ (持続的接続が有効になって
     いる場合には複数回) 呼び出して、HTTP リクエストを処理します。
     このメソッドを上書きする必要はまったくありません; そうする代わりに
     適切な `do_*()' を実装してください。

`handle_one_request()'
     このメソッドはリクエストを解釈し、適切な `do_*()' メソッドに
     転送します。このメソッドを上書きする必要はまったくありません。

`send_error(code[, message])'
     完全なエラー応答をクライアントに送信し、ログ記録します。 CODE
     は数値型で、 HTTP エラーコードを指定します。 MESSAGE
     はオプションで、より詳細なメッセージテキストです。
     完全なヘッダのセットが送信された後、`error_message_format'
     クラス変数を使って組み立てられたテキストが送られます。

`send_response(code[, message])'
     応答ヘッダを送信し、受理したリクエストをログ記録します。HTTP
     応答行が送られた後、_Server_ および _Date_ ヘッダが
     送られます。これら二つのヘッダはそれぞれ `version_string()' および
     `date_time_string()' メソッドで取り出します。

`send_header(keyword, value)'
     出力ストリームに特定の HTTP ヘッダを書き込みます。KEYWORD
     はヘッダのキーワードを指定し、VALUE にはその値を指定します。

`end_headers()'
     応答中の HTTP ヘッダの終了を示す空行を送信します。

`log_request([code[, size]])'
     受理された (成功した) リクエストをログに記録します。CODE には
     この応答に関連付けられた HTTP コード番号を指定します。
     応答メッセージの大きさを知ることができる場合、SIZE パラメタ
     に渡すとよいでしょう。

`log_error(...)'
     リクエストを遂行できなかった際に、エラーをログに記録します。
     標準では、メッセージを `log_message()' に渡します。 従って同じ引数
     (FORMAT と追加の値) を取ります。

`log_message(format, ...)'
     任意のメッセージを `sys.stderr' にログ記録します。
     このメソッドは通常、カスタムのエラーログ記録機構を作成するために
     上書きされます。FORMAT 引数は標準の printf 形式の書式化
     文字列で、`log_message()' に渡された追加の引数は
     書式化の入力として適用されます。ログ記録される全てのメッセージ
     には、クライアントのアドレスおよび現在の日付、時刻が先頭に
     付けられます。

`version_string()'
     サーバソフトウェアのバージョン文字列を返します。この文字列は
     クラス変数 `server_version' および `sys_version'
     を組み合わせたものです。

`date_time_string([timestamp])'
     メッセージヘッダ向けに書式化された、
     TIMESTAMP(`time.time()'のフォーマットである必要があります)で与えられた日時を返します。
     もし TIMESTAMP が省略された場合には、現在の日時が使われます。

     出力は `'Sun, 06 Nov 1994 08:49:37 GMT'' のようになります。 _Added
     in Python version 2.5_

`log_date_time_string()'
     ログ記録向けに書式化された、現在の日付および時刻を返します。

`address_string()'
     ログ記録向けに書式化された、クライアントのアドレスを返します。
     このときクライアントの IP アドレスに対する名前解決を行います。

See also:
     *Note CGIHTTPServer:: CGI
     スクリプトをサポートするように拡張されたリクエストハンドラ。

     *Note SimpleHTTPServer::
     ドキュメントルートの下にあるファイルに対する要求への応答のみに制限した基本リクエストハンドラ。


File: python-lib-jp.info,  Node: SimpleHTTPServer,  Next: CGIHTTPServer,  Prev: BaseHTTPServer,  Up: インターネットプロトコルとその支援

18.20 簡潔な HTTP リクエストハンドラ
====================================

このモジュールは HTTP サーバに基本的なリクエストハンドラを提供します。

`SimpleHTTPServer' モジュールはリクエストハンドラ (request-handler)
クラスを定義しています。インタフェースは
`BaseHTTPServer.BaseHTTPRequestHandler' と互換で、
基底ディレクトリにあるファイルだけを提供します。

`SimpleHTTPServer' モジュールでは以下のクラスを定義しています:

`SimpleHTTPRequestHandler(request, client_address, server)'
     このクラスは、現在のディレクトリ以下にあるファイルを、HTTP
     リクエストにおけるディレクトリ構造に直接対応付けて提供するために
     利用されます。

     リクエストの解釈のような、多くの作業は基底クラス
     `BaseHTTPServer.BaseHTTPRequestHandler' で行われます。
     このクラスは関数 `do_GET()' および `do_HEAD()' を実装しています。

`SimpleHTTPRequestHandler' では以下のメンバ変数を定義しています:

`server_version'
     この値は `"SimpleHTTP/" + __version__' になります。 `__version__'
     はこのモジュールで定義されている値です。

`extensions_map'
     拡張子を MIME
     型指定子に対応付ける辞書です。標準の型指定は空文字列で
     表され、この値は `application/octet-stream' と見なされます。
     対応付けは大小文字の区別をするので、小文字のキーのみを入れるべきです。

`SimpleHTTPRequestHandler' では以下のメソッドを定義しています:

`do_HEAD()'
     このメソッドは `'HEAD'' 型のリクエスト処理を実行します: すなわち、
     `GET' リクエストの時に送信されるものと同じヘッダを送信します。
     送信される可能性のあるヘッダについての完全な説明は `do_GET()'
     メソッドを参照してください。

`do_GET()'
     リクエストを現在の作業ディレクトリからの相対的なパスとして解釈することで、
     リクエストをローカルシステム上のファイルと対応付けます。

     リクエストがディレクトリに対応付けられた場合、`index.html'
     または`index.htm'をこの順序でチェックします。
     もしファイルを発見できればその内容を、そうでなければディレクトリ一覧
     を`list_directory()'メソッドで生成して、返します。
     このメソッドは`os.listdir()'をディレクトリのスキャンに用いてお
     り、`listdir()'が失敗した場合には `404' 応答 が返されます。

     リクエストがファイルに対応付けられた場合、そのファイルを開いて内容を
     返します。要求されたファイルを開く際に何らかの `IOError' 例外
     が送出された場合、リクエストは `404'、`'File not found''
     エラーに対応づけられます。そうでない場合、コンテントタイプが
     EXTENSIONS_MAP 変数を用いて推測されます。

     出力は `'Content-type:'' と推測されたコンテントタイプで、その
     後にファイルサイズを示す `'Content-Lenght;'' ヘッダと、
     ファイルの更新日時を示す `'Last-Modified:'' ヘッダが続きます。

     そしてヘッダの終了を示す空白行が続き、さらにその後にファイルの内容が
     続きます。このファイルはコンテントタイプが`text/'で始まっている場合
     はテキストモードで、そうでなければバイナリモードで開かれます。

     使用例については関数 `test()' の実装を参照してください。

     _Added in Python version 2.5_

See also:
     *Note BaseHTTPServer:: Web
     サーバおよび要求ハンドラの基底クラス実装。


File: python-lib-jp.info,  Node: CGIHTTPServer,  Next: cookielib,  Prev: SimpleHTTPServer,  Up: インターネットプロトコルとその支援

18.21 CGI 実行機能付き HTTP リクエスト処理機構
==============================================

CGI スクリプトの実行機能を持つ HTTP
サーバのためのリクエスト処理機構を提供します。

`CGIHTTPServer' モジュールでは、
`BaseHTTPServer.BaseHTTPRequestHandler' 互換のインタフェース
を持ち、`SimpleHTTPServer.SimpleHTTPRequestHandler' の動作を
継承していますが CGI スクリプトを動作することもできる、 HTTP
要求処理機構クラスを定義しています。

_Note:_ このモジュールは CGI スクリプトを UNIX および Windows システム
上で実行させることができます; Mac OS 上では、自分と同じプロセス内で
Python スクリプトを実行することしかできないはずです。

_Note:_  `CGIHTTPRequestHandler' クラスで実行されるCGIスクリプトは HTTP
コード200 (スクリプトの出力が後に続く)を実行に先立って出力される
(これがステータスコードになります) ため、リダイレクト(コード302)を行
なうことができません。

`CGIHTTPServer' モジュールでは、以下のクラスを定義しています:

`CGIHTTPRequestHandler(request, client_address, server)'
     このクラスは、現在のディレクトリかその下のディレクトリにおいて、ファイルか
     CGI スクリプト出力を提供するために使われます。HTTP 階層構造から
     ローカルなディレクトリ構造への対応付けは
     `SimpleHTTPServer.SimpleHTTPRequestHandler' と
     全く同じなので注意してください。

     このクラスでは、ファイルが CGI スクリプトであると推測された
     場合、これをファイルして提供する代わりにスクリプトを実行します。
     他の一般的なサーバ設定は特殊な拡張子を使って CGI
     スクリプトであることを 示すのに対し、ディレクトリベースの CGI
     だけが使われます。

     `do_GET()' および `do_HEAD()' 関数は、HTTP 要求 が
     `cgi_directories' パス以下のどこかを指している場合、
     ファイルを提供するのではなく、CGI スクリプトを実行してその出力を
     提供するように変更されています。

`CGIHTTPRequestHandler' では以下のデータメンバを定義しています:

`cgi_directories'
     この値は標準で `['/cgi-bin', '/htbin']' であり、CGI スクリプト
     を含んでいることを示すディレクトリを記述します。

`CGIHTTPRequestHandler' では以下のメソッドを定義しています:

`do_POST()'
     このメソッドは、CGI スクリプトでのみ許されている `'POST'' 型の
     HTTP 要求に対するサービスを行います。 CGI でない url に対して POST
     を試みた場合、出力は Error 501, "Can only POST to CGI scripts"
     になります。

セキュリティ上の理由から、CGI スクリプトはユーザ nobody の UID で動作
するので注意してください。CGI スクリプトが原因で発生した問題は、 Error
403 に変換されます。

使用例については、`test()' 関数の実装を参照してください。

See also:
     *Note BaseHTTPServer:: Web
     サーバとリクエスト処理機構を実装した基底クラスです。


File: python-lib-jp.info,  Node: cookielib,  Next: Cookie,  Prev: CGIHTTPServer,  Up: インターネットプロトコルとその支援

18.22 HTTP クライアント用の Cookie 処理
=======================================

_Added in Python version 2.4_

HTTP クライアント用の Cookie 処理

`cookielib' モジュールは HTTP クッキーの自動処理をおこなう
クラスを定義します。これは小さなデータの断片 - "クッキー" - を要求する
web サイトにアクセスする際に有用です。クッキーとは web サーバの HTTP
レスポンスによってクライアントのマシンに設定され、 のちの HTTP
リクエストをおこなうさいにサーバに返されるものです。

標準的な Netscape クッキープロトコルおよび RFC 2965 で定義されている
プロトコルの両方を処理できます。RFC 2965
の処理はデフォルトではオフになっています。 RFC 2109 のクッキーは
Netscape クッキーとして解析され、のちに 有効な 'ポリシー' に従って
Netscapeまたは RFC 2965 クッキーとして処理されます。
但し、インターネット上の大多数のクッキーは Netscapeクッキーです。
`cookielib' はデファクトスタンダードの Netscape クッキープロトコル
(これは元々 Netscape が策定した仕様とはかなり異なっています) に
従うようになっており、RFC 2109 で導入された `max-age' や `port' などの
クッキー属性にも注意を払います。 _Note:_ `Set-Cookie' や `Set-Cookie2'
ヘッダに現れる多種多様なパラメータの名前 (`domain' や `expires' など)
は便宜上 "属性" と呼ばれますが、 ここでは Python
の属性と区別するため、かわりに "クッキー属性" と呼ぶことにします。

このモジュールは以下の例外を定義しています:

`LoadError'
     この例外は `FileCookieJar' インスタンスがファイルからクッキーを
     読み込むのに失敗した場合に発生します。

以下のクラスが提供されています:

`CookieJar(policy=`None')'
     POLICY は `CookiePolicy'
     インターフェイスを実装するオブジェクトです。

     `CookieJar' クラスには HTTP クッキーを保管します。 これは HTTP
     リクエストに応じてクッキーを取り出し、それを HTTP
     レスポンスの中で返します。必要に応じて、 `CookieJar'
     インスタンスは保管されているクッキーを
     自動的に破棄します。このサブクラスは、クッキーをファイルや
     データベースに格納したり取り出したりする操作をおこなう役割を負っています。

`FileCookieJar(filename, delayload=`None', policy=`None')'
     POLICY は `CookiePolicy'
     インターフェイスを実装するオブジェクトです。
     これ以外の引数については、該当する属性の説明を参照してください。

     `FileCookieJar' はディスク上のファイルからのクッキーの読み込み、
     もしくは書き込みをサポートします。実際には、`load()' または
     `revert()' のどちらかのメソッドが呼ばれるまでクッキーは
     指定されたファイルからはロード*されません*。
     このクラスのサブクラスは *Note FileCookieJar のサブクラスと web
     ブラウザとの連携:: 節で説明します。

`CookiePolicy()'
     このクラスは、あるクッキーをサーバから受け入れるべきか、
     そしてサーバに返すべきかを決定する役割を負っています。

`DefaultCookiePolicy( blocked_domains=`None', allowed_domains=`None', netscape=`True', rfc2965=`False', rfc2109_as_netscape=`None', hide_cookie2=`False', strict_domain=`False', strict_rfc2965_unverifiable=`True', strict_ns_unverifiable=`False', strict_ns_domain=`DefaultCookiePolicy.DomainLiberal', strict_ns_set_initial_dollar=`False', strict_ns_set_path=`False' )'
     コンストラクタはキーワード引数しか取りません。 BLOCKED_DOMAINS
     はドメイン名からなるシーケンスで、ここからは
     決してクッキーを受けとらないし、このドメインにクッキーを返すこともありません。
     ALLOWED_DOMAINS が `None' でない場合、これはこのドメインのみから
     クッキーを受けとり、返すという指定になります。これ以外の引数については
     `CookiePolicy' および `DefaultCookiePolicy' オブジェクトの
     説明をごらんください。

     `DefaultCookiePolicy' は Netscape および RFC 2965 クッキーの
     標準的な許可 / 拒絶のルールを実装しています。デフォルトでは、RFC
     2109 のクッキー (`Set-Cookie' の version クッキー属性が 1
     で受けとられるもの) は RFC 2965 のルールで扱われます。 しかし、RFC
     2965処理が無効に設定されているか `rfc2109_as_netscape'が
     Trueの場合、RFC 2109クッキーは `CookieJar'インスタンスによって
     `Cookie'のインスタンスの `version'属性を 0に設定する事で
     Netscapeクッキーに「ダウングレード」されます。 また
     `DefaultCookiePolicy' には
     いくつかの細かいポリシー設定をおこなうパラメータが用意されています。

`Cookie()'
     このクラスは Netscape クッキー、RFC 2109 のクッキー、および RFC
     2965 のクッキーを 表現します。`cookielib' のユーザが自分で
     `Cookie' インスタンスを
     作成することは想定されていません。かわりに、必要に応じて
     `CookieJar' インスタンスの `make_cookies()'
     を呼ぶことになっています。

See also:
     *Note urllib2:: クッキーの自動処理をおこない URL
     を開くモジュールです。

     *Note Cookie:: HTTP のクッキークラスで、基本的にはサーバサイドの
     コードで有用です。`cookielib' および `Cookie' モジュールは
     互いに依存してはいません。

    `http://wwwsearch.sf.net/ClientCookie/'
          このモジュールの拡張で、 Windows 上の Microsoft Internet
          Explorer クッキーを読みこむクラスが含まれています。

    `http://www.netscape.com/newsref/std/cookie_spec.html'
          元祖 Netscape の
          クッキープロトコルの仕様です。今でもこれが主流のプロトコルですが、
          現在のメジャーなブラウザ (と `cookielib') が実装している
          「Netscape クッキープロトコル」は `cookie_spec.html'
          で述べられているものと おおまかにしか似ていません。

    *RFC2109 HTTP State Management Mechanism*
          RFC 2965 によって過去の遺物になりました。 `Set-Cookie' の
          version=1 で使います。

    *RFC2965 HTTP State Management Mechanism*
          Netscape プロトコルの バグを修正したものです。 `Set-Cookie'
          のかわりに `Set-Cookie2' を使いますが、普及してはいません。

    `http://kristol.org/cookie/errata.html'
          RFC 2965 に対する未完の正誤表です。

    *RFC2964 Use of HTTP State Management*


* Menu:

* CookieJar および FileCookieJar オブジェクト::
* FileCookieJar のサブクラスと web ブラウザとの連携::
* CookiePolicy オブジェクト::
* DefaultCookiePolicy オブジェクト::
* Cookie オブジェクト::
* 使用例 7::


File: python-lib-jp.info,  Node: CookieJar および FileCookieJar オブジェクト,  Next: FileCookieJar のサブクラスと web ブラウザとの連携,  Prev: cookielib,  Up: cookielib

18.22.1 CookieJar および FileCookieJar オブジェクト
---------------------------------------------------

`CookieJar' オブジェクトは保管されている `Cookie' オブジェクトを
ひとつずつ取り出すための、イテレータ・プロトコルをサポートしています。

`CookieJar' は以下のようなメソッドを持っています:

`add_cookie_header(request)'
     REQUEST に正しい `Cookie' ヘッダを追加します。

     ポリシーが許すようであれば (`CookieJar' の `CookiePolicy'
     インスタンスにある 属性のうち、`rfc2965' および `hide_cookie2'
     がそれぞれ 真と偽であるような場合)、必要に応じて `Cookie2'
     ヘッダも追加されます。

     REQUEST オブジェクト (通常は `urllib2.Request' インスタンス) は、
     `urllib2' のドキュメントに記されているように、 `get_full_url()',
     `get_host()', `get_type()', `unverifiable()',
     `get_origin_req_host()', `has_header()', `get_header()',
     `header_items()' および `add_unredirected_header()'
     の各メソッドをサポートしている必要があります。

`extract_cookies(response, request)'
     HTTP RESPONSE
     からクッキーを取り出し、ポリシーによって許可されていれば これを
     `CookieJar' 内に保管します。

     `CookieJar' は RESPONSE 引数の中から 許可されている `Set-Cookie'
     および `Set-Cookie2' ヘッダを 探しだし、適切に
     (`CookiePolicy.set_ok()' メソッドの承認におうじて)
     クッキーを保管します。

     RESPONSE オブジェクト (通常は `urllib2.urlopen()' あるいは
     それに類似する呼び出しによって得られます) は `info()' メソッドを
     サポートしている必要があります。これは `getallmatchingheaders()'
     メソッドのある オブジェクト (通常は `mimetools.Message'
     インスタンス) を返すものです。

     REQUEST オブジェクト (通常は `urllib2.Request' インスタンス) は
     `urllib2' のドキュメントに記されているように、 `get_full_url()',
     `get_host()', `unverifiable()' および `get_origin_req_host()'
     の各メソッドをサポートしている必要があります。 この request
     はそのクッキーの保存が許可されているかを検査するとともに、
     クッキー属性のデフォルト値を設定するのに使われます。

`set_policy(policy)'
     使用する `CookiePolicy' インスタンスを指定します。

`make_cookies(response, request)'
     RESPONSE オブジェクトから得られた `Cookie' オブジェクトからなる
     シーケンスを返します。

     RESPONSE および REQUEST 引数で要求されるインスタンスについては、
     `extract_cookies' の説明を参照してください。

`set_cookie_if_ok(cookie, request)'
     ポリシーが許すのであれば、与えられた `Cookie' を設定します。

`set_cookie(cookie)'
     与えられた `Cookie' を、それが設定されるべきかどうかの
     ポリシーのチェックを行わずに設定します。

`clear([domain[, path[, name]]])'
     いくつかのクッキーを消去します。

     引数なしで呼ばれた場合は、すべてのクッキーを消去します。
     引数がひとつ与えられた場合、その DOMAIN
     に属するクッキーのみを消去します。
     ふたつの引数が与えられた場合、指定された DOMAIN と URL PATH に
     属するクッキーのみを消去します。引数が 3つ与えられた場合、 DOMAIN,
     PATH および NAME で指定されるクッキーが消去されます。

     与えられた条件に一致するクッキーがない場合は `KeyError'
     を発生させます。

`clear_session_cookies()'
     すべてのセッションクッキーを消去します。

     保存されているクッキーのうち、`discard' 属性が真になっているもの
     すべてを消去します (通常これは `max-age' または `expires' の
     どちらのクッキー属性もないか、あるいは明示的に `discard'
     クッキー属性が
     指定されているものです)。対話的なブラウザの場合、セッションの終了は
     ふつうブラウザのウィンドウを閉じることに相当します。

     注意: IGNORE_DISCARD 引数に真を指定しないかぎり、 `save()'
     メソッドはセッションクッキーは保存しません。

さらに `FileCookieJar' は以下のようなメソッドを実装しています:

`save(filename=`None', ignore_discard=`False', ignore_expires=`False')'
     クッキーをファイルに保存します。

     この基底クラスは  `NotImplementedError' を発生させます。
     サブクラスはこのメソッドを実装しないままにしておいてもかまいません。

     FILENAME はクッキーを保存するファイルの名前です。 FILENAME
     が指定されない場合、 `self.filename' が使用されます
     (このデフォルト値は、それが存在する場合は、コンストラクタに渡されています)。
     `self.filename' も `None' の場合は `ValueError' が発生します。

     IGNORE_DISCARD:
     破棄されるよう指示されていたクッキーでも保存します。
     IGNORE_EXPIRES: 期限の切れたクッキーでも保存します。

     ここで指定されたファイルがもしすでに存在する場合は上書きされるため、
     以前にあったクッキーはすべて消去されます。保存したクッキーはあとで
     `load()' または `revert()' メソッドを使って復元することができます。

`load(filename=`None', ignore_discard=`False', ignore_expires=`False')'
     ファイルからクッキーを読み込みます。

     それまでのクッキーは新しいものに上書きされない限り残ります。

     ここでの引数の値は `save()' と同じです。

     名前のついたファイルはこのクラスがわかるやり方で指定する必要があります。
     さもないと `LoadError' が発生します。
     さらに、例えばファイルが存在しないような時に `IOError' が
     発生する場合があります。 _Note:_ (`IOError'を発行する)Python
     2.4との 後方互換性のために、`LoadError'は `IOError'のサブクラス
     です。

`revert(filename=`None', ignore_discard=`False', ignore_expires=`False')'
     すべてのクッキーを破棄し、保存されているファイルから読み込み直します。

     `revert()' は `load()' と同じ例外を発生させる事ができます。
     失敗した場合、オブジェクトの状態は変更されません。

`FileCookieJar' インスタンスは以下のような公開の属性をもっています:

`filename'
     クッキーを保存するデフォルトのファイル名を指定します。
     この属性には代入することができます。

`delayload'
     真であれば、クッキーを読み込むさいにディスクから遅延読み込み
     (lazy) します。
     この属性には代入することができません。この情報は単なるヒントであり、
     (ディスク上のクッキーが変わらない限りは)
     インスタンスのふるまいには影響を与えず、
     パフォーマンスのみに影響します。`CookieJar'
     オブジェクトはこの値を無視することもあります。
     標準ライブラリに含まれている `FileCookieJar' クラスで遅延読み込みを
     おこなうものはありません。


File: python-lib-jp.info,  Node: FileCookieJar のサブクラスと web ブラウザとの連携,  Next: CookiePolicy オブジェクト,  Prev: CookieJar および FileCookieJar オブジェクト,  Up: cookielib

18.22.2 FileCookieJar のサブクラスと web ブラウザとの連携
---------------------------------------------------------

クッキーの読み書きのために、 以下の `CookieJar'
サブクラスが提供されています。 これ以外の `CookieJar'
サブクラスは、Microsoft Internet Explorer
ブラウザのクッキーを読みこむものも含め、
`http://wwwsearch.sf.net/ClientCookie/' から使用可能です。

`MozillaCookieJar(filename, delayload=`None', policy=`None')'
     Mozilla の `cookies.txt' ファイル形式 (この形式はまた Lynx と
     Netscape ブラウザによっても使われています)
     でディスクにクッキーを読み書きするための `FileCookieJar' です。
     _Note:_ このクラスは RFC 2965 クッキーに関する
     情報を失います。また、より新しいか、標準でない `port' などの
     クッキー属性についての情報も失います。

     _もしクッキーの損失や欠損が望ましくない場合は、クッキーを保存する前に
     バックアップを取っておくようにしてください (ファイルへの読み込み /
     保存を くり返すと微妙な変化が生じる場合があります)。_

     また、 Mozilla の起動中にクッキーを保存すると、 Mozilla
     によって内容が破壊されてしまうことにも注意してください。

`LWPCookieJar(filename, delayload=`None', policy=`None')'
     libwww-perl のライブラリである `Set-Cookie3' ファイル形式で
     ディスクにクッキーを読み書きするための `FileCookieJar' です。
     これはクッキーを人間に可読な形式で保存するのに向いています。


File: python-lib-jp.info,  Node: CookiePolicy オブジェクト,  Next: DefaultCookiePolicy オブジェクト,  Prev: FileCookieJar のサブクラスと web ブラウザとの連携,  Up: cookielib

18.22.3 CookiePolicy オブジェクト
---------------------------------

`CookiePolicy' インターフェイスを実装するオブジェクトは
以下のようなメソッドを持っています:

`set_ok(cookie, request)'
     クッキーがサーバから受け入れられるべきかどうかを表わす boolean
     値を返します。

     COOKIE は `cookielib.Cookie' インスタンスです。 REQUEST は
     `CookieJar.extract_cookies()'
     の説明で定義されているインターフェイスを 実装するオブジェクトです。

`return_ok(cookie, request)'
     クッキーがサーバに返されるべきかどうかを表わす boolean
     値を返します。

     COOKIE は `cookielib.Cookie' インスタンスです。 REQUEST は
     `CookieJar.add_cookie_header()'
     の説明で定義されているインターフェイスを 実装するオブジェクトです。

`domain_return_ok(domain, request)'
     与えられたクッキーのドメインに対して、そこにクッキーを返すべきでない場合には
     false を返します。

     このメソッドは高速化のためのものです。これにより、すべてのクッキーをある特定の
     ドメインに対してチェックする
     (これには多数のファイル読みこみを伴なう場合があります)
     必要がなくなります。 `domain_return_ok()' および
     `path_return_ok()' の 両方から true が返された場合、すべての決定は
     `return_ok()' に委ねられます。

     もし、このクッキードメインに対して `domain_return_ok()' が true
     を返すと、 つぎにそのクッキーのパス名に対して `path_return_ok()'
     が呼ばれます。 そうでない場合、そのクッキードメインに対する
     `path_return_ok()' および `return_ok()'
     は決して呼ばれることはありません。`path_return_ok()' が true
     を返すと、 `return_ok()' がその `Cookie'
     オブジェクト自身の全チェックのために
     呼ばれます。そうでない場合、そのクッキーパス名に対する
     `return_ok()' は 決して呼ばれることはありません。

     注意: `domain_return_ok()' は _request_ ドメインだけではなく、
     すべての _cookie_ ドメインに対して呼ばれます。たとえば request
     ドメインが `"www.example.com"' だった場合、この関数は
     `".example.com"' および `"www.example.com"'
     の両方に対して呼ばれることがあります。 同じことは
     `path_return_ok()' にもいえます。

     REQUEST 引数は `return_ok()' で説明されているとおりです。

`path_return_ok(path, request)'
     与えられたクッキーのパス名に対して、そこにクッキーを返すべきでない場合には
     false を返します。

     `domain_return_ok()' の説明を参照してください。

上のメソッドの実装にくわえて、`CookiePolicy' インターフェイスの実装では
以下の属性を設定する必要があります。これはどのプロトコルがどのように使われるべきかを
示すもので、これらの属性にはすべて代入することが許されています。

`netscape'
     Netscape プロトコルを実装していることを示します。

`rfc2965'
     RFC 2965 プロトコルを実装していることを示します。

`hide_cookie2'
     `Cookie2' ヘッダをリクエストに含めないようにします
     (このヘッダが存在する場合、私たちは RFC 2965 クッキーを理解すると
     いうことをサーバに示すことになります)。

もっとも有用な方法は、`DefaultCookiePolicy' をサブクラス化した
`CookiePolicy' クラスを定義して、いくつか (あるいはすべて) の
メソッドをオーバーライドすることでしょう。`CookiePolicy' 自体は
どのようなクッキーも受け入れて設定を許可する「ポリシー無し」ポリシーとして
使うこともできます (これが役に立つことはあまりありませんが)。


File: python-lib-jp.info,  Node: DefaultCookiePolicy オブジェクト,  Next: Cookie オブジェクト,  Prev: CookiePolicy オブジェクト,  Up: cookielib

18.22.4 DefaultCookiePolicy オブジェクト
----------------------------------------

クッキーを受けつけ、またそれを返す際の標準的なルールを実装します。

RFC 2965 クッキーと Netscape クッキーの両方に対応しています。
デフォルトでは、RFC 2965 の処理はオフになっています。

自分のポリシーを提供するいちばん簡単な方法は、このクラスを継承して、
自分用の追加チェックの前にオーバーライドした元のメソッドを呼び出すことです:

     import cookielib
     class MyCookiePolicy(cookielib.DefaultCookiePolicy):
         def set_ok(self, cookie, request):
             if not cookielib.DefaultCookiePolicy.set_ok(self, cookie, request):
                 return False
             if i_dont_want_to_store_this_cookie(cookie):
                 return False
             return True

`CookiePolicy' インターフェイスを実装するのに必要な機能に加えて、
このクラスではクッキーを受けとったり設定したりするドメインを
許可したり拒絶したりできるようになっています。ほかにも、 Netscape
プロトコルのかなり緩い規則をややきつくするために、いくつかの
厳密性のスイッチがついています
(いくつかの良性クッキーをブロックする危険性もありますが)。

ドメインのブラックリスト機能やホワイトリスト機能も提供されています
(デフォルトではオフになっています)。
ブラックリストになく、(ホワイトリスト機能を使用している場合は)
ホワイトリストにある
ドメインのみがクッキーを設定したり返したりすることを許可されます。
コンストラクタの引数 BLOCKED_DOMAINS、および `blocked_domains()' と
`set_blocked_domains()' メソッドを 使ってください (ALLOWED_DOMAINS
に関しても同様の対応する引数とメソッドがあります)。
ホワイトリストを設定した場合は、それを `None' にすることで
ホワイトリスト機能をオフにすることができます。

ブラックリストあるいはホワイトリスト中にあるドメインのうち、 ドット (.)
で始まっていないものは、正確にそれと一致する
ドメインのクッキーにしか適用されません。たとえば
ブラックリスト中のエントリ `"example.com"' は、 `"example.com"'
にはマッチしますが、`"www.example.com"' にはマッチしません。 一方ドット
(.) で始まっているドメインは、より特化されたドメインともマッチします。
たとえば、`".example.com"' は、`"www.example.com"' と
`"www.coyote.example.com"' の両方にマッチします (が、`"example.com"'
自身にはマッチしません)。IP アドレスは例外で、
つねに正確に一致する必要があります。たとえば、かりに BLOCKED_DOMAINS が
`"192.168.1.2"' と `".168.1.2"' を 含んでいたとして、192.168.1.2
はブロックされますが、 193.168.1.2 はブロックされません。

`DefaultCookiePolicy' は以下のような追加メソッドを実装しています:

`blocked_domains()'
     ブロックしているドメインのシーケンスを (タプルとして) 返します。

`set_blocked_domains(blocked_domains)'
     ブロックするドメインを設定します。

`is_blocked(domain)'
     DOMAIN
     がクッキーを授受しないブラックリストに載っているかどうかを返します。

`allowed_domains()'
     `None' あるいは明示的に許可されているドメインを (タプルとして)
     返します。

`set_allowed_domains(allowed_domains)'
     許可するドメイン、あるいは `None' を設定します。

`is_not_allowed(domain)'
     DOMAIN
     がクッキーを授受するホワイトリストに載っているかどうかを返します。

`DefaultCookiePolicy' インスタンスは以下の属性をもっています。
これらはすべてコンストラクタから同じ名前の引数をつかって初期化することができ、
代入してもかまいません。

`rfc2109_as_netscape'
     Trueの場合、`CookieJar' のインスタンスに RFC 2109 クッキー (即ち
     `Set-Cookie'ヘッダのVersion cookie属性の値が1のクッキー)を
     Netscapeクッキーへ、`Cookie'
     インスタンスのversion属性を0に設定する事で
     ダウングレードするように要求します。デフォルトの値は `None'で
     あり、この場合 RFC 2109 クッキーは RFC 2965
     処理が無効に設定されている
     場合に限りダウングレードされます。それ故に RFC 2109
     クッキーはデフォルトでは ダウングレードされます。 _Added in Python
     version 2.5_

一般的な厳密性のスイッチ:

`strict_domain'
     サイトに、 国別コードとトップレベルドメインだけからなるドメイン名
     (`.co.uk', `.gov.uk', `.co.nz' など) を設定させないようにします。
     これは完璧からはほど遠い実装であり、いつもうまくいくとは限りません!

RFC 2965 プロトコルの厳密性に関するスイッチ:

`strict_rfc2965_unverifiable'
     検証不可能なトランザクション (通常これはリダイレクトか、
     別のサイトがホスティングしているイメージの読み込み要求です)
     に関する RFC 2965
     の規則に従います。この値が偽の場合、検証可能性を基準にして
     クッキーがブロックされることは_決して_ありません。

Netscape プロトコルの厳密性に関するスイッチ:

`strict_ns_unverifiable'
     検証不可能なトランザクションに関する RFC 2965 の規則を Netscape
     クッキーに 対しても適用します。

`strict_ns_domain'
     Netscape
     クッキーに対するドメインマッチングの規則をどの程度厳しくするかを
     指示するフラグです。とりうる値については下の説明を見てください。

`strict_ns_set_initial_dollar'
     Set-Cookie: ヘッダで、`'$'' で始まる名前のクッキーを無視します。

`strict_ns_set_path'
     要求した URI にパスがマッチしないクッキの設定を禁止します。

`strict_ns_domain' はいくつかのフラグの集合です。 これはいくつかの値を
or することで構成します (たとえば
`DomainStrictNoDots|DomainStrictNonDomain' は両方のフラグが
設定されていることになります)。

`DomainStrictNoDots'
     クッキーを設定するさい、ホスト名のプレフィクスにドットが含まれるのを
     禁止します (例: `www.foo.bar.com' は `.bar.com'
     のクッキーを設定することはできません、 なぜなら `www.foo'
     はドットを含んでいるからです)。

`DomainStrictNonDomain'
     `domain' クッキー属性を明示的に指定していないクッキーは、
     そのクッキーを設定したドメインと同一のドメインだけに返されます
     (例: `example.com' からのクッキーに `domain' クッキー属性が
     ない場合、そのクッキーが `spam.example.com'
     に返されることはありません)。

`DomainRFC2965Match'
     クッキーを設定するさい、RFC 2965
     の完全ドメインマッチングを要求します。

以下の属性は上記のフラグのうちもっともよく使われる組み合わせで、
便宜をはかるために提供されています。

`DomainLiberal'
     0 と同じです (つまり、上述の Netscape のドメイン厳密性フラグが
     すべてオフにされます)。

`DomainStrict'
     `DomainStrictNoDots|DomainStrictNonDomain' と同じです。


File: python-lib-jp.info,  Node: Cookie オブジェクト,  Next: 使用例 7,  Prev: DefaultCookiePolicy オブジェクト,  Up: cookielib

18.22.5 Cookie オブジェクト
---------------------------

`Cookie' インスタンスは、さまざまなクッキーの標準で規定されている
標準的なクッキー属性とおおまかに対応する Python 属性をもっています。
しかしデフォルト値を決める複雑なやり方が存在しており、 また `max-age'
および `expires' クッキー属性は 同じ値をもつことになっているので、また
RFC 2109クッキーは `cookielib'によって version 1から version 0
(Netscape)クッキーへ 'ダウングレード' される場合があるため、 この対応は
1対 1 ではありません。

`CookiePolicy' メソッド内でのごくわずかな例外を除けば、
これらの属性に代入する必要はないはずです。このクラスは
内部の一貫性を保つようにはしていないため、代入するのは
自分のやっていることを理解している場合のみにしてください。

`version'
     整数または `None'。 Netscape クッキーは バージョン 0 であり、 RFC
     2965 および RFC 2109 クッキーは バージョン 1 です。
     しかし、`cookielib' は RFC 2109クッキーを Netscapeクッキー
     (`version'が 0)に'ダウングレード'する場合がある事に注意して下さい。

`name'
     クッキーの名前 (文字列)。

`value'
     クッキーの値 (文字列)、あるいは `None'。

`port'
     ポートあるいはポートの集合をあらわす文字列 (例: '80' または
     '80,8080')、 あるいは `None'。

`path'
     クッキーのパス名 (文字列、例:`'/acme/rocket_launchers'')。

`secure'
     そのクッキーを返せるのが安全な接続のみならば真を返します。

`expires'
     クッキーの期限が切れる日時をあわらす整数
     (エポックから経過した秒数)、 あるいは `None'。`is_expired()'
     も参照してください。

`discard'
     これがセッションクッキーであれば真を返します。

`comment'
     このクッキーの働きを説明する、サーバからのコメント文字列、
     あるいは `None'。

`comment_url'
     このクッキーの働きを説明する、サーバからのコメントのリンク URL、
     あるいは `None'。

`rfc2109'
     RFC 2109クッキー(即ち `Set-Cookie'ヘッダにあり、 かつVersion
     cookie属性の値が1のクッキー)の場合、Trueを返します。 `cookielib'が
     RFC 2109クッキーを Netscapeクッキー (`version' が
     0)に'ダウングレード'する場合があるので、
     この属性が提供されています。 _Added in Python version 2.5_

`port_specified'
     サーバがポート、あるいはポートの集合を (`Set-Cookie' /
     `Set-Cookie2' ヘッダ内で) 明示的に指定していれば真を返します。

`domain_specified'
     サーバがドメインを明示的に指定していれば真を返します。

`domain_initial_dot'
     サーバが明示的に指定したドメインが、ドット (`'.'')
     で始まっていれば真を返します。

クッキーは、オプションとして標準的でないクッキー属性を持つこともできます。
これらは以下のメソッドでアクセスできます:

`has_nonstandard_attr(name)'
     そのクッキーが指定された名前のクッキー属性をもっている場合には真を返します。

`get_nonstandard_attr(name, default=`None')'
     クッキーが指定された名前のクッキー属性をもっていれば、その値を返します。
     そうでない場合は DEFAULT を返します。

`set_nonstandard_attr(name, value)'
     指定された名前のクッキー属性を設定します。

`Cookie' クラスは以下のメソッドも定義しています:

`is_expired([now=`None'])'
     サーバが指定した、クッキーの期限が切れるべき時が過ぎていれば真を返します。
     NOW が指定されているときは (エポックから経過した秒数です)、
     そのクッキーが指定された時間において期限切れになっているかどうかを判定します。


File: python-lib-jp.info,  Node: 使用例 7,  Prev: Cookie オブジェクト,  Up: cookielib

18.22.6 使用例
--------------

はじめに、もっとも一般的な `cookielib' の使用例をあげます:

     import cookielib, urllib2
     cj = cookielib.CookieJar()
     opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
     r = opener.open("http://example.com/")

以下の例では、 URL を開く際に Netscape や Mozilla または Lynx
のクッキーを 使う方法を示しています (クッキーファイルの位置は
UNIX/Netscape の慣例に したがうものと仮定しています):

     import os, cookielib, urllib2
     cj = cookielib.MozillaCookieJar()
     cj.load(os.path.join(os.environ["HOME"], ".netscape/cookies.txt"))
     opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
     r = opener.open("http://example.com/")

つぎの例は `DefaultCookiePolicy' の使用例です。 RFC 2965
クッキーをオンにし、Netscape クッキーを設定したり返したりするドメインに
対してより厳密な規則を適用します。そしていくつかのドメインから
クッキーを設定あるいは返還するのをブロックしています:

     import urllib2
     from cookielib import CookieJar, DefaultCookiePolicy
     policy = DefaultCookiePolicy(
         rfc2965=True, strict_ns_domain=Policy.DomainStrict,
         blocked_domains=["ads.net", ".ads.net"])
     cj = CookieJar(policy)
     opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))
     r = opener.open("http://example.com/")


File: python-lib-jp.info,  Node: Cookie,  Next: xmlrpclib,  Prev: cookielib,  Up: インターネットプロトコルとその支援

18.23 HTTPの状態管理
====================

HTTP状態管理(cookies)のサポート。

`Cookie'モジュールはHTTPの状態管理機能であるcookieの概念を抽象
化、定義しているクラスです。単純な文字列のみで構成されるcookieのほか、
シリアル化可能なあらゆるデータ型でクッキーの値を保持するための機能も備
えています。

このモジュールは元々RFC 2109 とRFC 2068 に定義されている構文解析の規
則を厳密に守っていました。しかし、MSIE 3.0xがこれらのRFCで定義された文
字の規則に従っていないことが判明したため、結局、やや厳密さを欠く構文
解析規則にせざるを得ませんでした。

`CookieError'
     属性や`Set-Cookie'ヘッダが正しくないなど、RFC 2109 に合致してい
     ないときに発生する例外です。

`BaseCookie([input])'
     このクラスはキーが文字列、値が`Morsel'インスタンスで構成される辞書風オブジェ
     クトです。値に対するキーを設定するときは、値がキーと値を含む
     `Morsel'に変換されることに注意してください。

     INPUTが与えられたときは、そのまま`load()'メソッドへ渡され ます。

`SimpleCookie([input])'
     このクラスは`BaseCookie'の派生クラスで、`value_decode()'
     は与えられた値の正当性を確認するように、`value_encode()'は
     `str()'で文字列化するようにそれぞれオーバライドします。

`SerialCookie([input])'
     このクラスは`BaseCookie'の派生クラスで、`value_decode()'
     と`value_encode()'をそれぞれ`pickle.loads()'と
     `pickle.dumps()'を実行するようにオーバーライドします。

     _This is deprecated in Python 2.3.
     このクラスを使ってはいけません! 信頼できないcookieのデータか ら
     pickle
     化された値を読み込むことは、あなたのサーバ上で任意のコードを
     実行するために pickle
     化した文字列の作成が可能であることを意味し、重大
     なセキュリティホールとなります。_


`SmartCookie([input])'
     このクラスは`BaseCookie'の派生クラスで、`value_decode()' を、値が
     pickle 化されたデータとして正当なときは
     `pickle.loads()'を実行、そうでないときはその値自体を返すよう
     にオーバーライドします。また`value_encode()'を、値が文字列以外
     のときは`pickle.dumps()'を実行、文字列のときはその値自体を返
     すようにオーバーライドします。

     _This is deprecated in Python 2.3.
     `SerialCookie'と同じセキュリティ上の注意が当ては まります。_


関連して、さらなるセキュリティ上の注意があります。後方互換性のため、
`Cookie'モジュールは`Cookie'というクラス名を
`SmartCookie'のエイリアスとしてエクスポートしています。これはほ
ぼ確実に誤った措置であり、将来のバージョンでは削除することが適当と思わ
れます。アプリケーションにおいて`SerialCookie'クラスを使うべきで
ないのと同じ理由で`Cookie'クラスを使うべきではありません。

See also:
     *Note cookielib:: Web_クライアント_向けの HTTP クッキー処理です。
     `cookielib'と`Cookie'は互いに独立しています。

    *RFC2109 HTTP State Management Mechanism*
          このモジュールが実装 しているHTTPの状態管理に関する規格です。


* Menu:

* Cookieオブジェクト::
* Morselオブジェクト::
* 例 13::


File: python-lib-jp.info,  Node: Cookieオブジェクト,  Next: Morselオブジェクト,  Prev: Cookie,  Up: Cookie

18.23.1 Cookieオブジェクト
--------------------------

`value_decode(val)'
     文字列表現を値にデコードして返します。戻り値の型はどのようなものでも許
     されます。このメソッドは`BaseCookie'において何も実行せず、オーバー
     ライドされるためにだけ存在します。

`value_encode(val)'
     エンコードした値を返します。元の値はどのような型でもかまいませんが、戻
     り値は必ず文字列となります。このメソッドは`BaseCookie'において何
     も実行せず、オーバーライドされるためにだけ存在します。

     通常`value_encode()'と`value_decode()'はともに
     VALUE_DECODEの処理内容から逆算した範囲に収まっていなければなりま
     せん。

`output([attrs[, header[, sep]]])'
     HTTPヘッダ形式の文字列表現を返します。ATTRSとHEADERはそれ
     ぞれ`Morsel'の`output()'メソッドに送られます。SEP
     はヘッダの連結に用いられる文字で、デフォルトは`'\r\n''
     (CRLF)となっています。 _Changed in Python version 2.5_

`output([attrs[, header[, sep]]])'
     HTTPヘッダ形式の文字列表現を返します。

`js_output([attrs])'
     ブラウザがJavaScriptをサポートしている場合、HTTPヘッダを送信した場合と
     同様に動作する埋め込み可能なJavaScript snippetを返します。

     ATTRSの意味は`output()'と同じです。

`load(rawdata)'
     RAWDATAが文字列であれば、`HTTP_COOKIE'として処理し、その値
     を`Morsel'として追加します。辞書の場合は次と同様の処理をおこない
     ます。

          for k, v in rawdata.items():
              cookie[k] = v



File: python-lib-jp.info,  Node: Morselオブジェクト,  Next: 例 13,  Prev: Cookieオブジェクト,  Up: Cookie

18.23.2 Morselオブジェクト
--------------------------

`Morsel()'
     RFC 2109 の属性をキーと値で保持するabstractクラスです。

     Morselは辞書風のオブジェクトで、キーは次のようなRFC 2109 準拠の定数と
     なっています。

        * `expires'

        * `path'

        * `comment'

        * `domain'

        * `max-age'

        * `secure'

        * `version'

     キーの大小文字は区別されます。

`value'
     クッキーの値。

`coded_value'
     実際に送信する形式にエンコードされたcookieの値。

`key'
     cookieの名前。

`set(key, value, coded_value)'
     メンバKEY、VALUE、CODED_VALUEに値をセットします。

`isReservedKey(K)'
     Kが`Morsel'のキーであるかどうかを判定します。

`output([attrs[, header]])'
     MoselをHTTPヘッダ形式の文字列表現にして返します。ATTRS を指定しない
     場合、デフォルトですべての属性を含めます。ATTRSを指定する場合，
     属性をリストで渡さなければなりません。HEADERのデフォルトは
     `"Set-Cookie:"'です。

`js_output([attrs])'
     ブラウザがJavaScriptをサポートしている場合、HTTPヘッダを送信した場合と
     同様に動作する埋め込み可能なJavaScript snippetを返します。

     ATTRSの意味は`output()'と同じです。

`OutputString([attrs])'
     Moselの文字列表現をHTTPやJavaScriptで囲まずに出力します。

     ATTRSの意味は`output()'と同じです。


File: python-lib-jp.info,  Node: 例 13,  Prev: Morselオブジェクト,  Up: Cookie

18.23.3 例
----------

次の例は`Cookie'の使い方を示したものです。

     >>> import Cookie
     >>> C = Cookie.SimpleCookie()
     >>> C = Cookie.SerialCookie()
     >>> C = Cookie.SmartCookie()
     >>> C["fig"] = "newton"
     >>> C["sugar"] = "wafer"
     >>> print C # generate HTTP headers
     Set-Cookie: sugar=wafer
     Set-Cookie: fig=newton
     >>> print C.output() # same thing
     Set-Cookie: sugar=wafer
     Set-Cookie: fig=newton
     >>> C = Cookie.SmartCookie()
     >>> C["rocky"] = "road"
     >>> C["rocky"]["path"] = "/cookie"
     >>> print C.output(header="Cookie:")
     Cookie: rocky=road; Path=/cookie
     >>> print C.output(attrs=[], header="Cookie:")
     Cookie: rocky=road
     >>> C = Cookie.SmartCookie()
     >>> C.load("chips=ahoy; vienna=finger") # load from a string (HTTP header)
     >>> print C
     Set-Cookie: vienna=finger
     Set-Cookie: chips=ahoy
     >>> C = Cookie.SmartCookie()
     >>> C.load('keebler="E=everybody; L=\\"Loves\\"; fudge=\\012;";')
     >>> print C
     Set-Cookie: keebler="E=everybody; L=\"Loves\"; fudge=\012;"
     >>> C = Cookie.SmartCookie()
     >>> C["oreo"] = "doublestuff"
     >>> C["oreo"]["path"] = "/"
     >>> print C
     Set-Cookie: oreo=doublestuff; Path=/
     >>> C = Cookie.SmartCookie()
     >>> C["twix"] = "none for you"
     >>> C["twix"].value
     'none for you'
     >>> C = Cookie.SimpleCookie()
     >>> C["number"] = 7 # equivalent to C["number"] = str(7)
     >>> C["string"] = "seven"
     >>> C["number"].value
     '7'
     >>> C["string"].value
     'seven'
     >>> print C
     Set-Cookie: number=7
     Set-Cookie: string=seven
     >>> C = Cookie.SerialCookie()
     >>> C["number"] = 7
     >>> C["string"] = "seven"
     >>> C["number"].value
     7
     >>> C["string"].value
     'seven'
     >>> print C
     Set-Cookie: number="I7\012."
     Set-Cookie: string="S'seven'\012p1\012."
     >>> C = Cookie.SmartCookie()
     >>> C["number"] = 7
     >>> C["string"] = "seven"
     >>> C["number"].value
     7
     >>> C["string"].value
     'seven'
     >>> print C
     Set-Cookie: number="I7\012."
     Set-Cookie: string=seven


File: python-lib-jp.info,  Node: xmlrpclib,  Next: SimpleXMLRPCServer,  Prev: Cookie,  Up: インターネットプロトコルとその支援

18.24 XML-RPC クライアントアクセス
==================================

XML-RPC client access.

_Added in Python version 2.2_

XML-RPCはXMLを利用した遠隔手続き呼び出し(Remote Procedure Call)の一種
で、HTTPをトランスポートとして使用します。XML-RPCでは、クライアントはリ
モートサーバ(URIで指定されたサーバ)上のメソッドをパラメータを指定して呼
び出し、構造化されたデータを取得します。このモジュールは、XML-RPCクライ
アントの開発をサポートしており、Pythonオブジェクトに適合する転送用XMLの
変換の全てを行います。

`ServerProxy(uri[, transport[, encoding[, verbose[,  allow_none[, use_datetime]]]]])'
     `ServerProxy'は、リモートのXML-RPCサーバとの通信を管理するオブジェ
     クトです。最初のパラメータはURI(Uniform Resource
     Indicator)で、通常は
     サーバのURLを指定します。2番目のパラメータにはトランスポート・ファクトリ
     を指定する事ができます。トランスポート・ファクトリを省略した場合、URLが
     https: ならモジュール内部の`SafeTransport'インスタンスを使用し、そ
     れ以外の場合にはモジュール内部の`Transport'インスタンスを使用しま
     す。オプションの 3 番目の引数はエンコード方法で、デフォルトでは
     UTF-8 です。オプションの 4 番目の引数はデバッグフラグです。
     ALLOW_NONE が真の場合、Python の定数 `None' は XML に翻訳されます;
     デフォルトの動作は `None' に対して `TypeError' を送出します。
     この仕様は XML-RPC 仕様でよく用いられている拡張ですが、
     全てのクライアントやサーバでサポートされているわけではありません;
     詳細記述については `http://ontosys.com/xml-rpc/extensions.html'
     を参照してください。
     USE_DATETIMEフラグは``datetime'.datetime'のオブジェクトとして
     日付/時刻を表現する時に使用し、デフォルトでは false
     に設定されています。 ``datetime'.datetime'、
     ``datetime'.date'および``datetime'.time'
     のオブジェクトを渡すことができます。
     ``datetime'.date'オブジェクトは 時刻"00:00:00"に変換されます。
     ``datetime'.time'オブジェクトは、 今日の日付に変換されます。

     HTTP及びHTTPS通信の両方で、`http://user:pass@host:port/path'のよう
     なHTTP基本認証のための拡張URL構文をサポートしています。`user:pass'
     はbase64でエンコードしてHTTPの`Authorization'ヘッダとなり、XML-RPCメソッ
     ド呼び出し時に接続処理の一部としてリモートサーバに送信されます。リモート
     サーバが基本認証を要求する場合のみ、この機能を利用する必要があります。

     生成されるインスタンスはリモートサーバへのプロクシオブジェクトで、RPC呼
     び出しを行う為のメソッドを持ちます。リモートサーバがイントロスペクション
     APIをサポートしている場合は、リモートサーバのサポートするメソッドを検索
     (サービス検索)やサーバのメタデータの取得なども行えます。

     `ServerProxy'インスタンスのメソッドは引数としてPythonの基礎型とオ
     ブジェクトを受け取り、戻り値としてPythonの基礎型かオブジェクトを返しま
     す。以下の型をXMLに変換(XMLを通じてマーシャルする)する事ができます(特別
     な指定がない限り、逆変換でも同じ型として変換されます):

     名前                               意味
     ------                             -----
     boolean                            定数`True'と`False'
     整数                               そのまま
     浮動小数点                         そのまま
     文字列                             そのまま
     配列                               変換可能な要素を含むPythonシーケンス。
                                        戻り値はリスト。
     構造体                             Pythonの辞書。キーは文字列のみ。全ての値は変換可能でな
                                        くてはならない。
     日付                               エポックからの経過秒数。引数として指定する時は
                                        `DataTime'ラッパクラスまたは、
                                        ``datetime'.datetime'、
                                        ``datetime'.date'、
                                        ``datetime'.time'のいずれかのインスタンスを使用する。
     バイナリ                           `Binary'ラッパクラスのインスタンス

     上記のXML-RPCでサポートする全データ型を使用することができます。メソッド
     呼び出し時、XML-RPCサーバエラーが発生すると`Fault'インスタンス
     を送出し、HTTP/HTTPSトランスポート層でエラーが発生した場合には
     `ProtocolError'を送出します。 `Error'をベースとする
     `Fault'と`ProtocolError'の両方が発生します。 Python
     2.2以降では組み込み型のサ
     ブクラスを作成する事ができますが、現在のところxmlrpclibではそのようなサ
     ブクラスのインスタンスをマーシャルすることはできません。

     文字列を渡す場合、`<'・`>'・`&'などのXMLで特殊な意味を持
     つ文字は自動的にエスケープされます。しかし、ASCII値0〜31の制御文字などの
     XMLで使用することのできない文字を使用することはできず、使用するとその
     XML-RPCリクエストはwell-formedなXMLとはなりません。そのような文字列を渡
     す必要がある場合は、後述の`Binary'ラッパクラスを使用してください。

     `Server'は、上位互換性の為に`ServerProxy'の別名として残され
     ています。新しいコードでは`ServerProxy'を使用してください。

     _Changed in Python version 2.5_

See also:
     `XML-RPC HOWTO'{週種類のプログラミング言語で記述された
     XMLの操作とクライアントソフトウェアの素晴らしい
     説明が掲載されています。
     XML-RPCクライアントの開発者が知っておくべきことが
     ほとんど全て記載されています。} `XML-RPC-Hacks
     page'{イントロスペクションとマルチコールを
     サポートしているオープンソースの拡張ライブラリについて説明しています。}

* Menu:

* ServerProxy オブジェクト::
* Boolean オブジェクト::
* DateTime オブジェクト::
* Binary オブジェクト::
* Fault オブジェクト::
* ProtocolError オブジェクト::
* MultiCall オブジェクト::
* 補助関数::
* クライアントのサンプル::


File: python-lib-jp.info,  Node: ServerProxy オブジェクト,  Next: Boolean オブジェクト,  Prev: xmlrpclib,  Up: xmlrpclib

18.24.1 ServerProxy オブジェクト
--------------------------------

`ServerProxy'インスタンスの各メソッドはそれぞれXML-RPCサーバの遠隔
手続き呼び出しに対応しており、メソッドが呼び出されると名前と引数をシグネ
チャとしてRPCを実行します(同じ名前のメソッドでも、異なる引数シグネチャに
よってオーバロードされます)。RPC実行後、変換された値を返すか、または
`Fault'オブジェクトもしくは`ProtocolError'オブジェクトでエ
ラーを通知します。

予約メンバ`system'から、XMLイントロスペクションAPIの一般的なメソ
ッドを利用する事ができます。

`system.listMethods()'
     XML-RPCサーバがサポートするメソッド名(system以外)を格納する文字列のリス
     トを返します。

`system.methodSignature(name)'
     XML-RPCサーバで実装されているメソッドの名前を指定し、利用可能なシグネチ
     ャの配列を取得します。シグネチャは型のリストで、先頭の型は戻り値の型を示
     し、以降はパラメータの型を示します。

     XML-RPCでは複数のシグネチャ(オーバロード)を使用することができるので、単
     独のシグネチャではなく、シグネチャのリストを返します。

     シグネチャは、メソッドが使用する最上位のパラメータにのみ適用されます。例
     えばあるメソッドのパラメータが構造体の配列で戻り値が文字列の場合、シグネ
     チャは単に"文字列, 配列"
     となります。パラメータが三つの整数で戻り値が文
     字列の場合は"文字列, 整数, 整数, 整数"となります。

     メソッドにシグネチャが定義されていない場合、配列以外の値が返ります。
     Pythonでは、この値はlist以外の値となります。

`system.methodHelp(name)'
     XML-RPCサーバで実装されているメソッドの名前を指定し、そのメソッドを解説
     する文書文字列を取得します。文書文字列を取得できない場合は空文字列を返し
     ます。文書文字列にはHTMLマークアップが含まれます

イントロスペクション用のメソッドは、PHP・C・Microsoft .NETのサーバなどで
サポートされています。UserLand Frontierの最近のバージョンでもイントロス
ペクションを部分的にサポートしています。Perl, Python, Javaでのイントロス
ペクションサポートについては XML-RPC Hacksを参照してください。


File: python-lib-jp.info,  Node: Boolean オブジェクト,  Next: DateTime オブジェクト,  Prev: ServerProxy オブジェクト,  Up: xmlrpclib

18.24.2 Boolean オブジェクト
----------------------------

このクラスは全てのPythonの値で初期化することができ、生成されるインスタン
スは指定した値の真偽値によってのみ決まります。Booleanという名前から想像
される通りに各種のPython演算子を実装しており、`__cmp__()',
`__repr__()', `__int__()', `__nonzero__()'で定義さ
れる演算子を使用することができます。

以下のメソッドは、主に内部的にアンマーシャル時に使用されます:

`encode(out)'
     出力ストリームオブジェクト `out'
     に、XML-RPCエンコーディングのBoolean値を出力します。


File: python-lib-jp.info,  Node: DateTime オブジェクト,  Next: Binary オブジェクト,  Prev: Boolean オブジェクト,  Up: xmlrpclib

18.24.3 DateTime オブジェクト
-----------------------------

このクラスは、エポックからの秒数、タプルで表現された時刻、ISO 8601形式の
時間/日付文字列、 {}``datetime'.datetime'、
{}``datetime'.date'または{}``datetime'.time' のインスタンス
の何れかで初期化することができます。

このクラスには以下のメソッドがあり、
主にコードをマーシャル/アンマーシャルするための内部処理を行います。

`decode(string)'
     文字列をインスタンスの新しい時間を示す値として指定します。

`encode(out)'
     出力ストリームオブジェクト `out' に、XML-RPCエンコーディングの
     `DateTime'値を出力します。

また、`__cmp__()'と`__repr__()'で定義される演算子を使用するこ
とができます。


File: python-lib-jp.info,  Node: Binary オブジェクト,  Next: Fault オブジェクト,  Prev: DateTime オブジェクト,  Up: xmlrpclib

18.24.4 Binary オブジェクト
---------------------------

このクラスは、文字列(NULを含む)で初期化することができます。
`Binary'の内容は、属性で参照します。

`data'
     `Binary'インスタンスがカプセル化しているバイナリデータ。このデータ
     は8bitクリーンです。

以下のメソッドは、主に内部的にマーシャル/アンマーシャル時に使用されます:

`decode(string)'
     指定されたbase64文字列をデコードし、インスタンスのデータとします。

`encode(out)'
     バイナリ値をbase64でエンコードし、出力ストリームオブジェクト `out'
     に出力します。

また、`__cmp__()'で定義される演算子を使用することができます。


File: python-lib-jp.info,  Node: Fault オブジェクト,  Next: ProtocolError オブジェクト,  Prev: Binary オブジェクト,  Up: xmlrpclib

18.24.5 Fault オブジェクト
--------------------------

`Fault'オブジェクトは、XML-RPCのfaultタグの内容をカプセル化してお
り、以下のメンバを持ちます:

`faultCode'
     失敗のタイプを示す文字列。

`faultString'
     失敗の診断メッセージを含む文字列。


File: python-lib-jp.info,  Node: ProtocolError オブジェクト,  Next: MultiCall オブジェクト,  Prev: Fault オブジェクト,  Up: xmlrpclib

18.24.6 ProtocolError オブジェクト
----------------------------------

`ProtocolError'オブジェクトはトランスポート層で発生したエラー(URI
で指定したサーバが見つからなかった場合に発生する404 `not found'など)の内
容を示し、以下のメンバを持ちます:

`url'
     エラーの原因となったURIまたはURL。

`errcode'
     エラーコード。

`errmsg'
     エラーメッセージまたは診断文字列。

`headers'
     エラーの原因となったHTTP/HTTPSリクエストを含む文字列。


File: python-lib-jp.info,  Node: MultiCall オブジェクト,  Next: 補助関数,  Prev: ProtocolError オブジェクト,  Up: xmlrpclib

18.24.7 MultiCall オブジェクト
------------------------------

_Added in Python version 2.4_

遠隔のサーバに対する複数の呼び出しをひとつのリクエストにカプセル化
する方法は、`http://www.xmlrpc.com/discuss/msgReader%241208' で
示されています。

`MultiCall(server)'
     巨大な (boxcar) メソッド呼び出しに使えるオブジェクトを作成します。
     SERVER には最終的に呼び出しを行う対象を指定します。 作成した
     MultiCall オブジェクトを使って呼び出しを行うと、 即座にNONE
     を返し、呼び出したい手続き名とパラメタに保存する だけに留まります。
     オブジェクト自体を呼び出すと、それまでに保存しておいたすべての
     呼び出しを単一の`system.multicall' リクエストの形で伝送します。
     呼び出し結果はジェネレータになります。このジェネレータにわたって
     イテレーションを行うと、個々の呼び出し結果を返します。


以下にこのクラスの使い方を示します。

     multicall = MultiCall(server_proxy)
     multicall.add(2,3)
     multicall.get_address("Guido")
     add_result, address = multicall()


File: python-lib-jp.info,  Node: 補助関数,  Next: クライアントのサンプル,  Prev: MultiCall オブジェクト,  Up: xmlrpclib

18.24.8 補助関数
----------------

`boolean(value)'
     Pythonの値を、XML-RPCのBoolean定数 `True'または`False'に変換し
     ます。

`dumps(params[, methodname[,  methodresponse[, encoding[, allow_none]]]])'
     PARAMS を XML-RPC リクエストの形式に変換します。 METHODRESPONSE
     が真の場合、XML-RPC レスポンスの形式に変換します。 PARAMS
     に指定できるのは、引数からなるタプルか `Fault'
     例外クラスのインスタンスです。 METHODRESPONSE
     が真の場合、単一の値だけを返します。従って、 PARAMS の長さも 1
     でなければなりません。 ENCODING を指定した場合、生成される XML
     のエンコード方式に なります。デフォルトは UTF-8 です。 Python の
     `None' は標準の XML-RPC には利用できません。 `None'
     を使えるようにするには、ALLOW_NONE を真に
     して、拡張機能つきにしてください。

`loads(data[, use_datetime])'
     XML-RPC リクエストまたはレスポンスを `(PARAMS, METHODNAME)'
     の形式をとる Python オブジェクトにします。 PARAMS
     は引数のタプルです。METHODNAME は
     文字列で、パケット中にメソッド名がない場合には `None' に なります。
     例外条件を示す XML-RPC パケットの場合には、 `Fault' 例外
     を送出します。
     USE_DATETIMEフラグは``datetime'.datetime'のオブジェクトとして
     日付/時刻を表現する時に使用し、デフォルトでは false
     に設定されています。

     もし、 ``datetime'.date'、``datetime'.time'の
     オブジェクトとともにXML-RPCを呼び出した場合は、
     内部で`DateTime'のオブジェクトに変換され、
     戻り値として{}``datetime'.datetime'のオブジェクトのみが返される
     ことに注意してください。

     _Changed in Python version 2.5_


File: python-lib-jp.info,  Node: クライアントのサンプル,  Prev: 補助関数,  Up: xmlrpclib

18.24.9 クライアントのサンプル
------------------------------

     # simple test program (from the XML-RPC specification)
     from xmlrpclib import ServerProxy, Error

     # server = ServerProxy("http://localhost:8000") # local server
     server = ServerProxy("http://betty.userland.com")

     print server

     try:
         print server.examples.getStateName(41)
     except Error, v:
         print "ERROR", v

XML-RPCサーバにプロキシを経由して接続する場合、
カスタムトランスポートを定義する必要があります。
以下にNoboNoboが作成した例を示します:
     import xmlrpclib, httplib

     class ProxiedTransport(xmlrpclib.Transport):
         def set_proxy(self, proxy):
             self.proxy = proxy
         def make_connection(self, host):
             self.realhost = host
     	h = httplib.HTTP(self.proxy)
     	return h
         def send_request(self, connection, handler, request_body):
             connection.putrequest("POST", 'http://%s%s' % (self.realhost, handler))
         def send_host(self, connection, host):
             connection.putheader('Host', self.realhost)

     p = ProxiedTransport()
     p.set_proxy('proxy-server:8080')
     server = xmlrpclib.Server('http://time.xmlrpc.com/RPC2', transport=p)
     print server.currentTime.getCurrentTime()


File: python-lib-jp.info,  Node: SimpleXMLRPCServer,  Next: DocXMLRPCServer,  Prev: xmlrpclib,  Up: インターネットプロトコルとその支援

18.25 基本的なXML-RPCサーバー
=============================

基本的なXML-RPCサーバーの実装。

_Added in Python version 2.2_

`SimpleXMLRPCServer'モジュールはPythonで記述された基本的なXML-RPC
サーバーフレームワークを提供します。サーバーはスタンドアロンであるか、`SimpleXMLRPCServer'
を使うか、`CGIXMLRPCRequestHandler' を使って CGI
環境に組み込まれるかの、いずれかです。

`SimpleXMLRPCServer(addr[, requestHandler[, logRequests[allow_none[, encoding]]]])'
     新しくサーバーインスタンスを作成します。このクラスはXML-RPCプロトコルで
     呼ばれる関数の登録のためのメソッドを提供します。
     引数REQUESTHANDLERには、リクエストハンドラーインスタンスのファクトリーを設定します。デフォルトは`SimpleXMLRPCRequestHandler'です。引数ADDRとREQUESTHANDLERは``SocketServer'.TCPServer'のコンストラクターに引き渡されます。もし引数LOGREQUESTSが真(true)であれば、(それがデフォルトですが、)リクエストはログに記録されます。偽(false)である場合にはログは記録されません。
     引数ALLOW_NONEとENCODINGは`xmlrpclib'に引き継がれ、
     サーバーから返されるXML-RPCレスポンスを制御します。 _Changed in
     Python version 2.5_

`CGIXMLRPCRequestHandler([allow_none[, encoding]])'
     CGI 環境における XML-RPC リクエストハンドラーを、新たに作成します。
     引数ALLOW_NONEとENCODINGは`xmlrpclib'に引き継がれ、
     サーバーから返されるXML-RPCレスポンスを制御します。 _Added in
     Python version 2.3_ _Changed in Python version 2.5_

`SimpleXMLRPCRequestHandler()'
     新しくリクエストハンドラーインスタンスを作成します。このリクエストハンドラーは`POST'リクエストを受け持ち、`SimpleXMLRPCServer'のコンストラクターの引数LOGREQUESTSに従ったログ出力を行います。

* Menu:

* SimpleXMLRPCServer オブジェクト::
* CGIXMLRPCRequestHandler::

