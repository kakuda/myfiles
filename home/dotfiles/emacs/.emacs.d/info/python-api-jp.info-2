これは python-api-jp.info、python-api-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-api-jp.info,  Node: 概要,  Next: メモリインタフェース,  Prev: メモリ管理,  Up: メモリ管理

9.1 概要
========

Python におけるメモリ管理には、全ての Python オブジェクトとデータ構造が
入ったプライベートヒープ (private heap) が必須です。プライベートヒープ
の管理は、内部的には _Python メモリマネージャ (Python memory manager)_
が確実に行います。Python メモリマネージャには、共有 (sharing)、
セグメント分割 (segmentation)、事前割り当て (preallocation)、
キャッシュ化 (caching) といった、様々な動的記憶管理の側面を
扱うために、個別のコンポーネントがあります。

最低水準層では、素のメモリ操作関数 (raw memory allocator) が
オペレーティングシステムのメモリ管理機構とやりとりして、
プライベートヒープ内にPython 関連の全てのデータを記憶するのに
十分な空きがあるかどうか確認します。
素のメモリ操作関数の上には、いくつかのオブジェクト固有の
メモリ操作関数があります。これらは同じヒープを操作し、
各オブジェクト型固有の事情に合ったメモリ管理ポリシを実装しています。
例えば、整数オブジェクトは文字列やタプル、辞書とは違ったやり方で
ヒープ内で管理されます。というのも、整数には値を記憶する上で
特別な要件があり、速度/容量のトレードオフが存在するからです。
このように、 Python メモリマネジャは作業のいくつかをオブジェクト
固有のメモリ操作関数に委譲しますが、これらの関数が
プライベートヒープからはみ出してメモリ管理を行わないように しています。

重要なのは、たとえユーザがいつもヒープ内のメモリブロックを指すような
オブジェクトポインタを操作しているとしても、Python 用ヒープの管理は
インタプリタ自体が行うもので、ユーザがそれを制御する余地はないと理解
することです。Python オブジェクトや内部使用されるバッファを入れるための
ヒープ空間のメモリ確保は、必要に応じて、Python メモリマネージャがこの
ドキュメント内で列挙しているPython/C API 関数群を介して行います。

メモリ管理の崩壊を避けるため、拡張モジュールの作者は決して Python
オブジェクトを C ライブラリが公開している関数: `malloc()' 、 `calloc()' 、
`realloc()'  および `free()'  で操作しようとしては
なりません。こうした関数を使うと、C のメモリ操作関数と Python
メモリマネージャとの間で関数呼び出しが交錯します。 C
のメモリ操作関数とPython メモリマネージャは異なる
アルゴリズムで実装されていて、異なるヒープを操作するため、
呼び出しの交錯は致命的な結果を招きます。
とはいえ、個別の目的のためなら、 C ライブラリのメモリ操作関数を
使って安全にメモリを確保したり解放したりできます。
例えば、以下がそのような例です:

         PyObject *res;
         char *buf = (char *) malloc(BUFSIZ); /* for I/O */

         if (buf == NULL)
             return PyErr_NoMemory();
         ...Do some I/O operation involving buf...
         res = PyString_FromString(buf);
         free(buf); /* malloc'ed */
         return res;

この例では、I/O バッファに対するメモリ要求は C ライブラリのメモリ
操作関数を使っています。 Python メモリマネジャは戻り値として
返される文字列オブジェクトを確保する時にだけ必要です。

とはいえ、ほとんどの状況では、メモリの操作は Python ヒープに
固定して行うよう勧めます。なぜなら、Python ヒープは Python
メモリマネジャの管理下にあるからです。 例えば、インタプリタを C
で書かれた新たなオブジェクト型で拡張
する際には、ヒープでのメモリ管理が必要です。 Python
ヒープを使った方がよいもう一つの理由として、拡張モジュールが
必要としているメモリについて Python メモリマネージャに _情報を提供_
してほしいということがあります。
たとえ必要なメモリが内部的かつ非常に特化した用途に対して排他的に
用いられるものだとしても、全てのメモリ操作要求を Python メモリマネージャ
に委譲すれば、インタプリタはより正確なメモリフットプリント (memory
footprint) の全体像を把握できます。その結果、特定の状況では、 Python
メモリマネージャがガベージコレクションやメモリのコンパクト化、
その他何らかの予防措置といった、適切な動作をトリガできることが
あります。上の例で示したように C ライブラリのメモリ操作関数 を使うと、
I/O バッファ用に確保したメモリは Python メモリマネージャ
の管理から完全に外れることに注意してください。


File: python-api-jp.info,  Node: メモリインタフェース,  Next: 例,  Prev: 概要,  Up: メモリ管理

9.2 メモリインタフェース
========================

Python ヒープに対してメモリを確保したり解放したりするために、
以下の関数セットが利用できます。これらの関数は ANSI C 標準に
従ってモデル化されていますが、0 バイトの領域を要求した際の
動作についても定義しています:

`void* PyMem_Malloc(size_t n)'
     N バイトをメモリ確保し、確保されたメモリを指す `void*'
     型のポインタを返します。確保要求に失敗した場合には `NULL' を
     返します。 0 バイトをリクエストすると、可能ならば独立した非`NULL'
     の ポインタを返します。このポインタは  `PyMem_Malloc(1)'
     を代わりに呼んだときのようなメモリ領域を指しています。
     確保されたメモリ領域はいかなる初期化も行われていません。

`void* PyMem_Realloc(void *p, size_t n)'
     P が指しているメモリブロックを N バイトにサイズ変更
     します。メモリの内容のうち、新旧のサイズのうち小さい方までの
     領域は変更されません。P が `NULL'ならば、この関数は
     `PyMem_Malloc(N)' と等価になります; それ以外の場合で、N
     がゼロに等しければ、
     メモリブロックはサイズ変更されますが、解放されず、非 `NULL'の
     ポインタを返します。P の値を`NULL'にしないのなら、 以前呼び出した
     `PyMem_Malloc()' や `PyMem_Realloc()'
     の返した値でなければなりません。

`void PyMem_Free(void *p)'
     P が指すメモリブロックを解放します。P は 以前呼び出した
     `PyMem_Malloc()' や `PyMem_Realloc()'
     の返した値でなければなりません。 それ以外の場合や、すでに
     `PyMem_Free(p)' を 呼び出した後だった場合、未定義の動作になります。
     P が `NULL'なら、何も行いません。

以下に挙げる型対象のマクロは利便性のために提供されているものです。 TYPE
は任意の C の型を表します。

`TYPE* PyMem_New(TYPE, size_t n)'
     `PyMem_Malloc()' と同じですが、 `(N * sizeof(TYPE))'
     バイトのメモリを確保します。 `TYPE*'
     に型キャストされたポインタを返します。
     メモリには何の初期化も行われていません。

`TYPE* PyMem_Resize(void *p, TYPE, size_t n)'
     `PyMem_Realloc()' と同じですが、 `(N * sizeof(TYPE))'
     バイトにサイズ変更されたメモリを 確保します。 `TYPE*'
     に型キャストされたポインタを返します。

`void PyMem_Del(void *p)'
     `PyMem_Free()' と同じです。

上記に加えて、C API 関数を介することなく Python メモリ操作関数を
直接呼び出すための以下のマクロセットが提供されています。
ただし、これらのマクロは Python バージョン間でのバイナリ互換性を
保てず、それゆえに拡張モジュールでは撤廃されているので注意してください。

`PyMem_MALLOC()'、 `PyMem_REALLOC()'、 `PyMem_FREE()'。

`PyMem_NEW()'、 `PyMem_RESIZE()'、 `PyMem_DEL()'。


File: python-api-jp.info,  Node: 例,  Prev: メモリインタフェース,  Up: メモリ管理

9.3 例
======

最初に述べた関数セットを使って、*Note 概要:: 節の例を Python ヒープに
I/O バッファをメモリ確保するように書き換えたものを 以下に示します:

         PyObject *res;
         char *buf = (char *) PyMem_Malloc(BUFSIZ); /* for I/O */

         if (buf == NULL)
             return PyErr_NoMemory();
         /* ...Do some I/O operation involving buf... */
         res = PyString_FromString(buf);
         PyMem_Free(buf); /* allocated with PyMem_Malloc */
         return res;

同じコードを型対象の関数セットで書いたものを以下に示します:

         PyObject *res;
         char *buf = PyMem_New(char, BUFSIZ); /* for I/O */

         if (buf == NULL)
             return PyErr_NoMemory();
         /* ...Do some I/O operation involving buf... */
         res = PyString_FromString(buf);
         PyMem_Del(buf); /* allocated with PyMem_New */
         return res;

上の二つの例では、バッファを常に同じ関数セットに属する関数で
操作していることに注意してください。
実際、あるメモリブロックに対する操作は、異なるメモリ操作機構を
混用する危険を減らすために、同じメモリ API ファミリを使って行うことが
必要です。以下のコードには二つのエラーがあり、そのうちの一つには
異なるヒープを操作する別のメモリ操作関数を混用しているので _致命的
(Fatal)_ とラベルづけをしています。

     char *buf1 = PyMem_New(char, BUFSIZ);
     char *buf2 = (char *) malloc(BUFSIZ);
     char *buf3 = (char *) PyMem_Malloc(BUFSIZ);
     ...
     PyMem_Del(buf3);  /* Wrong -- should be PyMem_Free() */
     free(buf2);       /* Right -- allocated via malloc() */
     free(buf1);       /* Fatal -- should be PyMem_Del()  */

素のメモリブロックを Python ヒープ上で操作する関数に加え、
`PyObject_New()'、 `PyObject_NewVar()'、および `PyObject_Del()'
を使うと、 Python におけるオブジェクトを
メモリ確保したり解放したりできます。

これらの関数については、次章の C による新しいオブジェクト型の定義や
実装に関する記述の中で説明します。


File: python-api-jp.info,  Node: オブジェクト実装サポート object implementation support,  Next: バグ報告,  Prev: メモリ管理,  Up: Top

10 オブジェクト実装サポート (object implementation support)
***********************************************************

この章では、新しいオブジェクト型 (new object type) を定義する際に
使われる関数、型、およびマクロについて説明します。

* Menu:

* オブジェクトをヒープ上にメモリ確保する::
* 共通のオブジェクト構造体 common object structure::
* 型オブジェクト::
* マップ型オブジェクト構造体 mapping object structure::
* 数値オブジェクト構造体 number object structure::
* シーケンスオブジェクト構造体 sequence object structure::
* バッファオブジェクト構造体 buffer object structure::
* イテレータプロトコルをサポートする::
* 循環参照ガベージコレクションをサポートする::


File: python-api-jp.info,  Node: オブジェクトをヒープ上にメモリ確保する,  Next: 共通のオブジェクト構造体 common object structure,  Prev: オブジェクト実装サポート object implementation support,  Up: オブジェクト実装サポート object implementation support

10.1 オブジェクトをヒープ上にメモリ確保する
===========================================

`PyObject* _PyObject_New(PyTypeObject *type)'

`PyVarObject* _PyObject_NewVar(PyTypeObject *type, Py_ssize_t size)'

`void _PyObject_Del(PyObject *op)'

`PyObject* PyObject_Init(PyObject *op, PyTypeObject *type)'
     新たにメモリ確保されたオブジェクト OP に対し、型と初期状態での
     参照 (initial reference) を初期化します。
     初期化されたオブジェクトを返します。TYPE からそのオブジェクトが
     循環参照ガベージ検出の機能を有する場合、検出機構が監視対象とする
     オブジェクトのセットに追加されます。
     オブジェクトの他のフィールドには影響を及ぼしません。

`PyVarObject* PyObject_InitVar(PyVarObject *op, PyTypeObject *type, Py_ssize_t size)'
     `PyObject_Init()' の全ての処理を行い、可変サイズオブジェクト
     の場合には長さ情報も初期化します。

`TYPE* PyObject_New(TYPE, PyTypeObject *type)'
     C 構造体型 TYPE と Python 型オブジェクト TYPE を使って 新たな
     Python オブジェクトをメモリ確保します。 Python
     オブジェクトヘッダで定義されていないフィールドは初期化されません;
     オブジェクトの参照カウントは 1 になります。メモリ確保のサイズは
     型オブジェクトの `tp_basicsize' で決定します。

`TYPE* PyObject_NewVar(TYPE, PyTypeObject *type, Py_ssize_t size)'
     C 構造体型 TYPE と Python 型オブジェクト TYPE を使って 新たな
     Python オブジェクトをメモリ確保します。 Python
     オブジェクトヘッダで定義されていないフィールドは初期化されません。
     確保されたメモリは、TYPE 構造体に加え、var{type} の `tp_itemsize'
     フィールドで指定されているサイズ中の SIZE フィールドを
     収容できます。この関数は、例えばタプルのように生成時にサイズを決定
     できるオブジェクトを実装する際に便利です。一連の複数のフィールドに
     対するアロケーション操作を一つにして埋め込むと、アロケーション回数
     が減り、メモリ管理の処理効率が向上します。

`void PyObject_Del(PyObject *op)'
     `PyObject_New()' や `PyObject_NewVar()' で
     確保されたメモリを解放します。この関数は、通常オブジェクトの型に
     指定されている `tp_dealloc' ハンドラ内で呼び出します。
     この関数を呼び出した後では、オブジェクトのメモリ領域はもはや有効な
     Python オブジェクトを表現してはいないので、オブジェクトのフィールド
     に対してアクセスしてはなりません。

`PyObject* Py_InitModule(char *name, PyMethodDef *methods)'
     NAME と関数のテーブルに基づいて新たなモジュールオブジェクトを
     生成し、生成されたモジュールオブジェクトを返します。 _Changed in
     Python version 2.3_

`PyObject* Py_InitModule3(char *name, PyMethodDef *methods, char *doc)'
     NAME と関数のテーブルに基づいて新たなモジュールオブジェクトを
     生成し、生成されたモジュールオブジェクトを返します。 DOC が
     `NULL'でない場合、モジュールの docstring として 使われます。
     _Changed in Python version 2.3_

`PyObject* Py_InitModule4(char *name, PyMethodDef *methods, char *doc, PyObject *self, int apiver)'
     NAME と関数のテーブルに基づいて新たなモジュールオブジェクトを
     生成し、生成されたモジュールオブジェクトを返します。 DOC が
     `NULL'でない場合、モジュールの docstring として 使われます。SELF
     が`NULL'でない場合、モジュール内の各関数
     の第一引数として渡されます (`NULL'の時には第一引数も
     `NULL'になります)。
     (この関数は実験的な機能のために追加されたもので、現在の Python の
     バージョンで使われてはいないはずです。) APIVER に渡してよい値は、
     `PYTHON_API_VERSION' で定義されている定数だけです。

     _Note:_ この関数のほとんどの用途は、代わりに`Py_InitModule3()'
     を使えるはずです;
     本当にこの関数を使いたいときにだけ利用してください _Changed in
     Python version 2.3_

`PyObject _Py_NoneStruct'
     Python からは `None' に見えるオブジェクトです。この値への
     アクセスは、このオブジェクトへのポインタを評価する`Py_None'
     マクロを使わねばなりません。


File: python-api-jp.info,  Node: 共通のオブジェクト構造体 common object structure,  Next: 型オブジェクト,  Prev: オブジェクトをヒープ上にメモリ確保する,  Up: オブジェクト実装サポート object implementation support

10.2 共通のオブジェクト構造体 (common object structure)
=======================================================

Python では、オブジェクト型を定義する上で数多くの構造体が使われます。
この節では三つの構造体とその利用方法について説明します。

全ての Python オブジェクトは、オブジェクトのメモリ内表現の先頭部分に
ある少数のフィールドを完全に共有しています。このフィールドは `PyObject'
および `PyVarObject' 型で表現されます。 `PyObject' 型や `PyVarObject'
型もまた、他の全ての Python
オブジェクトを定義する上で直接的・間接的に使われているマクロを
使って定義されています。

`PyObject'
     全てのオブジェクト型はこの型を拡張したものです。
     この型には、あるオブジェクトに対するオブジェクトとしてのポインタを
     Python から扱う必要がある際に必要な情報が入っています。 通常に
     "リリースされている" ビルドでは、この構造体にはオブジェクトの
     参照カウントと、オブジェクトに対応する型オブジェクトだけが入っています。

     `PyObject_HEAD' マクロ展開で定義されているフィールドに対応します。

`PyVarObject'
     `PyObject' を拡張して、`ob_size' フィールドを追加した
     ものです。この構造体は、_長さ (length)_ の概念を持つオブジェクト
     だけに対して使います。この型が Python/C API で使われることは
     ほとんどありません。 `PyObject_VAR_HEAD'
     マクロ展開で定義されているフィールドに対応します。

`PyObject' および `PyVarObject' の定義には以下のマクロが 使われています:

`PyObject_HEAD'
     `PyObject' 型のフィールド宣言に展開されるマクロです;
     可変でない長さを持つオブジェクトを表現する新たな型を宣言する
     場合に使います。展開によってどのフィールドが宣言されるかは、
     `Py_TRACE_REFS' の定義に依存します。
     デフォルトでは、`Py_TRACE_REFS' は定義されておらず、
     `PyObject_HEAD' は以下のコードに展開されます:
              Py_ssize_t ob_refcnt;
              PyTypeObject *ob_type;

     `Py_TRACE_REFS' が定義されている場合、以下のように展開 されます:
              PyObject *_ob_next, *_ob_prev;
              Py_ssize_t ob_refcnt;
              PyTypeObject *ob_type;


`PyObject_VAR_HEAD'
     マクロです。`PyVarObject' 型のフィールド宣言に展開されるマクロです;
     インスタンスによって可変の長さを持つオブジェクトを表現する新たな型を
     宣言する場合に使います。マクロは常に以下のように展開されます:
              PyObject_HEAD
              Py_ssize_t ob_size;

     マクロ展開結果の一部に`PyObject_HEAD' が含まれており、
     `PyObject_HEAD' の展開結果は`Py_TRACE_REFS' の定義に依存します。

`PyObject_HEAD_INIT'

`PyCFunction'
     ほとんどの Python の呼び出し可能オブジェクトを C で実装する際に
     用いられている関数の型です。 この型の関数は二つの `PyObject*'
     型パラメタをとり、 `PyObject*' 型の値を返します。戻り値を
     `NULL'にする場合、
     例外をセットしておかなければなりません。`NULL'でない値を返す場合、
     戻り値は Python
     に関数の戻り値として公開される値として解釈されます。
     この型の関数は新たな参照を返さなければなりません。

`PyMethodDef'
     拡張型のメソッドを記述する際に用いる構造体です。この構造体には 4
     つのフィールドがあります:

     フィールド             C データ型             意味
     ------                 -----                  -----
     ml_name                char *                 メソッド名
     ml_meth                PyCFunction            C 実装へのポインタ
     ml_flags               int                    呼び出しをどのように行うかを示すフラグビット
     ml_doc                 char *                 docstring
                                                   の内容を指すポインタ


`ml_meth' は C の関数ポインタです。関数は別の型で定義
されていてもかまいませんが、常に  `PyObject*' を返します。 関数が
`PyFunction' でない場合、メソッドテーブル内でキャスト
を行うようコンパイラが要求することになるでしょう。 `PyCFunction'
では最初のパラメタが`PyObject*' 型で あると定義していますが、固有の C
型を SELF オブジェクトに 使う実装はよく行われています。

`ml_flags' フィールドはビットフィールドで、以下のフラグが入ります。
個々のフラグは呼び出し規約 (calling convention) や束縛規約 (binding
convention) を表します。 呼び出し規約フラグでは、`METH_VARARGS' および
`METH_KEYWORDS' を組み合わせられます (ただし、 `METH_KEYWORDS'
単体の指定を行っても ``METH_VARARGS' | `METH_KEYWORDS'' と
同じなので注意してください)。
呼び出し規約フラグは束縛フラグと組み合わせられます。

`METH_VARARGS'
     `PyCFunction' 型のメソッドで典型的に使われる呼び出し規約です。
     関数は`PyObject*' 型の引数値を二つ要求します。最初の引数は
     メソッドの SELF オブジェクトです; モジュール関数の場合、
     `Py_InitModule4()' に与えることになる値が入ります (`NULL'
     にすると`Py_InitModule()' が使われます)。 第二のパラメタ (よく
     ARGS と呼ばれます) は、全ての引数を
     表現するタプルオブジェクトです。パラメタは通常、
     `PyArg_ParseTuple()' や `PyArg_UnpackTuple' で処理されます。

`METH_KEYWORDS'
     このフラグを持つメソッドは`PyCFunctionWithKeywords'
     型でなければなりません。`PyCFunctionWithKeywords' は
     三つのパラメタ:SELF、 ARGS、 およびキーワード引数
     全てからなる辞書、を要求します。このフラグは通常 `METH_VARARGS'
     と組み合わされ、パラメタは `PyArg_ParseTupleAndKeywords()'
     で処理されます。

`METH_NOARGS'
     引数のないメソッドは、`METH_NOARGS' フラグをつけた場合、
     必要な引数が指定されているかをチェックしなくなります。
     こうしたメソッドは `PyCFunction' 型でなくてはなりません。
     オブジェクトのメソッドに使った場合、第一のパラメタは `self'
     になり、オブジェクトインスタンスへの参照を保持することになります。
     いずれにせよ、第二のパラメタは `NULL'になります。

`METH_O'
     単一のオブジェクト引数だけをとるメソッドは、 `PyArg_ParseTuple()'
     を引数 `"O"' にして呼び出す代わりに、 `METH_O'
     フラグつきで指定できます。メソッドは `PyCFunction' 型で、SELF
     パラメタと単一の引数を表現する `PyObject*' パラメタを伴います。

`METH_OLDARGS'
     この呼び出し規約は撤廃されました。メソッドは`PyCFunction' 型で
     なければなりません。第二引数は、引数がない場合には `NULL'、単一の
     引数の場合にはその引数オブジェクト、複数個の引数の場合には引数
     オブジェクトからなるタプルです。この呼び出し規約を使うと、複数個の
     引数の場合と、単一のタプルが唯一引数の場合を区別できなくなってしまいます。

以下の二つの定数は、呼び出し規約を示すものではなく、
クラスのメソッドとして使う際の束縛方式を示すものです。
モジュールに対して定義された関数で用いてはなりません。
メソッドに対しては、最大で一つしかこのフラグをセットできません。

`METH_CLASS'
     メソッドの最初の引数には、型のインスタンスではなく型オブジェクト
     が渡されます。このフラグは 組み込み関数 `classmethod()' を使って生成するのと同じ_クラスメソッド
     (class method)_ を生成するために使われます。 _Added in Python
     version 2.3_

`METH_STATIC'
     メソッドの最初の引数には、型のインスタンスではなく `NULL' が
     渡されます。このフラグは、 `staticmethod()' 

     を使って生成するのと同じ_静的メソッド (static method)_
     を生成するために使われます。 _Added in Python version 2.3_

もう一つの定数は、あるメソッドを同名の別のメソッド定義と置き換えるか
どうかを制御します。

`METH_COEXIST'
     メソッドを既存の定義を置き換える形でロードします。 METH_COEXIST
     を指定しなければ、デフォルトの設定にしたがって、
     定義が重複しないようスキップします。スロットラッパはメソッドテーブル
     よりも前にロードされるので、例えば SQ_CONTAINS スロットは
     ラップしているメソッド `__contains__()' を生成し、同名の
     PyCFunction のロードを阻止します。このフラグを定義すると、
     PyCFunction はラッパオブジェクトを置き換える形でロードされ、
     スロットと連立します。 PyCFunctions
     の呼び出しはラッパオブジェクトの
     呼び出しよりも最適化されているので、こうした仕様が便利になります。
     _Added in Python version 2.4_

`PyObject* Py_FindMethod(PyMethodDef table[], PyObject *ob, char *name)'
     C で実装された拡張型の束縛メソッドオブジェクトを返します。
     `PyObject_GenericGetAttr()' 関数を使わない `tp_getattro' や
     `tp_getattr' ハンドラを実装する際に 便利です。


File: python-api-jp.info,  Node: 型オブジェクト,  Next: マップ型オブジェクト構造体 mapping object structure,  Prev: 共通のオブジェクト構造体 common object structure,  Up: オブジェクト実装サポート object implementation support

10.3 型オブジェクト
===================

新スタイルの型を定義する構造体: `PyTypeObject' 構造体は、おそらく
Python オブジェクトシステムの中で最も重要な構造体の一つでしょう。
型オブジェクトは`PyObject_*()' 系や `PyType_*()'
系の関数で扱えますが、ほとんどの Python アプリケーションにとって、
さして面白みのある機能を提供しません。
とはいえ、型オブジェクトはオブジェクトがどのように振舞うかを決める
基盤ですから、インタプリタ自体や新たな型を定義する拡張モジュールでは
非常に重要な存在です。

型オブジェクトは標準の型 (standard type) に比べるとかなり大きな
構造体です。その理由は、型オブジェクトがある型の様々な機能を実現する
小さな機能単位を実装した C 関数へのポインタが大部分を占めるような
多数の値を保持しているからです。この節では、型オブジェクトの各
フィールドについて詳細を説明します。各フィールドは、構造体内で
出現する順番に説明されています。

Typedefs: unaryfunc, binaryfunc, ternaryfunc, inquiry, coercion,
intargfunc, intintargfunc, intobjargproc, intintobjargproc,
objobjargproc, destructor, freefunc, printfunc, getattrfunc,
getattrofunc, setattrfunc, setattrofunc, cmpfunc, reprfunc, hashfunc

`PyTypeObject' の構造体定義は`Include/object.h'
で見つけられるはずです。参照の手間を省くために、ここでは
定義を繰り返します:

`typestruct.h'

型オブジェクト構造体は`PyVarObject' 構造体を拡張したものです。
`ob_size' フィールドは、(通常 class 文が呼び出す `type_new()'
で生成される) 動的な型に使います。 `PyType_Type' (メタタイプ)
は`tp_itemsize' を初期化するので
注意してください。すなわち、インスタンス (つまり型オブジェクト) には
`ob_size' フィールドがなければ_なりません_。

`PyObject* _ob_next'
`PyObject* _ob_prev'
     これらのフィールドはマクロ  `Py_TRACE_REFS' が定義されている
     場合のみ存在します。`PyObject_HEAD_INIT' マクロを使うと、
     フィールドを `NULL' に初期化します。静的にメモリ確保されている
     オブジェクトでは、これらのフィールドは常に `NULL'のままです。
     動的にメモリ確保されるオブジェクトの場合、これら二つのフィールドは、
     ヒープ上の_全ての_ 存続中のオブジェクトからなる二重リンクリスト
     でオブジェクトをリンクする際に使われます。
     このことは様々なデバッグ目的に利用できます; 現状では、環境変数
     `PYTHONDUMPREFS' が設定されているときに、プログラムの実行
     終了時点で存続しているオブジェクトを出力するのが唯一の用例です。

     サブタイプはこのフィールドを継承しません。

`Py_ssize_t ob_refcnt'
     型オブジェクトの参照カウントで、`PyObject_HEAD_INIT' は この値を
     `1' に初期化します。静的にメモリ確保された型オブジェクト
     では、型のインスタンス (`ob_type' が該当する型を指している
     オブジェクト) は参照をカウントする対象には_なりません_。
     動的にメモリ確保される型オブジェクトの場合、インスタンスは
     参照カウントの対象に_なります_。

     サブタイプはこのフィールドを継承しません。

`PyTypeObject* ob_type'
     型自体の型、別の言い方をするとメタタイプです。
     `PyObject_HEAD_INIT' マクロで初期化され、通常は `&PyType_Type'
     になります。しかし、(少なくとも) Windows で
     利用できる動的ロード可能な拡張モジュールでは、コンパイラは
     有効な初期化ではないと文句をつけます。そこで、ならわしとして、
     `PyObject_HEAD_INIT' には `NULL' を渡して初期化しておき、
     他の操作を行う前にモジュールの初期化関数で明示的にこのフィールドを
     初期化することになっています。この操作は以下のように行います:

          Foo_Type.ob_type = &PyType_Type;

     上の操作は、該当する型のいかなるインスタンス生成よりも前に
     しておかねばなりません。`PyType_Ready()' は `ob_type' が
     `NULL'かどうか調べ、`NULL'の場合には 初期化します: Python 2.2
     では、`&PyType_Type' にセット します; in Python 2.2.1
     およびそれ以降では基底クラスの `ob_type' フィールドに初期化します。
     `ob_type' が非ゼロの場合、`PyType_Ready()' は
     このフィールドを変更しません。

     Python 2.2 では、サブタイプはこのフィールドを継承しません。 2.2.1
     と 2.3 以降では、サブタイプはこのフィールドを継承します。

`Py_ssize_t ob_size'
     静的にメモリ確保されている型オブジェクトの場合、このフィールドは
     ゼロに初期化されます。動的にメモリ確保されている型オブジェクトの
     場合、このフィールドは内部使用される特殊な意味を持ちます。

     サブタイプはこのフィールドを継承しません。

`char* tp_name'
     型の名前が入っている NUL 終端された文字列へのポインタです。
     モジュールのグローバル変数としてアクセスできる型の場合、
     この文字列は完全なモジュール名、ドット、そして型の名前と続く
     文字列になります; 組み込み型の場合、ただの型の名前です。
     モジュールがあるパッケージのサブモジュールの場合、完全なパッケージ名が
     完全なモジュール名の一部になっています。例えば、パッケージ `P'
     内のサブモジュール `Q' に入っているモジュール`M' 内で
     定義されている`T' は、`tp_name' を `"P.Q.M.T"' に 初期化します。

     動的にメモリ確保される型オブジェクトの場合、このフィールドは
     単に型の名前になり、モジュール名は型の辞書内でキー `'__module__''
     に対する値として明示的に保存されます。

     静的にメモリ確保される型オブジェクトの場合、`tp_name' フィールド
     にはドットが入っているはずです。最後のドットよりも前にある
     部分文字列全体は `__module__' 属性として、また
     ドットよりも後ろにある部分は`__name__' 属性としてアクセスできます。

     ドットが入っていない場合、`tp_name' フィールドの内容全てが
     `__name__' 属性になり、 `__module__' 属性は
     (前述のように型の辞書内で明示的にセットしないかぎり)
     未定義になります。 このため、こうした型オブジェクトは pickle
     化できないことになります。

     サブタイプはこのフィールドを継承しません。

`Py_ssize_t tp_basicsize'
`Py_ssize_t tp_itemsize'
     これらのフィールドは、型インスタンスのバイトサイズを計算できる
     ようにします。

     型には二つの種類があります: 固定長インスタンスの型は、
     `tp_itemsize' フィールドがゼロで、可変長インスタンスの方は
     `tp_itemsize' フィールドが非ゼロの値になります。
     固定長インスタンスの型の場合、全てのインスタンスは等しく
     `tp_basicsize' で与えられたサイズになります。

     可変長インスタンスの型の場合、インスタンスには`ob_size'
     フィールドがなくてはならず、インスタンスのサイズは N
     をオブジェクトの "長さ" として、`tp_basicsize' と N かける
     `tp_itemsize' の加算になります。N の値は通常、インスタンスの
     `ob_size' フィールドに記憶されます。ただし例外がいくつかあります:
     例えば、長整数では負の値を `ob_size' に使って、インスタンスの
     表す値が負であることを示し、 N 自体は `abs(`ob_size')'
     になります。また、`ob_size' フィールドがあるからといって、
     必ずしもインスタンスが可変長であることを意味しません (例えば、
     リスト型の構造体は固定長のインスタンスになるにもかかわらず、
     インスタンスにはちゃんと意味を持った `ob_size' フィールドが
     あります)。

     基本サイズには、`PyObject_HEAD' マクロまたは `PyObject_VAR_HEAD'
     マクロ (インスタンス構造体を 宣言するのに使ったどちらかのマクロ)
     で宣言されているフィールド が入っています。さらに、`_ob_prev'
     および `_ob_next'
     フィールドがある場合、これらのフィールドもサイズに加算されます。

     従って、`tp_basicsize' の正しい初期化パラメタを得るには、
     インスタンスデータのレイアウトを宣言するのに使う構造体に対して
     `sizeof' 演算子を使うしかありません。 基本サイズには、GC
     ヘッダサイズは入っていません (これは Python 2.2
     からの新しい仕様です; 2.1 や 2.0 では、GC ヘッダサイズは
     `tp_basicsize' に入っていました)。

     バイト整列 (alignment) に関する注釈:
     変数の各要素を配置する際に特定の
     バイト整列が必要となる場合、`tp_basicsize' の値に
     気をつけなければなりません。一例: 例えばある型が`double' の
     配列を実装しているとします。`tp_itemsize' は `sizeof(double)'
     です。(`double' のバイト整列条件に従って) `tp_basicsize'
     が`sizeof(double)' の個数分のサイズに
     なるようにするのはプログラマの責任です。

`destructor tp_dealloc'
     インスタンスのデストラクタ関数へのポインタです。この関数は
     (単量子`None' や`Ellipsis' の場合のように、インスタンスが
     決してメモリ解放されない型でない限り)
     必ず定義しなければなりません。

     デストラクタ関数は、`Py_DECREF()' や `Py_XDECREF()'
     マクロで、操作後の参照カウントがゼロになった際に呼び出されます。
     呼び出された時点では、インスタンスはまだ存在しますが、インスタンスに
     対する参照は全ない状態です。デストラクタ関数はインスタンスが保持している
     全ての参照を解放し、インスタンスが確保している全てのメモリバッファを
     (バッファの確保時に使った関数に対応するメモリ解放関数を使って)
     解放し、最後に (かならず最後に行う操作として) その型の `tp_free'
     関数を呼び出します。ある型がサブタイプを作成できない
     (`Py_TPFLAGS_BASETYPE' フラグがセットされていない) 場合、
     `tp_free' の代わりにオブジェクトのメモリ解放関数 (deallocator) を
     直接呼び出してもかまいません。オブジェクトのメモリ解放関数は、
     インスタンスのメモリ確保を行う際に使った関数と同じファミリでなければ
     なりません; インスタンスを `PyObject_New()' や `PyObject_VarNew()'
     でメモリ確保した場合には、通常 `PyObject_Del()'
     を使い、`PyObject_GC_New()' や `PyObject_GC_VarNew()'
     で確保した場合には `PyObject_GC_Del()' を使います。

     サブタイプはこのフィールドを継承します。

`printfunc tp_print'
     オプションのフィールドです。ポインタで、インスタンスの出力 (print)
     を 行う関数を指します。

     出力関数は、インスタンスが _実体のある (real)_ ファイルに出力
     される場合にのみ呼び出されます; (`StringIO' インスタンスのような)
     擬似ファイルに出力される場合には、インスタンスの `tp_repr' や
     `tp_str' が指す関数が呼び出され、文字列への変換を行います。
     また、`tp_print' が `NULL'の場合にもこれらの関数が呼び出され ます。
     `tp_repr' や `tp_str' と異なる出力を生成するような `tp_print'
     は、決して型に実装してはなりません。

     出力関数は`PyObject_Print()' と同じシグネチャ: `int
     tp_print(PyObject *self, FILE  *file, int flags)'
     で呼び出されます。SELF 引数は出力するインスタンスを指します。 FILE
     引数は出力先となる標準入出力 (stdio) ファイルです。 FLAGS
     引数はフラグビットを組み合わせた値です。
     現在定義されているフラグビットは `Py_PRINT_RAW' のみです。
     `Py_PRINT_RAW' フラグビットがセットされていれば、
     インスタンスは`tp_str' と同じ書式で出力されます。 `Py_PRINT_RAW'
     フラグビットがクリアならば、 インスタンスは`tp_repr'
     と同じ書式で出力されます。
     この関数は、操作中にエラーが生じた場合、`-1' を返して例外状態を
     セットしなければなりません。

     `tp_print' フィールドは撤廃されるかもしれません。いずれにせよ、
     `tp_print' は定義せず、代わりに`tp_repr' や `tp_str'
     に頼って出力を行うようにしてください。

     サブタイプはこのフィールドを継承します。

`getattrfunc tp_getattr'
     オプションのフィールドです。ポインタで、 get-attribute-string
     を行う関数を指します。

     このフィールドは撤廃されています。このフィールドを定義する場合、
     `tp_getattro' 関数と同じように動作し、属性名は Python 文字列
     オブジェクトではなく C 文字列で指定するような関数を指すように
     しなければなりません。シグネチャは `PyObject_GetAttrString()'
     と同じです。

     このフィールドは`tp_getattro' と共にサブタイプに継承 されます:
     すなわち、サブタイプの`tp_getattr' および `tp_getattro' が共に
     `NULL'の場合、サブタイプは 基底タイプから`tp_getattr' と
     `tp_getattro' を一緒に 継承します。

`setattrfunc tp_setattr'
     オプションのフィールドです。ポインタで、 set-attribute-string
     を行う関数を指します。

     このフィールドは撤廃されています。このフィールドを定義する場合、
     `tp_setattro' 関数と同じように動作し、属性名は Python 文字列
     オブジェクトではなく C 文字列で指定するような関数を指すように
     しなければなりません。シグネチャは `PyObject_SetAttrString()'
     と同じです。

     このフィールドは`tp_setattro' と共にサブタイプに継承 されます:
     すなわち、サブタイプの`tp_setattr' および `tp_setattro' が共に
     `NULL'の場合、サブタイプは 基底タイプから`tp_setattr' と
     `tp_setattro' を一緒に 継承します。

`cmpfunc tp_compare'
     オプションのフィールドです。ポインタで、 三値比較 (three-way
     comparison) を行う関数を指します。

     シグネチャは`PyObject_Compare()' と同じです。 この関数は SELF が
     OTHER よりも大きければ `1'、 SELF と OTHER の値が等しければ `0'、
     SELF が OTHER より小さければ `-1' を返します。
     この関数は、比較操作中にエラーが生じた場合、例外状態をセットして
     `-1' を返さねばなりません。

     このフィールドは`tp_richcompare' および`tp_hash'
     と共にサブタイプに継承されます: すなわち、サブタイプの
     `tp_compare' 、`tp_richcompare' および `tp_hash' が共に
     `NULL'の場合、サブタイプは
     基底タイプから`tp_compare'、`tp_richcompare'、 `tp_hash'
     の三つを一緒に継承します。

`reprfunc tp_repr'
     オプションのフィールドです。ポインタで、 組み込み関数`repr()'  を実装している
     関数を指します。

     シグネチャは`PyObject_Repr()' と同じです。
     この関数は文字列オブジェクトか Unicode オブジェクトを返さねば
     なりません。理想的には、この関数が返す文字列は、適切な環境で
     `eval()' に渡した場合、同じ値を持つオブジェクトになるような
     文字列でなければなりません。不可能な場合には、オブジェクトの型と
     値から導出した内容の入った `<' から始まって `>'
     で終わる文字列を返さねば なりません。

     このフィールドが設定されていない場合、`<%s object at %p>'
     の形式をとる文字列が返されます。 `%s' は型の名前に、 `%p'
     はオブジェクトのメモリアドレスに置き換えられます。

     サブタイプはこのフィールドを継承します。

PyNumberMethods *tp_as_number;

XXX

PySequenceMethods *tp_as_sequence;

XXX

PyMappingMethods *tp_as_mapping;

XXX

`hashfunc tp_hash'
     オプションのフィールドです。ポインタで、 組み込み関数`hash()'  を実装している
     関数を指します。

     シグネチャは`PyObject_Hash()' と同じです。 この関数は C の `long'
     型の値を返さねばなりません。 通常時には `-1'
     を戻り値にしてはなりません; ハッシュ値の
     計算中にエラーが生じた場合、関数は例外をセットして`-1' を
     返さねばなりません。

     このフィールドが設定されていない場合、二つの可能性があります:
     `tp_compare' および `tp_richcompare' フィールドの 両方が
     `NULL'の場合、オブジェクトのアドレスに基づいたデフォルトの
     ハッシュ値が返されます; それ以外の場合、`TypeError'
     が送出されます。

     このフィールドは`tp_compare' および`tp_richcompare'
     と共にサブタイプに継承されます: すなわち、サブタイプの
     `tp_compare' 、`tp_richcompare' および `tp_hash' が共に
     `NULL'の場合、サブタイプは
     基底タイプから`tp_compare'、`tp_richcompare'、 `tp_hash'
     の三つを一緒に継承します。

`ternaryfunc tp_call'
     オプションのフィールドです。ポインタで、
     オブジェクトの呼び出しを実装している 関数を指します。
     オブジェクトが呼び出し可能でない場合には `NULL' にしなければ
     なりません。シグネチャは `PyObject_Call()' と同じです。

     サブタイプはこのフィールドを継承します。

`reprfunc tp_str'
     オプションのフィールドです。ポインタで、 組み込みの演算 `str()'
     を実装している 関数を指します。(`str' が型の一つになったため、
     `str()' は `str' のコンストラクタを呼び出す
     ことに注意してください。このコンストラクタは実際の処理を行う
     上で`PyObject_Str()' を呼び出し、さらに `PyObject_Str()'
     がこのハンドラを呼び出すことになります。)

     シグネチャは`PyObject_Str()' と同じです;
     この関数は文字列オブジェクトか Unicode
     オブジェクトを返さねばなりません。 また、この関数はオブジェクトを
     "分かりやすく (friendly)" 表現
     した文字列を返さねばなりません。というのは、この文字列は `print'
     文で使われることになる表記だからです。

     このフィールドが設定されていない場合、文字列表現を返すためには
     `PyObject_Repr()' が呼び出されます。

     サブタイプはこのフィールドを継承します。

`getattrofunc tp_getattro'
     オプションのフィールドです。ポインタで、 get-attribute
     を実装している関数を指します。

     シグネチャは`PyObject_GetAttr()' と同じです。
     対する通常の属性検索を実装している`PyObject_GenericGetAttr()'
     をこのフィールドに設定しておくと往々にして便利です。

     このフィールドは`tp_getattr' と共にサブタイプに継承 されます:
     すなわち、サブタイプの`tp_getattr' および `tp_getattro' が共に
     `NULL'の場合、サブタイプは 基底タイプから`tp_getattr' と
     `tp_getattro' を一緒に 継承します。

`setattrofunc tp_setattro'
     オプションのフィールドです。ポインタで、 set-attribute
     を行う関数を指します。

     シグネチャは`PyObject_SetAttr()' と同じです。
     対する通常の属性設定を実装している`PyObject_GenericSetAttr()'
     をこのフィールドに設定しておくと往々にして便利です。

     このフィールドは`tp_setattr' と共にサブタイプに継承 されます:
     すなわち、サブタイプの`tp_setattr' および `tp_setattro' が共に
     `NULL'の場合、サブタイプは 基底タイプから`tp_setattr' と
     `tp_setattro' を一緒に 継承します。

`PyBufferProcs* tp_as_buffer'
     バッファインタフェースを実装しているオブジェクトにのみ関連する、
     一連のフィールド群が入った別の構造体を指すポインタです。
     構造体内の各フィールドは "バッファオブジェクト構造体" (*Note
     バッファオブジェクト構造体 buffer object structure:: 節)
     で説明します。

     `tp_as_buffer' フィールド自体は継承されませんが、フィールド内に
     入っているフィールドは個別に継承されます。

`long tp_flags'
     このフィールドは様々なフラグからなるビットマスクです。
     いくつかのフラグは、特定の状況において変則的なセマンティクスが適用
     されることを示します; その他のフラグは、型オブジェクト
     (あるいは`tp_as_number'、`tp_as_sequence'、
     `tp_as_mapping'、および`tp_as_buffer' が参照している
     拡張機能構造体: extention structure ) の特定のフィールドのうち、
     過去から現在までずっと存在しているわけではないもの が有効に
     なっていることを示すために使われます;
     フラグビットがクリアであれば、フラグが保護しているフィールド
     にはアクセスしない代わりに、その値はゼロか`NULL' に
     なっているとみなさなければなりません。

     このフィールドの継承は複雑です。ほとんどのフラグビットは
     個別に継承されます。つまり、基底タイプであるフラグビットがセット
     されている場合、サブタイプはそのフラグビットを継承します。
     機能拡張のための構造体に関するフラグビットは、その機能拡張構造体
     が継承されるときに限定して継承されます。すなわち、基底タイプの
     フラグビットの値は、機能拡張構造体へのポインタと一緒にサブタイプに
     コピーされます。 `Py_TPFLAGS_HAVE_GC' フラグビットは、`tp_traverse'
     および `tp_clear' フィールドと合わせてコピーされます。
     すなわち、サブタイプの `Py_TPFLAGS_HAVE_GC' フラグビットが
     クリアで、かつ (`Py_TPFLAGS_HAVE_RICHCOMPARE' フラグビットの
     指定によって)  `tp_traverse' および `tp_clear'
     フィールドがサブタイプ内に存在しており、かつ値が `NULL' の場合に
     基底タイプから値を継承します。

     以下のビットマスクは現在定義されているものです; フラグは`|'
     演算子で論理和を取って `tp_flags' フィールドの値にできます。
     `PyType_HasFeature()' マクロは型とフラグ値、 TP および F
     をとり、`TP->tp_flags & F' が非ゼロかどうか調べます。

    `Py_TPFLAGS_HAVE_GETCHARBUFFER'
          このビットがセットされていれば、`tp_as_buffer' が参照する
          `PyBufferProcs' 構造体には `bf_getcharbuffer' フィールドが
          あります。

    `Py_TPFLAGS_HAVE_SEQUENCE_IN'
          このビットがセットされていれば、`tp_as_sequence' が参照する
          `PySequenceMethods' 構造体には `sq_contains' フィールドが
          あります。

    `Py_TPFLAGS_GC'
          このビットは旧式のものです。このシンボルが指し示していたビットは
          もはや使われていません。シンボルの現在の定義はゼロになっています。

    `Py_TPFLAGS_HAVE_INPLACEOPS'
          このビットがセットされていれば、`tp_as_sequence' が参照する
          `PySequenceMethods' 構造体、および`tp_as_number' が参照する
          `PyNumberMethods' 構造体には in-place 演算に関するフィールドが
          入っています。具体的に言うと、 `PyNumberMethods'
          構造体はフィールド `nb_inplace_add'、 `nb_inplace_subtract'、
          `nb_inplace_multiply'、 `nb_inplace_divide'、
          `nb_inplace_remainder'、 `nb_inplace_power'、
          `nb_inplace_lshift'、 `nb_inplace_rshift'、 `nb_inplace_and'、
          `nb_inplace_xor'、および `nb_inplace_or'
          を持つことになります; また、 `PySequenceMethods'
          構造体はフィールド `sq_inplace_concat' および
          `sq_inplace_repeat' を持つことになります。

    `Py_TPFLAGS_CHECKTYPES'
          このビットがセットされていれば、`tp_as_number' が参照する
          `PyNumberMethods' 構造体内で定義されている二項演算子および
          三項演算子は任意のオブジェクト型を非演算子にとるようになり、
          必要に応じて引数の型変換を行います。このビットがクリアなら、
          演算子は全ての引数が現在のオブジェクト型と同じであるよう要求し、
          演算の呼び出し側は演算に先立って型変換を行うものと想定します。
          対象となる演算子は `nb_add'、 `nb_subtract'、 `nb_multiply'、
          `nb_divide'、 `nb_remainder'、 `nb_divmod'、 `nb_power'、
          `nb_lshift'、 `nb_rshift'、 `nb_and'、 `nb_xor'、および
          `nb_or' です。

    `Py_TPFLAGS_HAVE_RICHCOMPARE'
          このビットがセットされていれば、型オブジェクトには
          `tp_richcompare' フィールド、そして `tp_traverse' および
          `tp_clear' フィールドがあります。

    `Py_TPFLAGS_HAVE_WEAKREFS'
          このビットがセットされていれば、構造体には`tp_weaklistoffset'
          フィールドが定義されています。`tp_weaklistoffset' フィールドの
          値がゼロより大きければ、この型のインスタンスは弱参照で参照できます。

    `Py_TPFLAGS_HAVE_ITER'
          このビットがセットされていれば、型オブジェクトには`tp_iter'
          および `tp_iternext' フィールドがあります。

    `Py_TPFLAGS_HAVE_CLASS'
          このビットがセットされていれば、型オブジェクトは Python 2.2
          以降で 定義されている新たなフィールド: `tp_methods'、
          `tp_members'、 `tp_getset'、 `tp_base'、 `tp_dict'、
          `tp_descr_get'、 `tp_descr_set'、 `tp_dictoffset'、
          `tp_init'、 `tp_alloc'、 `tp_new'、 `tp_free'、 `tp_is_gc'、
          `tp_bases'、 `tp_mro'、 `tp_cache'、 `tp_subclasses'、 および
          `tp_weaklist' が あります。

    `Py_TPFLAGS_HEAPTYPE'
          型オブジェクト自体がヒープにメモリ確保される場合にセットされるビットです。
          型オブジェクト自体がヒープにメモリ確保される場合、インスタンスの
          `ob_type' フィールドは型オブジェクトへの参照とみなされます。
          この場合、新たなインスタンスを 生成する度に型オブジェクトを
          INCREF し、インスタンスを解放するたびに DECREF します
          (サブタイプのインスタンスには適当されません; インスタンスが
          `ob_type' で参照している型だけが INCREF および DECREF
          されます)。

    `Py_TPFLAGS_BASETYPE'
          型を別の型の基底タイプとして使える場合にセットされるビットです。
          このビットがクリアならば、この型のサブタイプは生成できません
          (Java における "final" クラスに似たクラスになります)。

    `Py_TPFLAGS_READY'
          型オブジェクトが `PyType_Ready()' で完全に初期化される
          とセットされるビットです。

    `Py_TPFLAGS_READYING'
          `PyType_Ready()' による型オブジェクトの初期化処理中にセット
          されるビットです。

    `Py_TPFLAGS_HAVE_GC'
          オブジェクトがガベージコレクション (GC)
          をサポートする場合にセットされる
          ビットです。このビットがセットされている場合、インスタンスは
          `PyObject_GC_New()' を使って生成し、 `PyObject_GC_Del()'
          を使って破壊しなければなりません。 詳しい情報は XXX
          節のガベージコレクションに関する説明中にあります。
          このビットはまた、GC に関連するフィールド`tp_traverse' および
          `tp_clear' が型オブジェクト内に存在することを示します;
          しかし、これらのフィールドは `Py_TPFLAGS_HAVE_GC' がクリア
          でも`Py_TPFLAGS_HAVE_RICHCOMPARE' がセットされている場合には
          存在します。

    `Py_TPFLAGS_DEFAULT'
          型オブジェクトおよび拡張機能構造体の特定のフィールドの存在の有無に
          関連する全てのビットからなるビットマスクです。
          現状では、このビットマスクには以下のビット:
          `Py_TPFLAGS_HAVE_GETCHARBUFFER'、
          `Py_TPFLAGS_HAVE_SEQUENCE_IN'、 `Py_TPFLAGS_HAVE_INPLACEOPS'、
          `Py_TPFLAGS_HAVE_RICHCOMPARE'、 `Py_TPFLAGS_HAVE_WEAKREFS'、
          `Py_TPFLAGS_HAVE_ITER'、および `Py_TPFLAGS_HAVE_CLASS'
          が入っています。


`char* tp_doc'
     オプションのフィールドです。ポインタで、この型オブジェクトの
     docstring を与える NUL 終端された C の文字列を指します。
     この値は型オブジェクトと型のインスタンスにおける `__doc__'
     属性として公開されます。

     サブタイプはこのフィールドを継承_しません_。

以下の三つのフィールドは、`Py_TPFLAGS_HAVE_RICHCOMPARE'
フラグビットがセットされている場合にのみ存在します。

`traverseproc tp_traverse'
     オプションのフィールドです。ポインタで、
     ガベージコレクタのためのトラバーサル関数 (traversal function)
     を指します。`Py_TPFLAGS_HAVE_GC' がセットされている
     場合にのみ使われます。Pythonのガベージコレクションの枠組みに関する詳細は
     *Note 25 差分翻訳者一覧 敬称略:: にあります。

     `tp_traverse'
     ポインタは、ガベージコレクタが循環参照を見つけるために 使われます。
     `tp_traverse' 関数の典型的な実装は、インスタンスの各メンバのうち
     Pythonオブジェクトに対して `Py_VISIT()' を呼び出します。
     例えば、次のコードは `thread' 拡張モジュールの `local_traverse'
     関数になります:

            static int
            local_traverse(localobject *self, visitproc visit, void *arg)
            {
                Py_VISIT(self->args);
                Py_VISIT(self->kw);
                Py_VISIT(self->dict);
                return 0;
            }

     `Py_VISIT()'
     が循環参照になる恐れのあるメンバにだけ呼び出されていることに
     注目してください。 `self->key' メンバもありますが、それは `NULL'
     か Python文字列なので、 循環参照の一部になることはありません。

     一方、メンバが循環参照の一部になり得ないと判っていても、デバッグ目的で巡回したい
     場合があるかもしれないので、 `gc' モジュールの `get_reference()'
     関数は 循環参照になり得ないメンバも返します。

     `Py_VISIT()' は `local_traverse' が VISIT と ARG
     という決まった名前の引数を持つことを要求します。

     このフィールドは `tp_clear' および `Py_TPFLAGS_HAVE_GC'
     フラグビットと一緒に継承されます: フラグビット、`tp_traverse'、
     および `tp_clear' の値がサブタイプで全てゼロになっており、 _かつ_
     サブタイプで `Py_TPFLAGS_HAVE_RICHCOMPARE'
     フラグビットがセットされている場合に、基底タイプから値を継承します。

`inquiry tp_clear'
     オプションのフィールドです。ポインタで、
     ガベージコレクタにおける消去関数 (clear function) を指します。
     `Py_TPFLAGS_HAVE_GC' がセットされている 場合にのみ使われます。

     `tp_clear' メンバ関数はGCが見つけた循環しているゴミの循環参照を
     壊すために用いられます。 システム内の全ての `tp_clear'
     関数によって、全ての循環参照を破壊しなければなりません。 (訳注:
     ある型が`tp_clear'を実装しなくても全ての循環参照が破壊できるのであれば
     実装しなくても良い)
     これはとても繊細で、もし少しでも不確かな部分があるのであれば、`tp_clear'
     関数を提供するべきです。
     例えば、タプルは`tp_clear'を実装しません。なぜなら、
     タプルだけで構成された循環参照がみつかることは無いからです。
     したがって、タプル以外の型 `tp_clear'
     関数たちが、タプルを含むどんな循環参照も 破壊できる必要があります。
     これは簡単に判ることでははありません。 `tp_clear'
     の実装を避ける良い理由はめったにありません。

     `tp_clear' の実装は、次の実装のように、インスタンスの
     (Pythonオブジェクト)メンバに対する参照を捨てて、メンバに対するポインタ変数を
     `NULL' にセットするべきです:

            static int
            local_clear(localobject *self)
            {
                Py_CLEAR(self->key);
                Py_CLEAR(self->args);
                Py_CLEAR(self->kw);
                Py_CLEAR(self->dict);
                return 0;
            }

     参照のクリアはデリケートなので、`Py_CLEAR()'マクロを使うべきです:
     ポインタを`NULL'にせっとするまで、そのオブジェクトの参照カウントを
     デクリメントしてはいけません。
     参照カウントのデクリメントすると、そのオブジェクトが破棄されるかもしれず、
     (そのオブジェクトに関連付けられたファイナライザ、弱参照のコールバックにより)
     任意のPythonコードの実行を含む後片付け処理が実行されるかもしれないからです。
     もしそういったコードが再び SELF を参照することがあれば、すでに
     持っていたオブジェクトへのポインタは `NULL' になっているので、
     SELF
     は所有していたオブジェクトをもう利用できないことを認識できます。
     `Py_CLEAR()'マクロはその手続きを安全な順番で実行します。

     `tp_clear'
     関数の目的は参照カウントを破壊することなので、Python文字列や
     Python整数のような、循環参照になりえないオブジェクトをクリアする必要はありません。
     一方、全部の所有オブジェクトをクリアするようにし、 `tp_dealloc'
     関数が `tp_clear' 関数を実行するようにすると実相が楽です。

     Pythonのガベージコレクションの仕組みについての詳細は、 *Note 25
     差分翻訳者一覧 敬称略:: にあります。

     このフィールドは `tp_traverse' および `Py_TPFLAGS_HAVE_GC'
     フラグビットと一緒に継承されます: フラグビット、`tp_traverse'、
     および `tp_clear' の値がサブタイプで全てゼロになっており、 _かつ_
     サブタイプで `Py_TPFLAGS_HAVE_RICHCOMPARE'
     フラグビットがセットされている場合に、基底タイプから値を継承します。

`richcmpfunc tp_richcompare'
     オプションのフィールドです。ポインタで、 拡張比較関数 (rich
     comparison function) を指します。

     シグネチャは`PyObject_RichCompare()' と同じです。
     この関数は、比較結果を返すべきです。(普通は `Py_True' か
     `Py_False'です。) 比較が未定義の場合は、
     `Py_NotImplemented'を、それ以外のエラーが
     発生した場合には例外状態をセットして `NULL' を返さねばなりません。

     このフィールドは`tp_compare' および`tp_hash'
     と共にサブタイプに継承されます: すなわち、サブタイプの
     `tp_compare' 、`tp_richcompare' および `tp_hash' が共に
     `NULL'の場合、サブタイプは
     基底タイプから`tp_compare'、`tp_richcompare'、 `tp_hash'
     の三つを一緒に継承します。

     `tp_richcompare' および`PyObject_RichCompare()'
     関数の第三引数に使うための定数としては以下が定義されています:

     定数                               比較
     ------                             -----
     Py_LT                              `<'
     Py_LE                              `<='
     Py_EQ                              `=='
     Py_NE                              `!='
     Py_GT                              `>'
     Py_GE                              `>='


次のフィールドは、`Py_TPFLAGS_HAVE_WEAKREFS'
フラグビットがセットされている場合にのみ存在します。

`long tp_weaklistoffset'
     型のインスタンスが弱参照可能な場合、このフィールドはゼロよりも
     大きな数になり、インスタンス構造体における弱参照リストの先頭を
     示すオフセットが入ります (GC ヘッダがある場合には無視します);
     このオフセット値は `PyObject_ClearWeakRefs()' および
     `PyWeakref_*()' 関数が利用します。 インスタンス構造体には、
     `NULL'に初期化された`PyObject*' 型の
     フィールドが入っていなければなりません。

     このフィールドを `tp_weaklist' と混同しないようにしてください;
     `tp_weaklist' は型オブジェクト自体の弱参照リストの先頭です。

     サブタイプはこのフィールドを継承しますが、以下の規則があるので
     読んでください。
     サブタイプはこのオフセット値をオーバライドできます; 従って、
     サブタイプでは弱参照リストの先頭が基底タイプとは異なる場合が
     あります。リストの先頭は常に`tp_weaklistoffset' で
     分かるはずなので、このことは問題にはならないはずです。

     `class' 文で定義された型に `__slots__' 宣言が
     全くなく、かつ基底タイプが弱参照可能でない場合、
     その型を弱参照可能にするには弱参照リストの先頭を表すスロットを
     インスタンスデータレイアウト構造体に追加し、スロットのオフセットを
     `tp_weaklistoffset' に設定します。

     型の `__slots__' 宣言中に `__weakref__' という名前の
     スロットが入っている場合、スロットはその型のインスタンスにおける
     弱参照リストの先頭を表すスロットになり、スロットのオフセットが
     型の `tp_weaklistoffset' に入ります。

     型の `__slots__' 宣言に `__weakref__' という名のスロット
     が入っていない場合、その型は基底タイプから`tp_weaklistoffset'
     を継承します。

次の二つのフィールドは、`Py_TPFLAGS_HAVE_CLASS'
フラグビットがセットされている場合にのみ存在します。

`getiterfunc tp_iter'
     An optional pointer to a function that returns an iterator for the
     object.  Its presence normally signals that the instances of this
     type are iterable (although sequences may be iterable without this
     function, and classic instances always have this function, even if
     they don't define an `__iter__()' method).

     This function has the same signature as `PyObject_GetIter()'.

     サブタイプはこのフィールドを継承します。

`iternextfunc tp_iternext'
     オプションのフィールドです。ポインタで、
     イテレータにおいて次の要素を返すか、イテレータの要素がなくなると
     `StopIteration' を送出する関数を指します。このフィールド
     があると、通常この型のインスタンスがイテレータであることを示します
     (ただし、旧スタイルのインスタンスでは、たとえ `next()' メソッドが
     定義されていなくても常にこの関数を持っています)。

     イテレータ型では、 `tp_iter' 関数も定義していなければならず、
     `tp_iter' は (新たなイテレータインスタンスではなく)
     イテレータインスタンス自体を返さねばなりません。

     この関数のシグネチャは `PyIter_Next()' と同じです。

     サブタイプはこのフィールドを継承します。

次の `tp_weaklist' までのフィールドは、 `Py_TPFLAGS_HAVE_CLASS'
フラグビットがセットされている場合にのみ存在します。

`struct PyMethodDef* tp_methods'
     オプションのフィールドです。ポインタで、 この型の正規 (regular)
     のメソッドを宣言している`PyMethodDef'
     構造体からなる、`NULL'で終端された静的な配列を指します。

     配列の各要素ごとに、メソッドデスクリプタの入ったエントリが 型辞書
     (下記の `tp_dict' 参照) に追加されます。

     サブタイプはこのフィールドを継承しません (メソッドは別個の
     メカニズムで継承されています)。

`struct PyMemberDef* tp_members'
     オプションのフィールドです。ポインタで、 型の正規 (regular)
     のデータメンバ (フィールドおよびスロット) を
     宣言している`PyMemberDef' 構造体からなる、
     `NULL'で終端された静的な配列を指します。

     配列の各要素ごとに、メンバデスクリプタの入ったエントリが 型辞書
     (下記の `tp_dict' 参照) に追加されます。

     サブタイプはこのフィールドを継承しません (メンバは別個の
     メカニズムで継承されています)。

`struct PyGetSetDef* tp_getset'
     オプションのフィールドです。ポインタで、 インスタンスの算出属性
     (computed attribute) を 宣言している`PyGetSetDef' 構造体からなる、
     `NULL'で終端された静的な配列を指します。

     配列の各要素ごとに、getset デスクリプタの入ったエントリが 型辞書
     (下記の `tp_dict' 参照) に追加されます。

     サブタイプはこのフィールドを継承しません (算出属性は別個の
     メカニズムで継承されています)。

     Docs for PyGetSetDef (XXX belong elsewhere):

          typedef PyObject *(*getter)(PyObject *, void *);
          typedef int (*setter)(PyObject *, PyObject *, void *);

          typedef struct PyGetSetDef {
              char *name;    /* 属性名 */
              getter get;    /* 属性の get を行う C 関数 */
              setter set;    /* 属性の set を行う C 関数 */
              char *doc;     /* オプションの docstring  */
              void *closure; /* オプションの get/set 関数用追加データ */
          } PyGetSetDef;


`PyTypeObject* tp_base'
     オプションのフィールドです。ポインタで、型に関するプロパティを
     継承する基底タイプへのポインタです。このフィールドのレベルでは、
     単継承 (single inheritance) だけがサポートされています;
     多重継承はメタタイプの呼び出しによる動的な型オブジェクトの生成を
     必要とします。

     (当たり前ですが) サブタイプはこのフィールドを継承しません。しかし、
     このフィールドのデフォルト値は (Python プログラマは`object'
     型として知っている) `&PyBaseObject_Type' になります。 .

`PyObject* tp_dict'
     型の辞書は`PyType_Ready()' によってこのフィールドに 収められます。

     このフィールドは通常、`PyType_Ready()' を呼び出す前に `NULL'
     に初期化しておかねばなりません; あるいは、型の初期属性の入った
     辞書で初期化しておいてもかまいません。`PyType_Ready()' が
     型をひとたび初期化すると、型の新たな属性をこの辞書に追加できるのは、
     属性が (`__add__()' のような) オーバロード用演算でないとき
     だけです。

     サブタイプはこのフィールドを継承しません (が、この辞書内で
     定義されている属性は異なるメカニズムで継承されます)。

`descrgetfunc tp_descr_get'
     オプションのフィールドです。ポインタで、 "デスクリプタ get"
     関数を指します。

     関数のシグネチャは次のとおりです。

          PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);

     XXX blah, blah.

     サブタイプはこのフィールドを継承します。

`descrsetfunc tp_descr_set'
     オプションのフィールドです。ポインタで、 "デスクリプタ set"
     関数を指します。

     関数のシグネチャは次のとおりです。

          int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);

     サブタイプはこのフィールドを継承します。

     XXX blah, blah.


`long tp_dictoffset'
     型のインスタンスにインスタンス変数の入った辞書がある場合、
     このフィールドは非ゼロの値になり、型のインスタンスデータ構造体
     におけるインスタンス変数辞書へのオフセットが入ります;
     このオフセット値は `PyObject_GenericGetAttr()' が 使います。

     このフィールドを `tp_dict' と混同しないでください; `tp_dict'
     は型オブジェクト自体の属性のための辞書です。

     このフィールドの値がゼロより大きければ、値はインスタンス構造体の
     先頭からのオフセットを表します。値がゼロより小さければ、
     インスタンス構造体の _末尾_ からのオフセットを表します。
     負のオフセットを使うコストは比較的高くつくので、インスタンス構造体に
     可変長の部分があるときのみ使うべきです。 例えば、`str' や `tuple'
     のサブタイプにインスタンス
     辞書を追加する場合には、負のオフセットを使います。
     この場合、たとえ辞書が基本のオブジェクトレイアウトに含まれていなくても、
     `tp_basicsize' フィールドは追加された辞書を考慮にいれなければ
     ならないので注意してください。ポインタサイズが 4
     バイトのシステムでは、
     構造体の最後尾に辞書が宣言されていることを示す場合、
     `tp_dictoffset' を`-4' にしなければなりません。

     `tp_dictoffset' が負の場合、インスタンスにおける実際の辞書の
     オフセットは以下のようにして計算されます:

          dictoffset = tp_basicsize + abs(ob_size)*tp_itemsize + tp_dictoffset
          if dictoffset is not aligned on sizeof(void*):
              round up to sizeof(void*)

     ここで、`tp_basicsize'、 `tp_itemsize' および `tp_dictoffset'
     は型オブジェクトから取り出され、 `ob_size'
     はインスタンスから取り出されます。 長整数は符号を記憶するのに
     `ob_size' の符号を使うため、 `ob_size'
     は絶対値を使います。(この計算を自分で行う必要は
     まったくありません; `_PyObject_GetDictPtr()' が やってくれます。)

     サブタイプはこのフィールドを継承しますが、以下の規則があるので
     読んでください。
     サブタイプはこのオフセット値をオーバライドできます; 従って、
     サブタイプでは辞書のオフセットが基底タイプとは異なる場合が
     あります。辞書へのオフセット常に`tp_dictoffset' で
     分かるはずなので、このことは問題にはならないはずです。

     `class' 文で定義された型に `__slots__' 宣言が
     全くなく、かつ基底タイプの全てにインスタンス変数辞書がない場合、
     辞書のスロットをインスタンスデータレイアウト構造体に追加し、
     スロットのオフセットを`tp_dictoffset' に設定します。

     `class' 文で定義された型に `__slots__' 宣言が
     ある場合、この型は基底タイプから `tp_dictoffset' を 継承します。

     (`__dict__' という名前のスロットを `__slots__' 宣言に
     追加しても、期待どおりの効果は得られず、単に混乱を招くだけに
     なります。とはいえ、これは将来`__weakref__' のように
     追加されるはずです。)

`initproc tp_init'
     オプションのフィールドです。ポインタで、
     インスタンス初期化関数を指します。

     この関数はクラスにおける  `__init__()' メソッドに対応
     します。`__init__()' と同様、`__init__()' を呼び出さず
     にインスタンスを作成できます。また、`__init__()' を再度
     呼び出してインスタンスの再初期化もできます。

     関数のシグネチャは

          int tp_init(PyObject *self, PyObject *args, PyObject *kwds)

     です。

     SELF 引数は初期化するインスタンスです; ARGS および KWDS
     引数は、`__init__()' を呼び出す際の
     固定引数およびキーワード引数です。

     `tp_init' 関数のフィールドが `NULL'でない場合、型の呼び出し
     で普通にインスタンスを生成する際に、型の`tp_new' が
     インスタンスを返した後に`tp_init' が呼び出されます。 `tp_new'
     が元の型のサブタイプでない別の型を返す場合、 `tp_init'
     は全く呼び出されません; `tp_new' が
     元の型のサブタイプのインスタンスを返す場合、サブタイプの `tp_init'
     が呼び出されます。 (VERSION NOTE: ここに書かれている
     内容は、Python 2.2.1 以降での実装に関するものです。Python 2.2
     では、 `tp_init' は `NULL'でない限り`tp_new' が返す全ての
     オブジェクトに対して常に呼び出されます。) not `NULL'.)

     サブタイプはこのフィールドを継承します。

`allocfunc tp_alloc'
     オプションのフィールドです。ポインタで、
     インスタンスのメモリ確保関数を指します。

     関数のシグネチャは

          PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems)

     です。

     この関数の目的は、メモリ確保をメモリ初期化から分離することにあります。
     この関数は、インスタンス用の的確なサイズを持ち、適切にバイト整列
     され、ゼロで初期化され、ただし`ob_refcnt' を `1' にセットされ、
     `ob_type' が型引数 (type argument) にセットされて
     いるようなメモリブロックを返さねばなりません。 型の `tp_itemsize'
     がゼロでない場合、オブジェクトの `ob_size' フィールドはNITEMS
     に初期化され、 確保されるメモリブロックの長さは `tp_basicsize +
     NITEMS*tp_itemsize' を`sizeof(void*)' の倍数で
     丸めた値になるはずです; それ以外の場合、NITEMS の値は使われず、
     メモリブロックの長さは `tp_basicsize' になるはずです。

     この関数をインスタンス初期化の他のどの処理にも、追加でメモリ確保
     をする場合でさえ使ってはなりません; そうした処理は `tp_new'
     で行わねばなりません。

     静的なサブタイプはこのフィールドを継承しますが、動的なサブタイプ
     (`class' 文で生成するサブタイプ) の場合は継承しません;
     後者の場合、このフィールドは常に`PyType_GenericAlloc()'
     にセットされ、標準のヒープ上メモリ確保戦略が強制されます。
     静的に定義する型の場合でも、`PyType_GenericAlloc()' を推奨します。

`newfunc tp_new'
     オプションのフィールドです。ポインタで、
     インスタンス生成関数を指します。

     このフィールドが `NULL' を指している型では、型を呼び出して新たな
     インスタンスを生成できません; こうした型では、おそらくファクトリ
     関数のように、インスタンスを生成する他の方法があるはずです。

     関数のシグネチャは

          PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds)

     です。

     引数 SUBTYPE は生成するオブジェクトの型です; ARGS およびKWDS
     引数は、型を呼び出すときの
     固定引数およびキーワード引数です。サブタイプは `tp_new' 関数
     を呼び出すときに使う型と等価というわけではないので注意してください;
     `tp_new' 関数を呼び出すときに使う型 (と無関係ではない)
     サブタイプのこともあります。

     `tp_new' 関数は `SUBTYPE->tp_alloc(SUBTYPE, NITEMS)'
     を呼び出してオブジェクトのメモリ領域を確保し、初期化で本当に必要と
     される処理だけを行います。省略したり繰り返したりしても問題のない
     初期化処理は`tp_init' ハンドラ内に配置しなければなりません。
     経験則からいうと、変更不能な型の場合、初期化は全て `tp_new'
     で行い、変更可能な型の場合はほとんどの初期化を `tp_init'
     に回すべきです。

     サブタイプはこのフィールドを継承します。例外として、 `tp_base'
     が`NULL' か`&PyBaseObject_Type' になっている静的な型では
     継承しません。後者が例外になっているのは、旧式の拡張型が Python 2.2
     でリンクされたときに呼び出し可能オブジェクトにならないように
     するための予防措置です。

`destructor tp_free'
     オプションのフィールドです。ポインタで、
     インスタンスのメモリ解放関数を指します。

     この関数のシグネチャは少し変更されています; Python 2.2 および 2.2.1
     では、シグネチャは`destructor' :

          void tp_free(PyObject *)

     でしたが、 Python 2.3 以降では、シグネチャは `freefunc':

          void tp_free(void *)

     になっています。

     両方のバージョンと互換性のある初期値は `_PyObject_Del' です。
     `_PyObject_Del' の定義は Python 2.3 で適切に対応できる
     よう変更されました。

     静的なサブタイプはこのフィールドを継承しますが、動的なサブタイプ
     (`class' 文で生成するサブタイプ) の場合は継承しません;
     後者の場合、このフィールドには`PyType_GenericAlloc()'
     と`Py_TPFLAGS_HAVE_GC' フラグビットの値に対応させるのに
     ふさわしいメモリ解放関数がセットされます。

`inquiry tp_is_gc'
     オプションのフィールドです。ポインタで、
     ガベージコレクタから呼び出される関数を指します。

     ガベージコレクタは、オブジェクトがガベージとして収集可能かどうか
     を知る必要があります。これを知るには、通常はオブジェクトの型の
     `tp_flags' フィールドを見て、 `Py_TPFLAGS_HAVE_GC'
     フラグビットを調べるだけで十分です。しかし、静的なメモリ確保と
     動的なメモリ確保が混じっているインスタンスを持つような型や、
     静的にメモリ確保されたインスタンスは収集できません。こうした型では、
     このフィールドに関数を定義しなければなりません; 関数は
     インスタンスが収集可能の場合には `1' を、 収集不能の場合には `0'
     を返さねばなりません。 シグネチャは

          int tp_is_gc(PyObject *self)

     です。

     (上記のような型の例は、型オブジェクト自体です。メタタイプ
     `PyType_Type' は、型のメモリ確保が静的か動的かを
     区別するためにこの関数を定義しています。)

     サブタイプはこのフィールドを継承します。 (VERSION NOTE: Python 2.2
     では、このフィールドは継承されませんでした。 2.2.1
     以降のバージョンから継承されるようになりました。)

`PyObject* tp_bases'
     基底型からなるタプルです。

     `class' 文で生成されたクラスの場合このフィールドがセット
     されます。静的に定義されている型の場合には、このフィールドは
     `NULL' になります。

     このフィールドは継承されません。

`PyObject* tp_mro'
     基底クラス群を展開した集合が入っているタプルです。集合は
     該当する型自体からはじまり、`object' で終わります。 メソッド解決順
     (Method Resolution Order) の順に並んでいます。

     このフィールドは継承されません; フィールドの値は `PyType_Ready()'
     で毎回計算されます。

`PyObject* tp_cache'
     使用されていません。継承されません。
     内部で使用するためだけのものです。

`PyObject* tp_subclasses'
     サブクラスへの弱参照からなるリストです。継承されません。
     内部で使用するためだけのものです。

`PyObject* tp_weaklist'
     この型オブジェクトに対する弱参照からなるリストの先頭です。

残りのフィールドは、機能テスト用のマクロである `COUNT_ALLOCS'
が定義されている場合のみ利用でき、内部で使用するためだけのものです。
これらのフィールドについて記述するのは単に完全性のためです。
サブタイプはこれらのフィールドを継承しません。

`Py_ssize_t tp_allocs'
     メモリ確保の回数です。

`Py_ssize_t tp_frees'
     メモリ解放の回数です。

`Py_ssize_t tp_maxalloc'
     同時にメモリ確保できる最大オブジェクト数です。

`PyTypeObject* tp_next'
     `tp_allocs' フィールドが非ゼロの、(リンクリストの) 次の型
     オブジェクトを指すポインタです。

また、 Python のガベージコレクションでは、TP_DEALLOC
を呼び出すのはオブジェクトを生成したスレッドだけではなく、 任意の
Python スレッドかもしれないという点にも注意して下さい。
(オブジェクトが循環参照の一部の場合、任意のスレッドのガベージコレクション
によって解放されてしまうかもしれません)。Python API 側からみれば、
TP_DEALLOC を呼び出すスレッドは グローバルインタプリタロック (GIL:
Global Interpreter Lock) を獲得するので、これは問題ではありません。
しかしながら、削除されようとしているオブジェクトが何らかの C や C++
ライブラリ由来のオブジェクトを削除する場合、 TP_DEALLOC を
呼び出すスレッドのオブジェクトを削除することで、ライブラリの仮定
している何らかの規約に違反しないように気を付ける必要があります。


File: python-api-jp.info,  Node: マップ型オブジェクト構造体 mapping object structure,  Next: 数値オブジェクト構造体 number object structure,  Prev: 型オブジェクト,  Up: オブジェクト実装サポート object implementation support

10.4 マップ型オブジェクト構造体 (mapping object structure)
==========================================================

`PyMappingMethods'
     拡張型でマップ型プロトコルを実装するために使われる関数群へのポインタを
     保持するために使われる構造体です。


File: python-api-jp.info,  Node: 数値オブジェクト構造体 number object structure,  Next: シーケンスオブジェクト構造体 sequence object structure,  Prev: マップ型オブジェクト構造体 mapping object structure,  Up: オブジェクト実装サポート object implementation support

10.5 数値オブジェクト構造体 (number object structure)
=====================================================

`PyNumberMethods'
     拡張型で数値型プロトコルを実装するために使われる関数群へのポインタを
     保持するために使われる構造体です。


File: python-api-jp.info,  Node: シーケンスオブジェクト構造体 sequence object structure,  Next: バッファオブジェクト構造体 buffer object structure,  Prev: 数値オブジェクト構造体 number object structure,  Up: オブジェクト実装サポート object implementation support

10.6 シーケンスオブジェクト構造体 (sequence object structure)
=============================================================

`PySequenceMethods'
     拡張型でシーケンス型プロトコルを実装するために使われる関数群へのポインタを
     保持するために使われる構造体です。


File: python-api-jp.info,  Node: バッファオブジェクト構造体 buffer object structure,  Next: イテレータプロトコルをサポートする,  Prev: シーケンスオブジェクト構造体 sequence object structure,  Up: オブジェクト実装サポート object implementation support

10.7 バッファオブジェクト構造体 (buffer object structure)
=========================================================

バッファインタフェースは、あるオブジェクトの内部データを一連の
データチャンク (chunk)
として見せるモデルを外部から利用できるようにします。
各チャンクはポインタ/データ長からなるペアで指定します。
チャンクはセグメント("segment") と呼ばれ、
メモリ内に不連続的に配置されるものと想定されています。

バッファインタフェースを利用できるようにしたくないオブジェクト
では、`PyTypeObject' 構造体の `tp_as_buffer' メンバを
`NULL'にしなくてはなりません。利用できるようにする場合、 `tp_as_buffer'
は`PyBufferProcs' 構造体を 指さねばなりません。

_Note:_  `PyTypeObject' 構造体の `tp_flags' メンバ の値を `0' でなく
`Py_TPFLAGS_DEFAULT' に しておくことがとても重要です。この設定は、
`PyBufferProcs' 構造体に `bf_getcharbuffer'  スロットが入っていることを
Python ランタイムに教えます。 Python の古いバージョンには
`bf_getcharbuffer' メンバが
存在しないので、古い拡張モジュールを使おうとしている新しいバージョンの
Python インタプリタは、このメンバがあるかどうかテストしてから
使えるようにする必要があるのです。

`PyBufferProcs'
     バッファプロトコルの実装を定義している関数群へのポインタを
     保持するのに使われる構造体です。

     最初のスロットは`bf_getreadbuffer' で、 `getreadbufferproc'
     型です。 このスロットが `NULL'の場合、オブジェクトは内部データの
     読み出しをサポートしません。そのような仕様には意味がないので、
     実装を行う側はこのスロットに値を埋めるはずですが、呼び出し側では
     非 `NULL' の値かどうかきちんと調べておくべきです。

     次のスロットは `bf_getwritebuffer' で、 `getwritebufferproc'
     型です。オブジェクトが返すバッファに
     対して書き込みを許可しない場合はこのスロットを`NULL' にできます。

     第三のスロットは `bf_getsegcount' で、 `getsegcountproc'
     型です。このスロットは `NULL' であっては
     ならず、オブジェクトにいくつセグメントが入っているかを呼び出し側に
     教えるために使われます。`PyString_Type' や `PyBuffer_Type'
     オブジェクトのような単純なオブジェクトには単一のセグメントしか入って
     いません。

     最後のスロットは `bf_getcharbuffer' で、 `getcharbufferproc'
     です。オブジェクトの `PyTypeObject' 構造体における `tp_flags'
     フィールドに、 `Py_TPFLAGS_HAVE_GETCHARBUFFER'
     ビットフラグがセットされている
     場合にのみ、このスロットが存在することになります。
     このスロットの使用に先立って、呼び出し側は `PyType_HasFeature()' を使ってスロットが存在するか調べねばなりません。
     フラグが立っていても、`bf_getcharbuffer'は `NULL'のときもあり、
     `NULL'はオブジェクトの内容を _8 ビット文字列_ として利用できない
     ことを示します。 このスロットに入る関数も、オブジェクトの内容を 8
     ビット文字列に
     変換できない場合に例外を送出することがあります。例えば、
     オブジェクトが浮動小数点数を保持するように設定されたアレイの場合、
     呼び出し側が `bf_getcharbuffer' を使って 8 ビット文字列
     としてデータを取り出そうとすると例外を送出するようにできます。
     この、内部バッファを "テキスト" として取り出すという概念は、
     本質的にはバイナリで、文字ベースの内容を持ったオブジェクト間の
     区別に使われます。

     _Note:_ 現在のポリシでは、文字 (character) はマルチバイト文字
     でもかまわないと決めているように思われます。従って、 サイズ N
     のバッファが N 個のキャラクタからなる
     とはかぎらないことになります。

`Py_TPFLAGS_HAVE_GETCHARBUFFER'
     型構造体中のフラグビットで、`bf_getcharbuffer' スロットが
     既知の値になっていることを示します。このフラグビットがセット
     されていたとしても、オブジェクトがバッファインタフェースをサポート
     していることや、`bf_getcharbuffer' スロットが `NULL'でない
     ことを示すわけではありません。

`Py_ssize_t (*getreadbufferproc) (PyObject *self, Py_ssize_t segment, void **ptrptr)'
     `*PTRPTR'の中の読み出し可能なバッファセグメントへのポインタを返します。
     この関数は例外を送出してもよく、送出する場合には `-1'
     を返さねばなりません。 SEGMENT
     に渡す値はゼロまたは正の値で、`bf_getsegcount'
     スロット関数が返すセグメント数よりも必ず小さな値でなければなりません。
     成功すると、セグメントのサイズを返し、 `*PTRPTR' を
     そのセグメントを指すポインタ値にセットします。

`Py_ssize_t (*getwritebufferproc) (PyObject *self, Py_ssize_t segment, void **ptrptr)'
     読み出し可能なバッファセグメントへのポインタを `*PTRPTR' に
     返し、セグメントの長さを関数の戻り値として返します。エラーによる例外の
     場合には `-1' を`-1' を返さねばなりません。
     オブジェクトが呼び出し専用バッファしかサポートしていない場合には
     `TypeError' を、SEGMENT が存在しないセグメントを
     指している場合には `SystemError' を送出しなければなりません。

`Py_ssize_t (*getsegcountproc) (PyObject *self, Py_ssize_t *lenp)'
     バッファを構成するメモリセグメントの数を返します。 LENP が
     `NULL'でない場合、この関数の実装は全てのセグメント のサイズ
     (バイト単位) の合計値を `*LENP' を介して
     報告しなければなりません。この関数呼び出しは失敗させられません。

`Py_ssize_t (*getcharbufferproc) (PyObject *self, Py_ssize_t segment, const char **ptrptr)'
     セグメント SEGMENT のメモリバッファを PTRPTR に入れ、
     そのサイズを返します。エラーのときに `-1' を返します。


File: python-api-jp.info,  Node: イテレータプロトコルをサポートする,  Next: 循環参照ガベージコレクションをサポートする,  Prev: バッファオブジェクト構造体 buffer object structure,  Up: オブジェクト実装サポート object implementation support

10.8 イテレータプロトコルをサポートする
=======================================


File: python-api-jp.info,  Node: 循環参照ガベージコレクションをサポートする,  Prev: イテレータプロトコルをサポートする,  Up: オブジェクト実装サポート object implementation support

10.9 循環参照ガベージコレクションをサポートする
===============================================

Python が循環参照を含むガベージの検出とコレクションをサポートする
には、他のオブジェクトに対する "コンテナ" (他のオブジェクトには
他のコンテナも含みます) となるオブジェクト型によるサポートが必要です。
他のオブジェクトに対する参照を記憶しないオブジェクトや、
(数値や文字列のような) アトム型 (atomic type) への参照だけを
記憶するような型では、ガベージコレクションに際して特別これといった
サポートを提供する必要はありません。

ここで説明しているインタフェースの使い方を示した例は、  の
"循環参照の収集をサポートする" にあります。
コンテナ型を作るには、型オブジェクトの `tp_flags' フィールド
に`Py_TPFLAGS_HAVE_GC' フラグがなくてはならず、 `tp_traverse'
ハンドラの実装を提供しなければなりません。
実装する型のインスタンスを変更可能なオブジェクトにするなら、 `tp_clear'
の実装も提供しなければなりません。

`Py_TPFLAGS_HAVE_GC'
     このフラグをセットした型のオブジェクトは、この節に述べた規則に
     適合しなければなりません。簡単のため、このフラグをセットした型の
     オブジェクトをコンテナオブジェクトと呼びます。

コンテナ型のコンストラクタは以下の二つの規則に適合しなければなりません:

  1. オブジェクトのメモリは `PyObject_GC_New()' または
     `PyObject_GC_VarNew()' で確保しなければなりません。

  2. 一度他のコンテナへの参照が入るかもしれないフィールドが全て
     初期化されたら、`PyObject_GC_Track()' を呼び出さねば なりません。

`TYPE* PyObject_GC_New(TYPE, PyTypeObject *type)'
     `PyObject_New()' に似ていますが、 `Py_TPFLAGS_HAVE_GC'
     のセットされたコンテナオブジェクト 用です。

`TYPE* PyObject_GC_NewVar(TYPE, PyTypeObject *type, Py_ssize_t size)'
     `PyObject_NewVar()' に似ていますが、 `Py_TPFLAGS_HAVE_GC'
     のセットされたコンテナオブジェクト 用です。

`PyVarObject * PyObject_GC_Resize(PyVarObject *op, Py_ssize_t)'
     `PyObject_NewVar()' が確保したオブジェクトのメモリを
     リサイズします。リサイズされたオブジェクトを返します。 失敗すると
     `NULL' を返します。

`void PyObject_GC_Track(PyObject *op)'
     ガベージコレクタが追跡しているコンテナオブジェクトの集合に
     オブジェクト OP を追加します。ガベージコレクタの動作する
     回数は予測不能なので、追加対象にするオブジェクトは追跡されている
     間ずっと有効なオブジェクトでなければなりません。
     この関数は、通常コンストラクタの最後付近で、`tp_traverse'
     ハンドラ以降の全てのフィールドが有効な値になった時点で呼び出さねば
     なりません。

`void _PyObject_GC_TRACK(PyObject *op)'
     `PyObject_GC_Track()' のマクロ版です。拡張モジュールに
     使ってはなりません。

同様に、オブジェクトのメモリ解放関数も以下の二つの規則に適合しなければ
なりません:

  1. 他のコンテナを参照しているフィールドを無効化する前に、
     `PyObject_GC_UnTrack()' を呼び出さねばなりません。

  2. オブジェクトのメモリは `PyObject_GC_Del()'
     で解放しなければなりません。

`void PyObject_GC_Del(void *op)'
     `PyObject_GC_New()' や `PyObject_GC_NewVar()'
     を使って確保されたメモリを解放します。

`void PyObject_GC_UnTrack(void *op)'
     ガベージコレクタが追跡しているコンテナオブジェクトの集合から
     オブジェクト OP を除去します。`PyObject_GC_Track()'
     を呼び出して、除去したオブジェクトを再度追跡対象セットに追加
     できるので注意してください。メモリ解放関数 (deallocator,
     `tp_dealloc' ハンドラ) は、`tp_traverse' ハンドラが
     使用しているフィールドのいずれかが無効化されるよりも
     以前にオブジェクトに対して呼び出されていなければなりません。

`void _PyObject_GC_UNTRACK(PyObject *op)'
     `PyObject_GC_UnTrack()' のマクロ版です。拡張モジュールに
     使ってはなりません。

`tp_traverse' ハンドラは以下の型を持つ関数を引数の一つとして とります:

`int (*visitproc)(PyObject *object, void *arg)'
     `tp_traverse' ハンドラに渡すビジタ関数 (visitor function)
     の型です。この関数は追跡すべきオブジェクトを OBJECT に、
     `tp_traverse' ハンドラの第三引数を ARG にして呼び出され
     ます。Python のコア部分では、ガベージコレクションの実装に複数の
     ビジタ関数を使っています。ユーザが独自にビジタ関数を書く必要がある
     とは想定されていません。

`tp_traverse' ハンドラは以下の型でなければなりません:

`int (*traverseproc)(PyObject *self, visitproc visit, void *arg)'
     コンテナオブジェクトのためのトラバーサル関数 (traversal function)
     です。 実装では、SELF に直接入っている各オブジェクトに対してVISIT
     関数を呼び出さねばなりません。このとき、VISIT へのパラメタは
     コンテナに入っている各オブジェクトと、このハンドラに渡された ARG
     の値です。VISIT 関数は `NULL' オブジェクトを引数に
     渡して呼び出してはなりません。VISIT が非ゼロの値を返す場合、
     エラーが発生し、戻り値をそのまま返すようににしなければなりません。

`tp_traverse' ハンドラの作成を単純化するため、`Py_VISIT()'
マクロが提供されています。このマクロを使うには、`tp_traverse' の
実装で、引数を VISIT および ARG という名前にしておかねば なりません:

`void Py_VISIT(PyObject *o)'
     引数 O および ARG を使ってVISIT コールバックを呼び出し ます。VISIT
     が非ゼロの値を返した場合、その値をそのまま返します。
     このマクロを使えば、`tp_traverse' ハンドラは以下のようになります:

          static int
          my_traverse(Noddy *self, visitproc visit, void *arg)
          {
              Py_VISIT(self->foo);
              Py_VISIT(self->bar);
              return 0;
          }

     _Added in Python version 2.4_

`tp_clear' ハンドラは `inquiry' 型にするか、
オブジェクトが変更不能の場合には `NULL' にしなければなりません。 `NULL'
if the object is immutable.

`int (*inquiry)(PyObject *self)'
     循環参照を形成しているとおぼしき参照群を放棄します。
     変更不可能なオブジェクトは循環参照を直接形成することが決してない
     ので、この関数を定義する必要はありません。
     このメソッドを呼び出した後でもオブジェクトは有効なままでなければ
     ならないので注意してください (参照に対して `Py_DECREF()'
     を呼ぶだけにしないでください)。ガベージコレクタは、オブジェクトが
     循環参照を形成していることを検出した際にこのメソッドを呼び出します。


File: python-api-jp.info,  Node: バグ報告,  Next: 歴史とライセンス,  Prev: オブジェクト実装サポート object implementation support,  Up: Top

Appendix A バグ報告
*******************

Python is a mature programming language which has established a
reputation for stability.  In order to maintain this reputation, the
developers would like to know of any deficiencies you find in Python or
its documentation.

Before submitting a report, you will be required to log into
SourceForge; this will make it possible for the developers to contact
you for additional information if needed.  It is not possible to submit
a bug report anonymously.

All bug reports should be submitted via the Python Bug Tracker on
SourceForge (`http://sourceforge.net/bugs/?group_id=5470').  The bug
tracker offers a Web form which allows pertinent information to be
entered and submitted to the developers.

The first step in filing a report is to determine whether the problem
has already been reported.  The advantage in doing so, aside from
saving the developers time, is that you learn what has been done to fix
it; it may be that the problem has already been fixed for the next
release, or additional information is needed (in which case you are
welcome to provide it if you can!).  To do this, search the bug
database using the search box on the left side of the page.

If the problem you're reporting is not already in the bug tracker, go
back to the Python Bug Tracker
(`http://sourceforge.net/bugs/?group_id=5470').  Select the "Submit a
Bug" link at the top of the page to open the bug reporting form.

The submission form has a number of fields.  The only fields that are
required are the "Summary" and "Details" fields.  For the summary,
enter a _very_ short description of the problem; less than ten words is
good.  In the Details field, describe the problem in detail, including
what you expected to happen and what did happen.  Be sure to include
the version of Python you used, whether any extension modules were
involved, and what hardware and software platform you were using
(including version information as appropriate).

The only other field that you may want to set is the "Category" field,
which allows you to place the bug report into a broad category (such as
"Documentation" or "Library").

Each bug report will be assigned to a developer who will determine what
needs to be done to correct the problem.  You will receive an update
each time action is taken on the bug.

See also:
     `How to Report Bugs Effectively'{Article which goes into some
     detail about how to create a useful bug report.  This describes
     what kind of information is useful and why it is useful.}

     `Bug Writing Guidelines'{Information about writing a good bug
     report.  Some of this is specific to the Mozilla project, but
     describes general good practices.}


File: python-api-jp.info,  Node: 歴史とライセンス,  Next: 日本語訳について,  Prev: バグ報告,  Up: Top

Appendix B 歴史とライセンス
***************************

* Menu:

* Python の歴史::
* Terms and conditions for accessing or otherwise using Python::
* Licenses and Acknowledgements for Incorporated Software::


File: python-api-jp.info,  Node: Python の歴史,  Next: Terms and conditions for accessing or otherwise using Python,  Prev: 歴史とライセンス,  Up: 歴史とライセンス

B.1 Python の歴史
=================

Python は 1990 年代の始め、オランダにある Stichting Mathematisch
Centrum (CWI, `http://www.cwi.nl/' 参照) で Guido van Rossum によって
ABC と呼ばれる言語の後継言語として生み 出されました。その後多くの人々が
Python に貢献していますが、 Guido は今日でも Python
製作者の先頭に立っています。

1995 年、 Guido は米国ヴァージニア州レストンにある Corporation for
National Reserch Initiatives (CNRI, `http://www.cnri.reston.va.us/'
参照) で Python の開発に携わり、
いくつかのバージョンをリリースしました。

2000 年 3 月、 Guido と Python のコア開発チームは BeOpen.com に 移り、
BeOpen PythonLabs チームを結成しました。同年 10 月、 PythonLabs
チームは Digital Creations (現在の Zope Corporation,
`http://www.zope.com/' 参照) に移りました。 そして 2001 年、 Python
に関する知的財産を保有するための非営利組織 Python Software Foundation
(PSF、 `http://www.python.org/psf/' 参照) を立ち上げました。このとき
Zope Corporation は PSF の賛助会員に なりました。

Python のリリースは全てオープンソース (オープンソースの定義は
`http://www.opensource.org/' を参照してください) です。
歴史的にみて、ごく一部を除くほとんどの Python リリースは GPL
互換になっています; 各リリースについては下表にまとめてあります。

リリース       ベース         年             権利           GPL 互換
------         ------         ------         ------         ------
0.9.0 thru     n/a            1991-1995      CWI            yes
1.2                                                         
1.3 thru       1.2            1995-1999      CNRI           yes
1.5.2                                                       
1.6            1.5.2          2000           CNRI           no
2.0            1.6            2000           BeOpen.com     no
1.6.1          1.6            2001           CNRI           no
2.1            2.0+1.6.1      2001           PSF            no
2.0.1          2.0+1.6.1      2001           PSF            yes
2.1.1          2.1+2.0.1      2001           PSF            yes
2.2            2.1.1          2001           PSF            yes
2.1.2          2.1.1          2002           PSF            yes
2.1.3          2.1.2          2002           PSF            yes
2.2.1          2.2            2002           PSF            yes
2.2.2          2.2.1          2002           PSF            yes
2.2.3          2.2.2          2002-2003      PSF            yes
2.3            2.2.2          2002-2003      PSF            yes
2.3.1          2.3            2002-2003      PSF            yes
2.3.2          2.3.1          2003           PSF            yes
2.3.3          2.3.2          2003           PSF            yes
2.3.4          2.3.3          2004           PSF            yes
2.3.5          2.3.4          2005           PSF            yes
2.4            2.3            2004           PSF            yes
2.4.1          2.4            2005           PSF            yes
2.4.2          2.4.1          2005           PSF            yes
2.4.3          2.4.2          2006           PSF            yes
2.5            2.4            2006           PSF            yes

_Note:_ 「GPL 互換」という表現は、Python が GPL で配布されていると
いう意味ではありません。Python のライセンスは全て、 GPL と違い、
変更したバージョンを配布する際に変更をオープンソースにしなくても
かまいません。 GPL 互換のライセンスの下では、GPL でリリースされて
いる他のソフトウェアと Python を組み合わせられますが、それ以外の
ライセンスではそうではありません。

Guido の指示の下、これらのリリースを可能にしてくださった多くの
ボランティアのみなさんに感謝します。


File: python-api-jp.info,  Node: Terms and conditions for accessing or otherwise using Python,  Next: Licenses and Acknowledgements for Incorporated Software,  Prev: Python の歴史,  Up: 歴史とライセンス

B.2 Terms and conditions for accessing or otherwise using Python
================================================================

                *PSF LICENSE AGREEMENT FOR PYTHON 2.5*

  1. This LICENSE AGREEMENT is between the Python Software Foundation
     ("PSF"), and the Individual or Organization ("Licensee") accessing
     and otherwise using Python 2.5 software in source or binary form
     and its associated documentation.

  2. Subject to the terms and conditions of this License Agreement, PSF
     hereby grants Licensee a nonexclusive, royalty-free, world-wide
     license to reproduce, analyze, test, perform and/or display
     publicly, prepare derivative works, distribute, and otherwise use
     Python 2.5 alone or in any derivative version, provided, however,
     that PSF's License Agreement and PSF's notice of copyright, i.e.,
     "Copyright (C) 2001-2006 Python Software Foundation; All Rights
     Reserved" are retained in Python 2.5 alone or in any derivative
     version prepared by Licensee.

  3. In the event Licensee prepares a derivative work that is based on
     or incorporates Python 2.5 or any part thereof, and wants to make
     the derivative work available to others as provided herein, then
     Licensee hereby agrees to include in any such work a brief summary
     of the changes made to Python 2.5.

  4. PSF is making Python 2.5 available to Licensee on an "AS IS"
     basis.  PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND
     DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 2.5
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
     2.5 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS
     AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON
     2.5, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY
     THEREOF.

  6. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  7. Nothing in this License Agreement shall be deemed to create any
     relationship of agency, partnership, or joint venture between PSF
     and Licensee.  This License Agreement does not grant permission to
     use PSF trademarks or trade name in a trademark sense to endorse
     or promote products or services of Licensee, or any third party.

  8. By copying, installing or otherwise using Python 2.5, Licensee
     agrees to be bound by the terms and conditions of this License
     Agreement.

             *BEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0*

        *BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1*

  1. This LICENSE AGREEMENT is between BeOpen.com ("BeOpen"), having an
     office at 160 Saratoga Avenue, Santa Clara, CA 95051, and the
     Individual or Organization ("Licensee") accessing and otherwise
     using this software in source or binary form and its associated
     documentation ("the Software").

  2. Subject to the terms and conditions of this BeOpen Python License
     Agreement, BeOpen hereby grants Licensee a non-exclusive,
     royalty-free, world-wide license to reproduce, analyze, test,
     perform and/or display publicly, prepare derivative works,
     distribute, and otherwise use the Software alone or in any
     derivative version, provided, however, that the BeOpen Python
     License is retained in the Software, alone or in any derivative
     version prepared by Licensee.

  3. BeOpen is making the Software available to Licensee on an "AS IS"
     basis.  BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO
     AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  4. BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE
     SOFTWARE FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE,
     OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY
     THEREOF.

  5. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  6. This License Agreement shall be governed by and interpreted in all
     respects by the law of the State of California, excluding conflict
     of law provisions.  Nothing in this License Agreement shall be
     deemed to create any relationship of agency, partnership, or joint
     venture between BeOpen and Licensee.  This License Agreement does
     not grant permission to use BeOpen trademarks or trade names in a
     trademark sense to endorse or promote products or services of
     Licensee, or any third party.  As an exception, the "BeOpen
     Python" logos available at http://www.pythonlabs.com/logos.html
     may be used according to the permissions granted on that web page.

  7. By copying, installing or otherwise using the software, Licensee
     agrees to be bound by the terms and conditions of this License
     Agreement.

               *CNRI LICENSE AGREEMENT FOR PYTHON 1.6.1*

  1. This LICENSE AGREEMENT is between the Corporation for National
     Research Initiatives, having an office at 1895 Preston White Drive,
     Reston, VA 20191 ("CNRI"), and the Individual or Organization
     ("Licensee") accessing and otherwise using Python 1.6.1 software in
     source or binary form and its associated documentation.

  2. Subject to the terms and conditions of this License Agreement, CNRI
     hereby grants Licensee a nonexclusive, royalty-free, world-wide
     license to reproduce, analyze, test, perform and/or display
     publicly, prepare derivative works, distribute, and otherwise use
     Python 1.6.1 alone or in any derivative version, provided,
     however, that CNRI's License Agreement and CNRI's notice of
     copyright, i.e., "Copyright (C) 1995-2001 Corporation for National
     Research Initiatives; All Rights Reserved" are retained in Python
     1.6.1 alone or in any derivative version prepared by Licensee.
     Alternately, in lieu of CNRI's License Agreement, Licensee may
     substitute the following text (omitting the quotes): "Python 1.6.1
     is made available subject to the terms and conditions in CNRI's
     License Agreement.  This Agreement together with Python 1.6.1 may
     be located on the Internet using the following unique, persistent
     identifier (known as a handle): 1895.22/1013.  This Agreement may
     also be obtained from a proxy server on the Internet using the
     following URL: `http://hdl.handle.net/1895.22/1013'."

  3. In the event Licensee prepares a derivative work that is based on
     or incorporates Python 1.6.1 or any part thereof, and wants to make
     the derivative work available to others as provided herein, then
     Licensee hereby agrees to include in any such work a brief summary
     of the changes made to Python 1.6.1.

  4. CNRI is making Python 1.6.1 available to Licensee on an "AS IS"
     basis.  CNRI MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR
     IMPLIED.  BY WAY OF EXAMPLE, BUT NOT LIMITATION, CNRI MAKES NO AND
     DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR
     FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 1.6.1
     WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

  5. CNRI SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON
     1.6.1 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR
     LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING
     PYTHON 1.6.1, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE
     POSSIBILITY THEREOF.

  6. This License Agreement will automatically terminate upon a material
     breach of its terms and conditions.

  7. This License Agreement shall be governed by the federal
     intellectual property law of the United States, including without
     limitation the federal copyright law, and, to the extent such U.S.
     federal law does not apply, by the law of the Commonwealth of
     Virginia, excluding Virginia's conflict of law provisions.
     Notwithstanding the foregoing, with regard to derivative works
     based on Python 1.6.1 that incorporate non-separable material that
     was previously distributed under the GNU General Public License
     (GPL), the law of the Commonwealth of Virginia shall govern this
     License Agreement only as to issues arising under or with respect
     to Paragraphs 4, 5, and 7 of this License Agreement.  Nothing in
     this License Agreement shall be deemed to create any relationship
     of agency, partnership, or joint venture between CNRI and
     Licensee.  This License Agreement does not grant permission to use
     CNRI trademarks or trade name in a trademark sense to endorse or
     promote products or services of Licensee, or any third party.

  8. By clicking on the "ACCEPT" button where indicated, or by copying,
     installing or otherwise using Python 1.6.1, Licensee agrees to be
     bound by the terms and conditions of this License Agreement.

                                ACCEPT

         *CWI LICENSE AGREEMENT FOR PYTHON 0.9.0 THROUGH 1.2*

Copyright (C) 1991 - 1995, Stichting Mathematisch Centrum Amsterdam,
The Netherlands.  All rights reserved.

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Stichting Mathematisch
Centrum or CWI not be used in advertising or publicity pertaining to
distribution of the software without specific, written prior permission.

STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE FOR
ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


File: python-api-jp.info,  Node: Licenses and Acknowledgements for Incorporated Software,  Prev: Terms and conditions for accessing or otherwise using Python,  Up: 歴史とライセンス

B.3 Licenses and Acknowledgements for Incorporated Software
===========================================================

This section is an incomplete, but growing list of licenses and
acknowledgements for third-party software incorporated in the Python
distribution.

* Menu:

* Mersenne Twister::
* Sockets::
* Floating point exception control::
* MD5 message digest algorithm::
* Asynchronous socket services::
* Cookie management::
* Profiling::
* Execution tracing::
* UUencode and UUdecode functions::
* XML Remote Procedure Calls::


File: python-api-jp.info,  Node: Mersenne Twister,  Next: Sockets,  Prev: Licenses and Acknowledgements for Incorporated Software,  Up: Licenses and Acknowledgements for Incorporated Software

B.3.1 Mersenne Twister
----------------------

The `_random' module includes code based on a download from
`http://www.math.keio.ac.jp/~matumoto/MT2002/emt19937ar.html'.  The
following are the verbatim comments from the original code:

     A C-program for MT19937, with initialization improved 2002/1/26.
     Coded by Takuji Nishimura and Makoto Matsumoto.

     Before using, initialize the state by using init_genrand(seed)
     or init_by_array(init_key, key_length).

     Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
     All rights reserved.

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.

      3. The names of its contributors may not be used to endorse or promote
         products derived from this software without specific prior written
         permission.

     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
     PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
     PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

     Any feedback is very welcome.
     http://www.math.keio.ac.jp/matumoto/emt.html
     email: matumoto@math.keio.ac.jp


File: python-api-jp.info,  Node: Sockets,  Next: Floating point exception control,  Prev: Mersenne Twister,  Up: Licenses and Acknowledgements for Incorporated Software

B.3.2 Sockets
-------------

The `socket' module uses the functions, `getaddrinfo', and
`getnameinfo', which are coded in separate source files from the WIDE
Project, `http://www.wide.ad.jp/about/index.html'.

     Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
     All rights reserved.

     Redistribution and use in source and binary forms, with or without
     modification, are permitted provided that the following conditions
     are met:
     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.
     3. Neither the name of the project nor the names of its contributors
        may be used to endorse or promote products derived from this software
        without specific prior written permission.

     THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
     GAI_ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
     FOR GAI_ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
     OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
     HOWEVER CAUSED AND ON GAI_ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
     LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN GAI_ANY WAY
     OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
     SUCH DAMAGE.


File: python-api-jp.info,  Node: Floating point exception control,  Next: MD5 message digest algorithm,  Prev: Sockets,  Up: Licenses and Acknowledgements for Incorporated Software

B.3.3 Floating point exception control
--------------------------------------

The source for the `fpectl' module includes the following notice:

          ---------------------------------------------------------------------
         /                       Copyright (c) 1996.                           \
        |          The Regents of the University of California.                 |
        |                        All rights reserved.                           |
        |                                                                       |
        |   Permission to use, copy, modify, and distribute this software for   |
        |   any purpose without fee is hereby granted, provided that this en-   |
        |   tire notice is included in all copies of any software which is or   |
        |   includes  a  copy  or  modification  of  this software and in all   |
        |   copies of the supporting documentation for such software.           |
        |                                                                       |
        |   This  work was produced at the University of California, Lawrence   |
        |   Livermore National Laboratory under  contract  no.  W-7405-ENG-48   |
        |   between  the  U.S.  Department  of  Energy and The Regents of the   |
        |   University of California for the operation of UC LLNL.              |
        |                                                                       |
        |                              DISCLAIMER                               |
        |                                                                       |
        |   This  software was prepared as an account of work sponsored by an   |
        |   agency of the United States Government. Neither the United States   |
        |   Government  nor the University of California nor any of their em-   |
        |   ployees, makes any warranty, express or implied, or  assumes  any   |
        |   liability  or  responsibility  for the accuracy, completeness, or   |
        |   usefulness of any information,  apparatus,  product,  or  process   |
        |   disclosed,   or  represents  that  its  use  would  not  infringe   |
        |   privately-owned rights. Reference herein to any specific  commer-   |
        |   cial  products,  process,  or  service  by trade name, trademark,   |
        |   manufacturer, or otherwise, does not  necessarily  constitute  or   |
        |   imply  its endorsement, recommendation, or favoring by the United   |
        |   States Government or the University of California. The views  and   |
        |   opinions  of authors expressed herein do not necessarily state or   |
        |   reflect those of the United States Government or  the  University   |
        |   of  California,  and shall not be used for advertising or product   |
         \  endorsement purposes.                                              /
          ---------------------------------------------------------------------


File: python-api-jp.info,  Node: MD5 message digest algorithm,  Next: Asynchronous socket services,  Prev: Floating point exception control,  Up: Licenses and Acknowledgements for Incorporated Software

B.3.4 MD5 message digest algorithm
----------------------------------

The source code for the `md5' module contains the following notice:

       Copyright (C) 1999, 2002 Aladdin Enterprises.  All rights reserved.

       This software is provided 'as-is', without any express or implied
       warranty.  In no event will the authors be held liable for any damages
       arising from the use of this software.

       Permission is granted to anyone to use this software for any purpose,
       including commercial applications, and to alter it and redistribute it
       freely, subject to the following restrictions:

       1. The origin of this software must not be misrepresented; you must not
          claim that you wrote the original software. If you use this software
          in a product, an acknowledgment in the product documentation would be
          appreciated but is not required.
       2. Altered source versions must be plainly marked as such, and must not be
          misrepresented as being the original software.
       3. This notice may not be removed or altered from any source distribution.

       L. Peter Deutsch
       ghost@aladdin.com

       Independent implementation of MD5 (RFC 1321).

       This code implements the MD5 Algorithm defined in RFC 1321, whose
       text is available at
     	http://www.ietf.org/rfc/rfc1321.txt
       The code is derived from the text of the RFC, including the test suite
       (section A.5) but excluding the rest of Appendix A.  It does not include
       any code or documentation that is identified in the RFC as being
       copyrighted.

       The original and principal author of md5.h is L. Peter Deutsch
       <ghost@aladdin.com>.  Other authors are noted in the change history
       that follows (in reverse chronological order):

       2002-04-13 lpd Removed support for non-ANSI compilers; removed
     	references to Ghostscript; clarified derivation from RFC 1321;
     	now handles byte order either statically or dynamically.
       1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
       1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5);
     	added conditionalization for C++ compilation from Martin
     	Purschke <purschke@bnl.gov>.
       1999-05-03 lpd Original version.


File: python-api-jp.info,  Node: Asynchronous socket services,  Next: Cookie management,  Prev: MD5 message digest algorithm,  Up: Licenses and Acknowledgements for Incorporated Software

B.3.5 Asynchronous socket services
----------------------------------

The `asynchat' and `asyncore' modules contain the following notice:

      Copyright 1996 by Sam Rushing

                              All Rights Reserved

      Permission to use, copy, modify, and distribute this software and
      its documentation for any purpose and without fee is hereby
      granted, provided that the above copyright notice appear in all
      copies and that both that copyright notice and this permission
      notice appear in supporting documentation, and that the name of Sam
      Rushing not be used in advertising or publicity pertaining to
      distribution of the software without specific, written prior
      permission.

      SAM RUSHING DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
      INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
      NO EVENT SHALL SAM RUSHING BE LIABLE FOR ANY SPECIAL, INDIRECT OR
      CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
      OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
      NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
      CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


File: python-api-jp.info,  Node: Cookie management,  Next: Profiling,  Prev: Asynchronous socket services,  Up: Licenses and Acknowledgements for Incorporated Software

B.3.6 Cookie management
-----------------------

The `Cookie' module contains the following notice:

      Copyright 2000 by Timothy O'Malley <timo@alum.mit.edu>

                     All Rights Reserved

      Permission to use, copy, modify, and distribute this software
      and its documentation for any purpose and without fee is hereby
      granted, provided that the above copyright notice appear in all
      copies and that both that copyright notice and this permission
      notice appear in supporting documentation, and that the name of
      Timothy O'Malley  not be used in advertising or publicity
      pertaining to distribution of the software without specific, written
      prior permission.

      Timothy O'Malley DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
      SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS, IN NO EVENT SHALL Timothy O'Malley BE LIABLE FOR
      ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
      WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
      WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
      ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.


File: python-api-jp.info,  Node: Profiling,  Next: Execution tracing,  Prev: Cookie management,  Up: Licenses and Acknowledgements for Incorporated Software

B.3.7 Profiling
---------------

The `profile' and `pstats' modules contain the following notice:

      Copyright 1994, by InfoSeek Corporation, all rights reserved.
      Written by James Roskind

      Permission to use, copy, modify, and distribute this Python software
      and its associated documentation for any purpose (subject to the
      restriction in the following sentence) without fee is hereby granted,
      provided that the above copyright notice appears in all copies, and
      that both that copyright notice and this permission notice appear in
      supporting documentation, and that the name of InfoSeek not be used in
      advertising or publicity pertaining to distribution of the software
      without specific, written prior permission.  This permission is
      explicitly restricted to the copying and modification of the software
      to remain in Python, compiled Python, or other languages (such as C)
      wherein the modified or derived code is exclusively imported into a
      Python module.

      INFOSEEK CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
      SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
      FITNESS. IN NO EVENT SHALL INFOSEEK CORPORATION BE LIABLE FOR ANY
      SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
      RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
      CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
      CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


File: python-api-jp.info,  Node: Execution tracing,  Next: UUencode and UUdecode functions,  Prev: Profiling,  Up: Licenses and Acknowledgements for Incorporated Software

B.3.8 Execution tracing
-----------------------

The `trace' module contains the following notice:

      portions copyright 2001, Autonomous Zones Industries, Inc., all rights...
      err...  reserved and offered to the public under the terms of the
      Python 2.2 license.
      Author: Zooko O'Whielacronx
      http://zooko.com/
      mailto:zooko@zooko.com

      Copyright 2000, Mojam Media, Inc., all rights reserved.
      Author: Skip Montanaro

      Copyright 1999, Bioreason, Inc., all rights reserved.
      Author: Andrew Dalke

      Copyright 1995-1997, Automatrix, Inc., all rights reserved.
      Author: Skip Montanaro

      Copyright 1991-1995, Stichting Mathematisch Centrum, all rights reserved.

      Permission to use, copy, modify, and distribute this Python software and
      its associated documentation for any purpose without fee is hereby
      granted, provided that the above copyright notice appears in all copies,
      and that both that copyright notice and this permission notice appear in
      supporting documentation, and that the name of neither Automatrix,
      Bioreason or Mojam Media be used in advertising or publicity pertaining to
      distribution of the software without specific, written prior permission.


File: python-api-jp.info,  Node: UUencode and UUdecode functions,  Next: XML Remote Procedure Calls,  Prev: Execution tracing,  Up: Licenses and Acknowledgements for Incorporated Software

B.3.9 UUencode and UUdecode functions
-------------------------------------

The `uu' module contains the following notice:

      Copyright 1994 by Lance Ellinghouse
      Cathedral City, California Republic, United States of America.
                             All Rights Reserved
      Permission to use, copy, modify, and distribute this software and its
      documentation for any purpose and without fee is hereby granted,
      provided that the above copyright notice appear in all copies and that
      both that copyright notice and this permission notice appear in
      supporting documentation, and that the name of Lance Ellinghouse
      not be used in advertising or publicity pertaining to distribution
      of the software without specific, written prior permission.
      LANCE ELLINGHOUSE DISCLAIMS ALL WARRANTIES WITH REGARD TO
      THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
      FITNESS, IN NO EVENT SHALL LANCE ELLINGHOUSE CENTRUM BE LIABLE
      FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
      WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
      ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
      OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

      Modified by Jack Jansen, CWI, July 1995:
      - Use binascii module to do the actual line-by-line conversion
        between ascii and binary. This results in a 1000-fold speedup. The C
        version is still 5 times faster, though.
      - Arguments more compliant with python standard


File: python-api-jp.info,  Node: XML Remote Procedure Calls,  Prev: UUencode and UUdecode functions,  Up: Licenses and Acknowledgements for Incorporated Software

B.3.10 XML Remote Procedure Calls
---------------------------------

The `xmlrpclib' module contains the following notice:

          The XML-RPC client interface is

      Copyright (c) 1999-2002 by Secret Labs AB
      Copyright (c) 1999-2002 by Fredrik Lundh

      By obtaining, using, and/or copying this software and/or its
      associated documentation, you agree that you have read, understood,
      and will comply with the following terms and conditions:

      Permission to use, copy, modify, and distribute this software and
      its associated documentation for any purpose and without fee is
      hereby granted, provided that the above copyright notice appears in
      all copies, and that both that copyright notice and this permission
      notice appear in supporting documentation, and that the name of
      Secret Labs AB or the author not be used in advertising or publicity
      pertaining to distribution of the software without specific, written
      prior permission.

      SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
      TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANT-
      ABILITY AND FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR
      BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
      DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
      WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
      ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
      OF THIS SOFTWARE.


File: python-api-jp.info,  Node: 日本語訳について,  Next: Module Index,  Prev: 歴史とライセンス,  Up: Top

Appendix C 日本語訳について
***************************

* Menu:

* このドキュメントについて::
* 翻訳者一覧 敬称略::
* 25 差分翻訳者一覧 敬称略::


File: python-api-jp.info,  Node: このドキュメントについて,  Next: 翻訳者一覧 敬称略,  Prev: 日本語訳について,  Up: 日本語訳について

C.1 このドキュメントについて
============================

この文書は、Pythonドキュメント翻訳プロジェクトによる Python C/API
Reference Release の日本語訳版です。日本語訳に対する質問や提案などが
ありましたら、Pythonドキュメント翻訳プロジェクトのメーリングリスト

`http://www.python.jp/mailman/listinfo/python-doc-jp'

または、プロジェクトのバグ管理ページ

`http://sourceforge.jp/tracker/?atid=116&group_id=11&func=browse'

までご報告ください。


File: python-api-jp.info,  Node: 翻訳者一覧 敬称略,  Next: 25 差分翻訳者一覧 敬称略,  Prev: このドキュメントについて,  Up: 日本語訳について

C.2 翻訳者一覧 (敬称略)
=======================

Yasushi MASUDA


File: python-api-jp.info,  Node: 25 差分翻訳者一覧 敬称略,  Prev: 翻訳者一覧 敬称略,  Up: 日本語訳について

C.3 2.5 差分翻訳者一覧 (敬称略)
===============================

Naoki INADA


File: python-api-jp.info,  Node: Module Index,  Next: Class-Exception-Object Index,  Prev: 日本語訳について,  Up: Top

Module Index
************

 [index ]
* Menu:

* __builtin__ <1>:                       初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  13)
* __builtin__:                           Python の埋め込み.   (line  14)
* __main__ <1>:                          初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  13)
* __main__:                              Python の埋め込み.   (line  14)
* exceptions:                            Python の埋め込み.   (line  15)
* ihooks:                                モジュールの import. (line  45)
* rexec:                                 モジュールの import. (line  45)
* signal:                                例外処理.            (line 270)
* sys <1>:                               初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  13)
* sys:                                   Python の埋め込み.   (line  14)
* thread:                                スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 180)


File: python-api-jp.info,  Node: Class-Exception-Object Index,  Next: Function-Method-Variable Index,  Prev: Module Index,  Up: Top

Class, Exception, and Object Index
**********************************

 [index ]
* Menu:

* buffer:                                Buffer Objects.       (line  6)
* CObject:                               Cオブジェクト CObject.
                                                               (line  6)
* complex number:                        浮動小数点オブジェクト complex number object.
                                                               (line  6)
* dictionary:                            辞書オブジェクト dictionary object.
                                                               (line  6)
* file:                                  ファイルオブジェクト file object.
                                                               (line  6)
* floating point:                        浮動小数点型オブジェクト floating point object.
                                                               (line  6)
* frozenset:                             集合オブジェクト Set Objects.
                                                               (line  6)
* function:                              関数オブジェクト Function Objects.
                                                               (line  6)
* instance:                              インスタンスオブジェクト instance object.
                                                               (line  6)
* integer:                               通常整数型オブジェクト plain integer object.
                                                               (line  6)
* list:                                  List Objects.         (line  6)
* long integer:                          長整数型オブジェクト long integer object.
                                                               (line  6)
* mapping:                               マップ型オブジェクト mapping object.
                                                               (line  6)
* method:                                メソッドオブジェクト method object.
                                                               (line  6)
* module:                                モジュールオブジェクト module object.
                                                               (line  6)
* None:                                  None オブジェクト.    (line  6)
* numeric:                               数値型オブジェクト numeric object.
                                                               (line  6)
* sequence:                              シーケンスオブジェクト sequence object.
                                                               (line  6)
* set:                                   集合オブジェクト Set Objects.
                                                               (line  6)
* string:                                文字列オブジェクト string object.
                                                               (line  9)
* tuple:                                 タプルオブジェクト tuple object.
                                                               (line  6)
* type <1>:                              型オブジェクト type object.
                                                               (line  6)
* type:                                  オブジェクト、型および参照カウント.
                                                               (line 14)


File: python-api-jp.info,  Node: Function-Method-Variable Index,  Next: Miscellaneous Index,  Prev: Class-Exception-Object Index,  Up: Top

Function, Method, and Variable Index
************************************

 [index ]
* Menu:

* __import__:                            モジュールの import. (line  27)
* _Py_c_diff:                            C 構造体としての複素数.
                                                              (line  26)
* _Py_c_neg:                             C 構造体としての複素数.
                                                              (line  29)
* _Py_c_pow:                             C 構造体としての複素数.
                                                              (line  38)
* _Py_c_prod:                            C 構造体としての複素数.
                                                              (line  32)
* _Py_c_quot:                            C 構造体としての複素数.
                                                              (line  35)
* _Py_c_sum:                             C 構造体としての複素数.
                                                              (line  23)
* _Py_NoneStruct:                        オブジェクトをヒープ上にメモリ確保する.
                                                              (line  78)
* _PyImport_FindExtension:               モジュールの import. (line 115)
* _PyImport_Fini:                        モジュールの import. (line 112)
* _PyImport_FixupExtension:              モジュールの import. (line 118)
* _PyImport_Init:                        モジュールの import. (line 106)
* _PyObject_Del:                         オブジェクトをヒープ上にメモリ確保する.
                                                              (line  11)
* _PyObject_GC_TRACK:                    循環参照ガベージコレクションをサポートする.
                                                              (line  58)
* _PyObject_GC_UNTRACK:                  循環参照ガベージコレクションをサポートする.
                                                              (line  84)
* _PyObject_New:                         オブジェクトをヒープ上にメモリ確保する.
                                                              (line   7)
* _PyObject_NewVar:                      オブジェクトをヒープ上にメモリ確保する.
                                                              (line   9)
* _PyString_Resize:                      文字列オブジェクト string object.
                                                              (line 144)
* _PyTuple_Resize:                       タプルオブジェクト tuple object.
                                                              (line  66)
* abs:                                   数値型プロトコル number protocol.
                                                              (line  66)
* apply:                                 オブジェクトプロトコル object protocol.
                                                              (line 157)
* classmethod:                           共通のオブジェクト構造体 common object structure.
                                                              (line 146)
* cmp:                                   オブジェクトプロトコル object protocol.
                                                              (line  74)
* CO_FUTURE_DIVISION:                    超高レベルレイヤ.    (line 209)
* coerce:                                数値型プロトコル number protocol.
                                                              (line 181)
* compile:                               モジュールの import. (line  72)
* divmod:                                数値型プロトコル number protocol.
                                                              (line  46)
* float:                                 数値型プロトコル number protocol.
                                                              (line 195)
* hash <1>:                              型オブジェクト.      (line 302)
* hash:                                  オブジェクトプロトコル object protocol.
                                                              (line 207)
* int:                                   数値型プロトコル number protocol.
                                                              (line 187)
* len <1>:                               集合オブジェクト Set Objects.
                                                              (line  70)
* len <2>:                               辞書オブジェクト dictionary object.
                                                              (line  95)
* len <3>:                               List Objects.        (line  29)
* len <4>:                               マップ型プロトコル mapping protocol.
                                                              (line  15)
* len <5>:                               シーケンス型プロトコル sequence protocol.
                                                              (line  15)
* len:                                   オブジェクトプロトコル object protocol.
                                                              (line 239)
* long:                                  数値型プロトコル number protocol.
                                                              (line 191)
* METH_CLASS:                            共通のオブジェクト構造体 common object structure.
                                                              (line 145)
* METH_COEXIST:                          共通のオブジェクト構造体 common object structure.
                                                              (line 161)
* METH_KEYWORDS:                         共通のオブジェクト構造体 common object structure.
                                                              (line 111)
* METH_NOARGS:                           共通のオブジェクト構造体 common object structure.
                                                              (line 119)
* METH_O:                                共通のオブジェクト構造体 common object structure.
                                                              (line 127)
* METH_OLDARGS:                          共通のオブジェクト構造体 common object structure.
                                                              (line 133)
* METH_STATIC:                           共通のオブジェクト構造体 common object structure.
                                                              (line 151)
* METH_VARARGS:                          共通のオブジェクト構造体 common object structure.
                                                              (line 101)
* pow:                                   数値型プロトコル number protocol.
                                                              (line  50)
* Py_AtExit:                             プロセス制御.        (line  20)
* Py_BuildValue:                         引数の解釈と値の構築.
                                                              (line 398)
* Py_CLEAR:                              参照カウント 2.      (line  41)
* Py_CompileString:                      超高レベルレイヤ.    (line 167)
* Py_CompileStringFlags:                 超高レベルレイヤ.    (line 171)
* Py_DECREF:                             参照カウント 2.      (line  18)
* Py_END_OF_BUFFER:                      Buffer Objects.      (line  62)
* Py_EndInterpreter:                     初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 135)
* Py_eval_input:                         超高レベルレイヤ.    (line 182)
* Py_Exit:                               プロセス制御.        (line  16)
* Py_False:                              Bool 型オブジェクト. (line  16)
* Py_FatalError:                         プロセス制御.        (line   7)
* Py_FdIsInteractive:                    オペレーティングシステム関連のユーティリティ.
                                                              (line   7)
* Py_file_input:                         超高レベルレイヤ.    (line 185)
* Py_Finalize:                           初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  34)
* Py_FindMethod:                         共通のオブジェクト構造体 common object structure.
                                                              (line 174)
* Py_GetBuildInfo:                       初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 290)
* Py_GetBuildNumber:                     初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 255)
* Py_GetCompiler:                        初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 278)
* Py_GetCopyright:                       初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 271)
* Py_GetExecPrefix:                      初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 179)
* Py_GetPath:                            初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 227)
* Py_GetPlatform:                        初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 261)
* Py_GetPrefix:                          初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 165)
* Py_GetProgramFullPath:                 初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 219)
* Py_GetProgramName:                     初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 159)
* Py_GetVersion:                         初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 241)
* Py_INCREF:                             参照カウント 2.      (line   9)
* Py_Initialize:                         初期化 initialization、終了処理 finalization、スレッド.
                                                              (line   7)
* Py_InitializeEx:                       初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  22)
* Py_InitModule:                         オブジェクトをヒープ上にメモリ確保する.
                                                              (line  51)
* Py_InitModule3:                        オブジェクトをヒープ上にメモリ確保する.
                                                              (line  56)
* Py_InitModule4:                        オブジェクトをヒープ上にメモリ確保する.
                                                              (line  62)
* Py_IsInitialized:                      初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  28)
* Py_Main:                               超高レベルレイヤ.    (line  23)
* Py_NewInterpreter:                     初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  67)
* Py_None:                               None オブジェクト.   (line  13)
* Py_SetProgramName:                     初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 146)
* Py_single_input:                       超高レベルレイヤ.    (line 191)
* Py_TPFLAGS_BASETYPE:                   型オブジェクト.      (line 494)
* Py_TPFLAGS_CHECKTYPES:                 型オブジェクト.      (line 449)
* Py_TPFLAGS_DEFAULT:                    型オブジェクト.      (line 520)
* Py_TPFLAGS_GC:                         型オブジェクト.      (line 431)
* Py_TPFLAGS_HAVE_CLASS:                 型オブジェクト.      (line 475)
* Py_TPFLAGS_HAVE_GC <1>:                循環参照ガベージコレクションをサポートする.
                                                              (line  23)
* Py_TPFLAGS_HAVE_GC:                    型オブジェクト.      (line 507)
* Py_TPFLAGS_HAVE_GETCHARBUFFER <1>:     バッファオブジェクト構造体 buffer object structure.
                                                              (line  72)
* Py_TPFLAGS_HAVE_GETCHARBUFFER:         型オブジェクト.      (line 421)
* Py_TPFLAGS_HAVE_INPLACEOPS:            型オブジェクト.      (line 435)
* Py_TPFLAGS_HAVE_ITER:                  型オブジェクト.      (line 471)
* Py_TPFLAGS_HAVE_RICHCOMPARE:           型オブジェクト.      (line 461)
* Py_TPFLAGS_HAVE_SEQUENCE_IN:           型オブジェクト.      (line 426)
* Py_TPFLAGS_HAVE_WEAKREFS:              型オブジェクト.      (line 466)
* Py_TPFLAGS_HEAPTYPE:                   型オブジェクト.      (line 484)
* Py_TPFLAGS_READY:                      型オブジェクト.      (line 499)
* Py_TPFLAGS_READYING:                   型オブジェクト.      (line 503)
* Py_True:                               Bool 型オブジェクト. (line  22)
* Py_UNICODE_ISALNUM:                    Unicode オブジェクト Unicode object.
                                                              (line  98)
* Py_UNICODE_ISALPHA:                    Unicode オブジェクト Unicode object.
                                                              (line  95)
* Py_UNICODE_ISDECIMAL:                  Unicode オブジェクト Unicode object.
                                                              (line  86)
* Py_UNICODE_ISDIGIT:                    Unicode オブジェクト Unicode object.
                                                              (line  89)
* Py_UNICODE_ISLINEBREAK:                Unicode オブジェクト Unicode object.
                                                              (line  83)
* Py_UNICODE_ISLOWER:                    Unicode オブジェクト Unicode object.
                                                              (line  73)
* Py_UNICODE_ISNUMERIC:                  Unicode オブジェクト Unicode object.
                                                              (line  92)
* Py_UNICODE_ISSPACE:                    Unicode オブジェクト Unicode object.
                                                              (line  70)
* Py_UNICODE_ISTITLE:                    Unicode オブジェクト Unicode object.
                                                              (line  79)
* Py_UNICODE_ISUPPER:                    Unicode オブジェクト Unicode object.
                                                              (line  76)
* Py_UNICODE_TODECIMAL:                  Unicode オブジェクト Unicode object.
                                                              (line 112)
* Py_UNICODE_TODIGIT:                    Unicode オブジェクト Unicode object.
                                                              (line 116)
* Py_UNICODE_TOLOWER:                    Unicode オブジェクト Unicode object.
                                                              (line 103)
* Py_UNICODE_TONUMERIC:                  Unicode オブジェクト Unicode object.
                                                              (line 120)
* Py_UNICODE_TOTITLE:                    Unicode オブジェクト Unicode object.
                                                              (line 109)
* Py_UNICODE_TOUPPER:                    Unicode オブジェクト Unicode object.
                                                              (line 106)
* Py_VISIT:                              循環参照ガベージコレクションをサポートする.
                                                              (line 113)
* Py_XDECREF:                            参照カウント 2.      (line  35)
* Py_XINCREF:                            参照カウント 2.      (line  14)
* PyAnySet_Check:                        集合オブジェクト Set Objects.
                                                              (line  39)
* PyAnySet_CheckExact:                   集合オブジェクト Set Objects.
                                                              (line  43)
* PyArg_Parse:                           引数の解釈と値の構築.
                                                              (line 343)
* PyArg_ParseTuple:                      引数の解釈と値の構築.
                                                              (line 325)
* PyArg_ParseTupleAndKeywords:           引数の解釈と値の構築.
                                                              (line 334)
* PyArg_UnpackTuple:                     引数の解釈と値の構築.
                                                              (line 354)
* PyArg_VaParse:                         引数の解釈と値の構築.
                                                              (line 330)
* PyArg_VaParseTupleAndKeywords:         引数の解釈と値の構築.
                                                              (line 339)
* PyBool_Check:                          Bool 型オブジェクト. (line  12)
* PyBool_FromLong:                       Bool 型オブジェクト. (line  35)
* PyBuffer_Check:                        Buffer Objects.      (line  70)
* PyBuffer_FromMemory:                   Buffer Objects.      (line  92)
* PyBuffer_FromObject:                   Buffer Objects.      (line  73)
* PyBuffer_FromReadWriteMemory:          Buffer Objects.      (line 101)
* PyBuffer_FromReadWriteObject:          Buffer Objects.      (line  86)
* PyBuffer_New:                          Buffer Objects.      (line 105)
* PyBuffer_Type:                         Buffer Objects.      (line  57)
* PyCallable_Check:                      オブジェクトプロトコル object protocol.
                                                              (line 143)
* PyCallIter_Check:                      イテレータオブジェクト iterator object.
                                                              (line  34)
* PyCallIter_New:                        イテレータオブジェクト iterator object.
                                                              (line  38)
* PyCallIter_Type:                       イテレータオブジェクト iterator object.
                                                              (line  29)
* PyCell_Check:                          セルオブジェクト cell object.
                                                              (line  24)
* PyCell_GET:                            セルオブジェクト cell object.
                                                              (line  35)
* PyCell_Get:                            セルオブジェクト cell object.
                                                              (line  32)
* PyCell_New:                            セルオブジェクト cell object.
                                                              (line  28)
* PyCell_SET:                            セルオブジェクト cell object.
                                                              (line  46)
* PyCell_Set:                            セルオブジェクト cell object.
                                                              (line  39)
* PyCell_Type:                           セルオブジェクト cell object.
                                                              (line  21)
* PyCObject_AsVoidPtr:                   Cオブジェクト CObject.
                                                              (line  32)
* PyCObject_Check:                       Cオブジェクト CObject.
                                                              (line  20)
* PyCObject_FromVoidPtr:                 Cオブジェクト CObject.
                                                              (line  23)
* PyCObject_FromVoidPtrAndDesc:          Cオブジェクト CObject.
                                                              (line  27)
* PyCObject_GetDesc:                     Cオブジェクト CObject.
                                                              (line  36)
* PyCObject_SetVoidPtr:                  Cオブジェクト CObject.
                                                              (line  40)
* PyComplex_AsCComplex:                  Python オブジェクトとしての複素数型.
                                                              (line  39)
* PyComplex_Check:                       Python オブジェクトとしての複素数型.
                                                              (line  16)
* PyComplex_CheckExact:                  Python オブジェクトとしての複素数型.
                                                              (line  21)
* PyComplex_FromCComplex:                Python オブジェクトとしての複素数型.
                                                              (line  26)
* PyComplex_FromDoubles:                 Python オブジェクトとしての複素数型.
                                                              (line  29)
* PyComplex_ImagAsDouble:                Python オブジェクトとしての複素数型.
                                                              (line  36)
* PyComplex_RealAsDouble:                Python オブジェクトとしての複素数型.
                                                              (line  33)
* PyComplex_Type:                        Python オブジェクトとしての複素数型.
                                                              (line  11)
* PyDate_Check:                          DateTime オブジェクト.
                                                              (line  16)
* PyDate_CheckExact:                     DateTime オブジェクト.
                                                              (line  21)
* PyDate_FromDate:                       DateTime オブジェクト.
                                                              (line  64)
* PyDate_FromTimestamp:                  DateTime オブジェクト.
                                                              (line 139)
* PyDateTime_Check:                      DateTime オブジェクト.
                                                              (line  25)
* PyDateTime_CheckExact:                 DateTime オブジェクト.
                                                              (line  30)
* PyDateTime_DATE_GET_HOUR:              DateTime オブジェクト.
                                                              (line 101)
* PyDateTime_DATE_GET_MICROSECOND:       DateTime オブジェクト.
                                                              (line 110)
* PyDateTime_DATE_GET_MINUTE:            DateTime オブジェクト.
                                                              (line 104)
* PyDateTime_DATE_GET_SECOND:            DateTime オブジェクト.
                                                              (line 107)
* PyDateTime_FromDateAndTime:            DateTime オブジェクト.
                                                              (line  68)
* PyDateTime_FromTimestamp:              DateTime オブジェクト.
                                                              (line 134)
* PyDateTime_GET_DAY:                    DateTime オブジェクト.
                                                              (line  93)
* PyDateTime_GET_MONTH:                  DateTime オブジェクト.
                                                              (line  90)
* PyDateTime_GET_YEAR:                   DateTime オブジェクト.
                                                              (line  87)
* PyDateTime_TIME_GET_HOUR:              DateTime オブジェクト.
                                                              (line 119)
* PyDateTime_TIME_GET_MICROSECOND:       DateTime オブジェクト.
                                                              (line 128)
* PyDateTime_TIME_GET_MINUTE:            DateTime オブジェクト.
                                                              (line 122)
* PyDateTime_TIME_GET_SECOND:            DateTime オブジェクト.
                                                              (line 125)
* PyDelta_Check:                         DateTime オブジェクト.
                                                              (line  44)
* PyDelta_CheckExact:                    DateTime オブジェクト.
                                                              (line  49)
* PyDelta_FromDSU:                       DateTime オブジェクト.
                                                              (line  76)
* PyDescr_IsData:                        デスクリプタオブジェクト descriptor object.
                                                              (line  27)
* PyDescr_NewGetSet:                     デスクリプタオブジェクト descriptor object.
                                                              (line  15)
* PyDescr_NewMember:                     デスクリプタオブジェクト descriptor object.
                                                              (line  18)
* PyDescr_NewMethod:                     デスクリプタオブジェクト descriptor object.
                                                              (line  21)
* PyDescr_NewWrapper:                    デスクリプタオブジェクト descriptor object.
                                                              (line  24)
* PyDict_Check:                          辞書オブジェクト dictionary object.
                                                              (line  16)
* PyDict_CheckExact:                     辞書オブジェクト dictionary object.
                                                              (line  19)
* PyDict_Clear:                          辞書オブジェクト dictionary object.
                                                              (line  34)
* PyDict_Contains:                       辞書オブジェクト dictionary object.
                                                              (line  37)
* PyDict_Copy:                           辞書オブジェクト dictionary object.
                                                              (line  43)
* PyDict_DelItem:                        辞書オブジェクト dictionary object.
                                                              (line  59)
* PyDict_DelItemString:                  辞書オブジェクト dictionary object.
                                                              (line  66)
* PyDict_GetItem:                        辞書オブジェクト dictionary object.
                                                              (line  70)
* PyDict_GetItemString:                  辞書オブジェクト dictionary object.
                                                              (line  75)
* PyDict_Items:                          辞書オブジェクト dictionary object.
                                                              (line  79)
* PyDict_Keys:                           辞書オブジェクト dictionary object.
                                                              (line  84)
* PyDict_Merge:                          辞書オブジェクト dictionary object.
                                                              (line 142)
* PyDict_MergeFromSeq2:                  辞書オブジェクト dictionary object.
                                                              (line 159)
* PyDict_New:                            辞書オブジェクト dictionary object.
                                                              (line  23)
* PyDict_Next:                           辞書オブジェクト dictionary object.
                                                              (line  98)
* PyDict_SetItem:                        辞書オブジェクト dictionary object.
                                                              (line  47)
* PyDict_SetItemString:                  辞書オブジェクト dictionary object.
                                                              (line  53)
* PyDict_Size:                           辞書オブジェクト dictionary object.
                                                              (line  94)
* PyDict_Type:                           辞書オブジェクト dictionary object.
                                                              (line  11)
* PyDict_Update:                         辞書オブジェクト dictionary object.
                                                              (line 153)
* PyDict_Values:                         辞書オブジェクト dictionary object.
                                                              (line  89)
* PyDictProxy_New:                       辞書オブジェクト dictionary object.
                                                              (line  27)
* PyErr_BadArgument:                     例外処理.            (line 155)
* PyErr_BadInternalCall:                 例外処理.            (line 212)
* PyErr_CheckSignals:                    例外処理.            (line 268)
* PyErr_Clear:                           例外処理.            (line  70)
* PyErr_ExceptionMatches:                例外処理.            (line  50)
* PyErr_Fetch:                           例外処理.            (line  74)
* PyErr_Format:                          例外処理.            (line 112)
* PyErr_GivenExceptionMatches:           例外処理.            (line  55)
* PyErr_NewException:                    例外処理.            (line 284)
* PyErr_NoMemory:                        例外処理.            (line 160)
* PyErr_NormalizeException:              例外処理.            (line  62)
* PyErr_Occurred:                        例外処理.            (line  38)
* PyErr_Print:                           例外処理.            (line  33)
* PyErr_Restore:                         例外処理.            (line  85)
* PyErr_SetExcFromWindowsErr:            例外処理.            (line 197)
* PyErr_SetExcFromWindowsErrWithFilename: 例外処理.           (line 207)
* PyErr_SetFromErrno:                    例外処理.            (line 166)
* PyErr_SetFromErrnoWithFilename:        例外処理.            (line 180)
* PyErr_SetFromWindowsErr:               例外処理.            (line 186)
* PyErr_SetFromWindowsErrWithFilename:   例外処理.            (line 202)
* PyErr_SetInterrupt:                    例外処理.            (line 278)
* PyErr_SetNone:                         例外処理.            (line 152)
* PyErr_SetObject:                       例外処理.            (line 108)
* PyErr_SetString:                       例外処理.            (line 102)
* PyErr_Warn:                            例外処理.            (line 254)
* PyErr_WarnEx:                          例外処理.            (line 218)
* PyErr_WarnExplicit:                    例外処理.            (line 262)
* PyErr_WriteUnraisable:                 例外処理.            (line 298)
* PyEval_AcquireLock:                    スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 201)
* PyEval_AcquireThread:                  スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 213)
* PyEval_InitThreads:                    スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 165)
* PyEval_ReleaseLock:                    スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 208)
* PyEval_ReleaseThread:                  スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 221)
* PyEval_RestoreThread:                  スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 238)
* PyEval_SaveThread:                     スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 231)
* PyEval_SetProfile:                     プロファイルとトレース profiling and tracing.
                                                              (line  83)
* PyEval_SetTrace:                       プロファイルとトレース profiling and tracing.
                                                              (line  93)
* PyEval_ThreadsInitialized:             スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 193)
* PyFile_AsFile:                         ファイルオブジェクト file object.
                                                              (line  42)
* PyFile_Check:                          ファイルオブジェクト file object.
                                                              (line  21)
* PyFile_CheckExact:                     ファイルオブジェクト file object.
                                                              (line  25)
* PyFile_Encoding:                       ファイルオブジェクト file object.
                                                              (line  65)
* PyFile_FromFile:                       ファイルオブジェクト file object.
                                                              (line  36)
* PyFile_FromString:                     ファイルオブジェクト file object.
                                                              (line  30)
* PyFile_GetLine:                        ファイルオブジェクト file object.
                                                              (line  45)
* PyFile_Name:                           ファイルオブジェクト file object.
                                                              (line  57)
* PyFile_SetBufSize:                     ファイルオブジェクト file object.
                                                              (line  60)
* PyFile_SoftSpace:                      ファイルオブジェクト file object.
                                                              (line  70)
* PyFile_Type:                           ファイルオブジェクト file object.
                                                              (line  16)
* PyFile_WriteObject:                    ファイルオブジェクト file object.
                                                              (line  82)
* PyFile_WriteString:                    ファイルオブジェクト file object.
                                                              (line  89)
* PyFloat_AS_DOUBLE:                     浮動小数点型オブジェクト floating point object.
                                                              (line  37)
* PyFloat_AsDouble:                      浮動小数点型オブジェクト floating point object.
                                                              (line  34)
* PyFloat_Check:                         浮動小数点型オブジェクト floating point object.
                                                              (line  16)
* PyFloat_CheckExact:                    浮動小数点型オブジェクト floating point object.
                                                              (line  20)
* PyFloat_FromDouble:                    浮動小数点型オブジェクト floating point object.
                                                              (line  30)
* PyFloat_FromString:                    浮動小数点型オブジェクト floating point object.
                                                              (line  25)
* PyFloat_Type:                          浮動小数点型オブジェクト floating point object.
                                                              (line  11)
* PyFrozenSet_CheckExact:                集合オブジェクト Set Objects.
                                                              (line  47)
* PyFrozenSet_New:                       集合オブジェクト Set Objects.
                                                              (line  59)
* PyFrozenSet_Type:                      集合オブジェクト Set Objects.
                                                              (line  32)
* PyFunction_Check:                      関数オブジェクト Function Objects.
                                                              (line  17)
* PyFunction_GetClosure:                 関数オブジェクト Function Objects.
                                                              (line  52)
* PyFunction_GetCode:                    関数オブジェクト Function Objects.
                                                              (line  31)
* PyFunction_GetDefaults:                関数オブジェクト Function Objects.
                                                              (line  42)
* PyFunction_GetGlobals:                 関数オブジェクト Function Objects.
                                                              (line  34)
* PyFunction_GetModule:                  関数オブジェクト Function Objects.
                                                              (line  37)
* PyFunction_New:                        関数オブジェクト Function Objects.
                                                              (line  21)
* PyFunction_SetClosure:                 関数オブジェクト Function Objects.
                                                              (line  56)
* PyFunction_SetDefaults:                関数オブジェクト Function Objects.
                                                              (line  46)
* PyFunction_Type:                       関数オブジェクト Function Objects.
                                                              (line  12)
* PyGen_Check:                           ジェネレータオブジェクト.
                                                              (line  19)
* PyGen_CheckExact:                      ジェネレータオブジェクト.
                                                              (line  23)
* PyGen_New:                             ジェネレータオブジェクト.
                                                              (line  27)
* PyGen_Type:                            ジェネレータオブジェクト.
                                                              (line  16)
* PyGILState_Ensure:                     スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 346)
* PyGILState_Release:                    スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 371)
* PyImport_AddModule:                    モジュールの import. (line  57)
* PyImport_AppendInittab:                モジュールの import. (line 152)
* PyImport_Cleanup:                      モジュールの import. (line 109)
* PyImport_ExecCodeModule:               モジュールの import. (line  71)
* PyImport_ExtendInittab:                モジュールの import. (line 175)
* PyImport_FrozenModules:                モジュールの import. (line 144)
* PyImport_GetMagicNumber:               モジュールの import. (line  96)
* PyImport_GetModuleDict:                モジュールの import. (line 102)
* PyImport_Import:                       モジュールの import. (line  41)
* PyImport_ImportFrozenModule:           モジュールの import. (line 121)
* PyImport_ImportModule:                 モジュールの import. (line   7)
* PyImport_ImportModuleEx:               モジュールの import. (line  26)
* PyImport_ReloadModule:                 モジュールの import. (line  48)
* PyIndex_Check:                         数値型プロトコル number protocol.
                                                              (line 212)
* PyInstance_Check:                      インスタンスオブジェクト instance object.
                                                              (line  12)
* PyInstance_New:                        インスタンスオブジェクト instance object.
                                                              (line  15)
* PyInstance_NewRaw:                     インスタンスオブジェクト instance object.
                                                              (line  20)
* PyInstance_Type:                       インスタンスオブジェクト instance object.
                                                              (line   9)
* PyInt_AS_LONG:                         通常整数型オブジェクト plain integer object.
                                                              (line  66)
* PyInt_AsLong:                          通常整数型オブジェクト plain integer object.
                                                              (line  60)
* PyInt_AsSsize_t:                       通常整数型オブジェクト plain integer object.
                                                              (line  81)
* PyInt_AsUnsignedLongLongMask:          通常整数型オブジェクト plain integer object.
                                                              (line  75)
* PyInt_AsUnsignedLongMask:              通常整数型オブジェクト plain integer object.
                                                              (line  69)
* PyInt_Check:                           通常整数型オブジェクト plain integer object.
                                                              (line  16)
* PyInt_CheckExact:                      通常整数型オブジェクト plain integer object.
                                                              (line  21)
* PyInt_FromLong:                        通常整数型オブジェクト plain integer object.
                                                              (line  44)
* PyInt_FromSsize_t:                     通常整数型オブジェクト plain integer object.
                                                              (line  54)
* PyInt_FromString:                      通常整数型オブジェクト plain integer object.
                                                              (line  26)
* PyInt_GetMax:                          通常整数型オブジェクト plain integer object.
                                                              (line  86)
* PyInt_Type:                            通常整数型オブジェクト plain integer object.
                                                              (line  11)
* PyInterpreterState_Clear:              スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 284)
* PyInterpreterState_Delete:             スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 288)
* PyInterpreterState_Head:               高度なデバッガサポート advanced debugger support.
                                                              (line   9)
* PyInterpreterState_New:                スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 279)
* PyInterpreterState_Next:               高度なデバッガサポート advanced debugger support.
                                                              (line  13)
* PyInterpreterState_ThreadHead:         高度なデバッガサポート advanced debugger support.
                                                              (line  17)
* PyIter_Check:                          イテレータプロトコル iterator protocol.
                                                              (line  11)
* PyIter_Next:                           イテレータプロトコル iterator protocol.
                                                              (line  14)
* PyList_Append:                         List Objects.        (line  69)
* PyList_AsTuple:                        List Objects.        (line  96)
* PyList_Check:                          List Objects.        (line  16)
* PyList_GET_ITEM:                       List Objects.        (line  42)
* PyList_GET_SIZE:                       List Objects.        (line  32)
* PyList_GetItem:                        List Objects.        (line  35)
* PyList_GetSlice:                       List Objects.        (line  74)
* PyList_Insert:                         List Objects.        (line  64)
* PyList_New:                            List Objects.        (line  19)
* PyList_Reverse:                        List Objects.        (line  91)
* PyList_SET_ITEM:                       List Objects.        (line  54)
* PyList_SetItem:                        List Objects.        (line  46)
* PyList_SetSlice:                       List Objects.        (line  79)
* PyList_Size:                           List Objects.        (line  28)
* PyList_Sort:                           List Objects.        (line  86)
* PyList_Type:                           List Objects.        (line  11)
* PyLong_AsDouble:                       長整数型オブジェクト long integer object.
                                                              (line  97)
* PyLong_AsLong:                         長整数型オブジェクト long integer object.
                                                              (line  69)
* PyLong_AsLongLong:                     長整数型オブジェクト long integer object.
                                                              (line  78)
* PyLong_AsUnsignedLong:                 長整数型オブジェクト long integer object.
                                                              (line  73)
* PyLong_AsUnsignedLongLong:             長整数型オブジェクト long integer object.
                                                              (line  83)
* PyLong_AsUnsignedLongLongMask:         長整数型オブジェクト long integer object.
                                                              (line  93)
* PyLong_AsUnsignedLongMask:             長整数型オブジェクト long integer object.
                                                              (line  89)
* PyLong_AsVoidPtr:                      長整数型オブジェクト long integer object.
                                                              (line 102)
* PyLong_Check:                          長整数型オブジェクト long integer object.
                                                              (line  14)
* PyLong_CheckExact:                     長整数型オブジェクト long integer object.
                                                              (line  18)
* PyLong_FromDouble:                     長整数型オブジェクト long integer object.
                                                              (line  39)
* PyLong_FromLong:                       長整数型オブジェクト long integer object.
                                                              (line  23)
* PyLong_FromLongLong:                   長整数型オブジェクト long integer object.
                                                              (line  31)
* PyLong_FromString:                     長整数型オブジェクト long integer object.
                                                              (line  43)
* PyLong_FromUnicode:                    長整数型オブジェクト long integer object.
                                                              (line  56)
* PyLong_FromUnsignedLong:               長整数型オブジェクト long integer object.
                                                              (line  27)
* PyLong_FromUnsignedLongLong:           長整数型オブジェクト long integer object.
                                                              (line  35)
* PyLong_FromVoidPtr:                    長整数型オブジェクト long integer object.
                                                              (line  63)
* PyLong_Type:                           長整数型オブジェクト long integer object.
                                                              (line  10)
* PyMapping_Check:                       マップ型プロトコル mapping protocol.
                                                              (line   7)
* PyMapping_DelItem:                     マップ型プロトコル mapping protocol.
                                                              (line  22)
* PyMapping_DelItemString:               マップ型プロトコル mapping protocol.
                                                              (line  18)
* PyMapping_GetItemString:               マップ型プロトコル mapping protocol.
                                                              (line  50)
* PyMapping_HasKey:                      マップ型プロトコル mapping protocol.
                                                              (line  31)
* PyMapping_HasKeyString:                マップ型プロトコル mapping protocol.
                                                              (line  26)
* PyMapping_Items:                       マップ型プロトコル mapping protocol.
                                                              (line  45)
* PyMapping_Keys:                        マップ型プロトコル mapping protocol.
                                                              (line  36)
* PyMapping_Length:                      マップ型プロトコル mapping protocol.
                                                              (line  12)
* PyMapping_SetItemString:               マップ型プロトコル mapping protocol.
                                                              (line  54)
* PyMapping_Values:                      マップ型プロトコル mapping protocol.
                                                              (line  40)
* PyMarshal_ReadLastObjectFromFile:      データ整列化 data marshalling のサポート.
                                                              (line  55)
* PyMarshal_ReadLongFromFile:            データ整列化 data marshalling のサポート.
                                                              (line  40)
* PyMarshal_ReadObjectFromFile:          データ整列化 data marshalling のサポート.
                                                              (line  50)
* PyMarshal_ReadObjectFromString:        データ整列化 data marshalling のサポート.
                                                              (line  67)
* PyMarshal_ReadShortFromFile:           データ整列化 data marshalling のサポート.
                                                              (line  45)
* PyMarshal_WriteLongToFile:             データ整列化 data marshalling のサポート.
                                                              (line  21)
* PyMarshal_WriteObjectToFile:           データ整列化 data marshalling のサポート.
                                                              (line  28)
* PyMarshal_WriteObjectToString:         データ整列化 data marshalling のサポート.
                                                              (line  33)
* PyMem_Del:                             メモリインタフェース.
                                                              (line  52)
* PyMem_Free:                            メモリインタフェース.
                                                              (line  31)
* PyMem_Malloc:                          メモリインタフェース.
                                                              (line  12)
* PyMem_New:                             メモリインタフェース.
                                                              (line  41)
* PyMem_Realloc:                         メモリインタフェース.
                                                              (line  20)
* PyMem_Resize:                          メモリインタフェース.
                                                              (line  47)
* PyMethod_Check:                        メソッドオブジェクト method object.
                                                              (line  14)
* PyMethod_Class:                        メソッドオブジェクト method object.
                                                              (line  27)
* PyMethod_Function:                     メソッドオブジェクト method object.
                                                              (line  36)
* PyMethod_GET_CLASS:                    メソッドオブジェクト method object.
                                                              (line  32)
* PyMethod_GET_FUNCTION:                 メソッドオブジェクト method object.
                                                              (line  39)
* PyMethod_GET_SELF:                     メソッドオブジェクト method object.
                                                              (line  46)
* PyMethod_New:                          メソッドオブジェクト method object.
                                                              (line  18)
* PyMethod_Self:                         メソッドオブジェクト method object.
                                                              (line  42)
* PyMethod_Type:                         メソッドオブジェクト method object.
                                                              (line   9)
* PyModule_AddIntConstant:               モジュールオブジェクト module object.
                                                              (line  53)
* PyModule_AddObject:                    モジュールオブジェクト module object.
                                                              (line  47)
* PyModule_AddStringConstant:            モジュールオブジェクト module object.
                                                              (line  59)
* PyModule_Check:                        モジュールオブジェクト module object.
                                                              (line  14)
* PyModule_CheckExact:                   モジュールオブジェクト module object.
                                                              (line  18)
* PyModule_GetDict:                      モジュールオブジェクト module object.
                                                              (line  29)
* PyModule_GetFilename:                  モジュールオブジェクト module object.
                                                              (line  41)
* PyModule_GetName:                      モジュールオブジェクト module object.
                                                              (line  36)
* PyModule_New:                          モジュールオブジェクト module object.
                                                              (line  23)
* PyModule_Type:                         モジュールオブジェクト module object.
                                                              (line   9)
* PyNumber_Absolute:                     数値型プロトコル number protocol.
                                                              (line  65)
* PyNumber_Add:                          数値型プロトコル number protocol.
                                                              (line  12)
* PyNumber_And:                          数値型プロトコル number protocol.
                                                              (line  81)
* PyNumber_AsSsize_t:                    数値型プロトコル number protocol.
                                                              (line 203)
* PyNumber_Check:                        数値型プロトコル number protocol.
                                                              (line   7)
* PyNumber_Coerce:                       数値型プロトコル number protocol.
                                                              (line 172)
* PyNumber_Divide:                       数値型プロトコル number protocol.
                                                              (line  24)
* PyNumber_Divmod:                       数値型プロトコル number protocol.
                                                              (line  46)
* PyNumber_Float:                        数値型プロトコル number protocol.
                                                              (line 194)
* PyNumber_FloorDivide:                  数値型プロトコル number protocol.
                                                              (line  28)
* PyNumber_Index:                        数値型プロトコル number protocol.
                                                              (line 198)
* PyNumber_InPlaceAdd:                   数値型プロトコル number protocol.
                                                              (line  94)
* PyNumber_InPlaceAnd:                   数値型プロトコル number protocol.
                                                              (line 154)
* PyNumber_InPlaceDivide:                数値型プロトコル number protocol.
                                                              (line 109)
* PyNumber_InPlaceFloorDivide:           数値型プロトコル number protocol.
                                                              (line 114)
* PyNumber_InPlaceLshift:                数値型プロトコル number protocol.
                                                              (line 144)
* PyNumber_InPlaceMultiply:              数値型プロトコル number protocol.
                                                              (line 104)
* PyNumber_InPlaceOr:                    数値型プロトコル number protocol.
                                                              (line 166)
* PyNumber_InPlacePower:                 数値型プロトコル number protocol.
                                                              (line 135)
* PyNumber_InPlaceRemainder:             数値型プロトコル number protocol.
                                                              (line 130)
* PyNumber_InPlaceRshift:                数値型プロトコル number protocol.
                                                              (line 149)
* PyNumber_InPlaceSubtract:              数値型プロトコル number protocol.
                                                              (line  99)
* PyNumber_InPlaceTrueDivide:            数値型プロトコル number protocol.
                                                              (line 120)
* PyNumber_InPlaceXor:                   数値型プロトコル number protocol.
                                                              (line 160)
* PyNumber_Int:                          数値型プロトコル number protocol.
                                                              (line 184)
* PyNumber_Invert:                       数値型プロトコル number protocol.
                                                              (line  69)
* PyNumber_Long:                         数値型プロトコル number protocol.
                                                              (line 190)
* PyNumber_Lshift:                       数値型プロトコル number protocol.
                                                              (line  73)
* PyNumber_Multiply:                     数値型プロトコル number protocol.
                                                              (line  20)
* PyNumber_Negative:                     数値型プロトコル number protocol.
                                                              (line  57)
* PyNumber_Or:                           数値型プロトコル number protocol.
                                                              (line  90)
* PyNumber_Positive:                     数値型プロトコル number protocol.
                                                              (line  61)
* PyNumber_Power:                        数値型プロトコル number protocol.
                                                              (line  50)
* PyNumber_Remainder:                    数値型プロトコル number protocol.
                                                              (line  42)
* PyNumber_Rshift:                       数値型プロトコル number protocol.
                                                              (line  77)
* PyNumber_Subtract:                     数値型プロトコル number protocol.
                                                              (line  16)
* PyNumber_TrueDivide:                   数値型プロトコル number protocol.
                                                              (line  33)
* PyNumber_Xor:                          数値型プロトコル number protocol.
                                                              (line  85)
* PyObject_AsCharBuffer:                 バッファプロトコル buffer protocol.
                                                              (line   7)
* PyObject_AsFileDescriptor:             オブジェクトプロトコル object protocol.
                                                              (line 254)
* PyObject_AsReadBuffer:                 バッファプロトコル buffer protocol.
                                                              (line  15)
* PyObject_AsWriteBuffer:                バッファプロトコル buffer protocol.
                                                              (line  28)
* PyObject_Call:                         オブジェクトプロトコル object protocol.
                                                              (line 149)
* PyObject_CallFunction:                 オブジェクトプロトコル object protocol.
                                                              (line 169)
* PyObject_CallFunctionObjArgs:          オブジェクトプロトコル object protocol.
                                                              (line 191)
* PyObject_CallMethod:                   オブジェクトプロトコル object protocol.
                                                              (line 180)
* PyObject_CallMethodObjArgs:            オブジェクトプロトコル object protocol.
                                                              (line 198)
* PyObject_CallObject:                   オブジェクトプロトコル object protocol.
                                                              (line 161)
* PyObject_CheckReadBuffer:              バッファプロトコル buffer protocol.
                                                              (line  23)
* PyObject_Cmp:                          オブジェクトプロトコル object protocol.
                                                              (line  71)
* PyObject_Compare:                      オブジェクトプロトコル object protocol.
                                                              (line  77)
* PyObject_Del:                          オブジェクトをヒープ上にメモリ確保する.
                                                              (line  43)
* PyObject_DelAttr:                      オブジェクトプロトコル object protocol.
                                                              (line  50)
* PyObject_DelAttrString:                オブジェクトプロトコル object protocol.
                                                              (line  45)
* PyObject_DelItem:                      オブジェクトプロトコル object protocol.
                                                              (line 250)
* PyObject_Dir:                          オブジェクトプロトコル object protocol.
                                                              (line 262)
* PyObject_GC_Del:                       循環参照ガベージコレクションをサポートする.
                                                              (line  71)
* PyObject_GC_New:                       循環参照ガベージコレクションをサポートする.
                                                              (line  36)
* PyObject_GC_NewVar:                    循環参照ガベージコレクションをサポートする.
                                                              (line  40)
* PyObject_GC_Resize:                    循環参照ガベージコレクションをサポートする.
                                                              (line  44)
* PyObject_GC_Track:                     循環参照ガベージコレクションをサポートする.
                                                              (line  49)
* PyObject_GC_UnTrack:                   循環参照ガベージコレクションをサポートする.
                                                              (line  75)
* PyObject_GetAttr:                      オブジェクトプロトコル object protocol.
                                                              (line  30)
* PyObject_GetAttrString:                オブジェクトプロトコル object protocol.
                                                              (line  20)
* PyObject_GetItem:                      オブジェクトプロトコル object protocol.
                                                              (line 242)
* PyObject_GetIter:                      オブジェクトプロトコル object protocol.
                                                              (line 271)
* PyObject_HasAttr:                      オブジェクトプロトコル object protocol.
                                                              (line  25)
* PyObject_HasAttrString:                オブジェクトプロトコル object protocol.
                                                              (line  15)
* PyObject_Hash:                         オブジェクトプロトコル object protocol.
                                                              (line 206)
* PyObject_Init:                         オブジェクトをヒープ上にメモリ確保する.
                                                              (line  13)
* PyObject_InitVar:                      オブジェクトをヒープ上にメモリ確保する.
                                                              (line  21)
* PyObject_IsInstance:                   オブジェクトプロトコル object protocol.
                                                              (line 103)
* PyObject_IsSubclass:                   オブジェクトプロトコル object protocol.
                                                              (line 132)
* PyObject_IsTrue:                       オブジェクトプロトコル object protocol.
                                                              (line 210)
* PyObject_Length:                       オブジェクトプロトコル object protocol.
                                                              (line 235)
* PyObject_New:                          オブジェクトをヒープ上にメモリ確保する.
                                                              (line  25)
* PyObject_NewVar:                       オブジェクトをヒープ上にメモリ確保する.
                                                              (line  32)
* PyObject_Not:                          オブジェクトプロトコル object protocol.
                                                              (line 215)
* PyObject_Print:                        オブジェクトプロトコル object protocol.
                                                              (line   7)
* PyObject_Repr:                         オブジェクトプロトコル object protocol.
                                                              (line  86)
* PyObject_RichCompare:                  オブジェクトプロトコル object protocol.
                                                              (line  55)
* PyObject_RichCompareBool:              オブジェクトプロトコル object protocol.
                                                              (line  63)
* PyObject_SetAttr:                      オブジェクトプロトコル object protocol.
                                                              (line  40)
* PyObject_SetAttrString:                オブジェクトプロトコル object protocol.
                                                              (line  35)
* PyObject_SetItem:                      オブジェクトプロトコル object protocol.
                                                              (line 246)
* PyObject_Size:                         オブジェクトプロトコル object protocol.
                                                              (line 236)
* PyObject_Str:                          オブジェクトプロトコル object protocol.
                                                              (line  92)
* PyObject_Type:                         オブジェクトプロトコル object protocol.
                                                              (line 220)
* PyObject_TypeCheck:                    オブジェクトプロトコル object protocol.
                                                              (line 230)
* PyObject_Unicode:                      オブジェクトプロトコル object protocol.
                                                              (line  98)
* PyOS_AfterFork:                        オペレーティングシステム関連のユーティリティ.
                                                              (line  20)
* PyOS_CheckStack:                       オペレーティングシステム関連のユーティリティ.
                                                              (line  26)
* PyOS_GetLastModificationTime:          オペレーティングシステム関連のユーティリティ.
                                                              (line  15)
* PyOS_getsig:                           オペレーティングシステム関連のユーティリティ.
                                                              (line  34)
* PyOS_setsig:                           オペレーティングシステム関連のユーティリティ.
                                                              (line  40)
* PyParser_SimpleParseFile:              超高レベルレイヤ.    (line 124)
* PyParser_SimpleParseFileFlags:         超高レベルレイヤ.    (line 128)
* PyParser_SimpleParseString:            超高レベルレイヤ.    (line 110)
* PyParser_SimpleParseStringFlags:       超高レベルレイヤ.    (line 114)
* PyParser_SimpleParseStringFlagsFilename: 超高レベルレイヤ.  (line 118)
* PyProperty_Type:                       デスクリプタオブジェクト descriptor object.
                                                              (line  11)
* PyRun_AnyFile:                         超高レベルレイヤ.    (line  34)
* PyRun_AnyFileEx:                       超高レベルレイヤ.    (line  42)
* PyRun_AnyFileExFlags:                  超高レベルレイヤ.    (line  46)
* PyRun_AnyFileFlags:                    超高レベルレイヤ.    (line  38)
* PyRun_File:                            超高レベルレイヤ.    (line 147)
* PyRun_FileEx:                          超高レベルレイヤ.    (line 151)
* PyRun_FileExFlags:                     超高レベルレイヤ.    (line 160)
* PyRun_FileFlags:                       超高レベルレイヤ.    (line 155)
* PyRun_InteractiveLoop:                 超高レベルレイヤ.    (line  99)
* PyRun_InteractiveLoopFlags:            超高レベルレイヤ.    (line 103)
* PyRun_InteractiveOne:                  超高レベルレイヤ.    (line  84)
* PyRun_InteractiveOneFlags:             超高レベルレイヤ.    (line  88)
* PyRun_SimpleFile:                      超高レベルレイヤ.    (line  64)
* PyRun_SimpleFileEx:                    超高レベルレイヤ.    (line  72)
* PyRun_SimpleFileExFlags:               超高レベルレイヤ.    (line  76)
* PyRun_SimpleFileFlags:                 超高レベルレイヤ.    (line  68)
* PyRun_SimpleString:                    超高レベルレイヤ.    (line  53)
* PyRun_SimpleStringFlags:               超高レベルレイヤ.    (line  57)
* PyRun_String:                          超高レベルレイヤ.    (line 133)
* PyRun_StringFlags:                     超高レベルレイヤ.    (line 137)
* PySeqIter_Check:                       イテレータオブジェクト iterator object.
                                                              (line  20)
* PySeqIter_New:                         イテレータオブジェクト iterator object.
                                                              (line  24)
* PySeqIter_Type:                        イテレータオブジェクト iterator object.
                                                              (line  14)
* PySequence_Check:                      シーケンス型プロトコル sequence protocol.
                                                              (line   7)
* PySequence_Concat:                     シーケンス型プロトコル sequence protocol.
                                                              (line  21)
* PySequence_Contains:                   シーケンス型プロトコル sequence protocol.
                                                              (line  72)
* PySequence_Count:                      シーケンス型プロトコル sequence protocol.
                                                              (line  67)
* PySequence_DelItem:                    シーケンス型プロトコル sequence protocol.
                                                              (line  54)
* PySequence_DelSlice:                   シーケンス型プロトコル sequence protocol.
                                                              (line  62)
* PySequence_Fast:                       シーケンス型プロトコル sequence protocol.
                                                              (line  94)
* PySequence_Fast_GET_ITEM:              シーケンス型プロトコル sequence protocol.
                                                              (line 103)
* PySequence_Fast_GET_SIZE:              シーケンス型プロトコル sequence protocol.
                                                              (line 119)
* PySequence_Fast_ITEMS:                 シーケンス型プロトコル sequence protocol.
                                                              (line 108)
* PySequence_GetItem:                    シーケンス型プロトコル sequence protocol.
                                                              (line  41)
* PySequence_GetSlice:                   シーケンス型プロトコル sequence protocol.
                                                              (line  45)
* PySequence_Index:                      シーケンス型プロトコル sequence protocol.
                                                              (line  78)
* PySequence_InPlaceConcat:              シーケンス型プロトコル sequence protocol.
                                                              (line  29)
* PySequence_InPlaceRepeat:              シーケンス型プロトコル sequence protocol.
                                                              (line  35)
* PySequence_ITEM:                       シーケンス型プロトコル sequence protocol.
                                                              (line 113)
* PySequence_Length:                     シーケンス型プロトコル sequence protocol.
                                                              (line  18)
* PySequence_List:                       シーケンス型プロトコル sequence protocol.
                                                              (line  83)
* PySequence_Repeat:                     シーケンス型プロトコル sequence protocol.
                                                              (line  25)
* PySequence_SetItem:                    シーケンス型プロトコル sequence protocol.
                                                              (line  49)
* PySequence_SetSlice:                   シーケンス型プロトコル sequence protocol.
                                                              (line  58)
* PySequence_Size:                       シーケンス型プロトコル sequence protocol.
                                                              (line  12)
* PySequence_Tuple:                      シーケンス型プロトコル sequence protocol.
                                                              (line  87)
* PySet_Add:                             集合オブジェクト Set Objects.
                                                              (line  88)
* PySet_Clear:                           集合オブジェクト Set Objects.
                                                              (line 114)
* PySet_Contains:                        集合オブジェクト Set Objects.
                                                              (line  76)
* PySet_Discard:                         集合オブジェクト Set Objects.
                                                              (line  96)
* PySet_GET_SIZE:                        集合オブジェクト Set Objects.
                                                              (line  73)
* PySet_New:                             集合オブジェクト Set Objects.
                                                              (line  51)
* PySet_Pop:                             集合オブジェクト Set Objects.
                                                              (line 107)
* PySet_Size:                            集合オブジェクト Set Objects.
                                                              (line  67)
* PySet_Type:                            集合オブジェクト Set Objects.
                                                              (line  29)
* PySlice_Check:                         スライスオブジェクト slice object.
                                                              (line  11)
* PySlice_GetIndices:                    スライスオブジェクト slice object.
                                                              (line  22)
* PySlice_GetIndicesEx:                  スライスオブジェクト slice object.
                                                              (line  38)
* PySlice_New:                           スライスオブジェクト slice object.
                                                              (line  15)
* PySlice_Type:                          スライスオブジェクト slice object.
                                                              (line   7)
* PyString_AS_STRING:                    文字列オブジェクト string object.
                                                              (line 102)
* PyString_AsDecodedObject:              文字列オブジェクト string object.
                                                              (line 192)
* PyString_AsEncodedObject:              文字列オブジェクト string object.
                                                              (line 209)
* PyString_AsString:                     文字列オブジェクト string object.
                                                              (line  89)
* PyString_AsStringAndSize:              文字列オブジェクト string object.
                                                              (line 107)
* PyString_Check:                        文字列オブジェクト string object.
                                                              (line  19)
* PyString_CheckExact:                   文字列オブジェクト string object.
                                                              (line  23)
* PyString_Concat:                       文字列オブジェクト string object.
                                                              (line 131)
* PyString_ConcatAndDel:                 文字列オブジェクト string object.
                                                              (line 139)
* PyString_Decode:                       文字列オブジェクト string object.
                                                              (line 183)
* PyString_Encode:                       文字列オブジェクト string object.
                                                              (line 200)
* PyString_Format:                       文字列オブジェクト string object.
                                                              (line 159)
* PyString_FromFormat:                   文字列オブジェクト string object.
                                                              (line  37)
* PyString_FromFormatV:                  文字列オブジェクト string object.
                                                              (line  78)
* PyString_FromString:                   文字列オブジェクト string object.
                                                              (line  27)
* PyString_FromStringAndSize:            文字列オブジェクト string object.
                                                              (line  32)
* PyString_GET_SIZE:                     文字列オブジェクト string object.
                                                              (line  85)
* PyString_InternFromString:             文字列オブジェクト string object.
                                                              (line 176)
* PyString_InternInPlace:                文字列オブジェクト string object.
                                                              (line 164)
* PyString_Size:                         文字列オブジェクト string object.
                                                              (line  82)
* PyString_Type:                         文字列オブジェクト string object.
                                                              (line  14)
* PySys_SetArgv:                         初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 302)
* PyThreadState_Clear:                   スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 300)
* PyThreadState_Delete:                  スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 304)
* PyThreadState_Get:                     スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 310)
* PyThreadState_GetDict:                 スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 322)
* PyThreadState_New:                     スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 294)
* PyThreadState_Next:                    高度なデバッガサポート advanced debugger support.
                                                              (line  22)
* PyThreadState_SetAsyncExc:             スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 331)
* PyThreadState_Swap:                    スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 317)
* PyTime_Check:                          DateTime オブジェクト.
                                                              (line  35)
* PyTime_CheckExact:                     DateTime オブジェクト.
                                                              (line  40)
* PyTime_FromTime:                       DateTime オブジェクト.
                                                              (line  72)
* PyTrace_C_CALL:                        プロファイルとトレース profiling and tracing.
                                                              (line  71)
* PyTrace_C_EXCEPTION:                   プロファイルとトレース profiling and tracing.
                                                              (line  75)
* PyTrace_C_RETURN:                      プロファイルとトレース profiling and tracing.
                                                              (line  79)
* PyTrace_CALL:                          プロファイルとトレース profiling and tracing.
                                                              (line  45)
* PyTrace_EXCEPTION:                     プロファイルとトレース profiling and tracing.
                                                              (line  52)
* PyTrace_LINE:                          プロファイルとトレース profiling and tracing.
                                                              (line  63)
* PyTrace_RETURN:                        プロファイルとトレース profiling and tracing.
                                                              (line  67)
* PyTuple_Check:                         タプルオブジェクト tuple object.
                                                              (line  16)
* PyTuple_CheckExact:                    タプルオブジェクト tuple object.
                                                              (line  20)
* PyTuple_GET_ITEM:                      タプルオブジェクト tuple object.
                                                              (line  48)
* PyTuple_GET_SIZE:                      タプルオブジェクト tuple object.
                                                              (line  38)
* PyTuple_GetItem:                       タプルオブジェクト tuple object.
                                                              (line  43)
* PyTuple_GetSlice:                      タプルオブジェクト tuple object.
                                                              (line  52)
* PyTuple_New:                           タプルオブジェクト tuple object.
                                                              (line  24)
* PyTuple_Pack:                          タプルオブジェクト tuple object.
                                                              (line  28)
* PyTuple_SET_ITEM:                      タプルオブジェクト tuple object.
                                                              (line  61)
* PyTuple_SetItem:                       タプルオブジェクト tuple object.
                                                              (line  56)
* PyTuple_Size:                          タプルオブジェクト tuple object.
                                                              (line  34)
* PyTuple_Type:                          タプルオブジェクト tuple object.
                                                              (line  11)
* PyType_Check:                          型オブジェクト type object.
                                                              (line  15)
* PyType_CheckExact:                     型オブジェクト type object.
                                                              (line  20)
* PyType_GenericAlloc:                   型オブジェクト type object.
                                                              (line  38)
* PyType_GenericNew:                     型オブジェクト type object.
                                                              (line  41)
* PyType_HasFeature:                     型オブジェクト type object.
                                                              (line  25)
* PyType_IS_GC:                          型オブジェクト type object.
                                                              (line  29)
* PyType_IsSubtype:                      型オブジェクト type object.
                                                              (line  34)
* PyType_Ready:                          型オブジェクト type object.
                                                              (line  44)
* PyType_Type:                           型オブジェクト type object.
                                                              (line  11)
* PyTZInfo_Check:                        DateTime オブジェクト.
                                                              (line  53)
* PyTZInfo_CheckExact:                   DateTime オブジェクト.
                                                              (line  58)
* PyUnicode_AS_DATA:                     Unicode オブジェクト Unicode object.
                                                              (line  61)
* PyUnicode_AS_UNICODE:                  Unicode オブジェクト Unicode object.
                                                              (line  57)
* PyUnicode_AsASCIIString:               組み込み codec built-in codec.
                                                              (line 213)
* PyUnicode_AsCharmapString:             組み込み codec built-in codec.
                                                              (line 266)
* PyUnicode_AsEncodedString:             組み込み codec built-in codec.
                                                              (line  52)
* PyUnicode_AsLatin1String:              組み込み codec built-in codec.
                                                              (line 195)
* PyUnicode_AsMBCSString:                組み込み codec built-in codec.
                                                              (line 316)
* PyUnicode_AsRawUnicodeEscapeString:    組み込み codec built-in codec.
                                                              (line 177)
* PyUnicode_AsUnicode:                   Unicode オブジェクト Unicode object.
                                                              (line 136)
* PyUnicode_AsUnicodeEscapeString:       組み込み codec built-in codec.
                                                              (line 159)
* PyUnicode_AsUTF16String:               組み込み codec built-in codec.
                                                              (line 140)
* PyUnicode_AsUTF8String:                組み込み codec built-in codec.
                                                              (line  79)
* PyUnicode_AsWideChar:                  Unicode オブジェクト Unicode object.
                                                              (line 177)
* PyUnicode_Check:                       Unicode オブジェクト Unicode object.
                                                              (line  41)
* PyUnicode_CheckExact:                  Unicode オブジェクト Unicode object.
                                                              (line  45)
* PyUnicode_Compare:                     メソッドおよびスロット関数 slot function.
                                                              (line  76)
* PyUnicode_Concat:                      メソッドおよびスロット関数 slot function.
                                                              (line  14)
* PyUnicode_Contains:                    メソッドおよびスロット関数 slot function.
                                                              (line 104)
* PyUnicode_Count:                       メソッドおよびスロット関数 slot function.
                                                              (line  66)
* PyUnicode_Decode:                      組み込み codec built-in codec.
                                                              (line  36)
* PyUnicode_DecodeASCII:                 組み込み codec built-in codec.
                                                              (line 203)
* PyUnicode_DecodeCharmap:               組み込み codec built-in codec.
                                                              (line 244)
* PyUnicode_DecodeLatin1:                組み込み codec built-in codec.
                                                              (line 185)
* PyUnicode_DecodeMBCS:                  組み込み codec built-in codec.
                                                              (line 299)
* PyUnicode_DecodeMBCSStateful:          組み込み codec built-in codec.
                                                              (line 304)
* PyUnicode_DecodeRawUnicodeEscape:      組み込み codec built-in codec.
                                                              (line 166)
* PyUnicode_DecodeUnicodeEscape:         組み込み codec built-in codec.
                                                              (line 148)
* PyUnicode_DecodeUTF16:                 組み込み codec built-in codec.
                                                              (line  86)
* PyUnicode_DecodeUTF16Stateful:         組み込み codec built-in codec.
                                                              (line 111)
* PyUnicode_DecodeUTF8:                  組み込み codec built-in codec.
                                                              (line  62)
* PyUnicode_DecodeUTF8Stateful:          組み込み codec built-in codec.
                                                              (line  67)
* PyUnicode_Encode:                      組み込み codec built-in codec.
                                                              (line  44)
* PyUnicode_EncodeASCII:                 組み込み codec built-in codec.
                                                              (line 208)
* PyUnicode_EncodeCharmap:               組み込み codec built-in codec.
                                                              (line 260)
* PyUnicode_EncodeLatin1:                組み込み codec built-in codec.
                                                              (line 190)
* PyUnicode_EncodeMBCS:                  組み込み codec built-in codec.
                                                              (line 311)
* PyUnicode_EncodeRawUnicodeEscape:      組み込み codec built-in codec.
                                                              (line 171)
* PyUnicode_EncodeUnicodeEscape:         組み込み codec built-in codec.
                                                              (line 153)
* PyUnicode_EncodeUTF16:                 組み込み codec built-in codec.
                                                              (line 120)
* PyUnicode_EncodeUTF8:                  組み込み codec built-in codec.
                                                              (line  74)
* PyUnicode_Find:                        メソッドおよびスロット関数 slot function.
                                                              (line  57)
* PyUnicode_Format:                      メソッドおよびスロット関数 slot function.
                                                              (line  99)
* PyUnicode_FromEncodedObject:           Unicode オブジェクト Unicode object.
                                                              (line 144)
* PyUnicode_FromObject:                  Unicode オブジェクト Unicode object.
                                                              (line 162)
* PyUnicode_FromUnicode:                 Unicode オブジェクト Unicode object.
                                                              (line 127)
* PyUnicode_FromWideChar:                Unicode オブジェクト Unicode object.
                                                              (line 173)
* PyUnicode_GET_DATA_SIZE:               Unicode オブジェクト Unicode object.
                                                              (line  53)
* PyUnicode_GET_SIZE:                    Unicode オブジェクト Unicode object.
                                                              (line  49)
* PyUnicode_GetSize:                     Unicode オブジェクト Unicode object.
                                                              (line 141)
* PyUnicode_Join:                        メソッドおよびスロット関数 slot function.
                                                              (line  47)
* PyUnicode_Replace:                     メソッドおよびスロット関数 slot function.
                                                              (line  71)
* PyUnicode_RichCompare:                 メソッドおよびスロット関数 slot function.
                                                              (line  81)
* PyUnicode_Split:                       メソッドおよびスロット関数 slot function.
                                                              (line  17)
* PyUnicode_Splitlines:                  メソッドおよびスロット関数 slot function.
                                                              (line  25)
* PyUnicode_Tailmatch:                   メソッドおよびスロット関数 slot function.
                                                              (line  51)
* PyUnicode_Translate:                   メソッドおよびスロット関数 slot function.
                                                              (line  30)
* PyUnicode_TranslateCharmap:            組み込み codec built-in codec.
                                                              (line 275)
* PyUnicode_Type:                        Unicode オブジェクト Unicode object.
                                                              (line  32)
* PyWeakref_Check:                       弱参照オブジェクト weak reference object.
                                                              (line  12)
* PyWeakref_CheckProxy:                  弱参照オブジェクト weak reference object.
                                                              (line  20)
* PyWeakref_CheckRef:                    弱参照オブジェクト weak reference object.
                                                              (line  16)
* PyWeakref_GET_OBJECT:                  弱参照オブジェクト weak reference object.
                                                              (line  55)
* PyWeakref_GetObject:                   弱参照オブジェクト weak reference object.
                                                              (line  50)
* PyWeakref_NewProxy:                    弱参照オブジェクト weak reference object.
                                                              (line  37)
* PyWeakref_NewRef:                      弱参照オブジェクト weak reference object.
                                                              (line  24)
* PyWrapper_New:                         デスクリプタオブジェクト descriptor object.
                                                              (line  33)
* reload:                                モジュールの import. (line  50)
* repr <1>:                              型オブジェクト.      (line 272)
* repr:                                  オブジェクトプロトコル object protocol.
                                                              (line  88)
* staticmethod:                          共通のオブジェクト構造体 common object structure.
                                                              (line 152)
* str:                                   オブジェクトプロトコル object protocol.
                                                              (line  94)
* tuple <1>:                             List Objects.        (line  97)
* tuple:                                 シーケンス型プロトコル sequence protocol.
                                                              (line  91)
* type:                                  オブジェクトプロトコル object protocol.
                                                              (line 222)
* unicode:                               オブジェクトプロトコル object protocol.
                                                              (line 100)


File: python-api-jp.info,  Node: Miscellaneous Index,  Prev: Function-Method-Variable Index,  Up: Top

Miscellaneous Index
*******************

 [index ]
* Menu:

* __all__:                               モジュールの import. (line  15)
* __dict__:                              モジュールオブジェクト module object.
                                                              (line  31)
* __doc__:                               モジュールオブジェクト module object.
                                                              (line  26)
* __file__:                              モジュールオブジェクト module object.
                                                              (line  26)
* __name__:                              モジュールオブジェクト module object.
                                                              (line  26)
* abort():                               プロセス制御.        (line  13)
* argv:                                  初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 309)
* BaseException:                         文字列例外の廃止.    (line   7)
* buffer interface:                      Buffer Objects.      (line   6)
* BufferType:                            Buffer Objects.      (line  59)
* calloc():                              概要.                (line  36)
* cleanup functions:                     プロセス制御.        (line  22)
* close():                               初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 111)
* copyright:                             初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 275)
* DictionaryType:                        辞書オブジェクト dictionary object.
                                                              (line  13)
* DictType:                              辞書オブジェクト dictionary object.
                                                              (line  13)
* EOFError:                              ファイルオブジェクト file object.
                                                              (line  54)
* errno:                                 スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line  80)
* exc_info():                            例外.                (line  48)
* exc_traceback <1>:                     例外処理.            (line  27)
* exc_traceback:                         例外.                (line  37)
* exc_type <1>:                          例外処理.            (line  27)
* exc_type:                              例外.                (line  37)
* exc_value <1>:                         例外処理.            (line  27)
* exc_value:                             例外.                (line  37)
* executable:                            初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 224)
* exit():                                プロセス制御.        (line  17)
* FileType:                              ファイルオブジェクト file object.
                                                              (line  18)
* FloatType:                             浮動小数点型オブジェクト floating point object.
                                                              (line  13)
* fopen():                               ファイルオブジェクト file object.
                                                              (line  32)
* free():                                概要.                (line  37)
* freeze utility:                        モジュールの import. (line 130)
* global interpreter lock:               スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line   6)
* incr_item():                           例外.                (line  84)
* int (*inquiry)(PyObject *self):        循環参照ガベージコレクションをサポートする.
                                                              (line 132)
* int (*Py_tracefunc)(PyObject *obj, PyFrameObject *frame, int what, PyObject *arg): プロファイルとトレース profiling and tracing.
                                                              (line  23)
* int (*traverseproc)(PyObject *self, visitproc visit, void *arg): 循環参照ガベージコレクションをサポートする.
                                                              (line 100)
* int (*visitproc)(PyObject *object, void *arg): 循環参照ガベージコレクションをサポートする.
                                                              (line  90)
* interpreter lock:                      スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line   6)
* IntType:                               通常整数型オブジェクト plain integer object.
                                                              (line  13)
* KeyboardInterrupt:                     例外処理.            (line 272)
* ListType:                              List Objects.        (line  13)
* lock, interpreter:                     スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line   6)
* LONG_MAX <1>:                          長整数型オブジェクト long integer object.
                                                              (line  70)
* LONG_MAX:                              通常整数型オブジェクト plain integer object.
                                                              (line  87)
* LongType:                              長整数型オブジェクト long integer object.
                                                              (line  11)
* main():                                初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 148)
* malloc():                              概要.                (line  36)
* MethodType <1>:                        メソッドオブジェクト method object.
                                                              (line  10)
* MethodType:                            関数オブジェクト Function Objects.
                                                              (line  14)
* module search path <1>:                初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  14)
* module search path:                    Python の埋め込み.   (line  15)
* modules <1>:                           初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  12)
* modules:                               モジュールの import. (line  23)
* ModuleType:                            モジュールオブジェクト module object.
                                                              (line  11)
* OverflowError:                         長整数型オブジェクト long integer object.
                                                              (line  70)
* package variable!__all__:              モジュールの import. (line  15)
* path <1>:                              初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  12)
* path:                                  Python の埋め込み.   (line  17)
* PEP 238:                               超高レベルレイヤ.    (line 209)
* platform:                              初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 268)
* Py_BEGIN_ALLOW_THREADS:                スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line  52)
* Py_BLOCK_THREADS:                      スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 265)
* Py_CompileString():                    超高レベルレイヤ.    (line 182)
* Py_complex:                            C 構造体としての複素数.
                                                              (line  11)
* Py_DECREF():                           参照カウント.        (line  23)
* Py_END_ALLOW_THREADS:                  スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line  53)
* Py_FatalError():                       初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 309)
* Py_Finalize() <1>:                     初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  18)
* Py_Finalize():                         プロセス制御.        (line  16)
* Py_GetExecPrefix():                    Python の埋め込み.   (line  51)
* Py_GetPath() <1>:                      初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 149)
* Py_GetPath():                          Python の埋め込み.   (line  51)
* Py_GetPrefix():                        Python の埋め込み.   (line  51)
* Py_GetProgramFullPath():               Python の埋め込み.   (line  52)
* Py_INCREF():                           参照カウント.        (line  21)
* Py_Initialize() <1>:                   スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 170)
* Py_Initialize() <2>:                   初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 104)
* Py_Initialize():                       Python の埋め込み.   (line  12)
* Py_IsInitialized():                    Python の埋め込み.   (line  63)
* Py_PRINT_RAW:                          ファイルオブジェクト file object.
                                                              (line  83)
* Py_RETURN_FALSE:                       Bool 型オブジェクト. (line  27)
* Py_RETURN_NONE:                        None オブジェクト.   (line  19)
* Py_RETURN_TRUE:                        Bool 型オブジェクト. (line  31)
* Py_SetProgramName() <1>:               初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  10)
* Py_SetProgramName():                   Python の埋め込み.   (line  44)
* Py_ssize_t (*getcharbufferproc) (PyObject *self, Py_ssize_t segment, const char **ptrptr): バッファオブジェクト構造体 buffer object structure.
                                                              (line 102)
* Py_ssize_t (*getreadbufferproc) (PyObject *self, Py_ssize_t segment, void **ptrptr): バッファオブジェクト構造体 buffer object structure.
                                                              (line  79)
* Py_ssize_t (*getsegcountproc) (PyObject *self, Py_ssize_t *lenp): バッファオブジェクト構造体 buffer object structure.
                                                              (line  96)
* Py_ssize_t (*getwritebufferproc) (PyObject *self, Py_ssize_t segment, void **ptrptr): バッファオブジェクト構造体 buffer object structure.
                                                              (line  88)
* Py_UNBLOCK_THREADS:                    スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 270)
* Py_UNICODE:                            Unicode オブジェクト Unicode object.
                                                              (line  10)
* Py_XDECREF():                          例外.                (line 134)
* PyBufferObject:                        Buffer Objects.      (line  54)
* PyBufferProcs <1>:                     バッファオブジェクト構造体 buffer object structure.
                                                              (line  28)
* PyBufferProcs:                         Buffer Objects.      (line  29)
* PyCellObject:                          セルオブジェクト cell object.
                                                              (line  18)
* PyCFunction:                           共通のオブジェクト構造体 common object structure.
                                                              (line  63)
* PyCObject:                             Cオブジェクト CObject.
                                                              (line  11)
* PyComplexObject:                       Python オブジェクトとしての複素数型.
                                                              (line   7)
* PyDictObject:                          辞書オブジェクト dictionary object.
                                                              (line   7)
* PyErr_Clear():                         例外.                (line  33)
* PyErr_ExceptionMatches():              例外.                (line 130)
* PyErr_Occurred():                      例外.                (line  20)
* PyErr_SetString():                     例外.                (line  31)
* PyEval_AcquireLock() <1>:              スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line  85)
* PyEval_AcquireLock():                  初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  11)
* PyEval_InitThreads():                  初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  10)
* PyEval_ReleaseLock() <1>:              スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line  84)
* PyEval_ReleaseLock():                  初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  11)
* PyEval_ReleaseThread():                スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 167)
* PyEval_RestoreThread():                スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line  78)
* PyEval_SaveThread():                   スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line  83)
* PyExc_ArithmeticError:                 標準例外.            (line  16)
* PyExc_AssertionError:                  標準例外.            (line  18)
* PyExc_AttributeError:                  標準例外.            (line  19)
* PyExc_BaseException:                   標準例外.            (line  13)
* PyExc_EnvironmentError:                標準例外.            (line  21)
* PyExc_EOFError:                        標準例外.            (line  20)
* PyExc_Exception:                       標準例外.            (line  14)
* PyExc_FloatingPointError:              標準例外.            (line  22)
* PyExc_ImportError:                     標準例外.            (line  24)
* PyExc_IndexError:                      標準例外.            (line  25)
* PyExc_IOError:                         標準例外.            (line  23)
* PyExc_KeyboardInterrupt:               標準例外.            (line  27)
* PyExc_KeyError:                        標準例外.            (line  26)
* PyExc_LookupError:                     標準例外.            (line  17)
* PyExc_MemoryError:                     標準例外.            (line  28)
* PyExc_NameError:                       標準例外.            (line  29)
* PyExc_NotImplementedError:             標準例外.            (line  30)
* PyExc_OSError:                         標準例外.            (line  31)
* PyExc_OverflowError:                   標準例外.            (line  32)
* PyExc_ReferenceError:                  標準例外.            (line  33)
* PyExc_RuntimeError:                    標準例外.            (line  34)
* PyExc_StandardError:                   標準例外.            (line  15)
* PyExc_SyntaxError:                     標準例外.            (line  35)
* PyExc_SystemError:                     標準例外.            (line  36)
* PyExc_SystemExit:                      標準例外.            (line  37)
* PyExc_TypeError:                       標準例外.            (line  38)
* PyExc_ValueError:                      標準例外.            (line  39)
* PyExc_WindowsError:                    標準例外.            (line  40)
* PyExc_ZeroDivisionError:               標準例外.            (line  41)
* PyFileObject:                          ファイルオブジェクト file object.
                                                              (line  12)
* PyFloatObject:                         浮動小数点型オブジェクト floating point object.
                                                              (line   7)
* PyFunctionObject:                      関数オブジェクト Function Objects.
                                                              (line   9)
* PyGenObject:                           ジェネレータオブジェクト.
                                                              (line  13)
* PyInterpreterState:                    スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line 147)
* PyIntObject:                           通常整数型オブジェクト plain integer object.
                                                              (line   7)
* PyList_GetItem():                      参照カウントの詳細.  (line 123)
* PyList_SetItem():                      参照カウントの詳細.  (line  30)
* PyListObject:                          List Objects.        (line   7)
* PyLongObject:                          長整数型オブジェクト long integer object.
                                                              (line   7)
* PyMappingMethods:                      マップ型オブジェクト構造体 mapping object structure.
                                                              (line   7)
* PyMethodDef:                           共通のオブジェクト構造体 common object structure.
                                                              (line  73)
* PyNumberMethods:                       数値オブジェクト構造体 number object structure.
                                                              (line   7)
* PyObject:                              共通のオブジェクト構造体 common object structure.
                                                              (line  17)
* PyObject_HEAD:                         共通のオブジェクト構造体 common object structure.
                                                              (line  35)
* PyObject_HEAD_INIT:                    共通のオブジェクト構造体 common object structure.
                                                              (line  61)
* PyObject_VAR_HEAD:                     共通のオブジェクト構造体 common object structure.
                                                              (line  51)
* PySequence_GetItem():                  参照カウントの詳細.  (line 124)
* PySequenceMethods:                     シーケンスオブジェクト構造体 sequence object structure.
                                                              (line   7)
* PySetObject:                           集合オブジェクト Set Objects.
                                                              (line  20)
* PyString_FromString():                 辞書オブジェクト dictionary object.
                                                              (line  56)
* PyStringObject:                        文字列オブジェクト string object.
                                                              (line  10)
* PySys_SetArgv() <1>:                   初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  17)
* PySys_SetArgv():                       Python の埋め込み.   (line  22)
* PyThreadState:                         スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line  27)
* PyTuple_SetItem():                     参照カウントの詳細.  (line  30)
* PyTupleObject:                         タプルオブジェクト tuple object.
                                                              (line   7)
* PyType_HasFeature():                   バッファオブジェクト構造体 buffer object structure.
                                                              (line  53)
* PyTypeObject:                          型オブジェクト type object.
                                                              (line   7)
* PyUnicodeObject:                       Unicode オブジェクト Unicode object.
                                                              (line  29)
* PyVarObject:                           共通のオブジェクト構造体 common object structure.
                                                              (line  26)
* realloc():                             概要.                (line  37)
* set_all():                             参照カウントの詳細.  (line 101)
* setcheckinterval():                    スレッド状態 thread state とグローバルインタプリタロック global interpreter lock.
                                                              (line  20)
* setvbuf():                             ファイルオブジェクト file object.
                                                              (line  60)
* SIGINT:                                例外処理.            (line 272)
* SliceType:                             スライスオブジェクト slice object.
                                                              (line   8)
* softspace:                             ファイルオブジェクト file object.
                                                              (line  71)
* stderr:                                初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  79)
* stdin:                                 初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  79)
* stdout:                                初期化 initialization、終了処理 finalization、スレッド.
                                                              (line  79)
* strerror():                            例外処理.            (line 168)
* StringType:                            文字列オブジェクト string object.
                                                              (line  16)
* struct _frozen:                        モジュールの import. (line 130)
* struct _inittab:                       モジュールの import. (line 160)
* struct PyCompilerFlags:                超高レベルレイヤ.    (line 195)
* sum_list():                            参照カウントの詳細.  (line 144)
* sum_sequence() <1>:                    例外.                (line  71)
* sum_sequence():                        参照カウントの詳細.  (line 164)
* SystemError:                           モジュールオブジェクト module object.
                                                              (line  38)
* TupleType:                             タプルオブジェクト tuple object.
                                                              (line  13)
* TypeType:                              型オブジェクト type object.
                                                              (line  12)
* ULONG_MAX:                             長整数型オブジェクト long integer object.
                                                              (line  74)
* version:                               初期化 initialization、終了処理 finalization、スレッド.
                                                              (line 252)


