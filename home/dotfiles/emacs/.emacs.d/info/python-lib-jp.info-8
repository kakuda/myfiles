これは python-lib-jp.info、python-lib-jp.texi より makeinfo バージョン
4.8 によって作成されました。

19th September, 2006


File: python-lib-jp.info,  Node: SimpleXMLRPCServer オブジェクト,  Next: CGIXMLRPCRequestHandler,  Prev: SimpleXMLRPCServer,  Up: SimpleXMLRPCServer

18.25.1 SimpleXMLRPCServer オブジェクト
---------------------------------------

`SimpleXMLRPCServer' クラスは `SocketServer.TCPServer'
のサブクラスで、基本的なスタンドアロンの XML-RPC
サーバーを作成する手段を提供します。

`register_function(function[, name])'
     XML-RPCリクエストに応じる関数を登録します。引数NAMEが与えられている場合はその値が、関数FUNCTIONに関連付けられます。これが与えられない場合は`FUNCTION.__name__'の値が用いられます。引数NAMEは通常の文字列でもユニコード文字列でも良く、Pythonで識別子として正しくない文字("
     . "ピリオドなど )を含んでいても。


`register_instance(instance[, allow_dotted_names])'
     オブジェクトを登録し、そのオブジェクトの`register_function()'で
     登録されていないメソッドを公開します。もし、INSTANCEがメソッド
     `_dispatch()'を定義していれば、`_dispatch()'が、リクエス
     トされたメソッド名とパラメータの組を引数として呼び出されます。そして、
     `_dispatch()'の返り値が結果としてクライアントに返されます。
     そのAPIは  `def `_dispatch'(self, method, params)' (注意:
     PARAMSは可変引数リストではありません)です。仕事をするため
     に下位の関数を呼ぶ時には、その関数は`func(*params)'のように呼ばれ
     ます。`_dispatch()'の返り値はクライアントへ結果として返されます。
     もし、 INSTANCEがメソッド`_dispatch()'を定義していなければ、リク
     エストされたメソッド名がそのインスタンスに定義されているメソッド名から
     探されます。

     もしオプション引数ALLOW_DOTTED_NAMESが真(true)で、
     インスタンスがメソッド`_dispatch()'を定義していないとき、
     リクエストされたメソッド名がピリオドを含む場合は、（訳注：
     通常のPythonでのピリオドの解釈と同様に）階層的にオブジェクトを探索し
     ます。そして、そこで見つかったオブジェクトをリクエストから渡された引数
     で呼び出し、その返り値をクライアントに返します。

     _Notice:_ [warning]
     ALLOW_DOTTED_NAMESオプションを有効にすると、侵入者にあなたのモジュールの
     グローバル変数にアクセスすることを許し、あなたのコンピュータで任意のコードを実行する
     ことを許すことがあります。このオプションは安全な閉じたネットワークでのみお使い下さい。

     _Changed in Python version 2.3.5, 2.4.1_


`register_introspection_functions()'
     XML-RPC
     のイントロスペクション関数、`system.listMethods'、`system.methodHelp'、`system.methodSignature'
     を登録します。 _Added in Python version 2.3_

`register_multicall_functions()'
     XML-RPC における複数の要求を処理する関数 system.multicall
     を登録します。

`rpc_paths'
     この属性値はXML-RPCリクエストを受け付けるURLの正当なパス部分をリストするタプルで
     なければなりません。これ以外のパスへのリクエストは404「そのようなページはありません」
     HTTPエラーになります。このタプルが空の場合は全てのパスが正当であると見なされます。
     デフォルト値は`('/', '/RPC2')'です。 _Added in Python version 2.5_

以下に例を示します。

     from SimpleXMLRPCServer import SimpleXMLRPCServer

     # Create server
     server = SimpleXMLRPCServer(("localhost", 8000))
     server.register_introspection_functions()

     # Register pow() function; this will use the value of
     # pow.__name__ as the name, which is just 'pow'.
     server.register_function(pow)

     # Register a function under a different name
     def adder_function(x,y):
         return x + y
     server.register_function(adder_function, 'add')

     # Register an instance; all the methods of the instance are
     # published as XML-RPC methods (in this case, just 'div').
     class MyFuncs:
         def div(self, x, y):
             return x // y

     server.register_instance(MyFuncs())

     # Run the server's main loop
     server.serve_forever()

以下のクライアントコードは上のサーバーで使えるようになったメソッドを呼び出します:

     import xmlrpclib

     s = xmlrpclib.Server('http://localhost:8000')
     print s.pow(2,3)  # Returns 2**3 = 8
     print s.add(2,3)  # Returns 5
     print s.div(5,2)  # Returns 5//2 = 2

     # Print list of available methods
     print s.system.listMethods()


File: python-lib-jp.info,  Node: CGIXMLRPCRequestHandler,  Prev: SimpleXMLRPCServer オブジェクト,  Up: SimpleXMLRPCServer

18.25.2 CGIXMLRPCRequestHandler
-------------------------------

`CGIXMLRPCRequestHandler' クラスは、Python の CGI スクリプトに送られた
XML-RPC リクエストを処理するときに使用できます

`register_function(function[, name])'
     XML-RPC リクエストに応じる関数を登録します。
     引数NAMEが与えられている場合はその値が、関数FUNCTIONに関連付けられます。これが与えられない場合は`FUNCTION.__name__'の値が用いられます。引数NAMEは通常の文字列でもユニコード文字列でも良く、Pythonで識別子として正しくない文字("
     . "ピリオドなど )を含んでもかまいません。

`register_instance(instance)'
     オブジェクトを登録し、そのオブジェクトの`register_function()'で登録されていないメソッドを公開します。もし、INSTANCEがメソッド`_dispatch()'を定義していれば、`_dispatch()'が、リクエストされたメソッド名とパラメータの組を引数として呼び出されます。そして、`_dispatch()'の返り値が結果としてクライアントに返されます。もし、INSTANCEがメソッド`_dispatch()'を定義していなければ、リクエストされたメソッド名がそのインスタンスに定義されているメソッド名から探されます。リクエストされたメソッド名がピリオドを含む場合は、（訳注：通常のPythonでのピリオドの解釈と同様に）階層的にオブジェクトを探索します。そして、そこで見つかったオブジェクトをリクエストから渡された引数で呼び出し、その返り値をクライアントに返します。

`register_introspection_functions()'
     XML-RPC
     のイントロスペクション関数、`system.listMethods'、`system.methodHelp'、`system.methodSignature'
     を登録します。

`register_multicall_functions()'
     XML-RPC における複数の要求を処理する関数 system.multicall
     を登録します。

`handle_request([request_text = None])'
     XML-RPC リクエストを処理します。REQUEST_TEXT で渡されるのは、HTTP
     サーバーに提供された POST
     データです。何も渡されなければ標準入力からのデータが使われます。

以下に例を示します。

     class MyFuncs:
         def div(self, x, y) : return x // y

     handler = CGIXMLRPCRequestHandler()
     handler.register_function(pow)
     handler.register_function(lambda x,y: x+y, 'add')
     handler.register_introspection_functions()
     handler.register_instance(MyFuncs())
     handler.handle_request()


File: python-lib-jp.info,  Node: DocXMLRPCServer,  Prev: SimpleXMLRPCServer,  Up: インターネットプロトコルとその支援

18.26 セルフ-ドキュメンティング XML-RPC サーバ
==============================================

セルフ-ドキュメンティング XML-RPC サーバの実装。

_Added in Python version 2.3_

`DocXMLRPCServer' モジュールは `SimpleXMLRPCServer' クラ
スを拡張し、HTTP GET リクエストに対し HTML ドキュメントを返します。サー
バは `DocXMLRPCServer' を使ったスタンドアロン環境、
`DocCGIXMLRPCRequestHandler' を使った CGI 環境の2つがあります。

`DocXMLRPCServer(addr[,  requestHandler[, logRequests]])'
     当たなサーバ・インスタンスを生成します。各パラメータの内容は
     `SimpleXMLRPCServer.SimpleXMLRPCServer' のものと同じですが、
     REQUESTHANDLER のデフォルトは `DocXMLRPCRequestHandler' に
     なっています。


`DocCGIXMLRPCRequestHandler()'
     CGI環境に XMR-RPC
     リクエスト・ハンドラの新たなインスタンスを生成します。


`DocXMLRPCRequestHandler()'
     リクエスト・ハンドラの新たなインスタンスを生成します。このリクエスト・
     ハンドラは XML-RPC POST リクエスト、ドキュメントの GET、そして
     `DocXMLRPCServer' コンストラクタに与えられた LOGREQUESTS
     パラメータ設定を優先するため、ロギングの変更をサポートします。


* Menu:

* DocXMLRPCServer オブジェクト::
* DocCGIXMLRPCRequestHandler::


File: python-lib-jp.info,  Node: DocXMLRPCServer オブジェクト,  Next: DocCGIXMLRPCRequestHandler,  Prev: DocXMLRPCServer,  Up: DocXMLRPCServer

18.26.1 DocXMLRPCServer オブジェクト
------------------------------------

`DocXMLRPCServer' は `SimpleXMLRPCServer.SimpleXMLRPCServer'
の派生クラスで、セルフ- ドキュメンティングの手段と XML-RPC
サーバ機能を提供します。HTTP POST リクエストは XML-RPC
メソッドの呼び出しとして扱われます。HTTP GET リク エストは pydoc
スタイルの HTML ドキュメント生成のリクエストとして扱わ
れます。これはサーバが自分自身のドキュメントを Web ベースで提供可能で
あることを意味します。

`set_server_title(server_title)'
     生成する HTML ドキュメントのタイトルをセットします。このタイトルは
     HTML の title 要素として使われます。


`set_server_name(server_name)'
     生成する HTML ドキュメントの名前をセットします。この名前は HTML
     冒頭の h1 要素に使われます。

`set_server_documentation(server_documentation)'
     生成する HTML ドキュメントの本文をセットします。この本文は
     ドキュメント中の名前の下にパラグラフとして出力されます。



File: python-lib-jp.info,  Node: DocCGIXMLRPCRequestHandler,  Prev: DocXMLRPCServer オブジェクト,  Up: DocXMLRPCServer

18.26.2 DocCGIXMLRPCRequestHandler
----------------------------------

`DocCGIXMLRPCRequestHandler' は
`SimpleXMLRPCServer.CGIXMLRPCRequestHandler' の派生クラスで、セ ルフ-
ドキュメンティングの手段と XML-RPC CGI スクリプト機能を提供しま
す。HTTP POST リクエストは XML-RCP メソッドの呼び出しとして扱われます。
HTTP GET リクエストは pydoc スタイルの HTML ドキュメント生成のリクエス
トとして扱われます。これはサーバが自分自身のドキュメントを Web ベース
で提供可能であることを意味します。

`set_server_title(server_title)'
     生成する HTML ドキュメントのタイトルをセットします。このタイトルは
     HTML の title 要素として使われます。


`set_server_name(server_name)'
     生成する HTML ドキュメントの名前をセットします。この名前は HTML
     冒頭の h1 要素に使われます。


`set_server_documentation(server_documentation)'
     生成する HTML ドキュメントの本文をセットします。この本文は
     ドキュメント中の名前の下にパラグラフとして出力されます。



File: python-lib-jp.info,  Node: マルチメディアサービス,  Next: Tkを用いたグラフィカルユーザインターフェイス,  Prev: インターネットプロトコルとその支援,  Up: Top

19 マルチメディアサービス
*************************

この章で記述されているモジュールは、主にマルチメディアアプリケーションに
役立つさまざまなアルゴリズムまたはインターフェイスを実装しています。
これらのモジュールはインストール時の自由裁量に応じて利用できます。

以下に概要を示します。

* Menu:

* audioop::
* imageop::
* aifc::
* sunau::
* wave::
* chunk::
* colorsys::
* rgbimg::
* imghdr::
* sndhdr::
* ossaudiodev::


File: python-lib-jp.info,  Node: audioop,  Next: imageop,  Prev: マルチメディアサービス,  Up: マルチメディアサービス

19.1 生の音声データを操作する
=============================

生の音声データを操作する

`audioop' モジュールは音声データを操作する関数を収録しています。
このモジュールは、Python 文字列型中に入っている 8,  16, 32 ビットの
符号付き整数でできた音声データ、すなわち `al' および `sunaudiodev'
で使われているのと同じ形式の音声データを操作
します。特に指定の無いかぎり、スカラ量を表す要素はすべて整数型になって
います。

このモジュールはa-LAW、u-LAWそしてIntel/DVI
ADPCMエンコードをサポートしています。 

複雑な操作のうちいくつかはサンプル幅が 16 ビットのデータに対して
のみ働きますが、 それ以外は常にサンプル幅を操作のパラメタとして
(バイト単位で) 渡します。

このモジュールでは以下の変数と関数を定義しています：

`error'
     この例外は、未知のサンプル当たりのバイト数を指定した時など、
     全般的なエラーに対して送出されます。

`add(fragment1, fragment2, width)'
     パラメタに渡した 2 つのデータを加算した結果を返します。
     WIDTHはサンプル幅をバイトで表したもので、
     `1'、`2'、`4'のうちいずれかです。 2
     つのデータは同じサンプル幅でなければなりません。

`adpcm2lin(adpcmfragment, width, state)'
     Intel/DVI ADPCM 形式のデータをリニア (linear)
     形式にデコードします。 ADPCM
     符号化方式の詳細については`lin2adpcm()' の説明を
     参照して下さい。`(SAMPLE, NEWSTATE)' からなる
     タプルを返し、サンプルはWIDTH に指定した幅になります。

`alaw2lin(fragment, width)'
     a-LAW形式のデータをリニア (linear) 形式に変換します。
     a-LAW形式は常に 8 ビットのサンプルを使用するので、ここでは WIDTH
     は単に出力データのサンプル幅となります。 _Added in Python version
     2.5_

`avg(fragment, width)'
     データ中の全サンプルの平均値を返します。

`avgpp(fragment, width)'
     データ中の全サンプルの平均 peak-peak 振幅を返します。
     フィルタリングを行っていない場合、このルーチンの有用性は疑問です。

`bias(fragment, width, bias)'
     元データの各サンプルにバイアスを加えたデータを返します。

`cross(fragment, width)'
     引数に渡したデータ中のゼロ交差回数を返します。

`findfactor(fragment, reference)'
     `rms(add(FRAGMENT, mul(REFERENCE, -F)))' を 最小にするような係数F
     、すなわち、REFERENCE に乗算した ときにもっとも FRAGMENT
     に近くなるような値を返します。 FRAGMENTとREFERENCE
     のサンプル幅はいずれも 2バイト でなければなりません。

     このルーチンの実行に要する時間は`len(FRAGMENT)'に比例します。

`findfit(fragment, reference)'
     REFERENCE を可能な限り FRAGMENT に一致させようとします (FRAGMENT
     は REFERENCE より長くなければなりません)。 この処理は (概念的には)
     FRAGMENT からスライスをいくつか取り出し、
     それぞれについて`findfactor()' を使って最良な一致を計算し、
     誤差が最小の結果を選ぶことで実現します。
     FRAGMENTとREFERENCEのサンプル幅は両方とも2バイトでなければな
     りません。`(OFFSET, FACTOR)' からなるタプルを返します。 OFFSET
     は最適な一致箇所が始まるFRAGMENTのオフセット値（整
     数）で、FACTORは`findfactor()' の返す係数 (浮動小数点数) です。

`findmax(fragment, length)'
     FRAGMENT から、長さがLENGTH サンプル (バイトではありません!)
     で最大のエネルギーを持つスライス、
     すなわち、`rms(fragment[i*2:(i+length)*2])' を
     最大にするようなスライスを探し、 I を返します。
     データのはサンプル幅は 2バイトでなければなりません。

     このルーチンの実行に要する時間は`len(FRAGMENT)'に比例します。

`getsample(fragment, width, index)'
     データ中のINDEX サンプル目の値を返します。

`lin2adpcm(fragment, width, state)'
     データを 4 ビットの Intel/DVI ADPCM 符号化方式に変換します。 ADPCM
     符号化方式とは適応符号化方式の一つで、あるサンプルと (可変の)
     ステップだけ離れたその次のサンプルとの差を 4 ビットの整数
     で表現する方式です。 Intel/DVI ADPCMアルゴリズムは IMA
     (国際MIDI協会) に採用されているので、おそらく標準になるはずです。

     STATE はエンコーダの内部状態が入ったタプルです。
     エンコーダは`(ADPCMFRAG, NEWSTATE)' のタプルを返し、 次に
     `lin2adpcm()'を呼び出す時にNEWSTATE を渡さねば
     なりません。最初に呼び出す時にはSTATEに`None' を渡しても
     かまいません。ADPCMFRAG は ADPCMで符号化されたデータで、バイト
     当たり 2 つの4ビット値がパックされています。

`lin2alaw(fragment, width)'
     音声データの各サンプルを a-LAW
     符号でエンコードし、Python文字列として 返します。a-LAW
     とは音声符号化方式の一つで、約 13 ビットに相当する
     ダイナミックレンジをわずか 8 ビットで実現できます。 Sun
     やその他の音声 ハードウェアで使われています。 _Added in Python
     version 2.5_

`lin2lin(fragment, width, newwidth)'
     サンプル幅を 1、2、4 バイト形式の間で変換します。

`lin2ulaw(fragment, width)'
     音声データの各サンプルを u-LAW
     符号でエンコードし、Python文字列として 返します。 u-LAW
     とは音声符号化方式の一つで、約 14 ビットに相当する
     ダイナミックレンジをわずか 8 ビットで実現できます。 Sun
     やその他の音声 ハードウェアで使われています。

`minmax(fragment, width)'
     音声データ全サンプル中における最小値と最大値からなるタプルを返します。

`max(fragment, width)'
     音声データ全サンプルの_絶対値_ の最大値を返します。

`maxpp(fragment, width)'
     音声データの最大 peak-peak 振幅を返します。

`mul(fragment, width, factor)'
     元のデータの全サンプルに浮動小数点数FACTORを掛けたデータを返します。
     オーバフローが起きても例外を送出せず無視します。

`ratecv(fragment, width, nchannels, inrate, outrate, state[, weightA[, weightB]])'
     入力したデータのフレームレートを変換します。

     STATE は変換ルーチンの内部状態を入れたタプルです。
     変換ルーチンは`(NEWFRAGMENT, NEWSTATE)'
     を返し、次に`ratecv()'を呼び出す時にはNEWSTATEを
     渡さなねばなりません。最初の呼び出しでは`None'を渡します。

     引数WEIGHTAとWEIGHTB は単純なデジタルフィルタの
     パラメタで、デフォルト値はそれぞれ`1' と`0'です。

`reverse(fragment, width)'
     データ内のサンプルの順序を逆転し、変更されたデータを返します。

`rms(fragment, width)'
     データの自乗平均根 (root-mean-square) 、すなわち
          \catcode`_=8
          \sqrt{\frac{\sum{{S_{i}}^{2}}}{n}}

     を返します。これはオーディオ信号の強度 (power)
     を測る一つの目安です。

`tomono(fragment, width, lfactor, rfactor)'
     ステレオ音声データをモノラル音声データに変換します。
     左チャネルのデータに LFACTOR、右チャネルのデータに RFACTOR
     を掛けた後、二つのチャネルの値を加算して単一チャネルの信号を生成します。

`tostereo(fragment, width, lfactor, rfactor)'
     モノラル音声データをステレオ音声データに変換します。
     ステレオ音声データの各サンプル対は、モノラル音声データの各サンプルを
     それぞれ左チャネルは LFACTOR 倍、右チャネルは RFACTOR 倍
     して生成します。

`ulaw2lin(fragment, width)'
     u-LAW で符号化されている音声データを線形に符号化された音声データに
     変換します。 u-LAW 符号化は常にサンプル当たり 8 ビットを使うため、
     WIDTH は出力音声データのサンプル幅にしか使われません。

`mul()' や`max()' といった操作はモノラルと
ステレオを区別しない、すなわち全てのデータを平等に扱うという
ことに注意してください。この仕様が問題になるようなら、あらかじめ
ステレオ音声データを二つのモノラル音声データに分割しておき、
操作後に再度統合してください。そのような例を以下に示します:

     def mul_stereo(sample, width, lfactor, rfactor):
         lsample = audioop.tomono(sample, width, 1, 0)
         rsample = audioop.tomono(sample, width, 0, 1)
         lsample = audioop.mul(lsample, width, lfactor)
         rsample = audioop.mul(rsample, width, rfactor)
         lsample = audioop.tostereo(lsample, width, 1, 0)
         rsample = audioop.tostereo(rsample, width, 0, 1)
         return audioop.add(lsample, rsample, width)

ADPCM エンコーダを使って音声データの入ったネットワークパケットを
構築する際、自分のプロトコルを (パケットロスに耐えられるように)
ステートレス (stateless) にしたいなら、データだけでなく状態変数 (state)
も伝送せねばなりません。このとき、伝送するのはエンコード後状態
(エンコーダの返す値) ではなく、エンコーダの初期状態 (`lin2adpcm()'
に渡した値) INITIAL なので注意してください。 `struct.struct()'
を使って状態変数をバイナリ形式で保存したいなら、最初の要素 (予測値) は
16 ビットで、次の値 (デルタ係数: delta index) は 8 ビット
で符号化できます。

このモジュールの ADPCM 符号のテストは自分自身に対してのみ行っており、
他の ADPCM 符号との間では行っていません。作者が仕様を誤解している
部分もあるかもしれず、それぞれの標準との間で相互運用できない場合も
あり得ます。

`find*()' ルーチンは一見滑稽に見えるかもしれません。
これらの関数の主な目的はエコー除去 (echo cancellation) にあります。
エコー除去を十分高速に行うには、出力サンプル中から最も大きな
エネルギーを持った部分を取り出し、この部分が入力サンプル中の
どこにあるかを調べ、入力サンプルから出力サンプル自体を減算します:

     def echocancel(outputdata, inputdata):
         pos = audioop.findmax(outputdata, 800)    # 1/10秒
         out_test = outputdata[pos*2:]
         in_test = inputdata[pos*2:]
         ipos, factor = audioop.findfit(in_test, out_test)
         # Optional (for better cancellation):
         # factor = audioop.findfactor(in_test[ipos*2:ipos*2+len(out_test)],
         #              out_test)
         prefill = '\0'*(pos+ipos)*2
         postfill = '\0'*(len(inputdata)-len(prefill)-len(outputdata))
         outputdata = prefill + audioop.mul(outputdata,2,-factor) + postfill
         return audioop.add(inputdata, outputdata, 2)


File: python-lib-jp.info,  Node: imageop,  Next: aifc,  Prev: audioop,  Up: マルチメディアサービス

19.2 生の画像データを操作する
=============================

生の画像データを操作する。

`imageop'モジュールは画像に関する便利な演算がふくまれています。Python文字列に保存されている8または32ビットのピクセルから構成される画像を操作します。これは`gl.lrectwrite()'と`imgfile'モジュールが使用しているものと同じフォーマットです。

モジュールは次の変数と関数を定義しています:

`error'
     この例外はピクセル当りの未知のビット数などのすべてのエラーで発生させられます。

`crop(image, psize, width, height, x0, y0, x1, y1)'
     IMAGEの選択された部分を返します。IMAGEはWIDTH×HEIGHTの大きさで、PSIZEバイトのピクセルから構成されなければなりません。X0、Y0、X1およびY1は`gl.lrectread()'パラメータと同様です。すなわち、境界は新画像に含まれます。新しい境界は画像の内部である必要はありません。旧画像の外側になるピクセルは値をゼロに設定されます。X0がX1より大きければ、新画像は鏡像反転されます。y軸についても同じことが適用されます。

`scale(image, psize, width, height, newwidth, newheight)'
     IMAGEを大きさNEWWIDTH×NEWHEIGHTに伸縮させて返します。補間は行われません。ばかばかしいほど単純なピクセルの複製と間引きを行い伸縮させます。そのため、コンピュータで作った画像やディザ処理された画像は伸縮した後見た目が良くありません。

`tovideo(image, psize, width, height)'
     垂直ローパスフィルタ処理を画像全体に行います。それぞれの目標ピクセルを垂直に並んだ二つの元ピクセルから計算することで行います。このルーチンの主な用途としては、画像がインターレース走査のビデオ装置に表示された場合に極端なちらつきを抑えるために用います。そのため、この名前があります。

`grey2mono(image, width, height, threshold)'
     全ピクセルを二値化することによって、深さ8ビットのグレースケール画像を深さ1ビットの画像へ変換します。処理後の画像は隙間なく詰め込まれ、おそらく`mono2grey()'の引数としてしか使い道がないでしょう。

`dither2mono(image, width, height)'
     (ばかばかしいほど単純な)ディザ処理アルゴリズムを用いて、8ビットグレースケール画像を1ビットのモノクロ画像に変換します。

`mono2grey(image, width, height, p0, p1)'
     1ビットモノクロが象画像を8ビットのグレースケールまたはカラー画像に変換します。入力で値ゼロの全てのピクセルは出力では値P0を取り、値0の入力ピクセルは出力では値P1を取ります。白黒のモノクロ画像をグレースケールへ変換するためには、値`0'と`255'をそれぞれ渡してください。

`grey2grey4(image, width, height)'
     ディザ処理を行わずに、8ビットグレースケール画像を4ビットグレースケール画像へ変換します。

`grey2grey2(image, width, height)'
     ディザ処理を行わずに、8ビットグレースケール画像を2ビットグレースケール画像に変換します。

`dither2grey2(image, width, height)'
     ディザ処理を行い、8ビットグレースケール画像を2ビットグレースケール画像へ変換します。`dither2mono()'については、ディザ処理アルゴリズムは現在とても単純です。

`grey42grey(image, width, height)'
     4ビットグレースケール画像を8ビットグレースケール画像へ変換します。

`grey22grey(image, width, height)'
     2ビットグレースケール画像を8ビットグレースケール画像へ変換します。

`backward_compatible'
     0
     にセットすると、このモジュールの関数は、リトルエンディアンのシステムで
     以前のバージョンと互換性のない方法でマルチバイトピクセル値を表現
     するようになります。このモジュールはもともと SGI 向けに書かれたの
     ですが、SGI
     はビッグエンディアンのシステムであり、この変数を設定しても
     何の影響もありません。とはいえ、このコードはもともとどこでも動作
     するように考えて作られたわけではないので、バイトオーダに関する
     仮定が相互利用向けではありませんでした。 この変数を 0
     にすると、リトルエンディアンのシステムではバイトオーダを
     反転して、ビッグエンディアンと同じにします。


File: python-lib-jp.info,  Node: aifc,  Next: sunau,  Prev: imageop,  Up: マルチメディアサービス

19.3 AIFFおよびAIFCファイルの読み書き
=====================================

AIFFあるいはAIFCフォーマットのオーディオファイルの読み書き

このモジュールはAIFFとAIFF-Cファイルの読み書きをサポートします。
AIFF（Audio Interchange File Format）はデジタルオーディオサンプルをファ
イルに保存するためのフォーマットです。
AIFF-CはAIFFの新しいバージョンで、オーディオデータの圧縮に対応していま
す。

*注意：*  操作のいくつかはIRIX上でのみ動作します；
そういう操作ではIRIXでのみ利用できる`cl'モジュールをインポート
しようとして、`ImportError'を発生します。

オーディオファイルには、オーディオデータについて記述したパラメータがたく
さん含まれています。
サンプリングレートあるいはフレームレートは、1秒あたりのオーディオサンプ
ル数です。
チャンネル数は、モノラル、ステレオ、4チャンネルかどうかを示します。
フレームはそれぞれ、チャンネルごとに一つのサンプルからなります。
サンプルサイズは、一つのサンプルの大きさをバイト数で示したものです。
したがって、一つのフレームはNCHANNELS*SAMPLESIZEバイト
からなり、1秒間ではNCHANNELS*SAMPLESIZE*FRAMERATE バイトで構成されます。

例えば、CD品質のオーディオは2バイト（16ビット）のサンプルサイズを
持っていて、2チャンネル（ステレオ）であり、44,100フレーム／秒のフレーム
レートを持っています。そのため、フレームサイズは4バイト（2*2）で、
1秒間では2*2*44100バイト（176,400バイト）になります。

`aifc'モジュールは以下の関数を定義しています：

`open(file[, mode])'
     AIFFあるいはAIFF-Cファイルを開き、後述するメソッドを持つインスタンスを返
     します。
     引数FILEはファイルを示す文字列か、ファイルオブジェクトのいずれかで
     す。 MODEは、読み込み用に開くときには`'r''か`'rb''のどちらか
     で、書き込み用に開くときには`'w''か`'wb''のどちらかでなければ
     なりません。
     もし省略されたら、`FILE.mode'が存在すればそれが使用され、なけ
     れば`'rb''が使われます。
     書き込み用にこのメソッドを使用するときには、これから全部でどれだけのサン
     プル数を書き込むのか分からなかったり、`writeframesraw()'と
     `setnframes()'を使わないなら、
     ファイルオブジェクトはシーク可能でなければなりません。

ファイルが`open()'によって読み込み用に開かれたときに返されるオ
ブジェクトには、以下のメソッドがあります：

`getnchannels()'
     オーディオチャンネル数（モノラルなら1、ステレオなら2）を返します。

`getsampwidth()'
     サンプルサイズをバイト数で返します。

`getframerate()'
     サンプリングレート（1秒あたりのオーディオフレーム数）を返します。

`getnframes()'
     ファイルの中のオーディオフレーム数を返します。

`getcomptype()'
     オーディオファイルで使用されている圧縮形式を示す4文字の文字列を返しま
     す。AIFFファイルでは`'NONE''が返されます。

`getcompname()'
     オーディオファイルの圧縮形式を人に判読可能な形にしたものを返します。
     AIFFファイルでは`'not compressed''が返されます。

`getparams()'
     以上の全ての値を上の順に並べたタプルを返します。

`getmarkers()'
     オーディオファイルのマーカーのリストを返します。
     一つのマーカーは三つの要素のタプルです。
     要素の1番目はマークID（整数）、2番目はマーク位置のフレーム数をデータの始
     めから数えた値（整数）、3番目はマークの名称（文字列）です。

`getmark(id)'
     与えられたIDのマークの要素を`getmarkers()'で述べたタプルで
     返します。

`readframes(nframes)'
     オーディオファイルの次のNFRAMES個のフレームを読み込んで返します。
     返されるデータは、全チャンネルの圧縮されていないサンプルをフレームごとに
     文字列にしたものです。

`rewind()'
     読み込むポインタをデータの始めに巻き戻します。
     次に`readframes()'を使用すると、データの始めから読み込みます。

`setpos(pos)'
     指定したフレーム数の位置にポインタを設定します。

`tell()'
     現在のポインタのフレーム位置を返します。

`close()'
     AIFFファイルを閉じます。
     このメソッドを呼び出したあとでは、オブジェクトはもう使用できません。

ファイルが`open()'によって書き込み用に開かれたときに返されるオ
ブジェクトには、`readframes()'と`setpos()'を除く上述の全て
のメソッドがあります。 さらに以下のメソッドが定義されています。
`get*()'メソッドは、対応する`set*()'を呼び出したあとでのみ
呼び出し可能です。
最初に`writeframes()'あるいは`writeframesraw()'を呼び出す
前に、フレーム数を除く全てのパラメータが設定されていなければなりません。

`aiff()'
     AIFFファイルを作ります。
     デフォルトではAIFF-Cファイルが作られますが、ファイル名が`'.aiff''で
     終わっていればAIFFファイルが作られます。

`aifc()'
     AIFF-Cファイルを作ります。
     デフォルトではAIFF-Cファイルが作られますが、ファイル名が`'.aiff''で
     終わっていればAIFFファイルが作られます。

`setnchannels(nchannels)'
     オーディオファイルのチャンネル数を設定します。

`setsampwidth(width)'
     オーディオのサンプルサイズをバイト数で設定します。

`setframerate(rate)'
     サンプリングレートを1秒あたりのフレーム数で設定します。

`setnframes(nframes)'
     オーディオファイルに書き込まれるフレーム数を設定します。
     もしこのパラメータが設定されていなかったり正しくなかったら、ファイルは
     シークに対応していなければなりません。

`setcomptype(type, name)'
     圧縮形式を設定します。
     もし設定しなければ、オーディオデータは圧縮されません。
     AIFFファイルは圧縮できません。
     変数nameは圧縮形式を人に判読可能にしたもので、変数typeは4文字の文字列で
     なければなりません。
     現在のところ、以下の圧縮形式がサポートされています： NONE, ULAW,
     ALAW, G722。 

`setparams(nchannels, sampwidth, framerate, com ptype, compname)'
     上の全パラメータを一度に設定します。
     引数はそれぞれのパラメータからなるタプルです。
     つまり、`setparams()'の引数として、`getparams()'を呼び出し
     た結果を使うことができます。

`setmark(id, pos, name)'
     指定したID（1以上）、位置、名称でマークを加えます。
     このメソッドは、`close()'の前ならいつでも呼び出すことができます。

`tell()'
     出力ファイルの現在の書き込み位置を返します。
     `setmark()'との組み合わせで使うと便利です。

`writeframes(data)'
     出力ファイルにデータを書き込みます。
     このメソッドは、オーディオファイルのパラメータを設定したあとでのみ呼び出
     し可能です。

`writeframesraw(data)'
     オーディオファイルのヘッダ情報が更新されないことを除いて、
     `writeframes()'と同じです。

`close()'
     AIFFファイルを閉じます。
     ファイルのヘッダ情報は、オーディオデータの実際のサイズを反映して更新され
     ます。
     このメソッドを呼び出したあとでは、オブジェクトはもう使用できません。


File: python-lib-jp.info,  Node: sunau,  Next: wave,  Prev: aifc,  Up: マルチメディアサービス

19.4 Sun AUファイルの読み書き
=============================

Sun AUサウンドフォーマットへのインターフェース

`sunau'モジュールは、Sun AUサウンドフォーマットへの便利なインター
フェースを提供します。このモジュールは、`aifc'モジュールや
`wave'モジュールと互換性のあるインターフェースを備えています。

オーディオファイルはヘッダとそれに続くデータから構成されます。
ヘッダのフィールドは以下の通りです：

フィールド                           内容
------                               -----
magic word                           4バイト文字列 `.snd'。
header size                          infoを含むヘッダのサイズをバイト数で示したもの。
data size                            データの物理サイズをバイト数で示したもの。
encoding                             オーディオサンプルのエンコード形式。
sample rate                          サンプリングレート。
# of channels                        サンプルのチャンネル数。
info                                 オーディオファイルについての説明をASCII文字列で示した
                                     もの（null バイトで埋められます）。

infoフィールド以外の全てのヘッダフィールドは4バイトの大きさです。
ヘッダフィールドはbig-endianでエンコードされた、計32ビットの符合なし整数
です。

`sunau'モジュールは以下の関数を定義しています：

`open(file, mode)'
     FILEが文字列ならその名前のファイルを開き、そうでないならファイル
     のようにシーク可能なオブジェクトとして扱います。MODEは以下のうち
     のいずれかです。

    ``'r'''
          読み込みのみのモード。

    ``'w'''
          書き込みのみのモード。

     読み込み／書き込み両方のモードで開くことはできない
     ことに注意して下さい。

     `'r''のMODEは`AU_read'オブジェクトを
     返し、`'w''と`'wb''のMODEは`AU_write'オブジェク トを返します。

`openfp(file, mode)'
     `open()'と同義。後方互換性のために残されています。

`sunau'モジュールは以下の例外を定義しています：

`Error'
     Sun
     AUの仕様や実装に対する不適切な操作により何か実行不可能となった時に発
     生するエラー。

`sunau'モジュールは以下のデータアイテムを定義しています：

`AUDIO_FILE_MAGIC'
     big-endianで保存された正規のSun
     AUファイルは全てこの整数で始まります。
     これは文字列`.snd'を整数に変換したものです。

`AUDIO_FILE_ENCODING_MULAW_8'

`AUDIO_FILE_ENCODING_LINEAR_8'

`AUDIO_FILE_ENCODING_LINEAR_16'

`AUDIO_FILE_ENCODING_LINEAR_24'

`AUDIO_FILE_ENCODING_LINEAR_32'

`AUDIO_FILE_ENCODING_ALAW_8'
     AUヘッダのencodingフィールドの値で、このモジュールでサポートしているもの
     です。

`AUDIO_FILE_ENCODING_FLOAT'

`AUDIO_FILE_ENCODING_DOUBLE'

`AUDIO_FILE_ENCODING_ADPCM_G721'

`AUDIO_FILE_ENCODING_ADPCM_G722'

`AUDIO_FILE_ENCODING_ADPCM_G723_3'

`AUDIO_FILE_ENCODING_ADPCM_G723_5'
     AUヘッダのencodingフィールドの値のうち既知のものとして追加されているもの
     ですが、このモジュールではサポートされていません。

* Menu:

* AU_read オブジェクト::
* AU_write オブジェクト::


File: python-lib-jp.info,  Node: AU_read オブジェクト,  Next: AU_write オブジェクト,  Prev: sunau,  Up: sunau

19.4.1 AU_read オブジェクト
---------------------------

上述の`open()'によって返されるAU_readオブジェクトには、以下の
メソッドがあります：

`close()'
     ストリームを閉じ、このオブジェクトのインスタンスを使用できなくします。
     （これはオブジェクトのガベージコレクション時に自動的に呼び出されます。）

`getnchannels()'
     オーディオチャンネル数（モノラルなら`1'、ステレオなら`2'）を返
     します。

`getsampwidth()'
     サンプルサイズをバイト数で返します。

`getframerate()'
     サンプリングレートを返します。

`getnframes()'
     オーディオフレーム数を返します。

`getcomptype()'
     圧縮形式を返します。`'ULAW''、`'ALAW''、`'NONE''が
     サポートされている形式です。

`getcompname()'
     `getcomptype()'を人に判読可能な形にしたものです。
     上述の形式に対して、それぞれ`'CCITT G.711 u-law''、 `'CCITT G.711
     A-law''、`'not compressed''がサポートされて います。

`getparams()'
     `get*()'メソッドが返すのと同じ`(NCHANNELS,  SAMPWIDTH, FRAMERATE,
     NFRAMES, COMPTYPE, COMPNAME)'のタプルを返します。

`readframes(n)'
     N個のオーディオフレームの値を読み込んで、バイト
     ごとに文字に変換した文字列を返します。
     データはlinear形式で返されます。もし元のデータがu-LAW形式なら、変換され
     ます。

`rewind()'
     ファイルのポインタをオーディオストリームの先頭に戻します。

以下の2つのメソッドは共通の"位置"を定義しています。"位置"は他の関数
とは独立して実装されています。

`setpos(pos)'
     ファイルのポインタを指定した位置に設定します。
     `tell()'で返される値をPOSとして使用しなければなりません。

`tell()'
     ファイルの現在のポインタ位置を返します。
     返される値はファイルの実際の位置に対して何も操作はしません。

以下の2つのメソッドは`aifc'モジュールとの互換性のために定義さ
れていますが、何も面白いことはしません。

`getmarkers()'
     `None'を返します。

`getmark(id)'
     エラーを発生します。


File: python-lib-jp.info,  Node: AU_write オブジェクト,  Prev: AU_read オブジェクト,  Up: sunau

19.4.2 AU_write オブジェクト
----------------------------

上述の`open()'によって返されるWave_writeオブジェクトには、
以下のメソッドがあります：

`setnchannels(n)'
     チャンネル数を設定します。

`setsampwidth(n)'
     サンプルサイズを（バイト数で）設定します。

`setframerate(n)'
     フレームレートを設定します。

`setnframes(n)'
     フレーム数を設定します。あとからフレームが書き込まれるとフレー
     ム数は変更されます。

`setcomptype(type, name)'
     圧縮形式とその記述を設定します。
     `'NONE''と`'ULAW''だけが、出力時にサポートされている形式です。

`setparams(tuple)'
     TUPLEは`(NCHANNELS, SAMPWIDTH, FRAMERATE, NFRAMES, COMPTYPE,
     COMPNAME)'
     で、それぞれ`set*()'のメソッドの値にふさわしいものでなければなり
     ません。全ての変数を設定します。

`tell()'
     ファイルの中の現在位置を返します。`AU_read.tell()'と
     `AU_read.setpos()'メソッドでお断りしたことがこのメソッドにも当
     てはまります。

`writeframesraw(data)'
     NFRAMESの修正なしにオーディオフレームを書き込みます。

`writeframes(data)'
     オーディオフレームを書き込んでNFRAMESを修正します。

`close()'
     NFRAMESが正しいか確認して、ファイルを閉じます。
     このメソッドはオブジェクトの削除時に呼び出されます。

`writeframes()'や`writeframesraw()'メソッドを呼び出したあ
とで、どんなパラメータを設定しようとしても不正となることに注意して下さ
い。


File: python-lib-jp.info,  Node: wave,  Next: chunk,  Prev: sunau,  Up: マルチメディアサービス

19.5 WAVファイルの読み書き
==========================

WAVサウンドフォーマットへのインターフェイス

`wave'モジュールは、WAVサウンドフォーマットへの便利なインター
フェイスを提供するモジュールです。

このモジュールは圧縮／展開をサポートしていませんが、モノラル／ステレオ
には対応しています。

`wave'モジュールは、以下の関数と例外を定義しています。

`open(file[, mode])'
     FILEが文字列ならその名前のファイルを開き、そうでないならファイル
     のようにシーク可能なオブジェクトとして扱います。MODEは以下のうち
     のいずれかです。

    ``'r'', `'rb'''
          　読み込みのみのモード。

    ``'w'', `'wb'''
          　書き込みのみのモード。

     WAVファイルに対して読み込み／書き込み両方のモードで開くことはできない
     ことに注意して下さい。
     `'r''と`'rb''のMODEは`Wave_read'オブジェクトを
     返し、`'w''と`'wb''のMODEは`Wave_write'オブジェク トを返します。
     MODEが省略されていて、ファイルのようなオブジェクトがFILEとし
     て渡されると、`FILE.mode'がMODEのデフォルト値として使わ
     れます（必要であれば、さらにフラグ`b'が付け加えられます）。

`openfp(file, mode)'
     `open()'と同義。後方互換性のために残されています。

`Error'
     WAVの仕様を犯したり、実装の欠陥に遭遇して何か実行不可能となった時に発生
     するエラー。

* Menu:

* Wave_read オブジェクト::
* Wave_write オブジェクト::


File: python-lib-jp.info,  Node: Wave_read オブジェクト,  Next: Wave_write オブジェクト,  Prev: wave,  Up: wave

19.5.1 Wave_read オブジェクト
-----------------------------

`open()'によって返されるWave_readオブジェクトには、以下のメソッ
ドがあります：

`close()'
     ストリームを閉じ、このオブジェクトのインスタンスを使用できなくします。
     これはオブジェクトのガベージコレクション時に自動的に呼び出されます。

`getnchannels()'
     オーディオチャンネル数（モノラルなら`1'、ステレオなら`2'）を返
     します。

`getsampwidth()'
     サンプルサイズをバイト数で返します。

`getframerate()'
     サンプリングレートを返します。

`getnframes()'
     オーディオフレーム数を返します。

`getcomptype()'
     圧縮形式を返します（`'NONE''だけがサポートされている形式です）。

`getcompname()'
     `getcomptype()'を人に判読可能な形にしたものです。
     通常、`'NONE''に対して`'not compressed''が返されます。


`getparams()'
     `get*()'メソッドが返すのと同じ`(NCHANNELS,  SAMPWIDTH, FRAMERATE,
     NFRAMES, COMPTYPE, COMPNAME)'のタプルを返します。

`readframes(n)'
     現在のポインタからN個のオーディオフレームの値を読み込んで、バイト
     ごとに文字に変換して文字列を返します。

`rewind()'
     ファイルのポインタをオーディオストリームの先頭に戻します。

以下の2つのメソッドは`aifc'モジュールとの互換性のために定義さ
れていますが、何も面白いことはしません。

`getmarkers()'
     `None'を返します。

`getmark(id)'
     エラーを発生します。

以下の2つのメソッドは共通の"位置"を定義しています。"位置"は他の関数
とは独立して実装されています。

`setpos(pos)'
     ファイルのポインタを指定した位置に設定します。

`tell()'
     ファイルの現在のポインタ位置を返します。


File: python-lib-jp.info,  Node: Wave_write オブジェクト,  Prev: Wave_read オブジェクト,  Up: wave

19.5.2 Wave_write オブジェクト
------------------------------

`open()'によって返されるWave_writeオブジェクトには、以下のメ
ソッドがあります：

`close()'
     NFRAMESが正しいか確認して、ファイルを閉じます。
     このメソッドはオブジェクトの削除時に呼び出されます。

`setnchannels(n)'
     チャンネル数を設定します。

`setsampwidth(n)'
     サンプルサイズをNバイトに設定します。

`setframerate(n)'
     サンプリングレートをNに設定します。

`setnframes(n)'
     フレーム数をNに設定します。あとからフレームが書き込まれるとフレー
     ム数は変更されます。

`setcomptype(type, name)'
     圧縮形式とその記述を設定します。

`setparams(tuple)'
     TUPLEは`(NCHANNELS, SAMPWIDTH, FRAMERATE, NFRAMES, COMPTYPE,
     COMPNAME)'
     で、それぞれ`set*()'のメソッドの値にふさわしいものでなければなり
     ません。全ての変数を設定します。

`tell()'
     ファイルの中の現在位置を返します。`Wave_read.tell()'と
     `Wave_read.setpos()'メソッドでお断りしたことがこのメソッドにも当
     てはまります。

`writeframesraw(data)'
     NFRAMESの修正なしにオーディオフレームを書き込みます。

`writeframes(data)'
     オーディオフレームを書き込んでNFRAMESを修正します。

`writeframes()'や`writeframesraw()'メソッドを呼び出したあ
とで、どんなパラメータを設定しようとしても不正となることに注意して下さ
い。そうすると`wave.Error'を発生します。


File: python-lib-jp.info,  Node: chunk,  Next: colorsys,  Prev: wave,  Up: マルチメディアサービス

19.6 IFFチャンクデータの読み込み
================================

IFFチャンクデータの読み込み。

このモジュールはEA IFF 85チャンクを使用しているファイルの読み込みのため
のインターフェースを提供します。 (1) このフォーマットは少なくとも、Audio  Interchange
File Format (AIFF/AIFF-C) とReal  Media File Format  (RMFF)で使われています。
WAVEオーディオファイルフォーマットも厳密に対応しているので、このモジュー
ルで読み込みできます。 チャンクは以下の構造を持っています：

Offset値                 長さ                     内容
------                   -----                    -----
0                        4                        チャンクID
4                        4                        big-endianで示したチャンクのサイズで、ヘッダは含みませ
                                                  ん
8                        N                        バイトデータで、Nはこれより先のフィールドのサイズ
8 + N                    0 or 1                   Nが奇数ならチャンクの整頓のために埋められるバイト

IDはチャンクの種類を識別する4バイトの文字列です。

サイズフィールド（big-endianでエンコードされた32ビット値）は、8バイトの
ヘッダを含まないチャンクデータのサイズを示します。

普通、IFFタイプのファイルは1個かそれ以上のチャンクからなります。
このモジュールで定義される`Chunk'クラスの使い方として提案している
のは、それぞれのチャンクの始めにインスタンスを作り、終わりに達するまでそ
のインスタンスから読み取り、その後で新しいインスタンスを作るということで
す。 ファイルの終わりで新しいインスタンスを作ろうとすると、
`EOFError'の例外が発生して失敗します。

`Chunk(file[, align, bigendian, inclheader])'
     チャンクを表現するクラス。
     引数FILEはファイルのようなオブジェクトであることが想定されていま
     す。 このクラスのインスタンスは特別にそのように認められています。
     必要とされるメソッドは`read()'だけです。
     もし`seek()'と`tell()'メソッドが呼び出されて例外を発生させ
     なかったら、これらのメソッドも動作します。
     これらのメソッドが呼び出されて例外を発生させても、オブジェクトを変化させ
     ないようになっています。

     省略可能な引数ALIGNがtrueなら、チャンクデータが偶数個で2バイトごと
     に整頓されていると想定します。
     もしALIGNがfalseなら、チャンクデータが奇数個になっていると想定しま
     す。 デフォルト値はtrueです。

     もし省略可能な引数BIGENDIANがfalseなら、チャンクサイズは
     little-endianであると想定します。
     この引数の設定はWAVEオーディオファイルで必要です。デフォルト値はtrueで
     す。

     もし省略可能な引数INCLHEADERがtrueなら、チャンクのヘッダから得られ
     るサイズはヘッダのサイズを含んでいると想定します。
     デフォルト値はfalseです。

`Chunk'オブジェクトには以下のメソッドが定義されています：

`getname()'
     チャンクの名前（ID）を返します。
     これはチャンクの始めの4バイトです。

`getsize()'
     チャンクのサイズを返します。

`close()'
     オブジェクトを閉じて、チャンクの終わりまで飛びます。
     これは元のファイル自体は閉じません。

残りの以下のメソッドは、`close()'メソッドを呼び出した後に呼び出す
と例外`IOError'を発生します。

`isatty()'
     `False'を返します。

`seek(pos[, whence])'
     チャンクの現在位置を設定します。
     引数WHENCEは省略可能で、デフォルト値は`0'（ファイルの絶対位
     置）です；他に`1'（現在位置から相対的にシークします）と`2'
     （ファイルの末尾から相対的にシークします）の値を取ります。
     何も値は返しません。
     もし元のファイルがシークに対応していなければ、前方へのシークのみが可能で
     す。

`tell()'
     チャンク内の現在位置を返します。

`read([size])'
     チャンクから最大でSIZEバイト（SIZEバイトを読み込むまで、少な
     くともチャンクの最後に行き着くまで）読み込みます。
     もし引数SIZEが負か省略されたら、チャンクの最後まで全てのデータを読
     み込みます。 バイト値は文字列のオブジェクトとして返されます。
     チャンクの最後に行き着いたら、空文字列を返します。

`skip()'
     チャンクの最後まで飛びます。
     さらにチャンクの`read()'を呼び出すと、`'''が返されます。
     もしチャンクの内容に興味がないなら、このメソッドを呼び出してファイルポイ
     ンタを次のチャンクの始めに設定します。

---------- Footnotes ----------

(1) "EA IFF 85" Standard for Interchange Format Files, Jerry Morrison,
Electronic Arts, January 1985.


File: python-lib-jp.info,  Node: colorsys,  Next: rgbimg,  Prev: chunk,  Up: マルチメディアサービス

19.7 色体系間の変換
===================

RGB 他の色体系間の変換。

`colorsys' モジュールは、計算機のディスプレイモニタで 使われている RGB
(Red Green Blue) 色空間で表された色と、他の 3 種類の色座標系: YIQ, HLS
(Hue Lightness Saturation: 色相、彩度、 飽和) および HSV (Hue
Saturation Value: 色相、彩度、明度) との
間の双方向の色値変換を定義します。
これらの色空間における色座標系は全て浮動小数点数で表されます。 YIQ
空間では、Y 軸は 0 から 1 ですが、 I および Q 軸は正の値も
負の値もとり得ます。他の色空間では、各軸は全て 0 から 1 の値を
とります。

色空間に関するより詳細な情報は `http://www.poynton.com/ColorFAQ.html'
にあります。

`colorsys' モジュールでは、以下の関数が定義されています:

`rgb_to_yiq(r, g, b)'
     RGB から YIQ に変換します。

`yiq_to_rgb(y, i, q)'
     YIQ から RGB に変換します。

`rgb_to_hls(r, g, b)'
     RGB から HLS に変換します。

`hls_to_rgb(h, l, s)'
     HLS から RGB に変換します。

`rgb_to_hsv(r, g, b)'
     RGB から HSV に変換します。

`hsv_to_rgb(h, s, v)'
     HSV から RGB に変換します。

サンプルコード:

     >>> import colorsys
     >>> colorsys.rgb_to_hsv(.3, .4, .2)
     (0.25, 0.5, 0.4)
     >>> colorsys.hsv_to_rgb(0.25, 0.5, 0.4)
     (0.3, 0.4, 0.2)


File: python-lib-jp.info,  Node: rgbimg,  Next: imghdr,  Prev: colorsys,  Up: マルチメディアサービス

19.8 "SGI RGB"ファイルを読み書きする
====================================

"SGI RGB" 形式の 画像ファイルを読み書きします
(とはいえ、このモジュールは SGI 特有のもので は_ありません_ !)。

_This is deprecated in Python 2.5.
このモジュールはメンテナンスされておらず、使われても いないようです。_

`rgbimg'モジュールを使うと、Pythonプログラムから SGI imglib
画像ファイル (`.rgb' としても知られています) に
アクセスできます。このモジュールは完全とはいえませんが、ちょっとした
用途には十分な機能を持っているため提供されています。
現在のところカラーマップファイルはサポートされていません。

_Note:_ このモジュールはデフォルトでは32ビットプラットフォーム上でしか
構築されません。他のシステムでは適切に動作しそうにないからです。

このモジュールでは以下の変数と関数を定義しています:

`error'
     ファイル形式がサポートされていない場合など、全てのエラーに対して送出
     される例外です。

`sizeofimage(file)'
     タプル`(X, Y)'を返します。XとY は画像の
     大きさをピクセル単位で表した値です。現状では、
     4バイトRGBAピクセル、 3バイトRGBピクセル、および
     1バイトグレイスケールピクセル だけをサポート しています。

`longimagedata(file)'
     指定したファイル上の画像を読み込んでデコードし、Python文字列にして
     返します。文字列は4バイトRGBピクセル形式です。左下のピクセルが文字列の
     先頭になります。この形式は、例えば`gl.lrectwrite()' に渡す
     といった用途に適しています。

`longstoimage(data, x, y, z, file)'
     DATA の RGBAデータを画像ファイルFILE に書き込みます。
     XとYは画像の大きさを表します。画像を 1 バイトの Z
     はグレイスケールで保存する場合には 1 、3バイトのRGBデータの場合 は
     3 です、4バイトのRGBA データの場合には 4 になります。入力データは
     常にピクセル当たり 4 バイトにせねばなりません。 `gl.lrectread()'
     の返す形式と同じです。

`ttob(flag)'
     画像のスキャンラインを下端から上端に向かって読み書きする (FLAG は
     ゼロ、SGI GL 互換の方法) か、上端から下端に向かって読み書きする
     (FLAG は 1、 X 互換の方法) かを決めるグローバルなフラグです。
     デフォルト値はゼロです。


File: python-lib-jp.info,  Node: imghdr,  Next: sndhdr,  Prev: rgbimg,  Up: マルチメディアサービス

19.9 画像の形式を決定する
=========================

ファイルやバイトストリームに含まれる画像の形式を決定する。

`imghdr'モジュールはファイルやバイトストリームに含まれる画像の形式を決定します。

`imghdr'モジュールは次の関数を定義しています:

`what(filename[, h])'
     FILENAMEという名前のファイル内の画像データをテストし、画像形式を表す文字列を返します。オプションのHが与えられた場合は、FILENAMEは無視され、テストするバイトストリームを含んでいるとHは仮定されます。

以下に`what()'からの戻り値とともにリストするように、次の画像形式が認識されます:

Value                                Image format
------                               -----
'rgb'                                SGI ImgLib Files
'gif'                                GIF 87a and 89a Files
'pbm'                                Portable Bitmap Files
'pgm'                                Portable Graymap Files
'ppm'                                Portable Pixmap Files
'tiff'                               TIFF Files
'rast'                               Sun Raster Files
'xbm'                                X Bitmap Files
'jpeg'                               JPEG data in JFIF or Exif formats
'bmp'                                BMP files
'png'                                Portable Network Graphics

_Added in Python version 2.5_

この変数に追加することで、あなたは`imghdr'が認識できるファイル形式のリストを拡張できます:

`tests'
     個別のテストを行う関数のリスト。それぞれの関数は二つの引数をとります:
     バイトストリームとオープンされたファイルのようにふるまうオブジェクト。`what()'がバイトストリームとともに呼び出されたときは、ファイルのようにふるまうオブジェクトは`None'でしょう。

     テストが成功した場合は、テスト関数は画像形式を表す文字列を返すべきです。あるいは、失敗した場合は`None'を返すべきです。

例:

     >>> import imghdr
     >>> imghdr.what('/tmp/bass.gif')
     'gif'


File: python-lib-jp.info,  Node: sndhdr,  Next: ossaudiodev,  Prev: imghdr,  Up: マルチメディアサービス

19.10 サウンドファイルの識別
============================

サウンドファイルの識別

`sndhdr'モジュールには、ファイルに保存されたサウンドデータの形式
を識別するのに便利な関数が定義されています。
どんな形式のサウンドデータがファイルに保存されているのか識別可能な場合、
これらの関数は`(TYPE、SAMPLING_RATE、
CHANNELS、FRAMES、BITS_PER_SAMPLE)'のタプルを返しま す。
TYPEはデータの形式を示す文字列で、`'aifc''、`'aiff''、
`'au''、`'hcom''、`'sndr''、`'sndt''、`'voc''、
`'wav''、`'8svx''、`'sb''、`'ub''、`'ul''のうち の一つです。
SAMPLING_RATEは実際のサンプリングレート値で、未知の場合や読
み取ることが出来なかった場合は`0'です。
同様に、CHANNELSはチャンネル数で、識別できない場合や読
み取ることが出来なかった場合は`0'です。FRAMESはフレーム数で、識別できない場合は
`-1'です。
タプルの最後の要素BITS_PER_SAMPLEはサンプルサイズを示すビット数
ですが、A-LAW なら`'A''、u-LAW なら `'U''です。

`what(filename)'
     `whathdr()'を使って、ファイルFILENAMEに保存されたサウン
     ドデータの形式を識別します。
     識別可能なら上記のタプルを返し、識別できない場合は`None'を返します
     。

`whathdr(filename)'
     ファイルのヘッダ情報をもとに、保存されたサウンドデータの形式を識別し
     ます。 ファイル名はFILENAMEで渡されます。
     識別可能なら上記のタプルを返し、識別できない場合は`None'を
     返します。


File: python-lib-jp.info,  Node: ossaudiodev,  Prev: sndhdr,  Up: マルチメディアサービス

19.11 OSS互換オーディオデバイスへのアクセス
===========================================

OSS互換オーディオデバイスへのアクセス。

_Added in Python version 2.3_

このモジュールを使うとOSS (Open Sound System) オーディオインターフェース
にアクセスできます。
OSSはオープンソースあるいは商用のUnixで広く利用でき、Linux (カーネル
2.4まで) とFreeBSDで標準のオーディオインターフェースです。

See also:
     `Open Sound System Programmer's Guide' {OSS C API
     の公式ドキュメント}
     このモジュールではOSSデバイスドライバーが提供している多くの
     定数を定義しています; 定数のリストについては Linux や FreeBSDの
     `<sys/soundcard.h>'を参照してください。

`ossaudiodev' では以下の変数と関数を定義しています:

`error'
     何らかのエラーのときに送出される例外です。
     引数は何が誤っているかを示す文字列です。

     (`ossaudiodev' が`open()'、`write()'、 `ioctl()'
     などのシステムコールからエラーを受け取った 場合には `IOError'
     を送出します。 `ossaudiodev' が直接エラーを検出した場合には
     `OSSAudioError'になります。)

     (以前のバージョンとの互換性のため、この例外クラスは
     `ossaudiodev.error' としても利用できます。)

`open([device, ]mode)'
     オーディオデバイスを開き、OSSオーディオデバイスオブジェクトを返します。
     このオブジェクトは`read()'、`write()'、`fileno()'
     といったファイル類似オブジェクトのメソッドを数多くサポートしています。
     (とはいえ、伝統的な UNIX の read/write における意味づけと OSS
     デバイス の read/write との間には微妙な違いがあります)。
     また、オーディオ特有の多くのメソッドがあります;メソッドの完全なリストに
     ついては下記を参照してください。

     DEVICEは使用するオーディオデバイスファイルネームです。
     もしこれが指定されないなら、このモジュールは使うデバイスとして最初に環境
     変数`AUDIODEV'を参照します。
     見つからなければ`/dev/dsp'を参照します。

     MODE は読み出し専用アクセスの場合には `'r''、 書き込み専用
     (プレイバック) アクセスの場合には `'w''、
     読み書きアクセスの場合には `'rw'' にします．
     多くのサウンドカードは一つのプロセスが一度にレコーダとプレーヤの
     どちらかしか開けないようにしているため，必要な操作に応じた
     デバイスだけを開くようにするのがよいでしょう。また，サウンドカード
     には半二重 (half-duplex) 方式のものがあります: こうしたカードでは，
     デバイスを読み出しまたは書き込み用に開くことはできますが，両方
     同時には開けません．

     呼び出しの文法が普通と異なることに注意してください:
     _最初の_引数は省略可能で、2番目が必須です。
     これは`ossaudiodev'にとってかわられた古い
     `linuxaudiodev'との互換性のためという歴史的な産物です。


`openmixer([device])'
     ミキサデバイスを開き、OSSミキサデバイスオブジェクトを返します。
     DEVICEは使用するミキサデバイスのファイル名です。
     DEVICEを指定しない場合、モジュールはまず環境変数
     `AUDIODEV'を参照して使用するデバイスを探します。
     見つからなければ、`/dev/mixer'を参照します。

* Menu:

* オーディオデバイスオブジェクト::
* ミキサデバイスオブジェクト::


File: python-lib-jp.info,  Node: オーディオデバイスオブジェクト,  Next: ミキサデバイスオブジェクト,  Prev: ossaudiodev,  Up: ossaudiodev

19.11.1 オーディオデバイスオブジェクト
--------------------------------------

オーディオデバイスに読み書きできるようになるには、まず 3
つのメソッドを正しい順序で呼び出さねばなりません:
  1. `setfmt()' で出力形式を設定し、

  2. `channels()' でチャンネル数を設定し、

  3. `speed()' でサンプリングレートを設定します。
     この代わりに`setparameters()' メソッドを呼び出せば、
三つのオーディオパラメタを一度で設定できます。 `setparameters()'
は便利ですが、多くの状況で 柔軟性に欠けるでしょう。

`open()' の返すオーディオデバイスオブジェクトには以下のメ
ソッドおよび(読み出し専用の)属性があります:

`close()'
     オーディオデバイスを明示的に閉じます。
     オーディオデバイスは、読み出しや書き込みが終了したら必ず
     閉じねばなりません。閉じたオブジェクトを再度開くことは できません。

`fileno()'
     デバイスに関連付けられているファイル記述子を返します。

`read(size)'
     オーディオ入力から SIZE バイトを読みだし、 Python 文字列型に
     して返します。多くの UNIX デバイスドライバと違い、
     ブロックデバイスモード (デフォルト) の OSS オーディオデバイスでは、
     要求した量のデータ全体を取り込むまで`read()' がブロックします。

`write(data)'
     Python 文字列 DATA の内容をオーディオデバイスに書き込み、
     書き込まれたバイト数を返します。オーディオデバイスがブロックモード
     (デフォルト) の場合、常に文字列データ全体を書き込みます (前述の
     ように、これは通常のUNIX デバイスの振舞いとは異なります)。
     デバイスが非ブロックモードの場合、データの一部が書き込まれない
     ことがあります -- `writeall()' を参照してください。

`writeall(data)'
     Python文字列のDATA全体をオーディオデバイスに書き込みます。
     オーディオデバイスがデータを受け取れるようになるまで待機し、
     書き込めるだけのデータを書き込むという操作を、DATA を
     全て書き込み終わるまで繰り返します。 デバイスがブロックモード
     (デフォルト) の場合には、このメソッドは `write()'
     と同じです。`writeall()' が有用なのは
     非ブロックモードだけです。実際に書き込まれたデータの量と渡した
     データの量は必ず同じになるので、戻り値はありません。

以下のメソッドの各々は `ioctl()' システムコール
一つ一つに対応しています。対応関係ははっきりしています:
例えば、`setfmt()' は `SNDCTL_DSP_SETFMT' ioctl
に対応していますし、`sync()' は`SNDCTL_DSP_SYNC' に対応しています
(このシンボル名は OSS のドキュメントを参照する
時に助けになるでしょう)。根底にある `ioctl()' が
失敗した場合、これらの関数は全て `IOError' を 送出します。

`nonblock()'
     デバイスを非ブロックモードにします。
     いったん非ブロックモードにしたら、ブロックモードは戻せません。

`getfmts()'
     サウンドカードがサポートしているオーディオ出力形式をビットマスクで
     返します。 以下はOSSでサポートされているフォーマットの一部です。

     フォーマット                       説明
     ------                             -----
     AFMT_MU_LAW                        対数符号化 (Sun の `.au' 形式や
                                        `/dev/audio' で使われている形式)
     AFMT_A_LAW                         対数符号化
     AFMT_IMA_ADPCM                     Interactive Multimedia
                                        Association で 定義されている 4:1
                                        圧縮形式
     AFMT_U8                            符号なし 8 ビットオーディオ
     AFMT_S16_LE                        符号つき 16
                                        ビットオーディオ、リトルエンディアン
                                        バイトオーダ
                                        (Intelプロセッサで使われている形式)
     AFMT_S16_BE                        符号つき 16
                                        ビットオーディオ、ビッグエンディアン
                                        バイトオーダ
                                        (68k、PowerPC、Sparcで使われている形式)
     AFMT_S8                            符号つき 8 ビットオーディオ
     AFMT_U16_LE                        符号なし 16
                                        ビットリトルエンディアンオーディオ
     AFMT_U16_BE                        符号なし 16
                                        ビットビッグエンディアンオーディオ

     オーディオ形式の完全なリストは OSS の文書をひもといてください。
     ただ、ほとんどのシステムは、こうした形式のサブセットしかサポートしていません。
     古めのデバイスの中には `AFMT_U8'
     だけしかサポートしていないものがあります。
     現在使われている最も一般的な形式は`AFMT_S16_LE'です。

`setfmt(format)'
     現在のオーディオ形式をFORMATに設定しようと試みます --
     FORMATについては`getfmts()'のリストを参照してください。
     実際にデバイスに設定されたオーディオ形式を返します。要求通りの
     形式でないこともあります。`AFMT_QUERY' を渡すと
     現在デバイスに設定されているオーディオ形式を返します。

`channels(num_channels)'
     出力チャネル数をNUM_CHANNELSに設定します。 1 はモノラル、2
     はステレオです。
     いくつかのデバイスでは2つより多いチャンネルを持つものもありますし、
     ハイエンドなデバイスではモノラルをサポートしないものもあります。
     デバイスに設定されたチャンネル数を返します。

`speed(samplerate)'
     サンプリングレートを1秒あたりSAMPLERATE に設定しようと試み、
     実際に設定されたレートを返します。
     たいていのサウンドデバイスでは任意のサンプリングレートをサポートしていま
     せん。 一般的なレートは以下の通りです:

     レート                             説明
     ------                             -----
     8000                               `/dev/audio' のデフォルト
     11025                              会話音声の録音に使われるレート
     22050                              
     44100                              (サンプルあたり 16 ビットで 2
                                        チャネルの場合) CD
                                        品質のオーディオ
     96000                              (サンプル当たり 24 ビットの場合)
                                        DVD 品質のオーディオ


`sync()'
     サウンドデバイスがバッファ内の全てのデータを再生し終えるまで待機します。
     (デバイスを閉じると暗黙のうちに `sync()' が起こります) OSS の
     ドキュメント上では、`sync()' を使うよりデバイスを一度閉じて
     開き直すよう勧めています。

`reset()'
     再生あるいは録音を即座に中止して、デバイスをコマンドを受け取れる状態に
     戻します。OSSのドキュメントでは、`reset()' を呼び出した後に
     一度デバイスを閉じ、開き直すよう勧めています。

`post()'
     ドライバに出力の一時停止 (pause) が起きそうであることを伝え、
     ドライバが一時停止をより賢く扱えるようにします。
     短いサウンドエフェクトを再生した直後やユーザ入力待ちの前、また
     ディスク I/O 前などに使うことになるでしょう。

以下のメソッドは、複数の `ioctl' を組み合わせたり、 `ioctl'
と単純な計算を組み合わせたりした便宜用メソッドです。

`setparameters(format, nchannels, samplerate, [, strict=False])'
     主要なオーディオパラメタ、サンプル形式、チャネル数、サンプルレートを
     一つのメソッド呼び出しで設定します。 FORMAT、NCHANNELS および
     SAMPLERATE には、 それぞれ`setfmt()'、`channels()' および `speed()'
     と同じやり方で値を設定します。STRICT の値が真の場合、
     `setparameters()' は値が実際に要求通りにデバイスに設定されたか
     どうか調べ、違っていれば `OSSAudioError' を送出します。
     実際にデバイスドライバが設定したパラメタ値を表す (FORMAT,
     NCHANNELS, SAMPLERATE) からなるタプルを 返します
     (`setfmt()'、`channels()' および `speed()' の返す値と同じです)。

     以下に例を示します:
            (fmt, channels, rate) = dsp.setparameters(fmt, channels, rate)

     is equivalent to
            fmt = dsp.setfmt(fmt)
            channels = dsp.channels(channels)
            rate = dsp.rate(channels)


`bufsize()'
     ハードウェアのバッファサイズをサンプル数で返します。

`obufcount()'
     ハードウェアバッファ上に残っていてまだ再生されていないサンプル数を返します。

`obuffree()'
     ブロックを起こさずにハードウェアの再生キューに書き込めるサンプル数を返します。

オーディオデバイスオブジェクトは読み出し専用の属性もサポートしています:

`closed'
     {} デバイスが閉じられたかどうかを示す真偽値です。

`name'
     {} デバイスファイルの名前を含む文字列です。

`mode'
     {} ファイルの I/O モードで、`"r"', `"rw"', `"w"' のどれかです。


File: python-lib-jp.info,  Node: ミキサデバイスオブジェクト,  Prev: オーディオデバイスオブジェクト,  Up: ossaudiodev

19.11.2 ミキサデバイスオブジェクト
----------------------------------

ミキサオブジェクトには、2つのファイル類似メソッドがあります:

`close()'
     すでに開かれているミキサデバイスファイルを閉じます。
     ファイルを閉じた後でミキサを使おうとすると、`IOError'を
     送出します。

`fileno()'
     開かれているミキサデバイスファイルのファイルハンドルナンバを返します。

以下はオーディオミキシング固有のメソッドです。

`controls()'
     このメソッドは、利用可能なミキサコントロール (`SOUND_MIXER_PCM'
     や`SOUND_MIXER_SYNTH' のように、ミキシングを行えるチャネル)
     を指定するビットマスクを返します。このビットマスクは利用可能な全ての
     ミキサコントロールのサブセットです -- 定数`SOUND_MIXER_*'
     はモジュールレベルで定義されています。
     例えば、もし現在のミキサオブジェクトがPCM
     ミキサをサポートしているか
     調べるには、以下のPythonコードを実行します:

          if mixer.controls() & (1 << ossaudiodev.SOUND_MIXER_PCM):
              # PCM is supported
              ... code ...

     ほとんどの用途には、`SOUND_MIXER_VOLUME' (マスタボリューム)
     と`SOUND_MIXER_PCM'コントロールがあれば十分でしょう --
     とはいえ、ミキサを使うコードを書くときには、コントロールを選ぶ時に
     柔軟性を持たせるべきです。例えば Gravis Ultrasound
     には`SOUND_MIXER_VOLUME' がありません。

`stereocontrols()'
     ステレオミキサコントロールを示すビットマスクを返します。
     ビットが立っているコントロールはステレオであることを示し、立っていない
     コントロールはモノラルか、ミキサがサポートしていないコントロールで
     ある (どちらの理由かは`controls()' と組み合わせて使うことで
     判別できます) ことを示します。

     ビットマスクから情報を得る例は関数`controls()'のコード例を
     参照してください。

`reccontrols()'
     録音に使用できるミキサコントロールを特定するビットマスクを返します。
     ビットマスクから情報を得る例は関数`controls()'のコード例を
     参照してください。

`get(control)'
     指定したミキサコントロールのボリュームを返します。 2
     要素のタプル`(left_volume,right_volume)' を返します。
     ボリュームの値は 0 (無音) から100 (最大) で示されます。
     コントロールがモノラルでも2要素のタプルが返されますが、2つの要素の値は
     同じになります。

     不正なコントロールを指定した場合は`OSSAudioError'を送出しま
     す。また、サポートされていないコントロールを指定した場合には
     `IOError' を送出します。

`set(control, (left, right))'
     指定したミキサコントロールのボリュームを`(left,right)'に設定しま
     す。`left'と`right'は整数で、0 (無音) から100 (最大) の間で
     指定せねばなりません。呼び出しに成功すると新しいボリューム値を 2
     要素の タプルで返します。
     サウンドカードによっては、ミキサの分解能上の制限から、指定したボリューム
     と厳密に同じにはならない場合があります。

     不正なコントロールを指定した場合や、指定したボリューム値が範囲外であった
     場合、`IOError' を送出します。

`get_recsrc()'
     現在録音のソースに使われているコントロールを示すビットマスクを返します。

`set_recsrc(bitmask)'
     録音のソースを指定にはこの関数を使ってください。呼び出しに成功すると、
     新たな録音の (場合によっては複数の)
     ソースを示すビットマスクを返します;
     不正なソースを指定すると`IOError'を送出します。
     現在の録音のソースとしてマイク入力を設定するには、以下のようにします:

          mixer.setrecsrc (1 << ossaudiodev.SOUND_MIXER_MIC)



File: python-lib-jp.info,  Node: Tkを用いたグラフィカルユーザインターフェイス,  Next: 国際化,  Prev: マルチメディアサービス,  Up: Top

20 Tkを用いたグラフィカルユーザインターフェイス
***********************************************

Tk/Tcl は長きにわたり Python の不可欠な一部でありつづけています。
Tk/Tcl は頑健でプラットホームに依存しないウィンドウ構築
ツールキットであり、 Python プログラマは`Tkinter'モジュールや
その拡張の`Tix'モジュールを使って利用できます。

`Tkinter' モジュールは、 Tcl/Tk 上に作られた軽量な
オブジェクト指向のレイヤです。 `Tkinter' を使うために Tcl
コードを書く必要はありませんが、 Tk のドキュメントや、場合によって は
Tcl のドキュメントを調べる必要があるでしょう。 `Tkinter' は Tk
のウィジェットを Python のクラスとして
実装しているラッパをまとめたものです。加えて、内部モジュール `_tkinter'
では、 Python と Tcl がやり取りできるような
スレッド安全なメカニズムを提供しています。

Tk は Python にとって唯一の GUI というわけではありません。 Python
用の他の GUI ツールキットに 関する詳しい情報は、*Note
ロケールの背景、詳細、ヒント、助言および補足説明::章、「他のユーザ
インタフェースモジュールとパッケージ」を参照してください。

* Menu:

* Tkinter::
* Tix::
* ScrolledText::
* turtle::
* Idle::
* 他のグラフィカルユーザインタフェースパッケージ::


File: python-lib-jp.info,  Node: Tkinter,  Next: Tix,  Prev: Tkを用いたグラフィカルユーザインターフェイス,  Up: Tkを用いたグラフィカルユーザインターフェイス

20.1 Tcl/Tk への Python インタフェース
======================================

グラフィカルユーザインタフェースを実現する Tcl/Tk への インタフェース

`Tkinter' モジュール ("Tk インタフェース") は、 Tk GUI
ツールキットに対する標準の Python インタフェースです。 Tk と `Tkinter'
はほとんどの UNIX プラットフォーム の他、 Windows や Macintosh
システム上でも利用できます。 (Tk 自体は Python の一部ではありません。
Tk は ActiveState で保守されて います。)

See also:
     `Python Tkinter Resources' {Python Tkinter Topic Guide では、Tk を
     Python から利用する上 での情報と、その他の Tk
     にまつわる情報源を数多く提供していま す。}

     `An Introduction to Tkinter' {Fredrik Lundh
     のオンラインリファレンス資料です。}

     `Tkinter reference: a GUI for Python'
     {オンラインリファレンス資料です。}

     `Tkinter for JPython' {Jython から Tkinter
     へのインタフェースです。}

     `Python and Tkinter Programming' {John Graysonによる解説書 (ISBN
     1-884777-81-3) です。}

* Menu:

* Tkinter モジュール::
* Tkinter お助け手帳 life preserver::
* Tcl/Tk を 本当に少しだけ 見渡してみる::
* 基本的な Tk プログラムと Tkinter との対応関係::
* Tk と Tkinter はどのように関わっているのか::
* 簡単なリファレンス::


File: python-lib-jp.info,  Node: Tkinter モジュール,  Next: Tkinter お助け手帳 life preserver,  Prev: Tkinter,  Up: Tkinter

20.1.1 Tkinter モジュール
-------------------------

ほとんどの場合、本当に必要となるのは `Tkinter' モジュールだけ
ですが、他にもいくつかの追加モジュールを利用できます。 Tk
インタフェース自体は `_tkinter' と言う名前の
バイナリモジュール内にあります。 このモジュールに入っているのは Tk
への低水準のインタフェースであり、
プリケーションプログラマが直接使ってはなりません。 `_tkinter'
は通常共有ライブラリ (や DLL) になっていますが、 Python
インタプリタに静的にリンクされていることもあります。

Tk インタフェースモジュールの他にも、`Tkinter' には Python
モジュールが数多く入っています。最も重要なモジュールは、 `Tkinter'
自体と `Tkconstants' と呼ばれるモジュール
の二つです。前者は自動的に後者を import するので、以下のように
一方のモジュールを import するだけで Tkinter を使えるようになります:

     import Tkinter

あるいは、よく使うやり方で:

     from Tkinter import *

のようにします。

`Tk(screenName=None, baseName=None, className='Tk', useTk=1)'
     `Tk' クラスは引数なしでインスタンス化します。 これは Tk
     のトップレベルウィジェットを生成します。
     通常、トップレベルウィジェットはアプリケーションのメインウィンドウに
     なります。それぞれのインスタンスごとに固有の Tcl インタプリタが関連
     づけられます。 _Changed in Python version 2.4_

`Tcl(screenName=None, baseName=None, className='Tk', useTk=0)'
     `Tcl' はファクトリ関数で、`Tk' クラスで生成するオブジェクト
     とよく似たオブジェクトを生成します。ただし Tk サブシステムを初期化
     しません。この関数は、余分なトップレベルウィンドウを作る必要がなかったり、
     (X サーバを持たない UNIX/Linux システムなどのように)
     作成できない環境に おいて Tcl
     インタプリタを駆動したい場合に便利です。 `Tcl'
     で生成したオブジェクトに対して`loadtk' メソッドを
     呼び出せば、トップレベルウィンドウを作成 (して、Tk サブシステムを
     初期化) します。 _Added in Python version 2.4_

Tk をサポートしているモジュールには、他にも以下のようなモジュールが
あります:

``ScrolledText''
     垂直スクロールバー付きのテキストウィジェットです。

``tkColorChooser''
     ユーザに色を選択させるためのダイアログです。

``tkCommonDialog''
     このリストの他のモジュールが定義しているダイアログの基底クラスです。

``tkFileDialog''
     ユーザが開きたいファイルや保存したいファイルを指定できるようにする
     共通のダイアログです。

``tkFont''
     フォントの扱いを補助するためのユーティリティです。

``tkMessageBox''
     標準的な Tk のダイアログボックスにアクセスします。

``tkSimpleDialog''
     基本的なダイアログと便宜関数 (convenience function) です。

``Tkdnd''
     `Tkinter' 用のドラッグアンドドロップのサポートです。
     実験的なサポートで、Tk DND に置き替わった時点で撤廃されるはずです。

``turtle''
     Tk ウィンドウ上でタートルグラフィックスを実現します。



File: python-lib-jp.info,  Node: Tkinter お助け手帳 life preserver,  Next: Tcl/Tk を 本当に少しだけ 見渡してみる,  Prev: Tkinter モジュール,  Up: Tkinter

20.1.2 Tkinter お助け手帳 (life preserver)
------------------------------------------

この節は、 Tk や Tkinter を全て網羅したチュートリアルを目指している
わけではありません。むしろ、Tkinter のシステムを学ぶ上での指針を
示すための、その場しのぎ的なマニュアルです。

謝辞:
   * Tkinter は Steen Lumholt と Guido van Rossum が作成しました。

   * Tk は John Ousterhout が Berkeley の在籍中に作成しました。

   * この Life Preserver は Virginia 大学の Matt Conway 他が書きました。

   * html へのレンダリングやたくさんの編集は、Ken Manheimer が
     FrameMaker 版から行いました。

   * Fredrik Lundh はクラスインタフェース詳細な説明を書いたり
     内容を改訂したりして、現行の Tk 4.2 に合うようにしました。

   * Mike Clarkson はドキュメントをLaTeX 形式に変換し、
     リファレンスマニュアルのユーザインタフェースの章をコンパイルしました。

* Menu:

* この節の使い方::
* 簡単なHello Worldプログラム::


File: python-lib-jp.info,  Node: この節の使い方,  Next: 簡単なHello Worldプログラム,  Prev: Tkinter お助け手帳 life preserver,  Up: Tkinter お助け手帳 life preserver

20.1.2.1 この節の使い方
.......................

この節は二つの部分で構成されています: 前半では、背景となることがらを
(大雑把に) 網羅しています。後半は、キーボードの横に置けるような手軽な
リファレンスになっています。

「ホゲホゲ (blah) するにはどうしたらよいですか」
という形の問いに答えよう と思うなら、まず Tk
で「ホゲホゲ」する方法を調べてから、この
ドキュメントに戻ってきてその方法に対応する`Tkinter' の
関数呼び出しに変換するのが多くの場合最善の方法になります。 Python
プログラマが Tk ドキュメンテーションを見れば、たいてい 正しい Python
コマンドの見当をつけられます。従って、 Tkinter を使うには Tk
についてほんの少しだけ知っていればよいと いうことになります。
このドキュメントではその役割を果たせないので、次善の策として、
すでにある最良のドキュメントについていくつかヒントを示しておく
ことにしましょう:

   * Tk の man マニュアルのコピーを手に入れるよう強く勧めます。
     とりわけ最も役立つのは`mann' ディレクトリ内にあるマニュアルです。
     `man3' のマニュアルページは Tk ライブラリに対する C インタフェー
     スについての説明なので、スクリプト書きにとって取り立てて役に立つ内容
     ではありません。

   * Addison-Wesley は John Ousterhout の書いた  (ISBN 0-201-63337-X)
     という名前の本 を出版しています。この本は初心者向けの Tcl と Tk
     の良い入門書です。 内容は網羅的ではなく、詳細の多くは man
     マニュアル任せにしています。

   * たいていの場合、`Tkinter.py' は参照先としては最後の地 (last
     resort) ですが、それ以外の手段で調べても分からない場合には
     救いの地 (good place) になるかもしれません。

See also:
     `ActiveState Tclホームページ' {Tk/Tcl の開発は ActiveState
     で大々的に行われています。} `Tcl and the Tk Toolkit' {Tcl
     を考案した John Ousterhout による本です。} `Practical Programming
     in Tcl and Tk' {Brent Welch の百科事典のような本です。}


File: python-lib-jp.info,  Node: 簡単なHello Worldプログラム,  Prev: この節の使い方,  Up: Tkinter お助け手帳 life preserver

20.1.2.2 簡単なHello Worldプログラム
....................................

     from Tkinter import *

     class Application(Frame):
         def say_hi(self):
             print "hi there, everyone!"

         def createWidgets(self):
             self.QUIT = Button(self)
             self.QUIT["text"] = "QUIT"
             self.QUIT["fg"]   = "red"
             self.QUIT["command"] =  self.quit

             self.QUIT.pack({"side": "left"})

             self.hi_there = Button(self)
             self.hi_there["text"] = "Hello",
             self.hi_there["command"] = self.say_hi

             self.hi_there.pack({"side": "left"})

         def __init__(self, master=None):
             Frame.__init__(self, master)
             self.pack()
             self.createWidgets()

     root = Tk()
     app = Application(master=root)
     app.mainloop()
     root.destroy()


File: python-lib-jp.info,  Node: Tcl/Tk を 本当に少しだけ 見渡してみる,  Next: 基本的な Tk プログラムと Tkinter との対応関係,  Prev: Tkinter お助け手帳 life preserver,  Up: Tkinter

20.1.3 Tcl/Tk を (本当に少しだけ) 見渡してみる
----------------------------------------------

クラス階層は複雑に見えますが、実際にプログラムを書く際には、
アプリケーションプログラマはほとんど常にクラス階層の最底辺に
あるクラスしか参照しません。

注意:
   * クラスのいくつかは、特定の関数を一つの名前空間下にまとめるために
     提供されています。こうしたクラスは個別にインスタンス化するためのもの
     ではありません。

   * `Tk' クラスはアプリケーション内で一度だけインスタンス化
     するようになっています。アプリケーションプログラマが明示的に
     インスタンス化する必要はなく、他のクラスがインスタンス化されると
     常にシステムが作成します。

   * `Widget' クラスもまた、インスタンス化して使うようには
     なっていません。このクラスはサブクラス化して「実際の」ウィジェットを
     作成するためのものです。(C++ で言うところの、`抽象クラス (abstract
     class)' です)。


このリファレンス資料を活用するには、Tk の短いプログラムを読んだり、 Tk
コマンドの様々な側面を知っておく必要がままあるでしょう。
(下の説明の`Tkinter' 版は、 *Note 簡単なリファレンス::
節を参照してください。)

Tk スクリプトは Tcl プログラムです。全ての Tcl プログラムに同じく、 Tk
スクリプトはトークンをスペースで区切って並べます。 Tk
ウィジェットとは、ウィジェットの_クラス_、
ウィジェットの設定を行う_オプション_、そしてウィジェットに
役立つことをさせる_アクション_ をあわせたものに過ぎません。

Tk でウィジェットを作るには、常に次のような形式のコマンドを使います:

                     classCommand newPathname options

`CLASSCOMMAND'
     どの種類のウィジェット (ボタン、ラベル、メニュー、...)
     を作るかを表します。

`NEWPATHNAME'
     作成するウィジェットにつける新たな名前です。Tk 内の全ての名前は一意
     になっていなければなりません。一意性を持たせる助けとして、 Tk 内の
     ウィジェットは、ファイルシステムにおけるファイルと同様、 _パス名
     (pathname)_ を使って名づけられます。
     トップレベルのウィジェット、すなわち _ルート_ は `.' (ピリオド)
     という名前になり、その子ウィジェット階層もピリオドで
     区切ってゆきます。ウィジェットの名前は、例えば
     `.myApp.controlPanel.okButton' のようになります。

`OPTIONS'
     ウィジェットの見た目を設定します。場合によってはウィジェットの挙動も
     設定します。オプションはフラグと値がリストになった形式をとります。
     UNIX のシェルコマンドのフラグと同じように、フラグの前には `-' がつ
     き、複数の単語からなる値はクオートで囲まれます。

以下に例を示します:

         button   .fred   -fg red -text "hi there"
            ^       ^     \_____________________/
            |       |                |
          class    new            options
         command  widget  (-opt val -opt val ...)

ウィジェットを作成すると、ウィジェットへのパス名は新しいコマンドに
なります。この新たなWIDGET COMMAND は、プログラマが新たに作成した
ウィジェットにACTION を実行させる際のハンドル (handle) に
なります。Cでは someAction(fred, someOptions)と表し、
C++ではfred.someAction(someOptions)と表すでしょう。Tkでは:

         .fred someAction someOptions

のようにします。 オブジェクト名 `.fred'
はドットから始まっているので注意してください。

読者の想像の通り、SOMEACTION に指定できる値はウィジェット
のクラスに依存しています: fred がボタンなら `.fred disable' は
うまくいきます (fred はグレーになります) が、fred がラベルならうまく
いきません (Tkではラベルの無効化をサポートしていないからです)。

SOMEOPTIONS に指定できる値はアクションの内容に依存しています。
`disable' のようなアクションは引数を必要としませんが、
テキストエントリボックスの `delete'コマンドのようなアクションには
テキストを削除する範囲を指定するための引数が必要になります。


File: python-lib-jp.info,  Node: 基本的な Tk プログラムと Tkinter との対応関係,  Next: Tk と Tkinter はどのように関わっているのか,  Prev: Tcl/Tk を 本当に少しだけ 見渡してみる,  Up: Tkinter

20.1.4 基本的な Tk プログラムと Tkinter との対応関係
----------------------------------------------------

Tkのクラスコマンドは、Tkinterのクラスコンストラクタに対応しています。

         button .fred                =====>  fred = Button()

オブジェクトの親 (master)
は、オブジェクトの作成時に指定した新たな名前から
非明示的に決定されます。Tkinter では親を明示的に指定します。

         button .panel.fred          =====>  fred = Button(panel)

Tk の設定オプションは、ハイフンをつけたタグと値の組からなるリストで
指定します。Tkinter では、オプションはキーワード引数にして
インスタンスのコンストラクタに指定したり、`config' に
キーワード引数を指定して呼び出したり、インデクス指定を使って
インスタンスに代入したりして設定します。オプションの設定については
*Note turtle:: 節を参照してください。　

         button .fred -fg red        =====>  fred = Button(panel, fg = "red")
         .fred configure -fg red     =====>  fred["fg"] = red
                                     OR ==>  fred.config(fg = "red")

Tk でウィジェットにアクションを実行させるには、ウィジェット名を
コマンドにして、その後にアクション名を続け、必要に応じて引数
(オプション) を続けます。 Tkinter では、クラスインスタンスの
メソッドを呼び出して、ウィジェットのアクションを呼び出します。
あるウィジェットがどんなアクション (メソッド) を実行できるかは、
Tkinter.py モジュール内にリストされています。

         .fred invoke                =====>  fred.invoke()

Tk でウィジェットを packer (ジオメトリマネジャ) に渡すには、 pack
コマンドをオプション引数付きで呼び出します。 Tkinter では Pack
クラスがこの機能すべてを握っていて、 様々な pack
の形式がメソッドとして実装されています。 `Tkinter' のウィジェットは全て
Packer からサブクラス化 されているため、pack
操作にまつわる全てのメソッドを継承しています。 Form
ジオメトリマネジャに関する詳しい情報については `Tix'
モジュールのドキュメントを参照してください。

         pack .fred -side left       =====>  fred.pack(side = "left")


File: python-lib-jp.info,  Node: Tk と Tkinter はどのように関わっているのか,  Next: 簡単なリファレンス,  Prev: 基本的な Tk プログラムと Tkinter との対応関係,  Up: Tkinter

20.1.5 Tk と Tkinter はどのように関わっているのか
-------------------------------------------------

_Note:_
以下の構図は図版をもとに書き下ろしたものです。このドキュメントの
今後のバージョンでは、図版をもっと直接的に利用する予定です。

上から下に、呼び出しの階層構造を説明してゆきます:
`あなたのアプリケーション (Python)'
     まず、 Python アプリケーションが`Tkinter'を呼び出します。

`Tkinter ( Python モジュール)'
     上記の呼び出し (例えば、ボタンウィジェットの作成) は、 _Tkinter_
     モジュール内で実現されており、Python で書かれています。 この
     Python で書かれた関数は、コマンドと引数を解析して変換し、あたかも
     コマンドが Python スクリプトではなく Tk スクリプトから来たように
     みせかけます。

`tkinter (C)'
     上記のコマンドと引数は _tkinter_ (小文字です。注意してください)
     拡張モジュール内の C 関数に渡されます 。　

`Tk Widgets (C and Tcl)'
     上記の C 関数は、Tk ライブラリを構成する C 関数の入った別の C
     モジュールへの呼び出しを行えるようになっています。 Tk は C と Tcl
     を少し使って実装されています。 Tk ウィジェットの Tcl
     部分は、ウィジェットのデフォルト動作をバインド
     するために使われ、Python で書かれた`Tkinter' モジュールが import
     される時点で一度だけ実行されます。(ユーザがこの過程を目にする
     ことはありません。

`Tk (C)'
     Tkウィジェットの Tk
     部分で実装されている最終的な対応付け操作によって...

`Xlib (C)'
     Xlib ライブラリがスクリーン上にグラフィックスを描きます。


File: python-lib-jp.info,  Node: 簡単なリファレンス,  Prev: Tk と Tkinter はどのように関わっているのか,  Up: Tkinter

20.1.6 簡単なリファレンス
-------------------------

* Menu:

* オプションの設定::
* Packer::
* Packer のオプション::
* ウィジェット変数を関連付ける::
* ウィンドウマネジャ::
* Tk オプションデータ型::
* バインドとイベント::
* index パラメータ::
* 画像::


File: python-lib-jp.info,  Node: オプションの設定,  Next: Packer,  Prev: 簡単なリファレンス,  Up: 簡単なリファレンス

20.1.6.1 オプションの設定
.........................

オプションは、色やウィジェットの境界線幅などを制御します。
オプションの設定には三通りの方法があります:

`オブジェクトを作成する時にキーワード引数を使う'
     :
          fred = Button(self, fg = "red", bg = "blue")

`オブジェクトを作成した後、オプション名を辞書インデックスのように扱う'
     :
          fred["fg"] = "red"
          fred["bg"] = "blue"

`オブジェクトを生成した後、config()メソッドを使って複数の属性を更新する'
     :
          fred.config(fg = "red", bg = "blue")


オプションとその振る舞いに関する詳細な説明は、該当するウィジェットの Tk
の man マニュアルを参照してください。

man マニュアルには、各ウィジェットの "STANDARD OPTIONS(標準オプション)"
と "WIDGET SPECIFIC OPTIONS (ウィジェット固有のオプション)"
がリストされていることに注意しましょう。
前者は多くのウィジェットに共通のオプションのリストで、
後者は特定のウィジェットに特有のオプションです。標準オプションの 説明は
man マニュアルの`options(3)' にあります。

このドキュメントでは、標準オプションとウィジェット固有のオプションを
区別していません。オプションによっては、ある種のウィジェットに
適用できません。あるウィジェットがあるオプションに対応しているか
どうかは、ウィジェットのクラスによります。例えばボタンには `command'
オプションがありますが、ラベルにはありません。

あるウィジェットがどんなオプションをサポートしているかは、ウィジェット
の man マニュアルにリストされています。また、実行時にウィジェットの
`config()' メソッドを引数なしで呼び出したり、`keys()'
メソッドを呼び出したりして問い合わせることもできます。
メソッド呼び出しを行うと辞書型の値を返します。この辞書は、オプション
の名前がキー (例えば `'relief'') になっていて、値が 5
要素のタプルになっています。

`bg' のように、いくつかのオプションはより長い名前を持つ共通の
オプションに対する同義語になっています (`bg'は "background" を
短縮したものです)。短縮形のオプション名を `config()' に渡すと、 5
要素ではなく 2 要素のタプルを返します。このタプルには、同義語の 名前と
「本当の」オプション名が入っています (例えば `('bg', 'background')')。

インデックス             意味                     例
------                   -----                    -----
0                        オプション名             `'relief''
1                        データベース検索用のオプション名`'relief''
2                        データベース検索用のオプションクラス`'Relief''
3                        デフォルト値             `'raised''
4                        現在の値                 `'groove''

例:

     >>> print fred.config()
     {'relief' : ('relief', 'relief', 'Relief', 'raised', 'groove')}

もちろん、実際に出力される辞書には利用可能なオプションが全て
表示されます。上の表示例は単なる例にすぎません。


File: python-lib-jp.info,  Node: Packer,  Next: Packer のオプション,  Prev: オプションの設定,  Up: 簡単なリファレンス

20.1.6.2 Packer
...............

packer はTkのジオメトリ管理メカニズムの一つです。

ジオメトリマネジャは、複数のウィジェットの位置を、それぞれの
ウィジェットを含むコンテナ - 共通の_マスタ (master)_ からの
相対で指定するために使います。 やや扱いにくい _placer_
(あまり使われないのでここでは取り上げ ません) と違い、packer
は定性的な関係を表す指定子 - _上 (above)_、 _〜の左 (to the left
of)_、_引き延ばし (filling)_ など -
を受け取り、厳密な配置座標の決定を全て行ってくれます。

どんな_マスタ_ ウィジェットでも、大きさは内部の "スレイブ (slave)
ウィジェット" の大きさで決まります。packer は、スレイブウィジェットを
pack 先のマスタウィジェット中のどこに配置するかを制御するために使われ
ます。
望みのレイアウトを達成するには、ウィジェットをフレームにパックし、
そのフレームをまた別のフレームにパックできます。
さらに、一度パックを行うと、それ以後の設定変更に合わせて動的に
並べ方を調整します。

ジオメトリマネジャがウィジェットのジオメトリを確定するまで、
ウィジェットは表示されないので注意してください。
初心者のころにはよくジオメトリの確定を忘れてしまい、
ウィジェットを生成したのに何も表示されず驚くことになります。
ウィジェットは、(例えばpackerの`pack()'メソッドを適用して)
ジオメトリを確定した後で初めて表示されます。

pack() メソッドは、キーワード引数つきで呼び出せます。キーワード引数
は、ウィジェットをコンテナ内のどこに表示するか、メインの
アプリケーションウィンドウをリサイズしたときにウィジェットがどう
振舞うかを制御します。以下に例を示します:

         fred.pack()                     # デフォルトでは、side = "top"
         fred.pack(side = "left")
         fred.pack(expand = 1)


File: python-lib-jp.info,  Node: Packer のオプション,  Next: ウィジェット変数を関連付ける,  Prev: Packer,  Up: 簡単なリファレンス

20.1.6.3 Packer のオプション
............................

packer と packer の取りえるオプションについての詳細は、man マニュアル
や John Ousterhout の本の 183 ページを参照してください。

`anchor '
     アンカーの型です。 packer
     が区画内に各スレイブを配置する位置を示します。

`expand'
     ブール値で、`0'または`1' になります。

`fill'
     指定できる値は `'x''、`'y''、`'both''、`'none'' です。

`ipadxとipady'
     スレイブウィジェットの各側面の内側に行うパディング幅を表す長さを
     指定します。

`padxとpady'
     スレイブウィジェットの各側面の外側に行うパディング幅を表す長さを
     指定します。

`side'
     指定できる値は `'left'', `'right'', `'top'', `'bottom'' です。


File: python-lib-jp.info,  Node: ウィジェット変数を関連付ける,  Next: ウィンドウマネジャ,  Prev: Packer のオプション,  Up: 簡単なリファレンス

20.1.6.4 ウィジェット変数を関連付ける
.....................................

ウィジェットによっては、(テキスト入力ウィジェットのように)
特殊なオプションを使って、現在設定されている値をアプリケーション内の
変数に直接関連付けできます。このようなオプションには`variable'、
`textvariable'、`onvalue'、`offvalue'および`value'
があります。この関連付けは双方向に働きます: 変数の値が何らかの理由で
変更されると、関連付けされているウィジェットも更新され、新しい値を
反映します。

残念ながら、現在の`Tkinter' の実装では、 `variable' や`textvariable'
オプションでは 任意の Python の値をウィジェットに渡せません。
この関連付け機能がうまく働くのは、 `Tkinter' モジュール内で Variable
というクラスから サブクラス化されている変数によるオプションだけです。

Variable には、`StringVar'、`IntVar'、`DoubleVar'および `BooleanVar'
といった便利なサブクラスがすでにすでに数多く定義
されています。こうした変数の現在の値を読み出したければ、 `get()'
メソッドを呼び出します。また、値を変更したければ `set()'
メソッドを呼び出します。
このプロトコルに従っている限り、それ以上なにも手を加えなくても
ウィジェットは常に現在値に追従します。

例えば:
     class App(Frame):
         def __init__(self, master=None):
             Frame.__init__(self, master)
             self.pack()

             self.entrythingy = Entry()
             self.entrythingy.pack()

             # アプリケーション変数です
             self.contents = StringVar()
             # 変数の値を設定します
             self.contents.set("this is a variable")
             # エントリウィジェットに変数の値を監視させます
             self.entrythingy["textvariable"] = self.contents

             # ユーザがリターンキーを押した時にコールバックを呼び出させます
             # これで、このプログラムは、ユーザがリターンキーを押すと
             # アプリケーション変数の値を出力するようになります。
             self.entrythingy.bind('<Key-Return>',
                                   self.print_contents)

         def print_contents(self, event):
             print "hi. contents of entry is now ---->", \
                   self.contents.get()


File: python-lib-jp.info,  Node: ウィンドウマネジャ,  Next: Tk オプションデータ型,  Prev: ウィジェット変数を関連付ける,  Up: 簡単なリファレンス

20.1.6.5 ウィンドウマネジャ
...........................

Tk には、ウィンドウマネジャとやり取りするための `wm' という
ユーティリティコマンドがあります。`wm' コマンドにオプション
を指定すると、タイトルや配置、アイコンビットマップなどを操作
できます。`Tkinter' では、こうしたコマンドは `Wm'
クラスのメソッドとして実装されています。 トップレベルウィジェットは
`Wm' クラスからサブクラス化 されているので、`Wm'
のメソッドを直接呼び出せます。

あるウィジェットの入っているトップレベルウィンドウを取得したい場合、
大抵は単にウィジェットのマスタを参照するだけですみます。とはいえ、
ウィジェットがフレーム内にパックされている場合、マスタはトップレベル
ウィンドウではありません。任意のウィジェットの入っている
トップレベルウィンドウを知りたければ `_root()' メソッド
を呼び出してください。このメソッドはアンダースコアがついていますが、
これはこの関数が `Tkinter' の実装の一部であり、Tk の機能
に対するインタフェースではないことを示しています。

以下に典型的な使い方の例をいくつか挙げます:

     from Tkinter import *
     class App(Frame):
         def __init__(self, master=None):
             Frame.__init__(self, master)
             self.pack()

     # アプリケーションを作成します
     myapp = App()

     #
     # ウィンドウマネジャクラスのメソッドを呼び出します。
     #
     myapp.master.title("My Do-Nothing Application")
     myapp.master.maxsize(1000, 400)

     # プログラムを開始します
     myapp.mainloop()


File: python-lib-jp.info,  Node: Tk オプションデータ型,  Next: バインドとイベント,  Prev: ウィンドウマネジャ,  Up: 簡単なリファレンス

20.1.6.6 Tk オプションデータ型
..............................

`anchor'
     指定できる値はコンパスの方位です:
     `"n"'、`"ne"'、`"e"'、`"se"'、`"s"'、`"sw"'、`"w"'、`"nw"'、および`"center"'。

`bitmap'
     八つの組み込み、名前付きビットマップ:
     `'error''、`'gray25''、`'gray50''、`'hourglass''、`'info''、`'questhead''、`'question''、`'warning''。
     Xビットマップファイル名を指定するために、`"@/usr/contrib/bitmap/gumby.bit"'のような`@'を先頭に付けたファイルへの完全なパスを与えてください。

`boolean'
     整数0または1、あるいは、文字列`"yes"'または`"no"'を渡すことができます。

`callback'
     これは引数を取らない Python 関数ならどれでも構いません。例えば:
              def print_it():
                      print "hi there"
              fred["command"] = print_it

`color'
     色はrgb.txtファイルのXカラーの名前か、またはRGB値を表す文字列として与えられます。RGB値を表す文字列は、4ビット:
     `"#RGB"', 8 bit: `"#RRGGBB"', 12 bit" `"#RRRGGGBBB"', あるいは、16
     bit
     `"#RRRRGGGGBBBB"'の範囲を取ります。ここでは、R,G,Bは適切な十六進数ならどんなものでも表します。詳細は、Ousterhoutの本の160ページを参照してください。

`cursor'
     `cursorfont.h'の標準Xカーソル名を、接頭語`XC_'無しで使うことができます。例えば、handカーソル(`XC_hand2')を得るには、文字列`"hand2"'を使ってください。あなた自身のビットマップとマスクファイルを指定することもできます。Ousterhoutの本の179ページを参照してください。

`distance'
     スクリーン上の距離をピクセルか絶対距離のどちらかで指定できます。ピクセルは数として与えられ、絶対距離は文字列として与えられます。絶対距離を表す文字列は、単位を表す終了文字(センチメートルには`c'、インチには`i'、ミリメートルには`m'、プリンタのポイントには`p')を伴います。例えば、3.5インチは`"3.5i"'と表現します。

`font'
     Tkは`{courier 10
     bold}'のようなリストフォント名形式を使います。正の数のフォントサイズはポイント単位で表され。負の数のサイズはピクセル単位で表されます。

`geometry'
     これは`WIDTHxHEIGHT'形式の文字列です。ここでは、ほとんどのウィジェットに対して幅と高さピクセル単位で(テキストを表示するウィジェットに対しては文字単位で)表されます。例えば:
     `fred["geometry"] = "200x100"'。

`justify'
     指定できる値は文字列です: `"left"'、`"center"'、`"right"'、and
     `"fill"'。

`region'
     これは空白で区切られた四つの要素をもつ文字列です。各要素は指定可能な距離です(以下を参照)。例えば:
     `"2 3 4 5"'と`"3i 2i 4.5i 2i"'と`"3c 2c 4c
     10.43c"'は、すべて指定可能な範囲です。

`relief'
     ウィジェットのボーダのスタイルが何かを決めます。指定できる値は:
     `"raised"'、`"sunken"'、`"flat"'、`"groove"'、and `"ridge"'。

`scrollcommand'
     これはほとんど常にスクロールバー・ウィジェットの`set()'メソッドですが、一引数を取るどんなウィジェットメソッドでもあり得ます。例えば、
     Python
     ソース配布の`Demo/tkinter/matt/canvas-with-scrollbars.py'ファイルを参照してください。

`wrap:'
     次の中の一つでなければならない:
     `"none"'、`"char"'、あるいは`"word"'。


File: python-lib-jp.info,  Node: バインドとイベント,  Next: index パラメータ,  Prev: Tk オプションデータ型,  Up: 簡単なリファレンス

20.1.6.7 バインドとイベント
...........................

ウィジェットコマンドからのbindメソッドによって、あるイベントを待つことと、そのイベント型が起きたときにコールバック関数を呼び出すことができるようになります。bindメソッドの形式は:

         def bind(self, sequence, func, add=''):

ここでは:

`sequence'
     は対象とするイベントの型を示す文字列です。(詳細については、bindのmanページとJohn
     Ousterhoutの本の201ページをを参照してください。)

`func'
     は一引数を取り、イベントが起きるときに呼び出される Python
     関数です。イベント・インスタンスが引数として渡されます。(このように実施される関数は、一般にCALLBACKSとして知られています。)

`add'
     はオプションで、`'か`+'のどちらかです。
     空文字列を渡すことは、このイベントが関係する他のどんなバインドをもこのバインドが置き換えることを意味します。
     `+'を使う仕方は、この関数がこのイベント型にバインドされる関数のリストに追加されることを意味しています。

例えば:
         def turnRed(self, event):
             event.widget["activeforeground"] = "red"

         self.button.bind("<Enter>", self.turnRed)

イベントのウィジェットフィールドが`turnRed()'コールバック内でどのようにアクセスされているかに注意してください。
このフィールドはXイベントを捕らえるウィジェットを含んでいます。
以下の表はあなたがアクセスできる他のイベントフィールドとそれらのTkでの表現方法の一覧です。Tk
manページを参照するときに役に立つでしょう。

     Tk      Tkinterイベントフィールド       Tk      Tkinterイベントフィールド
     --      -------------------------       --      -------------------------
     %f      focus                           %A      char
     %h      height                          %E      send_event
     %k      keycode                         %K      keysym
     %s      state                           %N      keysym_num
     %t      time                            %T      type
     %w      width                           %W      widget
     %x      x                               %X      x_root
     %y      y                               %Y      y_root


File: python-lib-jp.info,  Node: index パラメータ,  Next: 画像,  Prev: バインドとイベント,  Up: 簡単なリファレンス

20.1.6.8 index パラメータ
.........................

たくさんのウィジェットが渡される"index"パラメータを必要とします。これらはテキストウィジェットでの特定の場所や、エントリウィジェットでの特定の文字、あるいは、メニューウィジェットでの特定のメニュー項目を指定するために使われます。

`エントリウィジェットのインデックス(インデックス、ビューインデックスなど)'
     エントリウィジェットは表示されているテキスト内の文字位置を参照するオプションを持っています。
     テキストウィジェットにおけるこれらの特別な位置にアクセスするために、これらの`Tkinter'関数を使うことができます:

    `AtEnd()'
          テキストの最後の位置を参照します

    `AtInsert()'
          テキストカーソルの位置を参照します

    `AtSelFirst()'
          選択されたテキストの先頭の位置を指します

    `AtSelLast()'
          選択されているテキストおよび最終的に選択されたテキストの末尾の位置を示します。

    `At(x[, y])'
          ピクセル位置X,
          Y(テキストを一行だけ含むテキストエントリウィジェットの場合にはYは使われない)の文字を参照します。

`テキストウィジェットのインデックス'
     テキストウィジェットに対するインデックス記法はとても機能が豊富で、Tk
     manページでよく説明されています。

`メニューのインデックス(menu.invoke()、menu.entryconfig()など)'
     メニューに対するいくつかのオプションとメソッドは特定のメニュー項目を操作します。メニューインデックスはオプションまたはパラメータのために必要とされるときはいつでも、以下のものを渡すことができます:
        * 頭から数えられ、0で始まるウィジェットの数字の位置を指す整数。

        * 文字列`'active''、現在カーソルがあるメニューの位置を指します。

        * 最後のメニューを指す文字列`"last"'。

        *
          `@6'のような`@'が前に来る整数。ここでは、整数がメニューの座標系におけるyピクセル座標として解釈されます。

        *
          文字列`"none"'、どんなメニューエントリもまったく指しておらず、ほとんどの場合、すべてのエントリの動作を停止させるためにmenu.activate()と一緒に使われます。そして、最後に、

        *
          メニューの先頭から一番下までスキャンしたときに、メニューエントリのラベルに一致したパターンであるテキスト文字列。このインデックス型は他すべての後に考慮されることに注意してください。その代わりに、それは`last'、`active'または`none'とラベル付けされたメニュー項目への一致は上のリテラルとして解釈されることを意味します。



File: python-lib-jp.info,  Node: 画像,  Prev: index パラメータ,  Up: 簡単なリファレンス

20.1.6.9 画像
.............

Bitmap/Pixelmap画像を`Tkinter.Image'のサブクラスを使って作ることができます:

   * `BitmapImage'はX11ビットマップデータに対して使えます。

   * `PhotoImage'はGIFとPPM/PGMカラービットマップに対して使えます。

画像のどちらの型でも`file'または`data'オプションを使って作られます(その上、他のオプションも利用できます)。

`image'オプションがウィジェットにサポートされるところならどこでも、画像オブジェクトを使うことができます(例えば、ラベル、ボタン、メニュー)。これらの場合では、Tkは画像への参照を保持しないでしょう。画像オブジェクトへの最後の
Python
の参照が削除されたときに、おまけに画像データが削除されます。そして、どこで画像が使われていようとも、Tkは空の箱を表示します。


File: python-lib-jp.info,  Node: Tix,  Next: ScrolledText,  Prev: Tkinter,  Up: Tkを用いたグラフィカルユーザインターフェイス

20.2 Tkの拡張ウィジェット
=========================

Tkinter用のTk拡張ウィジェット

`Tix' (Tk Interface
Extension)モジュールは豊富な追加ウィジェットを提供します。標準Tkライブラリには多くの有用なウィジェットがありますが、完全では決してありません。`Tix'ライブラリは標準Tkに欠けている一般的に必要とされるウィジェットの大部分を提供します:
`HList'、`ComboBox'、`Control'
(別名SpinBox)および各種のスクロール可能なウィジェット。`Tix'には、一般的に幅広い用途に役に立つたくさんのウィジェットも含まれています:
`NoteBook'、`FileEntry'、`PanedWindow'など。それらは40以上あります。

これら全ての新しいウィジェットと使うと、より便利でより直感的なユーザインタフェース作成し、あなたは新しい相互作用テクニックをアプリケーションに導入することができます。アプリケーションとユーザに特有の要求に合うように、大部分のアプリケーションウィジェットを選ぶことによって、アプリケーションを設計できます。

See also:
     `Tix Homepage' {`Tix'のホームページ。
     ここには追加ドキュメントとダウンロードへのリンクがあります。} `Tix
     Man Pages' {manページと参考資料のオンライン版。} `Tix Programming
     Guide' {プログラマ用参考資料のオンライン版。} `Tix Development
     Applications'
     {TixとTkinterプログラムの開発のためのTixアプリケーション。TideアプリケーションはTkまたはTkinterに基づいて動作します。また、リモートでTix/Tk/Tkinterアプリケーションを変更やデバグするためのインスペクタ`TixInspect'が含まれます。}

* Menu:

* Tixを使う::
* Tixウィジェット::
* Tixコマンド::


File: python-lib-jp.info,  Node: Tixを使う,  Next: Tixウィジェット,  Prev: Tix,  Up: Tix

20.2.1 Tixを使う
----------------

`Tix(screenName[, baseName[, className]])'
     たいていはアプリケーションのメインウィンドウを表すTixのトップレベルウィジェット。それにはTclインタープリタが付随します。

     `Tix'モジュールのクラスは`Tkinter'モジュールのクラスをサブクラス化します。前者は後者をインポートします。だから、Tkinterと一緒に`Tix'を使うためにやらなければならないのは、モジュールを一つインポートすることだけです。一般的に、`Tix'をインポートし、トップレベルでの`Tkinter.Tk'の呼び出しを`Tix.Tk'に置き換えるだけでよいのです:
          import Tix
          from Tkconstants import *
          root = Tix.Tk()


`Tix'を使うためには、通常Tkウィジェットのインストールと平行して、`Tix'ウィジェットをインストールしなければなりません。インストールをテストするために、次のことを試してください:
     import Tix
     root = Tix.Tk()
     root.tk.eval('package require Tix')

これが失敗した場合は、先に進む前に解決しなければならない問題がTkのインストールにあることになります。インストールされた`Tix'ライブラリを指定するためには環境変数`TIX_LIBRARY'を使ってください。Tk動的オブジェクトライブラリ(`tk8183.dll'または`libtk8183.so')を含むディレクトリと同じディレクトリに、動的オブジェクトライブラリ(`tix8183.dll'または`libtix8183.so')があるかどうかを確かめてください。動的オブジェクトライブラリのあるディレクトリには、`pkgIndex.tcl'
(大文字、小文字を区別します)という名前のファイルも含まれているべきで、それには次の一行が含まれます:

     package ifneeded Tix 8.1 [list load "[file join $dir tix8183.dll]" Tix]


File: python-lib-jp.info,  Node: Tixウィジェット,  Next: Tixコマンド,  Prev: Tixを使う,  Up: Tix

20.2.2 Tixウィジェット
----------------------

Tix
は40個以上のウィジェットクラスを`Tkinter'のレパートリーに導入します。
標準配布の`Demo/tix'ディレクトリには、`Tix'ウィジェットのデモがあります。

* Menu:

* 基本ウィジェット::
* ファイルセレクタ::
* ハイアラキカルリストボックス::
* タビュラーリストボックス::
* 管理ウィジェット::
* 画像タイプ::
* その他のウィジェット::
* ジオメトリマネジャを作る::


File: python-lib-jp.info,  Node: 基本ウィジェット,  Next: ファイルセレクタ,  Prev: Tixウィジェット,  Up: Tixウィジェット

20.2.2.1 基本ウィジェット
.........................

`Balloon()'
     ヘルプを提示するためにウィジェット上にポップアップするBalloon。ユーザがカーソルをBalloonウィジェットが束縛されているウィジェット内部へ移動させたとき、説明のメッセージが付いた小さなポップアップウィンドウがスクリーン上に表示されます。

`ButtonBox()'
     ButtonBoxウィジェットは、`Ok
     Cancel'のためだけに普通は使われるようなボタンボックスを作成します。

`ComboBox()'
     ComboBoxウィジェットはMS
     Windowsのコンボボックスコントロールに似ています。ユーザはエントリ・サブウィジェットでタイプするか、リストボックス・サブウィジェットから選択するかのどちらかで選択肢を選びます。

`Control()'
     Controlウィジェットは`SpinBox'ウィジェットとしても知られています。ユーザは二つの矢印ボタンを押すか、またはエントリに直接値を入力して値を調整します。新しい値をユーザが定義した上限と下限に対してチェックします。

`LabelEntry()'
     LabelEntryウィジェットはエントリウィジェットとラベルを一つのメガウィジェットにまとめたものです。"記入形式"型のインタフェースの作成を簡単に行うために使うことができます。

`LabelFrame()'
     LabelFrameウィジェットはフレームウィジェットとラベルを一つのメガウィジェットにまとめたものです。LabelFrameウィジェット内部にウィジェットを作成するためには、`frame'サブウィジェットに対して新しいウィジェットを作成し、それらを`frame'サブウィジェット内部で取り扱います。

`Meter()'
     Meterウィジェットは実行に時間のかかるバックグラウンド・ジョブの進み具合を表示するために使用できます。

`OptionMenu()'
     OptionMenuはオプションのメニューボタンを作成します。

`PopupMenu()'
     PopupMenuウィジェットは`tk_popup'コマンドの代替品として使用できます。`Tix'
     `PopupMenu'ウィジェットの利点は、操作するためにより少ないアプリケーション・コードしか必要としないことです。

`Select()'
     Selectウィジェットはボタン・サブウィジェットのコンテナです。ユーザに対する選択オプションのラジオボックスまたはチェックボックス形式を提供するために利用することができます。

`StdButtonBox()'
     StdButtonBoxウィジェットは、Motifに似たダイアログボックスのための標準的なボタンのグループです。


File: python-lib-jp.info,  Node: ファイルセレクタ,  Next: ハイアラキカルリストボックス,  Prev: 基本ウィジェット,  Up: Tixウィジェット

20.2.2.2 ファイルセレクタ
.........................

`DirList()'
     DirListウィジェットは、ディレクトリのリストビュー(その前のディレクトリとサブディレクトリ)を表示します。ユーザはリスト内の表示されたディレクトリの一つを選択したり、あるいは他のディレクトリへ変更したりできます。

`DirTree()'
     DirTreeウィジェットはディレクトリのツリービュー(その前のディレクトリとそのサブディレクトリ)を表示します。ユーザはリスト内に表示されたディレクトリの一つを選択したり、あるいは他のディレクトリに変更したりできます。

`DirSelectDialog()'
     DirSelectDialogウィジェットは、ダイアログウィンドウにファイルシステム内のディレクトリを提示します。望みのディレクトリを選択するために、ユーザはファイルシステムを介して操作するこのダイアログウィンドウを利用できます。

`DirSelectBox()'
     `DirSelectBox'は標準Motif(TM)ディレクトリ選択ボックスに似ています。ユーザがディレクトリを選択するために一般的に使われます。DirSelectBoxは主に最近ComboBoxウィジェットに選択されたディレクトリを保存し、すばやく再選択できるようにします。

`ExFileSelectBox()'
     ExFileSelectBoxウィジェットは、たいていtixExFileSelectDialogウィジェット内に組み込まれます。ユーザがファイルを選択するのに便利なメソッドを提供します。`ExFileSelectBox'ウィジェットのスタイルは、MS
     Windows 3.1の標準ファイルダイアログにとてもよく似ています。

`FileSelectBox()'
     FileSelectBoxは標準的なMotif(TM)ファイル選択ボックスに似ています。ユーザがファイルを選択するために一般的に使われます。FileSelectBoxは主に最近`ComboBox'ウィジェットに選択されたファイルを保存し、素早く再選択できるようにします。

`FileEntry()'
     FileEntryウィジェットはファイル名を入力するために使うことができます。ユーザは手でファイル名をタイプできます。その代わりに、ユーザはエントリの横に並んでいるボタンウィジェットを押すことができます。それはファイル選択ダイアログを表示します。


File: python-lib-jp.info,  Node: ハイアラキカルリストボックス,  Next: タビュラーリストボックス,  Prev: ファイルセレクタ,  Up: Tixウィジェット

20.2.2.3 ハイアラキカルリストボックス
.....................................

`HList()'
     HListウィジェットは階層構造をもつどんなデータ(例えば、ファイルシステムディレクトリツリー)でも表示するために使用できます。リストエントリは字下げされ、階層のそれぞれの場所に応じて分岐線で接続されます。

`CheckList()'
     CheckListウィジェットは、ユーザが選ぶ項目のリストを表示します。CheckListはTkのチェックリストやラジオボタンより多くの項目を扱うことができることを除いて、チェックボタンあるいはラジオボタンウィジェットと同じように動作します。

`Tree()'
     Treeウィジェットは階層的なデータをツリー形式で表示するために使うことができます。ユーザはツリーの一部を開いたり閉じたりすることによって、ツリーの見えを調整できます。


File: python-lib-jp.info,  Node: タビュラーリストボックス,  Next: 管理ウィジェット,  Prev: ハイアラキカルリストボックス,  Up: Tixウィジェット

20.2.2.4 タビュラーリストボックス
.................................

`TList()'
     TListウィジェットは、表形式でデータを表示するために使うことができます。`TList'ウィジェットのリスト・エントリは、Tkのリストボックス・ウィジェットのエントリに似ています。主な差は、(1)
     `TList'ウィジェットはリスト・エントリを二次元形式で表示でき、(2)
     リスト・エントリに対して複数の色やフォントだけでなく画像も使うことができるということです。


File: python-lib-jp.info,  Node: 管理ウィジェット,  Next: 画像タイプ,  Prev: タビュラーリストボックス,  Up: Tixウィジェット

20.2.2.5 管理ウィジェット
.........................

`PanedWindow()'
     PanedWindowウィジェットは、ユーザがいくつかのペインのサイズを対話的に操作できるようにします。ペインは垂直または水平のどちらかに配置されます。ユーザは二つのペインの間でリサイズ・ハンドルをドラッグしてペインの大きさを変更します。

`ListNoteBook()'
     ListNoteBookウィジェットは、`TixNoteBook'ウィジェットにとてもよく似ています。ノートのメタファを使って限られた空間をに多くのウィンドウを表示するために使われます。ノートはたくさんのページ(ウィンドウ)に分けられています。ある時には、これらのページの一つしか表示できません。ユーザは`hlist'サブウィジェットの中の望みのページの名前を選択することによって、これらのページを切り替えることができます。

`NoteBook()'
     NoteBookウィジェットは、ノートのメタファを多くのウィンドウを表示することができます。ノートはたくさんのページに分けられています。ある時には、これらのページの一つしか表示できません。ユーザはNoteBookウィジェットの一番上にある目に見える"タブ"を選択することで、これらのページを切り替えることができます。


File: python-lib-jp.info,  Node: 画像タイプ,  Next: その他のウィジェット,  Prev: 管理ウィジェット,  Up: Tixウィジェット

20.2.2.6 画像タイプ
...................

`Tix'モジュールは次のものを追加します:
   *
     全ての`Tix'と`Tkinter'ウィジェットに対してXPMファイルからカラー画像を作成するpixmap機能。

   * Compound
     画像タイプは複数の水平方向の線から構成される画像を作成するために使うこ
     とができます。それぞれの線は左から右に並べられた一連のアイテム(テキスト、
     ビットマップ、画像あるいは空白)から作られます。例え
     ば、Tkの`Button'ウィジェットの中にビットマップとテキスト文字列を
     同時に表示するためにcompound画像は使われます。



File: python-lib-jp.info,  Node: その他のウィジェット,  Next: ジオメトリマネジャを作る,  Prev: 画像タイプ,  Up: Tixウィジェット

20.2.2.7 その他のウィジェット
.............................

`InputOnly()'
     InputOnlyウィジェットは、ユーザから入力を受け付けます。それは、`bind'コマンドを使って行われます(UNIXのみ)。



File: python-lib-jp.info,  Node: ジオメトリマネジャを作る,  Prev: その他のウィジェット,  Up: Tixウィジェット

20.2.2.8 ジオメトリマネジャを作る
.................................

加えて、`Tix'は次のものを提供することで`Tkinter'を補強します:

`Form()'
     Tkウィジェットに対する接続ルールに基づいたジオメトリマネジャを作成(Form)します。


File: python-lib-jp.info,  Node: Tixコマンド,  Prev: Tixウィジェット,  Up: Tix

20.2.3 Tixコマンド
------------------

`tixCommand()'
     tixコマンドは`Tix'の内部状態と`Tix'アプリケーション・コンテキストのいろいろな要素へのアクセスを提供します。これらのメソッドによって操作される情報の大部分は、特定のウィンドウというよりむしろアプリケーション全体かスクリーンあるいはディスプレイに関するものです。

     現在の設定を見るための一般的な方法は、
          import Tix
          root = Tix.Tk()
          print root.tix_configure()


`tix_configure([cnf,] **kw)'
     Tixアプリケーション・コンテキストの設定オプションを問い合わせたり、変更したりします。オプションが指定されなければ、利用可能なオプションすべてのディクショナリを返します。オプションが値なしで指定された場合は、メソッドは指定されたオプションを説明するリストを返します(このリストはオプションが指定されていない場合に返される値に含まれている、指定されたオプションに対応するサブリストと同一です)。一つ以上のオプション-値のペアが指定された場合は、メソッドは与えられたオプションが与えられた値を持つように変更します。この場合は、メソッドは空文字列を返します。オプションは設定オプションのどれでも構いません。

`tix_cget(option)'
     OPTIONによって与えられた設定オプションの現在の値を返します。オプションは設定オプションのどれでも構いません。

`tix_getbitmap(name)'
     ビットマップディレクトリの一つの中の`name.xpm'または`name'と言う名前のビットマップファイルの場所を見つけ出します(`tix_addbitmapdir()'メソッドを参照してください)。`tix_getbitmap()'を使うことで、アプリケーションにビットマップファイルのパス名をハードコーディングすることを避けることができます。成功すれば、文字`@'を先頭に付けたビットマップファイルの完全なパス名を返します。戻り値をTkとTixウィジェットの`bitmap'オプションを設定するために使うことができます。

`tix_addbitmapdir(directory)'
     Tixは`tix_getimage()'と`tix_getbitmap()'メソッドが画像ファイルを検索するディレクトリのリストを保持しています。標準ビットマップディレクトリは`$TIX_LIBRARY/bitmaps'です。`tix_addbitmapdir()'メソッドはDIRECTORYをこのリストに追加します。そのメソッドを使うことによって、アプリケーションの画像ファイルを`tix_getimage()'または`tix_getbitmap()'メソッドを使って見つけることができます。

`tix_filedialog([dlgclass])'
     このアプリケーションからの異なる呼び出しの間で共有される可能性があるファイル選択ダイアログを返します。最初に呼ばれた時に、このメソッドはファイル選択ダイアログ・ウィジェットを作成します。このダイアログはその後のすべての`tix_filedialog()'への呼び出しで返されます。オプションのdlgclassパラメータは、要求されているファイル選択ダイアログ・ウィジェットの型を指定するために文字列として渡されます。指定可能なオプションは`tix'、`FileSelectDialog'あるいは`tixExFileSelectDialog'です。

`tix_getimage(self, name)'
     ビットマップディレクトリの一つの中の`name.xpm'、`name.xbm'または`name.ppm'という名前の画像ファイルの場所を見つけ出します(上の`tix_addbitmapdir()'メソッドを参照してください)。同じ名前(だが異なる拡張子)のファイルが一つ以上ある場合は、画像のタイプがXディスプレイの深さに応じて選択されます。xbm画像はモノクロディスプレイの場合に選択され、カラー画像はカラーディスプレイの場合に選択されます。`tix_getimage()'を使うことによって、アプリケーションに画像ファイルのパス名をハードコーディングすることを避けられます。成功すれば、このメソッドは新たに作成した画像の名前を返し、TkとTixウィジェットの`image'オプションを設定するためにそれを使うことができます。

`tix_option_get(name)'
     Tixのスキーム・メカニズムによって保持されているオプションを得ます。

`tix_resetoptions(newScheme, newFontSet[, newScmPrio])'
     TixアプリケーションのスキームとフォントセットをNEWSCHEMEとNEWFONTSETそれぞれへと再設定します。これはこの呼び出し後に作成されたそれらのウィジェットだけに影響します。そのため、Tixアプリケーションのどんなウィジェットを作成する前にresetoptionsメソッドを呼び出すのが最も良いのです。

     オプション・パラメータNEWSCMPRIOを、Tixスキームによって設定されるTkオプションの優先度レベルを再設定するために与えることができます。

     TkがXオプションデータベースを扱う方法のため、Tixがインポートされ初期化された後に、カラースキームとフォントセットを`tix_config()'メソッドを使って再設定することができません。その代わりに、`tix_resetoptions()'メソッドを使わなければならないのです。


File: python-lib-jp.info,  Node: ScrolledText,  Next: turtle,  Prev: Tix,  Up: Tkを用いたグラフィカルユーザインターフェイス

20.3 スクロールするテキストウィジェット
=======================================

垂直スクロールバーを持つテキストウィジェット。

`ScrolledText'モジュールは"正しい動作"をするように設定された垂直スクロールバーをもつ基本的なテキストウィジェットを実装する同じ名前のクラスを提供します。`ScrolledText'クラスを使うことは、テキストウィジェットとスクロールバーを直接設定するより簡単です。コンストラクタは`Tkinter.Text'クラスのものを同じです。

テキストウィジェットとスクロールバーは`Frame'の中に一緒にpackされ、`Grid'と`Pack'ジオメトリマネジャのメソッドは`Frame'オブジェクトから得られます。これによって、もっとも標準的なジオメトリマネジャの振る舞いにするために、直接`ScrolledText'ウィジェットを使えるようになります。

特定の制御が必要ならば、以下の属性が利用できます:

`frame'
     テキストとスクロールバーウィジェットを取り囲むフレーム。

`vbar'
     スクロールバーウィジェット。


File: python-lib-jp.info,  Node: turtle,  Next: Idle,  Prev: ScrolledText,  Up: Tkを用いたグラフィカルユーザインターフェイス

20.4 Tkのためのタートルグラフィックス
=====================================

タートルグラフィックスのための環境。

`turtle'モジュールはオブジェクト指向と手続き指向の両方の方法でタートルグラフィックス・プリミティブを提供します。グラフィックスの基礎として`Tkinter'を使っているために、TkをサポートしたPythonのバージョンが必要です。

手続き型インターフェイスでは、関数のどれかが呼び出されたときに自動的に作られるペンとキャンバスを使います。

`turtle'モジュールは次の関数を定義しています:

`degrees()'
     角度を計る単位を度にします。

`radians()'
     角度を計る単位をラジアンにします。

`setup(**kwargs)'
     メインウインドウの大きさと位置を設定します。キーワードは：
        * `width': ピクセル数かスクリーンに対する割合での大きさ。
          デフォルトはスクリーンの 50% です。

        * `height': ピクセル数かスクリーンに対する割合での大きさ。
          デフォルトはスクリーンの 50% です。

        * `startx': スクリーン左端からのピクセル数での開始位置。 `None'
          はデフォルト値で、スクリーンの水平方向にセンタリングします。

        * `starty': スクリーン左端からのピクセル数での開始位置。 `None'
          はデフォルト値で、スクリーンの垂直方向にセンタリングします。

     例：

          # デフォルトのジオメトリを利用： スクリーンの 50% x 50%、センタリング。
          setup()

          # ウインドウを 200x200 ピクセル、スクリーンの左上。
          setup (width=200, height=200, startx=0, starty=0)

          # ウインドウをスクリーンの 75% x 50% にして、センタリング。
          setup(width=.75, height=0.5, startx=None, starty=None)


`title(title_str)'
     ウインドウのタイトルを TITLE に設定します。

`done()'
     Tk のメインループに入ります。ウインドウは、クローズされるか、
     プロセスが kill されるまで表示され続けます。

`reset()'
     スクリーンを消去し、ペンを中心に持って行き、変数をデフォルト値に設定します。

`clear()'
     スクリーンを消去します。

`tracer(flag)'
     トレースをon/offにします(フラグが真かどうかに応じて)。トレースとは、線に沿って矢印のアニメーションが付き、線がよりゆっくりと引かれることを意味します。

`speed(speed)'
     タートルのスピードを設定します。SPEED パラメータに適切な値は
     `'fastest'' （ウェイト無し）、`'fast'' （5ms のウェイト）、
     `'normal'' （10ms のウェイト）、`'slow'' （15ms のウェイト）、
     それと `'slowest'' （20ms のウェイト）です。 _Added in Python
     version 2.5_

`delay(delay)'
     タートルのスピードを DELAY に設定します。これは ms
     で与えます。_Added in Python version 2.5_

`forward(distance)'
     DISTANCEステップだけ前に進みます。

`backward(distance)'
     DISTANCEステップだけ後ろに進みます。

`left(angle)'
     ANGLE単位だけ左に回ります。単位のデフォルトは度ですが、`degrees()'と`radians()'関数を使って設定できます。

`right(angle)'
     ANGLE単位だけ右に回ります。単位のデフォルトは度ですが、`degrees()'と`radians()'関数を使って設定できます。

`up()'
     ペンを上げます -- 線を引くことを止めます。

`down()'
     ペンを下げます -- 移動したときに線を引きます。

`width(width)'
     線幅をWIDTHに設定します。

`color(s)'

`color (r, g, b)'

`color r, g, b'
     ペンの色を設定します。最初の形式では、色は文字列としてTkの色の仕様の通りに指定されます。二番目の形式は色をRGB値(それぞれは範囲[0..1])のタプルとして指定します。三番目の形式では、色は三つに別れたパラメータとしてRGB値(それぞれは範囲[0..1])を与えて指定しています。

`write(text[, move])'
     現在のペンの位置にTEXTを書き込みます。MOVEが真ならば、ペンはテキストの右下の角へ移動します。デフォルトでは、MOVEは偽です。

`fill(flag)'
     完全な仕様はかなり複雑ですが、推奨する使い方は:
     塗りつぶしたい経路を描く前に`fill(1)'を呼び出し、経路を描き終えたときに`fill(0)'を呼び出します。

`begin_fill()'
     タートルを塗りつぶしモードにします。 後には、対応する end_fill()
     呼び出しが続かなければいけません。
     さもないと、これは無視されてしまいます。 _Added in Python version
     2.5_

`end_fill()'
     塗りつぶしモードを終了し、図形を塗りつぶします； `fill(0)'
     と等価です。 End filling mode, and fill the shape; equivalent to
     `fill(0)'.  _Added in Python version 2.5_

`circle(radius[, extent])'
     半径RADIUS、中心がタートルの左
     RADIUSユニットの円を描きます。EXTENTは円のどの部分を描くかを決定します:
     与えられなければ、デフォルトで完全な円になります。

     EXTENTが完全な円である場合は、弧の一つの端点は、現在のペンの位置です。RADIUSが正の場合、弧は反時計回りに描かれます。そうでなければ、時計回りです。

`goto(x, y)'

`goto (x, y)'
     座標X,
     Yへ移動します。座標は二つの別個の引数か、2-タプルのどちらかで指定することができます。

`towards(x, y)'
     タートルの位置から点 X、Y までの線の角度を返します。
     この座標は二つの別々の引数、2タプルまたは別のペンオブジェクトとして
     指定できます。 _Added in Python version 2.5_

`heading()'
     タートルの現在の向きを返します。 _Added in Python version 2.3_

`setheading(angle)'
     タートルの向きを ANGLE に設定します。 _Added in Python version 2.3_

`position()'
     タートルの現在の位置を `(x,y)' のペアで返します。 _Added in Python
     version 2.3_

`setx(x)'
     タートルの x 座標を X に設定します。 _Added in Python version 2.3_

`sety(y)'
     タートルの y 座標を Y に設定します。 Set the y coordinate of the
     turtle to Y.  _Added in Python version 2.3_

`window_width()'
     キャンバスウインドウの幅を返します。 _Added in Python version 2.3_

`window_height()'
     キャンバスウインドウの高さを返します。 _Added in Python version
     2.3_

このモジュールは`from math import
*'も実行します。従って、タートルグラフィックスのために役に立つ追加の定数と関数については、`math'モジュールのドキュメントを参照してください。

`demo()'
     モジュールをちょっとばかり試しています。

`Error'
     このモジュールによって捕捉されたあらゆるエラー対して発生した例外。

例として、`demo()'関数のコードを参照してください。

このモジュールは次のクラスを定義します:

`Pen()'
     ペンを定義します。上記のすべての関数は与えられたペンのメソッドとして呼び出されます。このコンストラクタは線を描くキャンバスを自動的に作成します。

`Turtle()'
     ペンを定義します。これは基本的に `Pen()' と同義です; `Turtle'
     は、`Pen' の空の派生クラスです。

`RawPen(canvas)'
     キャンバスCANVASに描くペンを定義します。これは"実際の"プログラムでグラフィックスを作成するためにモジュールを使いたい場合に役に立ちます。

* Menu:

* Turtle、Pen と RawPen オブジェクト::


File: python-lib-jp.info,  Node: Turtle、Pen と RawPen オブジェクト,  Prev: turtle,  Up: turtle

20.4.1 Turtle、Pen と RawPen オブジェクト
-----------------------------------------

モジュールで利用可能なグローバル関数の大部分は `Turtle'、 `Pen' や
`RawPen' のメソッドとしても利用可能で、
これは特定のペンの状態にだけ影響します。

メソッドとして強力になっているメソッドは`degrees()'だけで、
これは1回転相当の単位数を指定できるオプション引数を取ります。

`degrees([fullcircle])'
     FULLCIRCLEはデフォルトで360です。たとえFULLCIRCLEにラジアンで2*$pi$、あるいは度で400を与えようとも、これはペンがどんな角度単位でも取ることができるようにしています。


File: python-lib-jp.info,  Node: Idle,  Next: 他のグラフィカルユーザインタフェースパッケージ,  Prev: turtle,  Up: Tkを用いたグラフィカルユーザインターフェイス

20.5 Idle
=========

Idleは`Tkinter' GUIツールキットをつかって作られた Python  IDEです。 

IDLEは次のような特徴があります:

   * `Tkinter' GUIツールキットを使って、100% ピュア  Python
     でコーディングされています

   * クロス-プラットホーム: WindowsとUNIXで動作します (Mac
     OSでは、現在Tcl/Tkに問題があります)

   * 多段Undo、 Python
     対応の色づけや他にもたくさんの機能(例えば、自動的な字下げや呼び出し情報の表示)をもつマルチ-ウィンドウ・テキストエディタ

   * Python シェルウィンドウ(別名、対話インタープリタ)

   *
     デバッガ(完全ではりませんが、ブレークポイントの設定や値の表示、ステップ実行ができます)

* Menu:

* メニュー::
* 基本的な編集とナビゲーション::
* 構文の色づけ::


File: python-lib-jp.info,  Node: メニュー,  Next: 基本的な編集とナビゲーション,  Prev: Idle,  Up: Idle

20.5.1 メニュー
---------------

* Menu:

* Fileメニュー::
* Editメニュー::
* Windowsメニュー::
* Debugメニュー Python シェルウィンドウ内のみ::


File: python-lib-jp.info,  Node: Fileメニュー,  Next: Editメニュー,  Prev: メニュー,  Up: メニュー

20.5.1.1 Fileメニュー
.....................

`New window'
     新しい編集ウィンドウを作成します

`Open...'
     既存のファイルをオープンします

`Open module...'
     既存のモジュールをオープンします(sys.pathを検索します)

`Class browser'
     現在のファイルの中のクラスとモジュールを示します

`Path browser'
     sys.pathディレクトリ、モジュール、クラスおよびメソッドを示します

`Save'
     現在のウィンドウを対応するファイルにセーブします(未セーブのウィンドウには、ウィンドウタイトルの前後に*があります)

`Save As...'
     現在のウィンドウを新しいファイルへセーブします。そのファイルが対応するファイルになります

`Save Copy As...'
     現在のウィンドウを対応するファイルを変えずに異なるファイルにセーブします。

`Close'
     現在のウィンドウを閉じます(未セーブの場合はセーブするか質問します)

`Exit'
     すべてのウィンドウを閉じてIDLEを終了します(未セーブの場合はセーブするか質問します)


File: python-lib-jp.info,  Node: Editメニュー,  Next: Windowsメニュー,  Prev: Fileメニュー,  Up: メニュー

20.5.1.2 Editメニュー
.....................

`Undo'
     現在のウィンドウに対する最後の変更をUndo(取り消し)します(最大で1000個の変更)

`Redo'
     現在のウィンドウに対する最後にundoされた変更をRedo(再実行)します

`Cut'
     システムのクリップボードへ選択された部分をコピーします。それから選択された部分を削除します

`Copy'
     選択された部分をシステムのクリップボードへコピーします

`Paste'
     システムのクリップボードをウィンドウへ挿入します

`Select All'
     編集バッファの内容全体を選択します

`Find...'
     たくさんのオプションをもつ検索ダイアログボックスを開きます

`Find again'
     最後の検索を繰り返します

`Find selection'
     選択された文字列を検索します

`Find in Files...'
     検索するファイルに対する検索ダイアログボックスを開きます

`Replace...'
     検索と置換ダイアログボックスを開きます

`Go to line'
     行番号を尋ね、その行を表示します

`Indent region'
     選択された行を右へ空白4個分シフトします

`Dedent region'
     選択された行を左へ空白4個分シフトします

`Comment out region'
     選択された行の先頭に##を挿入します

`Uncomment region'
     選択された行から先頭の#あるいは##を取り除きます

`Tabify region'
     _先頭_の一続きの空白をタブに置き換えます

`Untabify region'
     _すべての_タブを適切な数の空白に置き換えます

`Expand word'
     あなたがタイプした語を同じバッファの別の語に一致するように展開します。そして、異なる展開が得るために繰り返します

`Format Paragraph'
     現在の空行で区切られた段落を再フォーマットします

`Import module'
     現在のモジュールをインポートまたはリロードします

`Run script'
     現在のファイルを__main__名前空間内で実行します


File: python-lib-jp.info,  Node: Windowsメニュー,  Next: Debugメニュー Python シェルウィンドウ内のみ,  Prev: Editメニュー,  Up: メニュー

20.5.1.3 Windowsメニュー
........................

`Zoom Height'
     ウィンドウを標準サイズ(24x80)と最大の高さの間で切り替えます

このメニューの残りはすべての開いたウィンドウの名前の一覧になっています。一つを選ぶとそれを最前面に持ってくることができます(必要ならばアイコン化をやめさせます)


File: python-lib-jp.info,  Node: Debugメニュー Python シェルウィンドウ内のみ,  Prev: Windowsメニュー,  Up: メニュー

20.5.1.4 Debugメニュー( Python シェルウィンドウ内のみ)
......................................................

`Go to file/line'
     挿入ポイントの周りからファイル名と行番号を探し、ファイルをオープンし、その行を表示します

`Open stack viewer'
     最後の例外のスタックトレースバックを表示します

`Debugger toggle'
     デバッガの下、シェル内でコマンドを実行します

`JIT Stack viewer toggle'
     トレースバック上のスタックビューアをオープンします


File: python-lib-jp.info,  Node: 基本的な編集とナビゲーション,  Next: 構文の色づけ,  Prev: メニュー,  Up: Idle

20.5.2 基本的な編集とナビゲーション
-----------------------------------

   * <Backspace>は左側を削除し、<Del>は右側を削除します

   * 矢印キーと<Page Up>/<Page Down>はそれぞれ移動します

   * <Home>/<End>は行の始め/終わりへ移動します

   * <C-Home>/<C-End>はファイルの始め/終わりへ移動します

   *
     <C-B>、<C-P>、<C-A>、<C-E>、<C-D>、<C-L>を含む、いくつかの`Emacs'バインディングも動作します

* Menu:

* 自動的な字下げ::
* Python  Shellウィンドウ::


File: python-lib-jp.info,  Node: 自動的な字下げ,  Next: Python Shellウィンドウ,  Prev: 基本的な編集とナビゲーション,  Up: 基本的な編集とナビゲーション

20.5.2.1 自動的な字下げ
.......................

ブロックの始まりの文の後、次の行は4つの空白( Python
Shellウィンドウでは、一つのタブ)で字下げされます。あるキーワード(break、returnなど)の後では、次の行は字下げが解除(dedent)されます。先頭の字下げでは、<Backspace>は4つの空白があれば削除します。<Tab>は1-4つの空白(
Python
Shellウィンドウでは一つのタブ)を挿入します。editメニューのindent/dedent
regionコマンドも参照してください。


File: python-lib-jp.info,  Node: Python Shellウィンドウ,  Prev: 自動的な字下げ,  Up: 基本的な編集とナビゲーション

20.5.2.2 Python  Shellウィンドウ
................................

   * <C-C> 実行中のコマンドを中断します

   * <C-D>
     ファイル終端(end-of-file)を送り、`>>>~'プロンプトでタイプしていた場合はウィンドウを閉じます

   * <Alt-p>
     あなたがタイプしたことに一致する以前のコマンドを取り出します

   * <Alt-n> 次を取り出します

   * <Return> 以前のコマンドを取り出しているときは、そのコマンド

   * <Alt-/> (語を展開します)ここでも便利です


File: python-lib-jp.info,  Node: 構文の色づけ,  Prev: 基本的な編集とナビゲーション,  Up: Idle

20.5.3 構文の色づけ
-------------------

色づけはバックグランド"スレッド"で適用され、そのため時折色付けされないテキストが見えます。カラースキームを変えるには、`config.txt'の`[Colors]'節を編集してください。

`Python の構文の色:'

    `キーワード'
          オレンジ

    `文字列'
          緑

    `コメント'
          赤

    `定義'
          青

`シェルの色:'

    `コンソールの出力'
          茶色

    `stdout'
          青

    `stderr'
          暗い緑

    `stdin'
          黒


* Menu:

* コマンドラインの使い方::


File: python-lib-jp.info,  Node: コマンドラインの使い方,  Prev: 構文の色づけ,  Up: 構文の色づけ

20.5.3.1 コマンドラインの使い方
...............................

     idle.py [-c command] [-d] [-e] [-s] [-t title] [arg] ...

     -c コマンド このコマンドを実行します
     -d          デバッガを有効にします
     -e          編集モード、引数は編集するファイルです
     -s          $IDLESTARTUPまたは$PYTHONSTARTUPを最初に実行します
     -t タイトル シェルウィンドウのタイトルを設定します

引数がある場合:

  1.
     `-e'が使われる場合は、引数は編集のためにオープンされるファイルで、`sys.argv'はIDLE自体へ渡される引数を反映します。

  2.
     そうではなく、`-c'が使われる場合には、すべての引数が`sys.argv[1:...]'の中に置かれ、`sys.argv[0]'が`'-c''に設定されます。

  3.
     そうではなく、`-e'でも`-c'でも使われない場合は、最初の引数は`sys.argv[1:...]'にある残りの引数とスクリプト名に設定される`sys.argv[0]'と一緒に実行されるスクリプトです。スクリプト名が'-'のときは、実行されるスクリプトはありませんが、対話的な
     Python
     セッションが始まります。引数はまだ`sys.argv'にあり利用できます。


File: python-lib-jp.info,  Node: 他のグラフィカルユーザインタフェースパッケージ,  Prev: Idle,  Up: Tkを用いたグラフィカルユーザインターフェイス

20.6 他のグラフィカルユーザインタフェースパッケージ
===================================================

`Tkinter'へ付け加えられるたくさんの拡張ウィジェットがあります。

     ` Python メガウィジェット' {`Tkinter'モジュールを使い Python
     で高レベルの複合
     ウィジェットを構築するためのツールキットです。基本クラスと
     この基礎の上に構築された柔軟で拡張可能なメガウィジェットか
     ら構成されています。これらのメガウィジェットはノートブック、
     コンボボックス、選択ウィジェット、ペインウィジェット、スク
     ロールするウィジェット、ダイアログウィンドウなどを含みます。
     BLTに対するPmw.Bltインタフェースを持ち、busy、graph、
     stripchart、tabsetおよびvectorコマンドが利用できます。
     Pmwの最初のアイディアは、Michael McLennanによるTk `itcl'拡張
     `[incr Tk]'とMark Ulfertsによる`[incr Widgets]'から得ました。
     メガウィジェットのいくつかはitclから Python
     へ直接変換したものです。 `[incr
     Widgets]'が提供するウィジェットとほぼ同等のものを提供しま
     す。そして、Tixと同様にほぼ完成しています。しかしながら、ツリーを描く
     ためのTixの高速な`HList'ウィジェットが欠けています。  }

     `Tkinter3000 Widget Construction Kit (WCK)'{は、新しい Tkinter
     ウィジェットを、 Python  で書けるようにするライブラリで す。WCK
     フレームワークは、ウィジェットの生成、設定、スクリーンの外観、イ
     ベント操作における、完全な制御を提供します。Tk/Tcl
     レイヤーを通してデー タ転送する必要がなく、直接  Python
     のデータ構造を操作することができるので、 WCK
     ウィジェットは非常に高速で軽量になり得ます。}

他にも Python で使える GUI パッケージがあります。

     `wxPython'{ wxPython はクロスプラットフォームの Python 用 GUI
     ツールキットで、 人気のある wxWidgets C++
     ツールキットに基づいて作られています。このツールキットは Windows,
     Mac OS X および UNIX システムのアプリケーションに、
     それぞれのプラットフォームのネイティブなウィジェットを可能ならば利用して
     (UNIX系のシステムでは
     GTK+)、ネイティブなルック＆フィールを提供します。
     多彩なウィジェットの他に、オンラインドキュメントや場面に応じたヘルプ、
     印刷、HTML
     表示、低級デバイスコンテキスト描画、ドラッグ＆ドロップ、
     システムクリップボードへのアクセス、XML
     に基づいたリソースフォーマット、
     さらにユーザ寄贈のモジュールからなる成長し続けているライブラリ等々を
     wxPython は提供しています。wxWidget も wxPython
     もどちらのプロジェクトも
     活発に開発が続けられ改良が進められており、活動的で親切なユーザと開発者の
     コミュニティがあります。 } `wxPython in Action'{ Noel Rappin と
     Robin Dunn による wxPython の本。 } `PyQt'{
     PyQtは`sip'でラップされたQtツールキットへの
     バインディングです。QtはUNIX、WindowsおよびMac OS Xで利用できる大
     規模なC++ GUIツールキットです。`sip'は Python クラスとし
     てC++ライブラリに対するバインディングを生成するためのツールキット
     で、特に Python 用に設計されています。オンライン・マニュアルは
     `http://www.opendocspublishing.com/pyqt/' (正誤表は
     `http://www.valdyas.org/python/book.html'にあります)で手に入りま
     す。  }

     `PyKDE'{
     PyKDEは`sip'でラップされたKDEデスクトップライブラリに対するイ
     ンタフェースです。KDEはUNIXコンピュータ用のデスクトップ環境です。グ
     ラフィカル・コンポーネントはQtに基づいています。 } `FXPy'{
     GUIへのインタフェースを提供する Python
     拡張モジュールです。FOXは、グ
     ラフィカルユーザインタフェースを簡単かつ効率良く開発するためのC++
     ベースのツールキットです。それは幅広く、成長しているコントロール・コ
     レクションで、3Dグラフィックスの操作のためのOpenGLウィジェットと同様
     に、ドラッグアンドドロップ、選択のような最新の機能を提供します。FOX
     はアイコン、画像およびステータスライン・ヘルプやツールチップのような
     ユーザにとって便利な機能も実装しています。
     FOXはすでに大規模なコントロール・コレクションを提供していますが、単に
     既存のコントロールを使って望みの振る舞いを追加または再定義する派生クラ
     スを作成することによってプログラマが簡単に追加コントロールとGUI要素を
     構築できるようにするために、FOXはC++を利用しています。  }
     `PyGTK'{GTKウィ
     ジェットセットのための一連のバインディングです。Cのものより少しだけ
     高レベルなオブジェクト指向インタフェースを提供します。普通はC
     APIを
     使ってやらなければならない型キャストとリファレンス・カウントをすべて
     自動的に行います。GNOMEに対しても、
     バインディングがあります。チュートリアルが手に入ります。  }


File: python-lib-jp.info,  Node: 国際化,  Next: プログラムのフレームワーク,  Prev: Tkを用いたグラフィカルユーザインターフェイス,  Up: Top

21 国際化
*********

この章ので解説されるモジュールはプログラムのメッセージで使用される言語
を選択する、または出力を地域の習慣に従って変更するメカニズムを提供して
言語や地域に依存しないソフトの開発を支援します。

この章で解説されるモジュールの一覧は:

* Menu:

* gettext::
* locale::


File: python-lib-jp.info,  Node: gettext,  Next: locale,  Prev: 国際化,  Up: 国際化

21.1 多言語対応に関する国際化サービス
=====================================

多言語対応に関する国際化サービス。

`gettext' モジュールは、 Python によるモジュールや
アプリケーションの国際化 (I18N, I-nternationalizatio-N) および地域化
(L10N, L-ocalizatio-N) サービスを提供します。 このモジュールは GNU
`gettext' メッセージカタログへの API と、 より高レベルで Python
ファイルに適しているクラスに基づいた API の
両方をサポートしてます。以下で述べるインタフェースを使うことで、
モジュールやアプリケーションのメッセージをある自然言語で記述しておき、
翻訳されたメッセージのカタログを与えて他の異なる自然言語の環境下で動作
させることができます。

ここでは Python のモジュールやアプリケーションを地域化する
ためのいくつかのヒントも提供しています。

* Menu:

* GNU gettext API::
* クラスに基づいた API::
* プログラムやモジュールを国際化する::
* 謝辞::


File: python-lib-jp.info,  Node: GNU gettext API,  Next: クラスに基づいた API,  Prev: gettext,  Up: gettext

21.1.1 GNU `gettext' API
------------------------

`gettext' モジュールでは、以下の GNU `gettext' API に 非常に良く似た
API を提供しています。この API を使う場合、
メッセージ翻訳の影響はアプリケーション全体に及ぼすことになります。
アプリケーションが単一の言語しか扱わず、各言語に依存する部分を
ユーザのロケール情報によって選ぶのなら、ほとんどの場合この方法で
やりたいことを実現できます。Python モジュールを地域化していたり、
アプリケーションの実行中に言語を切り替えたい場合、おそらくクラス
に基づいた API を使いたくなるでしょう。

`bindtextdomain(domain[, localedir])'
     DOMAIN をロケール辞書 LOCALEDIR に結び付け (bind) ます。
     具体的には、 `gettext' は与えられたドメインに対する バイナリ形式の
     `.mo' ファイルを、(UNIXでは)
     `LOCALEDIR/LANGUAGE/LC_MESSAGES/DOMAIN.mo' から探します。ここで
     LANGUAGES はそれぞれ環境変数 `LANGUAGE'、`LC_ALL' 、`LC_MESSAGES'、
     および `LANG' の中から検索されます。

     LOCALEDIR が省略されるか `None' の場合、現在 DOMAIN
     に結び付けられている内容が返されます。(1)

`bind_textdomain_codeset(domain[, codeset])'
     DOMAIN をCODESET に結び付けて、`gettext()'
     ファミリの関数が返す文字列のエンコード方式を変更します。 CODESET
     を省略すると、現在結び付けられているコードセットを 返します。

     _Added in Python version 2.4_

`textdomain([domain])'
     現在のグローバルドメインを調べたり変更したりします。 DOMAIN が
     `None' の場合、現在のグローバルドメインが返され
     ます。それ以外の場合にはグローバルドメインは DOMAIN に設定され、
     設定されたグローバルドメインを返します。

`gettext(message)'
     現在のグローバルドメイン、言語、およびロケール辞書に基づいて、
     MESSAGE の特定地域向けの翻訳を返します。通常、
     ローカルな名前空間ではこの関数に `_' という別名をつけます
     (下の例を参照してください)。

`lgettext(message)'
     `gettext()' と同じですが、`bind_textdomain_codeset()'
     で特にエンコードを指定しない限り、翻訳結果を優先システムエンコーディング
     (preferred system encoding) で返します。

     _Added in Python version 2.4_

`dgettext(domain, message)'
     `gettext()' と同様ですが、指定された DOMAIN から
     メッセージを探します。

`ldgettext(message)'
     `dgettext()' と同じですが、`bind_textdomain_codeset()'
     で特にエンコードを指定しない限り、翻訳結果を優先システムエンコーディング
     (preferred system encoding) で返します。

     _Added in Python version 2.4_

`ngettext(singular, plural, n)'
     `gettext()' と同様ですが、複数形の場合を考慮しています。
     翻訳文字列が見つかった場合、N の様式を適用し、
     その結果得られたメッセージを返します (言語によっては二つ以上の
     複数形があります)。 翻訳文字列が見つからなかった場合、 N が 1 なら
     SINGULAR を返します; そうでない場合 PLURAL を返します。

     複数形の様式はカタログのヘッダから取り出されます。様式は C または
     Python の式で、自由な変数 n を持ちます; 式の評価値はカタログ中の
     複数形のインデクスとなります。.po ファイルで用いられる
     詳細な文法と、様々な言語における様式については、GNU gettext
     ドキュメントを参照してください。

     _Added in Python version 2.3_

`lngettext(message)'
     `ngettext()' と同じですが、`bind_textdomain_codeset()'
     で特にエンコードを指定しない限り、翻訳結果を優先システムエンコーディング
     (preferred system encoding) で返します。

     _Added in Python version 2.4_

`dngettext(domain, singular, plural, n)'
     `ngettext()' と同様ですが、指定された DOMAIN から
     メッセージを探します。

     _Added in Python version 2.3_

`ldngettext(message)'
     `dngettext()' と同じですが、`bind_textdomain_codeset()'
     で特にエンコードを指定しない限り、翻訳結果を優先システムエンコーディング
     (preferred system encoding) で返します。

     _Added in Python version 2.4_

GNU `gettext' では `dcgettext()' も定義していますが、
このメソッドはあまり有用ではないと思われるので、現在のところ
実装されていません。

以下にこの API の典型的な使用法を示します:

     import gettext
     gettext.bindtextdomain('myapplication', '/path/to/my/language/directory')
     gettext.textdomain('myapplication')
     _ = gettext.gettext
     # ...
     print _('This is a translatable string.')

---------- Footnotes ----------

(1)  標準でロケールが収められているディレクトリはシステム依存です;
例えば、RedHat Linux では `/usr/share/locale' ですが、 Solaris では
`/usr/lib/locale' です。 `gettext'
モジュールはこうしたシステム依存の標準設定をサポートしません;
その代わりに ``sys.prefix'/share/locale' を標準の
設定とします。この理由から、常にアプリケーションの開始時に
絶対パスで明示的に指定して `bindtextdomain()' を呼び出す
のが最良のやり方ということになります。


File: python-lib-jp.info,  Node: クラスに基づいた API,  Next: プログラムやモジュールを国際化する,  Prev: GNU gettext API,  Up: gettext

21.1.2 クラスに基づいた API
---------------------------

クラス形式の `gettext' モジュールのAPI は GNU `gettext' API
よりも高い柔軟性と利便性を持っています。 Python
のアプリケーションやモジュールを地域化するにはこちらを使う
方を勧めます。`gettext' では、GNU `.mo' 形式のファイルを 解釈し、標準の
8 ビット文字列または Unicode 文字列形式でメッセージ を返す "翻訳"
クラスを定義しています。 この "翻訳"
クラスのインスタンスも、組み込み名前空間に関数 `_()' として組みこみ
(install) できます。

`find(domain[, localedir[,  languages[, all]]])'
     この関数は標準的な `.mo' ファイル検索アルゴリズムを実装
     しています。`textdomain()' と同じく、DOMAIN を引数に
     とります。オプションの LOCALEDIR は `bindtextdomain()'
     と同じです。またオプションの LANGUAGES は文字列を列挙したリスト
     で、各文字列は言語コードを表します。

     LOCALEDIR が与えられていない場合、標準のシステムロケール
     ディレクトリが使われます。(1)

     LANGUAGES が与えられなかった場合、以下の環境変数:
     `LANGUAGE'、`LC_ALL'、 `LC_MESSAGES'、および `LANG'
     が検索されます。空でない値を返した最初の候補が LANGUAGES
     変数として使われます。
     この環境変数は言語名をコロンで分かち書きしたリストを含んで
     いなければなりません。`find()' はこの文字列をコロンで
     分割し、言語コードの候補リストを生成します。

     `find()' は次に言語コードを展開および正規化し、リストの
     各要素について、以下のパス構成:

     `LOCALEDIR/LANGUAGE/LC_MESSAGES/DOMAIN.mo'

     からなる実在するファイルの探索を反復的に行います。`find()'
     は上記のような実在するファイルで最初に見つかったものを返します。
     該当するファイルが見つからなかった場合、`None' が返されます。 ALL
     が与えられていれば、全ファイル名のリストが言語リストまたは
     環境変数で指定されている順番に並べられたものを返します。

`translation(domain[, localedir[, languages[, class_[, fallback[, codeset]]]]])'
     `Translations' インスタンスを DOMAIN、LOCALEDIR、および LANGUAGES
     に基づいて 生成して返します。 DOMAIN、LOCALEDIR、および LANGUAGES
     はまず 関連付けられている `.mo' ファイルパスのリストを取得する
     ために`find()' に渡されます。同じ `.mo' ファイル名を
     持つインスタンスはキャッシュされます。実際にインスタンス化される
     クラスは CLASS_ が与えられていればそのクラスが、そうでない 時には
     `GNUTranslations' です。クラスのコンストラクタは
     単一の引数としてファイルオブジェクトを取らなくてはなりません。
     CODESET を指定した場合、翻訳文字列のエンコードに使う
     文字セットを変更します。

     複数のファイルが発見された場合、後で見つかったファイルは前に見つかった
     ファイルの代替でと見なされ、後で見つかった方が利用されます。
     代替の設定を可能にするには、`copy.copy' を使ってキャッシュから
     翻訳オブジェクトを複製します;
     こうすることで、実際のインスタンスデータは
     キャッシュのものと共有されます。

     `.mo' ファイルが見つからなかった場合、FALLBACK が偽
     (標準の設定です) ならこの関数は `IOError' を送出し、 FALLBACK
     が真なら `NullTranslations' インスタンスが 返されます。

     _Changed in Python version 2.4_

`install(domain[, localedir[, unicode [, codeset[, names]]]])'
     `translation()' にDOMAIN、 LOCALEDIR、 およびCODESET
     を渡してできる関数 `_' を Python の組み込み名前空間に組み込みます。
     UNICODE フラグは `translation()' の返す翻訳オブジェクト の
     `install' メソッドに渡されます。

     NAMES パラメタについては、翻訳オブジェクトの `install'
     メソッドの説明を参照ください。

     以下に示すように、通常はアプリケーション中の文字列を関数 `_()'
     の呼び出しで包み込んで翻訳対象候補であることを示します:

          print _('This string will be translated.')

     利便性を高めるためには、`_()' 関数を Python の組み込み
     名前空間に組み入れる必要があります。こうすることで、アプリケーション内の
     全てのモジュールからアクセスできるようになります。

     _Changed in Python version 2.4_ _Changed in Python version 2.5_

* Menu:

* NullTranslations クラス::
* GNUTranslations クラス::
* Solaris メッセージカタログ機構のサポート::
* Catalog コンストラクタ::

---------- Footnotes ----------

(1)  上の `bindtextdomain()' に関する脚注を参照してください。


File: python-lib-jp.info,  Node: NullTranslations クラス,  Next: GNUTranslations クラス,  Prev: クラスに基づいた API,  Up: クラスに基づいた API

21.1.2.1 `NullTranslations' クラス
..................................

翻訳クラスは、元のソースファイル中のメッセージ文字列から
翻訳されたメッセージ文字列への変換を実際に実装しているクラスです。
全ての翻訳クラスが基底クラスとして用いるクラスが `NullTranslations'
です; このクラスでは独自の特殊な翻訳
クラスを実装するために使うことができる基本的なインタフェースを 以下に
`NullTranslations' のメソッドを示します:

`__init__([fp])'
     オプションのファイルオブジェクト FP を取ります。この引数
     は基底クラスでは無視されます。このメソッドは "保護された
     (protected)" インスタンス変数 _INFO および _CHARSET
     を初期化します。これらの変数の値は導出クラスで設定
     することができます。同様に _FALLBACK も初期化しますが、 この値は
     `add_fallback' で設定されます。その後、 FP が `None' でない場合
     `self._parse(fp)' を 呼び出します。

`_parse(fp)'
     基底クラスでは何もしない (no-op) ようになっています。このメソッド
     の役割はファイルオブジェクト FP を引数に取り、ファイルからデータを
     読み出し、メッセージカタログを初期化することです。サポートされていない
     メッセージカタログ形式を使っている場合、その形式を解釈するためには
     このメソッドを上書きしなくてはなりません。

`add_fallback(fallback)'
     FALLBACK を現在の翻訳オブジェクトの代替オブジェクトとして追加
     します。翻訳オブジェクトが与えられたメッセージに対して翻訳メッセージ
     を提供できない場合、この代替オブジェクトに問い合わせることになります。

`gettext(message)'
     代替オブジェクトが設定されている場合、`gettext()'
     を代替オブジェクト
     に転送します。そうでない場合、翻訳されたメッセージを返します。
     導出クラスで上書きするメソッドです。

`lgettext(message)'
     代替オブジェクトが設定されている場合、`lgettext()'
     を代替オブジェクト
     に転送します。そうでない場合、翻訳されたメッセージを返します。
     導出クラスで上書きするメソッドです。 _Added in Python version 2.4_

`ugettext(message)'
     代替オブジェクトが設定されている場合、`gettext()'
     を代替オブジェクト
     に転送します。そうでない場合、翻訳されたメッセージを Unicode 文字列
     で返します。導出クラスで上書きするメソッドです。

`ngettext(singular, plural, n)'
     代替オブジェクトが設定されている場合、`ngettext()'
     を代替オブジェクト
     に転送します。そうでない場合、翻訳されたメッセージを返します。
     導出クラスで上書きするメソッドです。 _Added in Python version 2.3_

`lngettext(singular, plural, n)'
     代替オブジェクトが設定されている場合、`lngettext()'
     を代替オブジェクト
     に転送します。そうでない場合、翻訳されたメッセージを返します。
     導出クラスで上書きするメソッドです。 _Added in Python version 2.4_

`ungettext(singular, plural, n)'
     代替オブジェクトが設定されている場合、`ungettext()'
     を代替オブジェクト
     に転送します。そうでない場合、翻訳されたメッセージを Unicode 文字列
     で返します。導出クラスで上書きするメソッドです。 _Added in Python
     version 2.3_

`info()'
     "protected" の`_info' 変数を返します。

`charset()'
     "protected" の`_charset' 変数を返します。

`output_charset()'
     翻訳メッセージとして返す文字列のエンコードを決める、 "protected"
     の`_output_charset' 変数を返します。

     _Added in Python version 2.4_

`set_output_charset(charset)'
     翻訳メッセージとして返す文字列のエンコードを決める、 "protected"
     の変数 `_output_charset' を変更します。

     _Added in Python version 2.4_

`install([unicode [, names]])'
     UNICODE フラグが偽の場合、このメソッドは `self.gettext()'
     を組み込み名前空間に組み入れ、`_' と結び付けます。 UNICODE
     が真の場合、`self.gettext()' の代わりに `self.ugettext()'
     を結び付けます。 標準では UNICODE は偽です。

     NAMES パラメタには、`_()' 以外に組み込みの名前空間に
     インストールしたい関数名のシーケンスを指定します。サポートしている名前は
     `'gettext'' (UNICODE フラグの設定に応じて `self.gettext()'
     あるいは `self.ugettext()' のいずれかに対応します)、 `'ngettext''
     (UNICODE フラグの設定に応じて `self.ngettext()' あるいは
     `self.ungettext()' のいずれかに対応します)、 `'lgettext'' および
     `'lngettext'' です。

     この方法はアプリケーションで `_' 関数を利用できるようにする
     ための最も便利な方法ですが、唯一の手段でもあるので注意してください。
     この関数はアプリケーション全体、とりわけ組み込み名前空間に影響する
     ので、地域化されたモジュールで `_' を組み入れることが
     できないのです。その代わりに、以下のコード:

          import gettext
          t = gettext.translation('mymodule', ...)
          _ = t.gettext

     を使って `_' を使えるようにしなければなりません。

     この操作は `_' をモジュール内だけのグローバル名前空間に
     組み入れるので、モジュール内の `_' の呼び出しだけに影響 します。

     _Changed in Python version 2.5_


File: python-lib-jp.info,  Node: GNUTranslations クラス,  Next: Solaris メッセージカタログ機構のサポート,  Prev: NullTranslations クラス,  Up: クラスに基づいた API

21.1.2.2 `GNUTranslations' クラス
.................................

`gettext' モジュールでは `NullTranslations' から
導出されたもう一つのクラス: `GNUTranslations' を提供しています。
このクラスはビッグエンディアン、およびリトルエンディアン両方の
バイナリ形式の GNU `gettext' `.mo' ファイル を読み出せるように
`_parse()' を上書きしています。 また、このクラスはメッセージ id
とメッセージ文字列の両方を Unicode に型強制します。

このクラスではまた、翻訳カタログ以外に、オプションのメタデータ
を読み込んで解釈します。GNU `gettext' では、空の文字列に
対する変換先としてメタデータを取り込むことが慣習になっています。
このメタデータは RFC 822 形式の `key: value' のペアに なっており、
`Project-Id-Version' キーを含んでいなければ なりません。キー
`Content-Type' があった場合、 `charset' の特性値 (property) は
"保護された" `_charset' インスタンス
変数を初期化するために用いられます。値がない場合には、デフォルトと して
`None' が使われます。
エンコードに用いられる文字セットが指定されている場合、カタログから
読み出された全てのメッセージ id とメッセージ文字列は、指定された
エンコードを用いて Unicode に変換されます。`ugettext()' は常に Unicode
を返し、`gettext()' はエンコードされた 8
ビット文字列を返します。どちらのメソッドにおける引数 id の
場合も、Unicode 文字列か US-ASCII 文字のみを含む 8 ビット文字列
だけが受理可能です。国際化されたPython プログラムでは、メソッドの
Unicode 版 (すなわち `ugettext()' や `ungettext()')
の利用が推奨されています。

key/value ペアの集合全体は辞書型データ中に配置され、"保護された"
`_info' インスタンス変数に設定されます。

`.mo' ファイルのマジックナンバーが不正な場合、あるいは
その他の問題がファイルの読み出し中に発生した場合、 `GNUTranslations'
クラスのインスタンス化で `IOError' が送出されることがあります。

以下のメソッドは基底クラスの実装からオーバライドされています:

`gettext(message)'
     カタログから MESSAGE id を検索して、対応するメッセージ文字列を、
     カタログの文字セットが既知のエンコードの場合、エンコードされた 8
     ビット 文字列として返します。MESSAGE id
     に対するエントリがカタログに
     存在せず、フォールバックが設定されている場合、フォールバック
     検索はオブジェクトの `gettext()' メソッドに転送されます。
     そうでない場合、MESSAGE id 自体が返されます。

`ugettext(message)'
     カタログから MESSAGE id を検索して、対応するメッセージ文字列を、
     Unicode でエンコードして返します。MESSAGE id に対するエントリが
     カタログに存在せず、フォールバックが設定されている場合、フォールバック
     検索はオブジェクトの `ugettext()' メソッドに転送されます。
     そうでない場合、MESSAGE id 自体が返されます。

`ngettext(singular, plural, n)'
     メッセージ id に対する複数形を検索します。カタログに対する検索では
     SINGULAR がメッセージ id として用いられ、 N には
     どの複数形を用いるかを指定します。返されるメッセージ文字列は 8
     ビットの文字列で、カタログの文字セットが既知の場合にはその
     文字列セットでエンコードされています。

     メッセージ id がカタログ中に見つからず、フォールバックオブジェクト
     が指定されている場合、メッセージ検索要求はフォールバックオブジェクトの
     `ngettext()' メソッドに転送されます。そうでない場合、 N が 1
     ならば SINGULAR が返され、それ以外に対しては PLURAL が返されます。

     _Added in Python version 2.3_

`ungettext(singular, plural, n)'
     メッセージ id に対する複数形を検索します。カタログに対する検索では
     SINGULAR がメッセージ id として用いられ、 N には
     どの複数形を用いるかを指定します。返されるメッセージ文字列は
     Unicode 文字列です。

     メッセージ id がカタログ中に見つからず、フォールバックオブジェクト
     が指定されている場合、メッセージ検索要求はフォールバックオブジェクトの
     `ungettext()' メソッドに転送されます。そうでない場合、 N が 1
     ならば SINGULAR が返され、それ以外に対しては PLURAL が返されます。

     以下に例を示します。:

          n = len(os.listdir('.'))
          cat = GNUTranslations(somefile)
          message = cat.ungettext(
              'There is %(num)d file in this directory',
              'There are %(num)d files in this directory',
              n) % {'num': n}

     _Added in Python version 2.3_


File: python-lib-jp.info,  Node: Solaris メッセージカタログ機構のサポート,  Next: Catalog コンストラクタ,  Prev: GNUTranslations クラス,  Up: クラスに基づいた API

21.1.2.3 Solaris メッセージカタログ機構のサポート
.................................................

Solaris オペレーティングシステムでは、独自の `.mo'
バイナリファイル形式を定義していますが、この形式に関する
ドキュメントが手に入らないため、現時点ではサポートされていません。


File: python-lib-jp.info,  Node: Catalog コンストラクタ,  Prev: Solaris メッセージカタログ機構のサポート,  Up: クラスに基づいた API

21.1.2.4 Catalog コンストラクタ
...............................

GNOME  では、James Henstridge によるあるバージョンの `gettext'
モジュールを使っていますが、このバージョンは 少し異なった API
を持っています。ドキュメントに書かれている 利用法は:

     import gettext
     cat = gettext.Catalog(domain, localedir)
     _ = cat.gettext
     print _('hello world')

となっています。過去のモジュールとの互換性のために、 `Catalog()'
は前述の `translation()' 関数の別名になっています。

このモジュールと Henstridge のバージョンとの間には一つ相違点が
あります: 彼のカタログオブジェクトはマップ型の API を介した
アクセスがサポートされていましたが、この API は使われていない
らしく、現在はサポートされていません。


File: python-lib-jp.info,  Node: プログラムやモジュールを国際化する,  Next: 謝辞,  Prev: クラスに基づいた API,  Up: gettext

21.1.3 プログラムやモジュールを国際化する
-----------------------------------------

国際化 (I18N, I-nternationalizatio-N) とは、プログラムを複数の言語に
対応させる操作を指します。地域化 (L10N, L-ocalizatio-N) とは、すでに
国際化されているプログラムを特定地域の言語や文化的な事情に対応させる
ことを指します。Python プログラムに多言語メッセージ機能を追加するには、
以下の手順を踏む必要があります:

  1. プログラムやモジュールで翻訳対象とする文字列に特殊なマークを
     つけて準備します

  2. マークづけをしたファイルに一連のツールを走らせ、生のメッセージ
     カタログを生成します

  3. 特定の言語へのメッセージカタログの翻訳を作成します

  4. メッセージ文字列を適切に変換するために `gettext'
     モジュールを使います

ソースコードを I18N 化する準備として、ファイル内の全ての文字列
を探す必要があります。翻訳を行う必要のある文字列はどれも `_('...')' --
すなわち関数 `_()' の呼び出しで
包むことでマーク付けしなくてはなりません。例えば以下のようにします:

     filename = 'mylog.txt'
     message = _('writing a log message')
     fp = open(filename, 'w')
     fp.write(message)
     fp.close()

この例では、文字列 `'writing a log message'' が翻訳対象候補として
マーク付けされており、文字列 `'mylog.txt'' および `'w'' は
されていません。

Python の配布物には、ソースコードに準備作業を行った後で
メッセージカタログの生成を助ける 2 つのツールが付属します。
これらはバイナリ配布の場合には付属していたりしなかったりしますが、
ソースコード配布には入っており、`Tools/i18n' ディレクトリ にあります。

`pygettext' プログラム (1) は全ての Python
ソースコードを走査し、予め翻訳対象としてマーク
した文字列を探し出します。このツールは GNU `gettext'
プログラムと同様ですが、Python ソースコードの機微について
熟知している反面、C 言語や C++言語のソースコードについては
全く知りません。(C 言語による拡張モジュールのように) C 言語の
コードも翻訳対象にしたいのでない限り、 GNU `gettext' は必要ありません。

`pygettext' は、テキスト形式 Uniforum スタイルによる人間が
判読可能なメッセージカタログ `.pot' ファイル群を生成します。
このファイル群はソースコード中でマークされた全ての文字列と、
それに対応する翻訳文字列のためのプレースホルダを含むファイル
で構成されています。 `pygettext' はコマンドライン形式のスクリプトで、
`xgettext' と同様のコマンドラインインタフェースをサポート します;
使用法についての詳細を見るには:

     pygettext.py --help

を起動してください。

これら `.pot' ファイルのコピーは次に、サポート対象の
各自然言語について、言語ごとのバージョンを作成する個々の人間の
翻訳者に頒布されます。翻訳者たちはプレースホルダ部分を埋めて
言語ごとのバージョンをつくり、`.po' ファイルとして
返します。(`Tools/i18n' ディレクトリ内の) `msgfmt.py'(2)
プログラムを使い、翻訳者から返された `.po' ファイルから 機械可読な
`.mo' バイナリカタログファイルを生成します。 `.mo' ファイルは、
`gettext' モジュールが実行時に 実際の翻訳処理を行うために使われます。

`gettext' モジュールをソースコード中でどのように使うかは
単一のモジュールを国際化するのか、それともアプリケーション全体を
国際化するのかによります。
次のふたつのセクションで、それぞれについて説明します。

* Menu:

* モジュールを地域化する::
* アプリケーションを地域化する::
* 動作中 on the fly に言語を切り替える::
* 翻訳処理の遅延解決::
* gettext vs lgettext::

---------- Footnotes ----------

(1)  同様の作業を行う `xpot' と呼ばれるプログラムを  Franc,ois Pinard
が書いています。このプログラムは 彼の `po-utils' パッケージの一部で、
`http://po-utils.progiciels-bpi.ca/' で入手できます。

(2)  `msgfmt.py' は GNU `msgfmt' とバイナリ互換ですが、
より単純で、Python だけを使った実装がされています。 このプログラムと
`pygettext.py' があれば、通常 Python プログラムを国際化するために GNU
`gettext' パッケージを インストールする必要はありません。


File: python-lib-jp.info,  Node: モジュールを地域化する,  Next: アプリケーションを地域化する,  Prev: プログラムやモジュールを国際化する,  Up: プログラムやモジュールを国際化する

21.1.3.1 モジュールを地域化する
...............................

モジュールを地域化する場合、グローバルな変更、例えば組み込み名前空間
への変更を行わないように注意しなければなりません。GNU `gettext' API
ではなく、クラスベースの API を使うべきです。

仮に対象のモジュール名を "spam" とし、モジュールの各言語における
翻訳が収められた `.mo' ファイルが `/usr/share/locale' に GNU `gettext'
形式で置かれているとします。
この場合、モジュールの最初で以下のようにします:

     import gettext
     t = gettext.translation('spam', '/usr/share/locale')
     _ = t.lgettext

翻訳オブジェクトが `.po' ファイル中の Unicode 文字列を返す
ようになっているのなら、上の代わりに以下のようにします:

     import gettext
     t = gettext.translation('spam', '/usr/share/locale')
     _ = t.ugettext


File: python-lib-jp.info,  Node: アプリケーションを地域化する,  Next: 動作中 on the fly に言語を切り替える,  Prev: モジュールを地域化する,  Up: プログラムやモジュールを国際化する

21.1.3.2 アプリケーションを地域化する
.....................................

アプリケーションを地域化するのなら、関数 `_()' を
グローバルな組み込み名前空間に組み入れなければならず、これは
通常アプリケーションの主ドライバ (main driver) ファイル で
行います。この操作によって、アプリケーション独自のファイルは
明示的に各ファイルで `_()' の組み入れを行わなくても 単に `_('...')'
を使うだけで済むようになります。

単純な場合では、単に以下の短いコードをアプリケーションの
主ドライバファイルに追加するだけです:

     import gettext
     gettext.install('myapplication')

ロケールディレクトリや UNICODE フラグを設定する必要が
ある場合、それらの値を `install()' 関数に渡すことが できます:

     import gettext
     gettext.install('myapplication', '/usr/share/locale', unicode=1)


File: python-lib-jp.info,  Node: 動作中 on the fly に言語を切り替える,  Next: 翻訳処理の遅延解決,  Prev: アプリケーションを地域化する,  Up: プログラムやモジュールを国際化する

21.1.3.3 動作中 (on the fly) に言語を切り替える
...............................................

多くの言語を同時にサポートする必要がある場合、複数の翻訳インスタンスを
生成して、例えば以下のコード:
     import gettext

     lang1 = gettext.translation('myapplication', languages=['en'])
     lang2 = gettext.translation('myapplication', languages=['fr'])
     lang3 = gettext.translation('myapplication', languages=['de'])

     # start by using language1
     lang1.install()

     # ... time goes by, user selects language 2
     lang2.install()

     # ... more time goes by, user selects language 3
     lang3.install()

のように、インスタンスを明示的に切り替えてもかまいません。


File: python-lib-jp.info,  Node: 翻訳処理の遅延解決,  Next: gettext vs lgettext,  Prev: 動作中 on the fly に言語を切り替える,  Up: プログラムやモジュールを国際化する

21.1.3.4 翻訳処理の遅延解決
...........................

コードを書く上では、ほとんどの状況で文字列はコードされた場所で
翻訳されます。しかし場合によっては、翻訳対象として文字列をマーク
はするが、その後実際に翻訳が行われるように遅延させる必要が
生じます。古典的な例は以下のようなコートです:

     animals = ['mollusk',
                'albatross',
     	   'rat',
     	   'penguin',
     	   'python',
     	   ]
     # ...
     for a in animals:
         print a

ここで、リスト `animals' 内の文字列は翻訳対象としてマーク
はしたいが、文字列が出力されるまで実際に翻訳を行うのは避けたい
とします。

こうした状況を処理する一つの方法を以下に示します:

     def _(message): return message

     animals = [_('mollusk'),
                _('albatross'),
     	   _('rat'),
     	   _('penguin'),
     	   _('python'),
     	   ]

     del _

     # ...
     for a in animals:
         print _(a)

ダミーの `_()' 定義が単に文字列をそのまま返すように
なっているので、上のコードはうまく動作します。かつ、このダミーの
定義は、組み込み名前空間に置かれた `_()' の定義で (`del'
命令を実行するまで) 一時的に上書きすることが できます。もしそれまでに
`_' をローカルな名前空間に 持っていたら注意してください。

二つ目の例における `_()' の使い方では、"a" は文字列
リテラルではないので、`pygettext' プログラムが翻訳可能な
対象として識別しません。

もう一つの処理法は、以下の例のようなやり方です:

     def N_(message): return message

     animals = [N_('mollusk'),
                N_('albatross'),
     	   N_('rat'),
     	   N_('penguin'),
     	   N_('python'),
     	   ]

     # ...
     for a in animals:
         print _(a)

この例の場合では、翻訳可能な文字列を関数 `N_()' で マーク付けしており
(1) 、`_()' の定義とは全く衝突しません。しかしメッセージ
展開プログラムには翻訳対象の文字列が `N_()' でマーク
されていることを教える必要が出てくるでしょう。 `pygettext' および
`xpot' は両方とも、コマンドライン
上のスイッチでこの機能をサポートしています。

---------- Footnotes ----------

(1)  この `N_()' をどうするかは全くの自由です;
`MarkThisStringForTranslation()'  などとしてもかまいません。


File: python-lib-jp.info,  Node: gettext vs lgettext,  Prev: 翻訳処理の遅延解決,  Up: プログラムやモジュールを国際化する

21.1.3.5 `gettext()' vs. `lgettext()'
.....................................

Python 2.4 からは、 `lgettext()' ファミリが導入されました。
この関数の目的は、現行の GNU gettext 実装によりよく準拠した
別の関数を提供することにあります。翻訳メッセージファイル中で
使われているのと同じコードセットを使って文字列をエンコードして
返す`gettext()' と違い、これらの関数は `locale.getpreferredencoding()'
の返す
優先システムエンコーディングを使って翻訳メッセージ文字列をエンコード
して返します。また、Python 2.4 では、翻訳メッセージ文字列
で使われているコードセットを明示的に選べるようにする関数が新たに
導入されていることにも注意してください。コードセットを明示的に
設定すると、`lgettext()' でさえ、指定したコードセットで
翻訳メッセージ文字列を返します。これは GNU gettext 実装が期待している
仕様と同じです。


File: python-lib-jp.info,  Node: 謝辞,  Prev: プログラムやモジュールを国際化する,  Up: gettext

21.1.4 謝辞
-----------

以下の人々が、このモジュールのコード、フィードバック、設計に関する
助言、過去の実装、そして有益な経験談による貢献をしてくれました:

   * Peter Funk

   * James Henstridge

   * Juan David Ib'a~nez Palomar

   * Marc-Andr'e Lemburg

   * Martin von L"owis

   * Franc,ois Pinard

   * Barry Warsaw


File: python-lib-jp.info,  Node: locale,  Prev: gettext,  Up: 国際化

21.2 国際化サービス
===================

国際化サービス。

`locale' モジュールは POSIX ロケールデータベース
およびロケール関連機能へのアクセスを提供します。 POSIX
ロケール機構を使うことで、プログラマはソフトウェアが
実行される各国における詳細を知らなくても、
アプリケーション上で特定の地域文化に関係する部分を扱うことが できます。

`locale' モジュールは、`_locale' を被うように実装されており、ANSI C
ロケール実装を使っている `_locale'
が利用可能なら、こちらを先に使うようになっています。

`locale' モジュールでは以下の例外と関数を定義しています:

`Error'
     `setlocale()' が失敗したときに送出される例外です。

`setlocale(category[, locale])'
     LOCALE を指定する場合、文字列、 `(LANGUAGE CODE,
     ENCODING)'、からなるタプル、または `None'
     をとることができます。LOCALE がタプルのの場合、
     ロケール別名解決エンジンによって文字列に変換されます。 LOCALE
     が与えられていて、かつ `None' でない場合、 `setlocale()' は
     CATEGORY の設定を変更します。
     変更することのできるカテゴリは以下に列記されており、値は
     ロケール設定の名前です。空の文字列を指定すると、ユーザの環境における
     標準設定になります。 ロケールの変更に失敗した場合、`Error'
     が送出されます。 成功した場合、新たなロケール設定が返されます。

     LOCALE が省略されたり `None' の場合、CATEGORY
     の現在の設定が返されます。

     `setlocale()' はほとんどのシステムでスレッド安全では
     ありません。アプリケーションを書くとき、大抵は以下のコード

          import locale
          locale.setlocale(locale.LC_ALL, '')

     から書き始めます。これは全てのカテゴリをユーザの環境における
     標準設定 (大抵は環境変数 `LANG' で指定されています)
     に設定します。その後複数スレッドを使ってロケールを変更したり
     しない限り、問題は起こらないはずです。

     _Changed in Python version 2.0_

`localeconv()'
     地域的な慣行のデータベースを辞書として返します。辞書は以下の文字列を
     キーとして持っています:

     カテゴリ               キー名                 意味
     ------                 -----                  -----
     LC_NUMERIC             `'decimal_point''      小数点を表す文字です。
                            `'grouping''           `'thousands_sep''
                                                   が来るかもしれない場所を相対的に
                                                   表した数からなる配列です。配列が
                                                   `CHAR_MAX'
                                                   で終端されている
                                                   場合、それ以上の桁では桁数字のグループ化を行いません。配列が
                                                   `0'
                                                   で終端されている場合、最後に指定したグループが反復的に使われます。
                            `'thousands_sep''      桁グループ間を区切るために使われる文字です。
     LC_MONETARY            `'int_curr_symbol''    国際通貨を表現する記号です。
                            `'currency_symbol''    地域的な通貨を表現する記号です。
                            `'p_cs_precedes/n_cs_precedes''通貨記号が値の前につくかどうかです
                                                   (それぞれ正の値、
                                                   負の値を表します)。
                            `'p_sep_by_space/n_sep_by_space''通貨記号と値との間にスペースを入れるかどうかです
                                                   (それぞれ正の値、負の値を表します)。
                            `'mon_decimal_point''  金額表示の際に使われる小数点です。
                            `'frac_digits''        金額を地域的な方法で表現する際の小数点以下の桁数です。
                            `'int_frac_digits''    金額を国際的な方法で表現する際の小数点以下の桁数です。
                            `'mon_thousands_sep''  金額表示の際に桁区切り記号です。
                            `'mon_grouping''       `'grouping''
                                                   と同じで、金額表示の際に使われます。
                            `'positive_sign''      正の値の金額表示に使われる記号です。
                            `'negative_sign''      負の値の金額表示に使われる記号です。
                            `'p_sign_posn/n_sign_posn''符号の位置です
                                                   (それぞれ正の値と負の値を表します)。以下を参照ください。

     数値形式の値に`CHAR_MAX'を設定すると、そのロケールでは値が
     指定されていないことを表します。

     `'p_sign_posn'' および `'n_sing_posn'' の取り得る値は
     以下の通りです。

     値                                 説明
     ------                             -----
     0                                  通貨記号および値は丸括弧で囲われます。
     1                                  符号は値と通貨記号より前に来ます。
     2                                  符号は値と通貨記号の後に続きます。
     3                                  符号は値の直前に来ます。
     4                                  符号は値の直後に来ます。
     `CHAR_MAX'                         このロケールでは特に指定しません。


`nl_langinfo(option)'
     ロケール特有の情報を文字列として返します。この関数は全てのシステムで
     利用可能なわけではなく、指定できる OPTION もプラットフォーム
     間で大きく異なります。引数として使えるのは、locale モジュールで利用
     可能なシンボル定数を表す数字です。


`getdefaultlocale([envvars])'
     標準のロケール設定を取得しようと試み、結果をタプル `(LANGUAGE
     CODE, ENCODING)' の形式で 返します。
     POSIXによると、`setlocale(LC_ALL, '')' を呼ばなかった
     プログラムは、移植可能な `'C'' ロケール設定を使います。
     `setlocale(LC_ALL, '')' を呼ぶことで、`LANG' 変数で
     定義された標準のロケール設定を使うようになります。 Python
     では現在のロケール設定に干渉したくないので、上で述べた
     ような方法でその挙動をエミュレーションしています。

     他のプラットフォームとの互換性を維持するために、環境変数 `LANG'
     だけでなく、引数 ENVVARS で指定された環境変数のリスト
     も調べられます。ENVVARS は標準では GNU gettext で使われて
     いるサーチパスになります; パスには必ず変数名 `LANG' が含まれて
     いるからです。GNU gettext サーチパスは `'LANGUAGE''、
     `'LC_ALL''、`'LC_CTYPE''、および `'LANG'' が
     列挙した順番に含まれています。

     `'C'' の場合を除き、言語コードは RFC 1766 に対応します。 LANGUAGE
     CODE および ENCODING が決定できなかった 場合、`None'
     になるかもしれません。

     _Added in Python version 2.0_

`getlocale([category])'
     与えられたロケールカテゴリに対する現在の設定を、 LANGUAGE CODE、
     ENCODING を含むシーケンスで返します。 CATEGORY として `LC_ALL'
     以外の `LC_*' の 値の一つを指定できます。標準の設定は `LC_CTYPE'
     です。

     `'C'' の場合を除き、言語コードは RFC 1766 に対応します。 LANGUAGE
     CODE および ENCODING が決定できなかった 場合、`None'
     になるかもしれません。

     _Added in Python version 2.0_

`getpreferredencoding([do_setlocale])'
     テキストデータをエンコードする方法を、ユーザの設定に基づいて
     返します。ユーザの設定は異なるシステム間では異なった方法で
     表現され、システムによってはプログラミング的に得ることができない
     こともあるので、この関数が返すのはただの推測です。

     システムによっては、ユーザの設定を取得するために `setlocale'
     を呼び出す必要があるため、この関数はスレッド安全
     ではありません。`setlocale' を呼び出す必要がない、または
     呼び出したくない場合、DO_SETLOCALE を `False' に
     設定する必要があります。 _Added in Python version 2.3_

`normalize(localename)'
     与えたロケール名を規格化したロケールコードを返します。返される
     ロケールコードは `setlocale()' で使うために書式化されて
     います。規格化が失敗した場合、もとの名前がそのまま返されます。

     与えたエンコードがシステムにとって未知の場合、標準の設定では、
     この関数は `setlocale()' と同様に、エンコーディングを
     ロケールコードにおける標準のエンコーディングに設定します。 _Added
     in Python version 2.0_

`resetlocale([category])'
     CATEGORY のロケールを標準設定にします。

     標準設定は `getdefaultlocale()' を呼ぶことで決定されます。
     CATEGORY は標準で `LC_ALL' になっています。 _Added in Python
     version 2.0_

`strcoll(string1, string2)'
     現在の `LC_COLLATE' 設定に従って二つの文字列を比較します。
     他の比較を行う関数と同じように、STRING1 が STRING2
     に対して前に来るか、後に来るか、あるいは二つが等しいかによって、
     それぞれ負の値、正の値、あるいは `0' を返します。

`strxfrm(string)'
     文字列を組み込み関数 `cmp()'  で
     使える形式に変換し、かつロケールに則した結果を返します。
     この関数は同じ文字列が何度も比較される場合、例えば文字列から
     なるシーケンスを順序付けて並べる際に使うことができます。

`format(format, val[, grouping[, monetary]])'
     数値 VAL を現在の `LC_NUMERIC' の設定に基づいて
     書式化します。書式は `%' 演算子の慣行に従います。浮動小数点
     数については、必要に応じて浮動小数点が変更されます。GROUPING
     が真なら、ロケールに配慮した桁数の区切りが行われます。

     MONETARYが真なら、桁区切り記号やグループ化文字列を用いて変換を行
     います。

     この関数や、1文字の指定子でしか動作しないことに注意しましょう。フォー
     マット文字列を使う場合は`format_string()'を使用します。

     _Changed in Python version 2.5_

`format_string(format, val[, grouping])'
     `format % val'形式のフォーマット指定子を、現在のロケール設定を考
     慮したうえで処理します。

     _Added in Python version 2.5_

`currency(val[, symbol[, grouping[, international]]])'
     数値VALを、現在の`LC_MONETARY'の設定にあわせてフォーマッ トします。

     SYMBOLが真の場合は、返される文字列に通貨記号が含まれるようになり
     ます。これはデフォルトの設定です。GROUPINGが真の場合(これはデフォ
     ルトではありません)は、値をグループ化します。INTERNATIONALが真の
     場合(これはデフォルトではありません)は、国際的な通貨記号を使用します。

     この関数は`C'ロケールでは動作しないことに注意しましょう。まず最初に
     `setlocale()'でロケールを設定する必要があります。

     _Added in Python version 2.5_

`str(float)'
     浮動小数点数を `str(FLOAT)' と同じように書式化しますが、
     ロケールに配慮した小数点が使われます。

`atof(string)'
     文字列を `LC_NUMERIC' で設定された慣行に従って浮動小数点に変換
     します。

`atoi(string)'
     文字列を `LC_NUMERIC' で設定された慣行に従って整数に変換します。

`LC_CTYPE'
     文字タイプ関連の関数のためのロケールカテゴリです。このカテゴリの
     設定に従って、モジュール `string' における関数の振る舞い
     が変わります。

`LC_COLLATE'
     文字列を並べ替えるためのロケールカテゴリです。`locale'
     モジュールの関数 `strcoll()' および `strxfrm()' が 影響を受けます。

`LC_TIME'
     時刻を書式化するためのロケールカテゴリです。`time.strftime()'
     はこのカテゴリに設定されている慣行に従います。

`LC_MONETARY'
     金額に関係する値を書式化するためのロケールカテゴリです。
     設定可能なオプションは関数 `localeconv()' で得ることが できます。

`LC_MESSAGES'
     メッセージ表示のためのロケールカテゴリです。現在 Python は
     アプリケーション毎にロケールに対応したメッセージを出力する
     機能はサポートしていません。`os.strerror()' が
     返すような、オペレーティングシステムによって表示される
     メッセージはこのカテゴリによって影響を受けます。

`LC_NUMERIC'
     数字を書式化するためのロケールカテゴリです。関数 `format()'、
     `atoi()'、 `atof()' および `locale' モジュール の `str()'
     が影響を受けます。他の数値書式化操作は影響を 受けません。

`LC_ALL'
     全てのロケール設定を総合したものです。ロケールを変更する際にこの
     フラグが使われた場合、そのロケールにおける全てのカテゴリを設定
     しようと試みます。一つでも失敗したカテゴリがあった場合、全ての
     カテゴリにおいて設定変更を行いません。このフラグを使ってロケールを
     取得した場合、全てのカテゴリにおける設定を示す文字列が返されます。
     この文字列は、後に設定を元に戻すために使うことができます。

`CHAR_MAX'
     `localeconv()' の返す特別な値のためのシンボル定数です。

関数 `nl_langinfo' は以下のキーのうち一つを受理します。
ほとんどの記述は GNU C ライブラリ中の対応する説明から引用されています。

`CODESET'
     選択されたロケールで用いられている文字エンコーディングの名前を
     文字列で返します。

`D_T_FMT'
     時刻および日付をロケール特有の方法で表現するために、 strftime(3) の
     書式化文字列として用いることのできる文字列を返します。

`D_FMT'
     日付をロケール特有の方法で表現するために、 strftime(3) の
     書式化文字列として用いることのできる文字列を返します。

`T_FMT'
     時刻をロケール特有の方法で表現するために、 strftime(3) の
     書式化文字列として用いることのできる文字列を返します。

`T_FMT_AMPM'
     時刻を 午前／午後の書式で表現するために、 strftime(3) の
     書式化文字列として用いることのできる文字列を返します。 返される値は

`DAY_1 ... DAY_7'
     1 週間中の n 番目の曜日名を返します。_ロケール US における、
     `DAY_1' を日曜日とする慣行に従っています。国際的な (ISO 8601)
     月曜日を週の初めとする慣行ではありません。_

`ABDAY_1 ... ABDAY_7'
     1 週間中の n 番目の曜日名を略式表記で返します。

`MON_1 ... MON_12'
     n 番目の月の名前を返します。

`ABMON_1 ... ABMON_12'
     n 番目の月の名前を略式表記で返します。

`RADIXCHAR'
     基数点 (小数点ドット、あるいは小数点コンマ、等) を返します。

`THOUSEP'
     1000 単位桁区切り (3 桁ごとのグループ化) の区切り文字を返します。

`YESEXPR'
     肯定／否定で答える質問に対する肯定回答を正規表現関数で
     認識するために利用できる正規表現を返します。 _表現は C
     ライブラリの `regex()' 関数 に合ったものでなければならず、これは
     `re' で 使われている構文とは異なるかもしれません。_

`NOEXPR'
     肯定／否定で答える質問に対する否定回答を正規表現関数で
     認識するために利用できる正規表現を返します。

`CRNCYSTR'
     通貨シンボルを返します。シンボルを値の前に表示させる場合には "-"
     、値の後ろに表示させる場合には "+" 、シンボルを基数点と
     置き換える場合には "." を前につけます。

`ERA'
     現在のロケールで使われている年代を表現する値を返します。

     ほとんどのロケールではこの値を定義していません。この値を設定している
     ロケールの例は日本です。日本では、日付の伝統的な表示法に、時の天皇
     に対応する元号名を含めます。

     通常この値を直接指定する必要はありません。`E' を書式化文字列に
     指定することで、関数 `strftime' がこの情報を使うようになります。
     返される文字列の様式は決められていないので、異なるシステム間で様式に
     関する同じ知識が使えると期待してはいけません。

`ERA_YEAR'
     返される値はロケールでの現年代の年値です。

`ERA_D_T_FMT'
     返される値は `strftime' で日付および時間をロケール固有の
     年代に基づいた方法で表現するための書式化文字列として使うことができます。

`ERA_D_FMT'
     返される値は `strftime' で日付をロケール固有の
     年代に基づいた方法で表現するための書式化文字列として使うことができます。

`ALT_DIGITS'
     返される値は 0 から 99 までの 100 個の値の表現です。

例:

     >>> import locale
     >>> loc = locale.getlocale(locale.LC_ALL) # get current locale
     >>> locale.setlocale(locale.LC_ALL, 'de_DE') # use German locale; name might vary with platform
     >>> locale.strcoll('f\xe4n', 'foo') # compare a string containing an umlaut
     >>> locale.setlocale(locale.LC_ALL, '') # use user's preferred locale
     >>> locale.setlocale(locale.LC_ALL, 'C') # use default (C) locale
     >>> locale.setlocale(locale.LC_ALL, loc) # restore saved locale

* Menu:

* ロケールの背景、詳細、ヒント、助言および補足説明::
* Python 拡張の作者と、Python を埋め込むようなプログラムに関して::
* メッセージカタログへのアクセス::


File: python-lib-jp.info,  Node: ロケールの背景、詳細、ヒント、助言および補足説明,  Next: Python 拡張の作者と、Python を埋め込むようなプログラムに関して,  Prev: locale,  Up: locale

21.2.1 ロケールの背景、詳細、ヒント、助言および補足説明
-------------------------------------------------------

C 標準では、ロケールはプログラム全体にわたる特性であり、その変更は
高価な処理であるとしています。加えて、頻繁にロケールを変更する
ようなひどい実装はコアダンプを引き起こすこともあります。
このことがロケールを正しく利用する上で苦痛となっています。

そもそも、プログラムが起動した際、ロケールはユーザの希望するロケール
にかかわらず `C' です。プログラムは `setlocale(LC_ALL, '')'
を呼び出して、明示的にユーザの希望する
ロケール設定を行わなければなりません。

`setlocale()' をライブラリルーチン内で呼ぶことは、
それがプログラム全体に及ぼす副作用の面から、一般的によくない考えです。
ロケールを保存したり復帰したりするのもよくありません: 高価な処理
であり、ロケールの設定が復帰する以前に起動してしまった他のスレッド
に悪影響を及ぼすからです。

もし、汎用を目的としたモジュールを作っていて、ロケールによって
影響をうけるような操作 (例えば `string.lower()' や `time.strftime()'
の書式の一部) のロケール独立の
バージョンが必要ということになれば、標準ライブラリルーチンを
使わずに何とかしなければなりません。よりましな方法は、ロケール設定が
正しく利用できているか確かめることです。最後の手段は、
あなたのモジュールが `C' ロケール以外の設定には互換性がない
とドキュメントに書くことです。

`string'  モジュールの大小文字の変換を
行う関数はロケール設定によって影響を受けます。`setlocale()'
関数を呼んで `LC_CTYPE' 設定を変更した場合、変数
`string.lowercase'、`string.uppercase' および `string.letters'
は計算しなおされます。 例えば `from string import letters' のように、
``from' ... `import' ...' を使ってこれらの変数を
使っている場合には、それ以降の `setlocale()' の影響を
受けないので注意してください。

ロケールに従って数値操作を行うための唯一の方法はこのモジュールで
特別に定義されている関数: `atof()'、 `atoi()'、 `format()'、 `str()'
を使うことです。


File: python-lib-jp.info,  Node: Python 拡張の作者と、Python を埋め込むようなプログラムに関して,  Next: メッセージカタログへのアクセス,  Prev: ロケールの背景、詳細、ヒント、助言および補足説明,  Up: locale

21.2.2 Python 拡張の作者と、Python を埋め込むようなプログラムに関して
---------------------------------------------------------------------

拡張モジュールは、現在のロケールを調べる以外は、決して `setlocale()'
を呼び出してはなりません。
しかし、返される値もロケールの復帰のために使えるだけなので、
さほど便利とはいえません (例外はおそらくロケールが `C' か
どうか調べることでしょう)。

ロケールを変更するために Python コードで `locale' モジュール
を使った場合、Python を埋め込んでいるアプリケーションにも影響を
及ぼします。Python を埋め込んでいるアプリケーションに影響が及ぶ
ことを望まない場合、`config.c' ファイル内の組み込みモジュールの
テーブルから `_locale' 拡張モジュール  (ここで全てを行っています)
を削除し、共有ライブラリから `_locate' モジュールにアクセス
できないようにしてください。


File: python-lib-jp.info,  Node: メッセージカタログへのアクセス,  Prev: Python 拡張の作者と、Python を埋め込むようなプログラムに関して,  Up: locale

21.2.3 メッセージカタログへのアクセス
-------------------------------------

C ライブラリの gettext インタフェースが提供されているシステムでは、
locake モジュールでそのインタフェースを公開しています。
このインタフェースは関数 `gettext()'、 `dgettext()'、
`dcgettext()'、`textdomain()'、 `bindtextdomain()'、および
`bind_textdomain_codeset()' からなります。 これらは `gettext'
モジュールの同名の関数に似ていますが、 メッセージカタログとして C
ライブラリのバイナリフォーマットを使い、 メッセージカタログを探すために
C ライブラリのサーチアルゴリズムを 使います。

Python アプリケーションでは、通常これらの関数を呼び出す必要は
ないはずで、代わりに `gettext' を呼ぶべきです。
例外として知られているのは、内部で `gettext()' または `dcgettext()'
を呼び出すような C ライブラリにリンク
するアプリケーションです。こうしたアプリケーションでは、
ライブラリが正しいメッセージカタログを探せるようにテキスト
ドメイン名を指定する必要があります。


File: python-lib-jp.info,  Node: プログラムのフレームワーク,  Next: 開発ツール,  Prev: 国際化,  Up: Top

22 プログラムのフレームワーク
*****************************

この章で解説されるモジュールはあなたのプログラムの大枠を規定するフレー
ムワークです。現状では、ここで解説されるモジュールは全てコマンドライン
インタフェースを書くためのものです。

この章の完全な一覧は:

* Menu:

* cmd::
* shlex::


File: python-lib-jp.info,  Node: cmd,  Next: shlex,  Prev: プログラムのフレームワーク,  Up: プログラムのフレームワーク

22.1 行指向のコマンドインタープリタのサポート
=============================================

行指向のコマンドインタープリタを構築

`Cmd'クラスでは、行指向のコマンドインタープリタを書くための簡単なフレームワークを提供します。テスト用の仕掛けや管理ツール、そして、後により洗練されたインターフェイスでラップするプロトタイプとして、こうしたインタープリタはよく役に立ちます。

`Cmd([completekey[, stdin[, stdout]]])'
     `Cmd'インスタンス、あるいはサブクラスのインスタンスは、行指向のインタープリタ・フレームワークです。`Cmd'自身をインスタンス化することはありません。むしろ、`Cmd'のメソッドを継承したり、
     アクションメソッドをカプセル化するために、あなたが自分で定義するインタープリタクラスのスーパークラスとしての便利です。

     オプション引数 COMPLETEKEY は、補完キーの`readline'名です。
     デフォルトは<Tab>です。COMPLETEKEYが`None'でなく、
     `readline'が利用できるならば、コマンド補完は自動的に行われます。

     オプション引数 STDINとSTDOUTには、Cmd またはそのサブクラスの
     インスタンスが入出力に使用するファイルオブジェクトを指定します。
     省略時にはSYS.STDIN と SYS.STDOUT が使用されます。

     _Changed in Python version 2.3_

* Menu:

* Cmdオブジェクト::


File: python-lib-jp.info,  Node: Cmdオブジェクト,  Prev: cmd,  Up: cmd

22.1.1 Cmdオブジェクト
----------------------

`Cmd'インスタンスは、次のメソッドを持ちます:

`cmdloop([intro])'
     プロンプトを繰り返し出し、入力を受け取り、受け取った入力から取り去った先頭の語を解析し、その行の残りを引数としてアクションメソッドへディスパッチします。

     オプションの引数は、最初のプロンプトの前に表示されるバナーあるいは紹介用の文字列です(これはクラスメンバ`intro'をオーバーライドします)。

     `readline'モジュールがロードされているなら、入力は自動的に`bash'のような履歴リスト編集機能を受け継ぎます(例えば、<Control-P>は直前のコマンドへのスクロールバック、<Control-N>は次のものへ進む、<Control-F>はカーソルを右へ非破壊的に進める、<Control-B>はカーソルを非破壊的に左へ移動させる等)。

     入力のファイル終端は、文字列`'EOF''として渡されます。

     メソッド`do_foo()'を持っている場合に限って、インタープリタのインスタンスはコマンド名`foo'を認識します。特別な場合として、文字`?'で始まる行はメソッド`do_help()'へディスパッチします。他の特別な場合として、文字`!'で始まる行はメソッド`do_shell()'へディスパッチします
     (このようなメソッドが定義されている場合)。

     このメソッドは `postcmd()' メソッドが真を返したときに return
     します。 `postcmd()' に対する STOP 引数は、このコマンドが対応する
     `do_*()' メソッドからの返り値です。

     補完が有効になっているなら、コマンドの補完が自動的に行われます。また、コマンド引数の補完は、引数TEXT、LINE、BEGIDX、およびENDIDXと共に`complete_foo()'を呼び出すことによって行われます。TEXTは、我々がマッチしようとしている文字列の先頭の語です。返されるマッチは全てそれで始まっていなければなりません。LINEは始めの空白を除いた現在の入力行です。BEGIDXとENDIDXは先頭のテキストの始まりと終わりのインデックスで、引数の位置に依存した異なる補完を提供するのに使えます。

     `Cmd'のすべてのサブクラスは、定義済みの`do_help()'を継承します。このメソッドは、(引数`'bar''と共に呼ばれたとすると)対応するメソッド`help_bar()'を呼び出します。引数がなければ、`do_help()'は、すべての利用可能なヘルプ見出し(すなわち、対応する`help_*()'メソッドを持つすべてのコマンド)をリストアップします。また、文書化されていないコマンドでも、すべてリストアップします。

`onecmd(str)'
     プロンプトに答えてタイプしたかのように引数を解釈実行します。これをオーバーライドすることがあるかもしれませんが、通常は必要ないでしょう。便利な実行フックについては、`precmd()'と`postcmd()'メソッドを参照してください。戻り値は、インタープリタによるコマンドの解釈実行をやめるかどうかを示すフラグです。
     コマンド STR に対応する `do_*()' メソッドがある場合、
     そのメソッドの返り値が返されます。そうでない場合は `default()'
     メソッドからの 返り値が返されます。

`emptyline()'
     プロンプトに空行が入力されたときに呼び出されるメソッド。このメソッドがオーバーライドされていないなら、最後に入力された空行でないコマンドが繰り返されます。

`default(line)'
     コマンドの先頭の語が認識されないときに、入力行に対して呼び出されます。このメソッドがオーバーライドされていないなら、エラーメッセージを表示して戻ります。

`completedefault(text, line, begidx, endidx)'
     利用可能なコマンド固有の`complete_*()'が存在しないときに、入力行を補完するために呼び出されるメソッド。デフォルトでは、空行を返します。

`precmd(line)'
     コマンド行LINEが解釈実行される直前、しかし入力プロンプトが作られ表示された後に実行されるフックメソッド。このメソッドは`Cmd'内のスタブであって、サブクラスでオーバーライドされるために存在します。戻り値は`onecmd()'メソッドが実行するコマンドとして使われます。`precmd()'の実装では、コマンドを書き換えるかもしれないし、あるいは単に変更していないLINEを返すかもしれません。

`postcmd(stop, line)'
     コマンドディスパッチが終わった直後に実行されるフックメソッド。このメソッドは`Cmd'内のスタブで、サブクラスでオーバーライドされるために存在します。LINEは実行されたコマンド行で、STOPは`postcmd()'の呼び出しの後に実行を停止するかどうかを示すフラグです。これは`onecmd()'メソッドの戻り値です。このメソッドの戻り値は、STOPに対応する内部フラグの新しい値として使われます。偽を返すと、実行を続けます。

`preloop()'
     `cmdloop()'が呼び出されたときに一度だけ実行されるフックメソッド。このメソッドは`Cmd'内のスタブであって、サブクラスでオーバーライドされるために存在します。

`postloop()'
     `cmdloop()'が戻る直前に一度だけ実行されるフックメソッド。このメソッドは`Cmd'内のスタブであって、サブクラスでオーバーライドされるために存在します。

`Cmd'のサブクラスのインスタンスは、公開されたインスタンス変数をいくつか持っています:

`prompt'
     入力を求めるために表示されるプロンプト。

`identchars'
     コマンドの先頭の語として受け入れられる文字の文字列。

`lastcmd'
     最後の空でないコマンドプリフィックス。

`intro'
     紹介またはバナーとして表示される文字列。`cmdloop()'メソッドに引数を与えるために、オーバーライドされるかもしれません。

`doc_header'
     ヘルプの出力に文書化されたコマンドの部分がある場合に表示するヘッダ。

`misc_header'
     ヘルプの出力にその他のヘルプ見出しがある(すなわち、`do_*()'メソッドに対応していない`help_*()'メソッドが存在する)場合に表示するヘッダ。

`undoc_header'
     ヘルプの出力に文書化されていないコマンドの部分がある(すなわち、対応する`help_*()'メソッドを持たない`do_*()'メソッドが存在する)場合に表示するヘッダ。

`ruler'
     ヘルプメッセージのヘッダの下に、区切り行を表示するために使われる文字。空のときは、ルーラ行が表示されません。デフォルトでは、`='です。

`use_rawinput'
     フラグ、デフォルトでは真。真ならば、`cmdloop()'はプロンプトを表示して次のコマンド読み込むために`raw_input()'を使います。偽ならば、`sys.stdout.write()'と`sys.stdin.readline()'が使われます。
     (これが意味するのは、`readline'を import することによって、
     それをサポートするシステム上では、インタープリタが自動的に
     `Emacs'形式の行編集と
     コマンド履歴のキーストロークをサポートするということです。)


File: python-lib-jp.info,  Node: shlex,  Prev: cmd,  Up: プログラムのフレームワーク

22.2 単純な字句解析
===================

UNIX シェル類似の言語に対する単純な字句解析。

_Added in Python version 1.5.2_

`shlex' クラスは UNIX シェルを思わせる単純な構文に
対する字句解析器を簡単に書けるようにします。このクラスはしばしば、
Python アプリケーションのための実行制御ファイルのような、
小規模言語を書く上で便利です。

_Note:_ モジュール `shlex' は今のところユニコード入力をサポートし
ていません。

* Menu:

* モジュールの内容 4::
* shlex オブジェクト::
* 解析規則::


File: python-lib-jp.info,  Node: モジュールの内容 4,  Next: shlex オブジェクト,  Prev: shlex,  Up: shlex

22.2.1 モジュールの内容
-----------------------

`shlex' モジュールは以下の関数を定義します。

`split(s[, comments])'
     シェル類似の文法を使って、文字列 S を分割します。COMMENTS が
     `False'(デフォルト値)
     の場合、受理した文字列内のコメントを解析しません (`shlex'
     インスタンスの `commenters' メンバの値を空文字列に します)。
     この関数は POSIX モードで動作します。 _Added in Python version 2.3_

`shlex' モジュールは以下のクラスを定義します。

`shlex([instream[, infile[, posix]]])'
     `shlex'
     クラスとサブクラスのインスタンスは、字句解析器オブジェクトです。
     初期化引数を与えると、どこから文字を読み込むかを指定できます。指定先は
     `read()' メソッドと `readline()' メソッドを持つファイル/ス
     トリーム類似オブジェクトか、文字列でなくてはいけません（文字列が受理され
     るようになったのは Python 2.3 以降）。引数が与えられなければ、
     `sys.stdin' から入力を受け付けます。第 2 引数は、ファイル名を表す文
     字列で、 `infile' メンバの値の初期値を決定します。INSTREAM
     引数が省略された場合や、この値が `sys.stdin' である場合、第2引数の
     デフォルト値は "stdin" になります。POSIX 引数は Python 2.3 で導
     入されました。これは動作モードを定義します。POSIX が真でない場合
     （デフォルト）、`shlex' インスタンスは互換モードで動作します。
     POSIX モードで動作中、`shlex' は、できる限り POSIX シェルの
     解析規則に似せようとします。*Note shlex
     オブジェクト::節を参照のこと。

See also:
     *Note ConfigParser:: Windows `.ini'
     ファイルに似た設定ファイルのパーザ。


File: python-lib-jp.info,  Node: shlex オブジェクト,  Next: 解析規則,  Prev: モジュールの内容 4,  Up: shlex

22.2.2 shlex オブジェクト
-------------------------

`shlex' インスタンスは以下のメソッドを持っています:

`get_token()'
     トークンを一つ返します。トークンが `push_token()' で
     使ってスタックに積まれていた場合、トークンをスタックからポップ
     します。そうでない場合、トークンを一つ入力ストリームから読み出します。
     読み出し即時にファイル終了子に遭遇した場合、`self.eof' (非 POSIX
     モードでは空文字列 (`''')、POSIX モードでは `None') が返されます。

`push_token(str)'
     トークンスタックに引数文字列をスタックします。

`read_token()'
     生 (raw) のトークンを読み出します。プッシュバックスタックを無視し、
     かつソースリクエストを解釈しません
     (通常これは便利なエントリポイント
     ではありません。完全性のためにここで記述されています)。

`sourcehook(filename)'
     `shlex' がソースリクエスト (下の `source' を参照して ください)
     を検出した際、このメソッドはその後に続くトークンを
     引数として渡され、ファイル名と開かれたファイル類似オブジェクトからなる
     タプルを返すとされています。

     通常、このメソッドはまず引数から何らかのクオートを剥ぎ取ります。
     処理後の引数が絶対パス名であった場合か、以前に有効になったソースリクエスト
     が存在しない場合か、以前のソースが (`sys.stdin' のような)
     ストリームであった場合、この結果はそのままにされます。そうでない
     場合で、処理後の引数が相対パス名の場合、ソースインクルードスタックに
     ある直前のファイル名からディレクトリ部分が取り出され、相対パスの
     前の部分に追加されます (この動作は C 言語プリプロセッサにおける
     `#include "file.h"' の扱いと同様です) 。

     これらの操作の結果はファイル名として扱われ、タプルの最初の要素
     として返されます。同時にこのファイル名で `open()' を呼び出した
     結果が二つ目の要素になります (注意: インスタンス初期化のときとは
     引数の並びが逆になっています！)

     このフックはディレクトリサーチパスや、ファイル拡張子の追加、その他の
     名前空間に関するハックを実装できるようにするために公開されています。
     `close' フックに対応するものはありませんが、shlex インスタンスは
     ソースリクエストされている入力ストリームが `EOF' を返した時には
     `close()' を呼び出します。

     ソーススタックをより明示的に操作するには、`push_source()' および
     `pop_source()' メソッドを使ってください。

`push_source(stream[, filename])'
     入力ソースストリームを入力スタックにプッシュします。ファイル名
     引数が指定された場合、以後のエラーメッセージ中で利用することが
     できます。`sourcehook' メソッドが内部で使用しているのと
     同じメソッドです。 _Added in Python version 2.1_

`pop_source()'
     最後にプッシュされた入力ソースを入力スタックからポップします。
     字句解析器がスタック上の入力ストリームの `EOF' に到達した際に
     利用するメソッドと同じです。 _Added in Python version 2.1_

`error_leader([file[, line]])'
     このメソッドはエラーメッセージの論述部分を UNIX C コンパイラ
     エラーラベルの形式で生成します; この書式は `'"%s", line %d: ''
     で、`%s' は現在のソースファイル名 で置き換えられ、`%d'
     は現在の入力行番号で置き換えられます
     (オプションの引数を使ってこれらを上書きすることもできます)。

     このやり方は、`shlex' のユーザに対して、Emacs やその他の UNIX
     ツール群が解釈できる一般的な書式でのメッセージを生成する
     ことを推奨するために提供されています。

`shlex' サブクラスのインスタンスは、字句解析を制御したり、
デバッグに使えるような public なインスタンス変数を持っています:

`commenters'
     コメントの開始として認識される文字列です。コメントの開始から行末
     までのすべてのキャラクタ文字は無視されます。 標準では単に `#'
     が入っています。

`wordchars'
     複数文字からなるトークンを構成するためにバッファに蓄積していく
     ような文字からなる文字列です。標準では、全ての ASCII 英数字
     およびアンダースコアが入っています。

`whitespace'
     空白と見なされ、読み飛ばされる文字群です。空白はトークンの境界を
     作ります。標準では、スペース、タブ、改行 (linefeed) および 復帰
     (carriage-return) が入っています。

`escape'
     エスケープ文字と見なされる文字群です。これは POSIX
     モードでのみ使われ、デフォルトでは `\' だけが入っています。 _Added
     in Python version 2.3_

`quotes'
     文字列引用符と見なされる文字群です。トークンを構成する際、
     同じクオートが再び出現するまで文字をバッファに蓄積します
     (すなわち、異なるクオート形式はシェル中で互いに保護し合う
     関係にあります)。標準では、ASCII 単引用符および二重引用符
     が入っています。

`escapedquotes'
     `quotes' のうち、`escape' で定義されたエスケープ文字を解釈
     する文字群です。これは POSIX モードでのみ使われ、デフォルトでは
     `"' だけが入っています。 _Added in Python version 2.3_

`whitespace_split'
     この値が `True'
     であれば、トークンは空白文字でのみで分割されます。たとえば `shlex'
     がシェル引数と同じ方法で、コマンドラインを解析するのに便利です。
     _Added in Python version 2.3_

`infile'
     現在の入力ファイル名です。クラスのインスタンス化時に初期設定
     されるか、その後のソースリクエストでスタックされます。
     エラーメッセージを構成する際にこの値を調べると便利なことがあります。

`instream'
     `shlex' インスタンスが文字を読み出している入力ストリームです。

`source'
     このメンバ変数は標準で `None' を取ります。この値に文字列を
     代入すると、その文字列は多くのシェルにおける `source' キーワード
     に似た、字句解析レベルでのインクルード要求として認識されます。すなわち、
     その直後に現れるトークンをファイル名として新たなストリームを開き、
     そのストリームを入力として、`EOF' に到達するまで読み込まれます。
     新たなストリームの `EOF' に到達した時点で `close()' が呼び出され、
     入力は元の入力ストリームに戻されます。ソースリクエストは任意のレベル
     の深さまでスタックしてかまいません。

`debug'
     このメンバ変数が数値で、かつ`1' またはそれ以上の値の場合、 `shlex'
     インスタンスは動作に関する冗長な進捗報告を出力
     します。この出力を使いたいなら、モジュールのソースコードを読めば
     詳細を学ぶことができます。

`lineno'
     ソース行番号 (遭遇した改行の数に 1 を加えたもの) です。

`token'
     トークンバッファです。例外を捕捉した際にこの値を調べると便利なことが
     あります。

`eof'
     ファイルの終端を決定するのに使われるトークンです。非 POSIX
     モードでは 空文字列 (`''') 、POSIX モードでは `None' が入ります。


File: python-lib-jp.info,  Node: 解析規則,  Prev: shlex オブジェクト,  Up: shlex

22.2.3 解析規則
---------------

非 POSIX モードで動作中の `shlex' は以下の規則に従おうとします。

   * ワード内の引用符を認識しない (`Do"Not"Separate' は単一ワード
     `Do"Not"Separate' として解析されます)

   * エスケープ文字を認識しない

   * 引用符で囲まれた文字列は、引用符内の全ての文字リテラルを保持する

   * 閉じ引用符でワードを区切る (`"Do"Separate' は、`"Do"' と
     `Separate' であると解析されます)

   * `whitespace_split' が `False' の場合、wordchar、 whitespace または
     quote として宣言されていない全ての文字を、単一の
     文字トークンとして返す。`True' の場合、`shlex' は空白文
     字でのみ単語を区切る。

   * 空文字列 (`''') で `EOF' を送出する

   * 引用符に囲んであっても、空文字列を解析しない

POSIX モードで動作中の `shlex' は以下の解析規則に従おうとします。

   * 引用符を取り除き、引用符で単語を分解しない (`"Do"Not"Separate"'
     は単一ワード  `DoNotSeparate' として解析されます)

   * 引用符で囲まれないエスケープ文字群 (`\' など)
     は直後に続く文字のリテラル値を保持する

   * `escapedquotes' でない引用符文字 (`'' など) で囲
     まれている全ての文字のリテラル値を保持する

   * 引用符に囲まれた `escapedquotes' に含まれる文字 (`"' など)
     は、`escape' に含まれる文字を除き、
     全ての文字のリテラル値を保持する。エスケープ文字群は使用中の引用符、
     または、そのエスケープ文字自身が直後にある場合のみ、特殊な機能を保
     持する。他の場合にはエスケープ文字は普通の文字とみなされる。

   * `None' で `EOF' を送出する

   * 引用符に囲まれた空文字列 (`''') を許す


File: python-lib-jp.info,  Node: 開発ツール,  Next: Pythonデバッガ,  Prev: プログラムのフレームワーク,  Up: Top

23 開発ツール
*************

この章で紹介されるモジュールはソフトウェアを書くことを支援します。
たとえば、`pydoc'モジュールはモジュールの内容からドキュメントを
生成します。`doctest'と `unittest'モジュールで
自動的に実行して予想通りの出力が生成されるか確認するユニットテストを書
くことができます。

この章で解説されるモジュールの完全な一覧は:

* Menu:

* pydoc::
* doctest::
* unittest::
* test::


File: python-lib-jp.info,  Node: pydoc,  Next: doctest,  Prev: 開発ツール,  Up: 開発ツール

23.1 ドキュメント生成とオンラインヘルプシステム
===============================================

ドキュメント生成とオンラインヘルプシステム

_Added in Python version 2.1_ 

`pydoc'モジュールは、Pythonモジュールから自動的にドキュメントを生成します。
生成されたドキュメントをテキスト形式でコンソールに表示したり、 Web
browserにサーバとして提供したり、HTMLファイルとして保存したりできます。

組み込み関数の`help()'を使うことで、対話型のインタプリタから
オンラインヘルプを起動することができます。コンソール用のテキスト形式の
ドキュメントをつくるのにオンラインヘルプでは`pydoc'を使っています。
`pydoc'をPythonインタプリタからはなく、オペレーティングシステムの
コマンドプロンプトから起動した場合でも、同じテキスト形式のドキュメントを見ることができます。
例えば、以下をshellから実行すると

     pydoc sys

`sys'モジュールのドキュメントを、UNIX の`man'コマンドの
ような形式で表示させることができます。
`pydoc'の引数として与えることができるのは、関数名・モジュール名・パッケージ名、
また、モジュールやパッケージ内のモジュールに含まれるクラス・メソッド・関数への
ドット"."形式での参照です。
`pydoc'への引数がパスと解釈されるような場合で(オペレーティングシステムの
パス区切り記号を含む場合です。例えばUNIXならば
"/"(スラッシュ)含む場合になります)、
さらに、そのパスがPythonのソースファイルを指しているなら、そのファイルに対する
ドキュメントが生成されます。

引数の前に `-w'フラグを指定すると、コンソールにテキストを表示させる
かわりにカレントディレクトリにHTMLドキュメントを生成します。

引数の前に `-k'フラグを指定すると、引数をキーワードとして
利用可能な全てのモジュールの概要を検索します。
検索のやりかたは、UNIXの`man'コマンドと同様です。
モジュールの概要というのは、モジュールのドキュメントの一行目のことです。

また、`pydoc'を使うことでローカルマシンに Web browserから
閲覧可能なドキュメントを提供するHTTPサーバーを起動することもできます。
`pydoc' `-p 1234'とすると、HTTPサーバーをポート1234に起動します。
これで、お好きなWeb browserを使って`http://localhost:1234/'から
ドキュメントを見ることができます。

`pydoc'でドキュメントを生成する場合、その時点での環境とパス情報に基づいて
モジュールがどこにあるのか決定されます。 そのため、`pydoc'
`spam'を実行した場合につくられる
ドキュメントは、Pythonインタプリタを起動して`import
spam'と入力したときに
読み込まれるモジュールに対するドキュメントになります。

コアモジュールのドキュメントは `http://www.python.org/doc/current/lib/'
にあると仮定されています。
これは、ライブラリリファレンスマニュアルを置いている異なるURLかローカ
ルディレクトリを 環境変数`PYTHONDOCS'に設定することでオーバーラ
イドすることができます。


File: python-lib-jp.info,  Node: doctest,  Next: unittest,  Prev: pydoc,  Up: 開発ツール

23.2 対話モードを使った使用例の内容をテストする
===============================================

対話モードを使った使用例の内容を検証するためのフレームワーク。

`doctest' モジュールは、対話的 Python セッションのように
見えるテキストを探し出し、セッションの内容を実行して、そこに書かれている
通りに振舞うかを調べます。 `doctest' は以下のような用途に
よく使われています:

   * モジュールの docstring (ドキュメンテーション文字列) 中にある対話
     モードでの使用例全てが書かれている通りに動作するかを検証することで、
     docstring の内容が最新のものになるよう保ちます。

   * テストファイルやテストオブジェクト中の対話モードにおける使用例が
     期待通りに動作するかを検証することで、回帰テストを実現します。

   * 入出力例をふんだんに使ったパッケージのチュートリアルドキュメントを
     書けます。入出力例と解説文のどちらに注目するかによって、ドキュメントは
     「読めるテスト」にも「実行できるドキュメント」にもなります。

以下にちょっとした、それでいて完全な例を示します:

`doctest' モジュールは、モジュールの docstring から、
これらのセッションを実際に実行して、そこに書かれている通りに動作するか
検証します。

     """
     This is the "example" module.

     The example module supplies one function, factorial().  For example,

     >>> factorial(5)
     120
     """

     def factorial(n):
         """Return the factorial of n, an exact integer >= 0.

         If the result is small enough to fit in an int, return an int.
         Else return a long.

         >>> [factorial(n) for n in range(6)]
         [1, 1, 2, 6, 24, 120]
         >>> [factorial(long(n)) for n in range(6)]
         [1, 1, 2, 6, 24, 120]
         >>> factorial(30)
         265252859812191058636308480000000L
         >>> factorial(30L)
         265252859812191058636308480000000L
         >>> factorial(-1)
         Traceback (most recent call last):
             ...
         ValueError: n must be >= 0

         Factorials of floats are OK, but the float must be an exact integer:
         >>> factorial(30.1)
         Traceback (most recent call last):
             ...
         ValueError: n must be exact integer
         >>> factorial(30.0)
         265252859812191058636308480000000L

         It must also not be ridiculously large:
         >>> factorial(1e100)
         Traceback (most recent call last):
             ...
         OverflowError: n too large
         """


         import math
         if not n >= 0:
             raise ValueError("n must be >= 0")
         if math.floor(n) != n:
             raise ValueError("n must be exact integer")
         if n+1 == n:  # catch a value like 1e300
             raise OverflowError("n too large")
         result = 1
         factor = 2
         while factor <= n:
             result *= factor
             factor += 1
         return result

     def _test():
         import doctest
         doctest.testmod()

     if __name__ == "__main__":
         _test()

`example.py' をコマンドラインから直接実行すると、 `doctest'
はその魔法を働かせます:

     $ python example.py
     $

出力は何もありません！ しかしこれが正常で、全ての例が正しく動作する
ことを意味しています。 スクリプトに `-v' を与えると、`doctest'
は何を行おうとしているのかを記録した詳細なログを出力し、
最後にまとめを出力します:

     $ python example.py -v
     Trying:
         factorial(5)
     Expecting:
         120
     ok
     Trying:
         [factorial(n) for n in range(6)]
     Expecting:
         [1, 1, 2, 6, 24, 120]
     ok
     Trying:
         [factorial(long(n)) for n in range(6)]
     Expecting:
         [1, 1, 2, 6, 24, 120]
     ok

といった具合で、最後には:

     Trying:
         factorial(1e100)
     Expecting:
         Traceback (most recent call last):
             ...
         OverflowError: n too large
     ok
     1 items had no tests:
         __main__._test
     2 items passed all tests:
        1 tests in __main__
        8 tests in __main__.factorial
     9 tests in 3 items.
     9 passed and 0 failed.
     Test passed.
     $

これが、`doctest' を使って生産性の向上を目指す上で知っておく
必要があることの全てです！
さあやってみましょう。詳細な事柄は後続の各節で全て説明しています。
doctest の例は、標準の Python テストスイートやライブラリ中に
沢山あります。標準のテストファイル `Lib/test/test_doctest.py'
には、特に便利な例題があります。

`doctest.py' 内の docstring には `doctest' の全ての側面に
ついての詳細な情報が入っており、ここではより重要な点をカバーするだけに
します。

* Menu:

* 簡単な利用法 docstring 中の例題をチェックする::
* 簡単な利用法 テキストファイル中の例題をチェックする::
* doctest のからくり::
* ドキュメンテーション文字列内の例をどうやって認識するのか?::
* 実行コンテキストとは何か?::
* 例外はどう扱えばよいのですか?::
* 基本 API::
* 単位テスト API::
* 拡張 API::
* デバッグ::
* 提言::
* 進んだ使い方::


File: python-lib-jp.info,  Node: 簡単な利用法 docstring 中の例題をチェックする,  Next: 簡単な利用法 テキストファイル中の例題をチェックする,  Prev: doctest,  Up: doctest

23.2.1 簡単な利用法: docstring 中の例題をチェックする
-----------------------------------------------------

doctest を試す簡単な方法、(とはいえ、いつもそうする必要はないのですが)
は、各モジュール `M' の最後を、以下:

     def _test():
         import doctest, M
         doctest.testmod()

     if __name__ == "__main__":
         _test()

のようにして締めくくるやりかたです。

こうすると、`doctest' は`M' 中の docstring を検査します。
モジュールをスクリプトとして実行すると、 docstring 中の例題が実行
され、検証されます:

     python M.py

ドキュメンテーション文字列に書かれた例の実行が失敗しない限り、何も
表示されません。失敗すると、失敗した例と、その原因が
(場合によっては複数) 標準出力に印字され、最後に`***Test Failed*** N
failures.' という行を出力します。ここで、N は失敗した例題の数です。

一方、`-v' スイッチをつけて走らせると:

     python M.py -v

実行を試みた全ての例について詳細に報告し、最後に各種まとめをおこなった
内容が標準出力に印字されます。

`verbose=True' を `testmod()' に渡せば、 詳細報告 (verbose)
モードを強制できます。また、 `verbose=False'
にすれば禁止できます。どちらの場合にも、 `testmod()' は `sys.argv'
上のスイッチ を調べません。(従って、`-v' をつけても効果はありません)。

`testmod()' の詳しい情報は*Note 基本 API:: 節を 参照してください。


File: python-lib-jp.info,  Node: 簡単な利用法 テキストファイル中の例題をチェックする,  Next: doctest のからくり,  Prev: 簡単な利用法 docstring 中の例題をチェックする,  Up: doctest

23.2.2 簡単な利用法: テキストファイル中の例題をチェックする
-----------------------------------------------------------

doctest のもう一つの簡単な用途は、テキストファイル中にある対話操作の
例に対するテストです。これには `testfile()' 関数を使います:

     import doctest
     doctest.testfile("example.txt")

この短いスクリプトは、`example.txt' というファイルの中に入っている
対話モードの Python 操作例全てを実行して、その内容を検証します。
ファイルの内容は一つの巨大な docstring であるかのように扱われます;
ファイルが Python プログラムでなくてもよいのです！ 例えば、
`example.txt' には以下のような内容が入っているかもしれません:

     The ``example`` module
     ======================

     Using ``factorial``
     -------------------
     This is an example text file in reStructuredText format.  First import
     ``factorial`` from the ``example`` module:

         >>> from example import factorial

     Now use it:

         >>> factorial(6)
         120

`doctest.testfile("example.txt")' を実行すると、
このドキュメント内のエラーを見つけ出します:

     File "./example.txt", line 14, in example.txt
     Failed example:
         factorial(6)
     Expected:
         120
     Got:
         720

`testmod()' と同じく、`testfile()' は例題が失敗しない
限り何も表示しません。例題が失敗すると、失敗した例題とその原因が
(場合によっては複数) `testmod()' と同じ書式で標準出力に 書き出されます。

デフォルトでは、`testfile()' は自分自身を呼び出した
モジュールのあるディレクトリを探します。その他の場所にあるファイルを
見に行くように`testfile()' に指示するためのオプション引数に
ついての説明は *Note 基本 API:: 節を参照してください。

`testmod()' と同様、コマンドラインオプション`-v'
またはオプションのキーワード引数 VERBOSE を使うと、 `testfile()'
の冗長度を設定できます。

`testfile()' の詳細は*Note 基本 API:: 節を参照してください。


File: python-lib-jp.info,  Node: doctest のからくり,  Next: ドキュメンテーション文字列内の例をどうやって認識するのか?,  Prev: 簡単な利用法 テキストファイル中の例題をチェックする,  Up: doctest

23.2.3 doctest のからくり
-------------------------

この節では、doctest のからくり: どの docstring を見に行くのか、
どうやって対話操作例を見つけ出すのか、どんな実行コンテキストを使うのか、
例外をどう扱うか、上記の振る舞いを制御するためにどのような
オプションフラグを使うか、について詳しく吟味します。こうした情報は、
doctest に対応した例題を書くために必要な知識です; 書いた例題に対して
実際に doctest を実行する上で必要な情報については後続の節を参照して
ください。

* Menu:

* どのドキュメンテーション文字列が検証されるのか?::


File: python-lib-jp.info,  Node: どのドキュメンテーション文字列が検証されるのか?,  Prev: doctest のからくり,  Up: doctest のからくり

23.2.3.1 どのドキュメンテーション文字列が検証されるのか?
........................................................

モジュールのドキュメンテーション文字列、
全ての関数、クラスおよびメソッドのドキュメンテーション文字列が
検索されます。モジュールに import されたオブジェクトは 検索されません。

加えて、 `M.__test__' が存在し、 "真の値を持つ" 場合、
この値は辞書で、辞書の各エントリは (文字列の) 名前を
関数オブジェクト、クラスオブジェクト、または文字列に対応付けて
いなくてはなりません。`M.__test__' から得られた関数および
クラスオブジェクトのドキュメンテーション文字列は、その名前が
プライベートなものでも検索され、文字列の場合にはそれが
ドキュメンテーション文字列であるかのように直接検索を行います。
出力においては、`M.__test__' におけるキー `K' は、

     <name of M>.__test__.K

のように表示されます。

検索中に見つかったクラスも同様に再帰的に検索が行われ、
クラスに含まれているメソッドおよびネストされたクラスについて
ドキュメンテーション文字列のテストが行われます。

_Changed in Python version 2.4_


File: python-lib-jp.info,  Node: ドキュメンテーション文字列内の例をどうやって認識するのか?,  Next: 実行コンテキストとは何か?,  Prev: doctest のからくり,  Up: doctest

23.2.4 ドキュメンテーション文字列内の例をどうやって認識するのか?
----------------------------------------------------------------

ほとんどの場合、対話コンソールセッション上でのコピー／ペーストはうまく
動作します。とはいえ、 `doctest' は特定の Python シェルの振る舞い
を正確にエミュレーションしようとするわけではありません。ハードタブは
全て 8 カラムのタブストップを使ってスペースに展開されます。従って、
タブがそのように表現されると考えておかないととまずいことになります:
その場合は、ハードタブを使わないか、自前で `DocTestParser'
クラスを書いてください。

_Changed in Python version 2.4_

     >>> # comments are ignored
     >>> x = 12
     >>> x
     12
     >>> if x == 13:
     ...     print "yes"
     ... else:
     ...     print "no"
     ...     print "NO"
     ...     print "NO!!!"
     ...
     no
     NO
     NO!!!
     >>>

出力結果例  (expected output) は、コードを含む最後の `'>>>~'' or
`'...~'' 行の直下に続きます。 また、出力結果例 (がある場合) は、次の
`'>>>~'' 行か、全て空白文字の行まで続きます。

細かな注意:

   *
     出力結果例には、全て空白の行が入っていてはなりません。そのような行は
     出力結果例の終了を表すと見なされるからです。もし予想出力結果の内容
     に空白行が入っている場合には、空白行が入るべき場所全てに
     `<BLANKLINE>' を入れてください。 _Changed in Python version 2.4_

   * stdout への出力は取り込まれますが、stderr は取り込まれません (例外
     発生時のトレースバックは別の方法で取り込まれます)。

   *
     対話セッションにおいて、バックスラッシュを用いて次の行に続ける場合や、
     その他の理由でバックスラッシュを用いる場合、raw docstring を使って
     バックスラッシュを入力どおりに扱わせるようにせねばなりません:

          >>> def f(x):
          ...     r'''Backslashes in a raw docstring: m\n'''
          >>> print f.__doc__
          Backslashes in a raw docstring: m\n

     こうしなければ、バックスラッシュは文字列の一部として解釈されてしまいます。
     例えば、上の例の "{\}" は改行文字として認識されてしまうでしょう。
     こうする代わりに、(raw docstring を使わずに) doctest 版の中では
     バックスラッシュを全て二重にしてもかまいません:

          >>> def f(x):
          ...     '''Backslashes in a raw docstring: m\\n'''
          >>> print f.__doc__
          Backslashes in a raw docstring: m\n

   * 開始カラムはどこでもかまいません:

            >>> assert "Easy!"
                  >>> import math
                      >>> math.floor(1.9)
                      1.0

     出力結果例の先頭部にある空白文字列は、例題の開始部分にあたる
     `'>>>~'' 行の先頭にある空白文字列と同じだけはぎとられます。


File: python-lib-jp.info,  Node: 実行コンテキストとは何か?,  Next: 例外はどう扱えばよいのですか?,  Prev: ドキュメンテーション文字列内の例をどうやって認識するのか?,  Up: doctest

23.2.5 実行コンテキストとは何か?
--------------------------------

デフォルトでは、`doctest' はテストを行うべき docstring を見つけるたびに
`M' のグローバル名前空間の_浅いコピー_
を使い、テストの実行によってモジュール
の実際のグローバル名前空間を変更しないようにし、かつ`M' 内で
行ったテストが痕跡を残して偶発的に別のテストを誤って動作させないように
しています。従って、例題中では `M' 内のトップレベルで定義された
すべての名前と、docstring ドキュメンテーション文字列が動作する以前に
定義された名前を自由に使えます。個々の例題は他の docstring 中で
定義された名前を参照できません。

`testmod()' や `testfile()'に `globs=your_dict' を
渡し、自前の辞書を実行コンテキストとして使うこともできます。


File: python-lib-jp.info,  Node: 例外はどう扱えばよいのですか?,  Next: 基本 API,  Prev: 実行コンテキストとは何か?,  Up: doctest

23.2.6 例外はどう扱えばよいのですか?
------------------------------------

例で生成される出力がトレースバックのみである限り問題ありません:
単にトレースバックを貼り付けてください。(1) トレースバックには、
頻繁に変更されがちな情報が入っている (例えばファイルパスや行番号など)
ものなので、受け入れるべきテスト結果に柔軟性を持たせようと doctest が
苦労している部分の一つです。

簡単な例を示しましょう:

     >>> [1, 2, 3].remove(42)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: list.remove(x): x not in list
     >>>

この doctest は `ValueError' が送出され、かつ詳細情報に
`list.remove(x): x not in list' が入っている場合にのみ成功します。

例外が発生したときの予想出力はトレースバックヘッダから始まっていなければ
なりません。トレースバックの形式は以下の二通りの行のいずれかでよく、
例題の最初の行と同じインデントでなければりません:

     Traceback (most recent call last):
     Traceback (innermost last):

トレースバックヘッダの後ろにトレースバックスタックを続けてもかまいませんが、
doctest
はその内容を無視します。普通はトレースバックスタックを無視するか、
対話セッションからそのままコピーしてきます。

トレースバックスタックの後ろにはもっとも有意義な部分、例外の型と
詳細情報の入った行があります。通常、この行はトレースバックの末尾
にあるのですが、例外が複数行の詳細情報を持っている場合、複数の行
にわたることもあります:

     >>> raise ValueError('multi\n    line\ndetail')
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: multi
         line
     detail

上の例では、最後の 3 行 (`ValueError' から始まる行)
における例外の型と詳細情報だけが比較され、それ以外の部分は無視
されます。

例外を扱うコツは、例題をドキュメントとして読む上で明らかに価値の
ある情報でない限り、トレースバックスタックは無視する、ということ
です。従って、先ほどの例は以下のように書くべきでしょう:

     >>> raise ValueError('multi\n    line\ndetail')
     Traceback (most recent call last):
         ...
     ValueError: multi
         line
     detail

トレースバックの扱いは非常に特殊なので注意してください。特に、
上の書き直した例題では、`...' の扱いが doctest の `ELLIPSIS'
オプションによって変わります。この例での省略記号
は何かの省略を表しているかもしれませんし、コンマや数字が 3 個 (または
300 個かもしれませんし、Monty Python のスキットをインデントして
書き写したものかもしれません。

以下の詳細はずっと覚えておく必要はないのですが、一度目を通しておいて
ください:

   * doctest は予想出力の出所が print 文なのか例外なのかを推測
     できません。従って、例えば予想出力が `ValueError: 42 is prime'
     であるような例題は、`ValueError' が実際に送出された
     場合と、万が一予想出力と同じ文字列を print した場合の両方で
     パスしてしまいます。現実的には、通常の出力がトレースバックヘッダ
     から始まることはないので、さしたる問題にはなりません。

   * トレースバックスタック (がある場合) の各行は、例題の最初の行
     よりも深くインデントされているか、_または_ 英数文字以外で
     始まっていなければなりません。トレースバックヘッダ以後に現れる行の
     うち、インデントが等しく英数文字で始まる最初の行は例外の詳細情報
     が書かれた行とみなされるからです。もちろん、通常のトレースバックでは
     全く正しく動作します。

   * doctest のオプション`IGNORE_EXCEPTION_DETAIL' を指定
     した場合、最も左端のコロン以後の内容が無視されます。

   * 対話シェルでは、`SyntaxError' の場合にトレースバック
     ヘッダを無視することがあります。しかし doctest
     にとっては、例外を例外で
     ないものと区別するためにトレースバックヘッダが必要です。
     そこで、トレースバックヘッダを省略するような`SyntaxError'
     をテストする必要があるというごく稀なケースでは、例題に自分で作った
     トレースバックヘッダを追加する必要があるでしょう。

   * `SyntaxError' の場合、 Python は構文エラーの起きた 場所を`^'
     マーカで表示します:

          >>> 1 1
            File "<stdin>", line 1
              1 1
                ^
          SyntaxError: invalid syntax

     例外の型と詳細情報の前にエラー位置を示す行がくるため、 doctest は
     この行を調べません。例えば、以下の例では、間違った場所に`^'
     マーカを入れてもパスしてしまいます:

          >>> 1 1
          Traceback (most recent call last):
            File "<stdin>", line 1
              1 1
              ^
          SyntaxError: invalid syntax


_Changed in Python version 2.4_

* Menu:

* オプションフラグとディレクティブ::
* 注意::

---------- Footnotes ----------

(1) 予想出力結果
と例外の両方を含んだ例はサポートされていません。一方の終わりと
他方の始まりを見分けようとするのはエラーの元になりがちですし、
解りにくいテストになってしまいます。


File: python-lib-jp.info,  Node: オプションフラグとディレクティブ,  Next: 注意,  Prev: 例外はどう扱えばよいのですか?,  Up: 例外はどう扱えばよいのですか?

23.2.6.1 オプションフラグとディレクティブ
.........................................

doctest では、その挙動の様々な側面をたくさんのオプションフラグで制御
しています。各フラグのシンボル名はモジュールの定数として提供されて
おり、論理和で組み合わせて様々な関数に渡せるようになっています。
シンボル名は doctest のディレクティブ (directive, 下記参照) としても
使えます。

最初に説明するオプション群は、 テストのセマンティクスを決めます。
すなわち、実際にテストを実行したときの出力と例題中の予想出力とが
一致しているかどうかを doctest がどうやって判断するかを制御します:

`DONT_ACCEPT_TRUE_FOR_1'
     デフォルトでは、予想出力ブロックに単に`1' だけが入っており、
     実際の出力ブロックに `1' または `True' だけが入って
     いた場合、これらの出力は一致しているとみなされます。 `0' と
     `False' の場合も同様です。 `DONT_ACCEPT_TRUE_FOR_1'
     を指定すると、こうした値の読み替え
     を行いません。デフォルトの挙動で読み替えを行うのは、最近の Python
     で
     多くの関数の戻り値型が整数型からブール型に変更されたことに対応する
     ためです; 読み替えを行う場合、"通常の整数" の出力を予想出力とする
     ような doctest
     も動作します。このオプションはそのうち無くなるでしょうが、
     ここ数年はそのままでしょう。

`DONT_ACCEPT_BLANKLINE'
     デフォルトでは、予想出力ブロックに `<BLANKLINE>' だけの
     入った行がある場合、その行は実際の出力における空行に一致する
     ようになります。完全な空行を入れてしまうと予想出力がそこで
     終わっているとみなされてしまうため、空行を予想出力に入れたい
     場合にはこの方法を使わねばなりません。 `DONT_ACCEPT_BLANKLINE'
     を指定すると、 `<BLANKLINE>' の読み替えを行わなくなります。

`NORMALIZE_WHITESPACE'
     このフラグを指定すると、空白 (空白と改行文字)
     の列は互いに等価であると
     みなします。予想出力における任意の空白列は実際の出力における任意の
     空白と一致します。デフォルトでは、空白は厳密に一致せねばなりません。
     `NORMALIZE_WHITESPACE' は、予想出力の内容が非常に長いために、
     ソースコード中でその内容を複数行に折り返して書きたい場合に特に便利です。

`ELLIPSIS'
     このフラグを指定すると、予想出力中の省略記号マーカ (`...')
     を実際の出力中の任意の部分文字列に一致させられます。部分文字列は
     行境界にわたるものや空文字列を含みます。従って、このフラグを使うのは
     単純な内容を対象にする場合にとどめましょう。複雑な使い方をすると、
     正規表現に ".*" を使ったときのように
     "あらら、省略部分をマッチがえてる (match too much) ！"
     と驚くことになりかねません。

`IGNORE_EXCEPTION_DETAIL'
     このフラグを指定すると、予想される実行結果に例外が入るような例題で、
     予想通りの型の例外が送出された場合に、例外の詳細情報が一致していなくても
     テストをパスさせます。例えば、予想出力が`ValueError: 42'
     であるような例題は、実際に送出された例外が`ValueError: 3*14' でも
     パスしますが、`TypeError' が送出されるといった場合には
     パスしません。

     `ELLIPSIS' を使っても同様のことができ、 `IGNORE_EXCEPTION_DETAIL'
     は リリース 2.4 以前の Python
     を使う人がほとんどいなくなった時期を見計らって撤廃するかもしれないので
     気をつけてください。それまでは、`IGNORE_EXCEPTION_DETAIL' は 2.4
     以前の Python
     で例外の詳細については気にせずテストをパスさせるように doctest
     を書くための唯一の明確な方法です。例えば、

          >>> (1, 2)[3] = 'moo' #doctest: +IGNORE_EXCEPTION_DETAIL
          Traceback (most recent call last):
            File "<stdin>", line 1, in ?
          TypeError: object doesn't support item assignment

     にすると、 Python 2.4 と Python 2.3
     の両方でテストをパスさせられます。 というのは、例外の詳細情報は
     2.4 で変更され、 "doesn't" から "does not"
     と書くようになったからです。


`SKIP'
     このフラグを指定すると、例題は一切実行されません。こうした機能 は
     doctest の実行例がドキュメントとテストを兼ねていて、ドキュメントの
     ためには含めておかなければならないけれどチェックされなくても良い、と
     いうような文脈で役に立ちます。例えば、実行例の出力がランダムであると
     か、テスト機構には手が届かない資源に依存している場合などです。

     SKIP フラグは一時的に例題を"コメントアウト"するのにも使えます。


`COMPARISON_FLAGS'
     上記の比較フラグ全ての論理和をとったビットマスクです。

二つ目のオプション群は、テストの失敗を報告する方法を制御します:

`REPORT_UDIFF'
     このオプションを指定すると、複数行にわたる予想出力や実際の出力
     を、一元化 (unified) diff を使って表示します。

`REPORT_CDIFF'
     このオプションを指定すると、複数行にわたる予想出力や実際の出力
     を、コンテキスト diff を使って表示します。

`REPORT_NDIFF'
     このオプションを指定すると、予想出力と実際の出力との間の差分を
     よく知られている`ndiff.py' ユーティリティと同じアルゴリズムを
     使っている `difflib.Differ' で分析します。これは、行単位の差分
     と同じように行内の差分にマーカをつけられるようにする唯一の手段です。
     例えば、予想出力のある行に数字の `1' が入っていて、実際の出力 には
     `l' が入っている場合、不一致のおきているカラム位置を
     示すキャレットの入った行が一行挿入されます。

`REPORT_ONLY_FIRST_FAILURE'
     このオプションを指定すると、各 doctest で最初にエラーの起きた例題
     だけを表示し、それ以後の例題の出力を抑制します。これにより、正しく
     書かれた例題が、それ以前の例題の失敗によっておかしくなってしまった
     場合に、doctest がそれを報告しないようになります。とはいえ、
     最初に失敗を引き起こした例題とは関係なく誤って書かれた例題の
     報告も抑制してしまいます。`REPORT_ONLY_FIRST_FAILURE' を
     指定した場合、例題がどこかで失敗しても、それ以後の例題を続けて実行し、
     失敗したテストの総数を報告します; 出力が抑制されるだけです。

`REPORTING_FLAGS'
     上記のエラー報告に関するフラグ全ての論理和をとったビットマスクです。

「doctest ディレクティブ」を使うと、個々の例題に対してオプションフラグ
の設定を変更できます。 doctest ディレクティブは特殊な Python コメント文
として表現され、例題のソースコードの後に続けます:

     [doctest]

`directive "#" "doctest:" `directive_options''

`directive_options `directive_option' ("," `directive_option')*'

`directive_option `on_or_off' `directive_option_name''

`on_or_off "+" | "-"'

`directive_option_name "DONT_ACCEPT_BLANKLINE" | "NORMALIZE_WHITESPACE" | ...'

`+' や`-' とディレクティブオプション名の間に空白を入れては
なりません。ディレクティブオプション名は上で説明したオプションフラグ名
のいずれかです。

ある例題の doctest ディレクティブは、その例題だけの doctest の
振る舞いを変えます。ある特定の挙動を有効にしたければ `+' を、
無効にしたければ `-' を使います。

例えば、以下のテストはパスします:

     >>> print range(20) #doctest: +NORMALIZE_WHITESPACE
     [0,   1,  2,  3,  4,  5,  6,  7,  8,  9,
     10,  11, 12, 13, 14, 15, 16, 17, 18, 19]

ディレクティブがない場合、実際の出力には一桁の数字の間に二つスペースが
入っていないこと、実際の出力は 1 行になることから、テストはパスしない
はずです。別のディレクティブを使って、このテストをパスさせることも
できます:

     >>> print range(20) # doctest:+ELLIPSIS
     [0, 1, ..., 18, 19]

複数のディレクティブは、一つの物理行の中にコンマで区切って指定できます:

     >>> print range(20) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
     [0,    1, ...,   18,    19]

一つの例題中で複数のディレクティブコメントを使った場合、それらは
組み合わされます:

     >>> print range(20) # doctest: +ELLIPSIS
     ...                 # doctest: +NORMALIZE_WHITESPACE
     [0,    1, ...,   18,    19]

前の例題で示したように、`...' の後ろにディレクティブだけの
入った行を例題のうしろに追加して書けます。この書きかたは、
例題が長すぎるためにディレクティブを同じ行に入れると収まりが悪い
場合に便利です:

     >>> print range(5) + range(10,20) + range(30,40) + range(50,60)
     ... # doctest: +ELLIPSIS
     [0, ..., 4, 10, ..., 19, 30, ..., 39, 50, ..., 59]

デフォルトでは全てのオプションが無効になっており、ディレクティブは
特定の例題だけに影響を及ぼすので、通常意味があるのは有効にするための
オプション(`+' のついたディレクティブ) だけです。とはいえ、 doctest
を実行する関数はオプションフラグを指定してデフォルトとは
異なった挙動を実現できるので、そのような場合には `-' を使った
無効化オプションも意味を持ちます。

_Changed in Python version 2.4_ _Changed in Python version 2.5_

新たなオプションフラグ名を登録する方法もありますが、`doctest'
の内部をサブクラスで拡張しない限り、意味はないでしょう:

`register_optionflag(name)'
     名前NAME の新たなオプションフラグを作成し、作成されたフラグの
     整数値を返します。`register_optionflag()' は `OutputChecker' や
     `DocTestRunner' をサブクラス化して、
     その中で新たに作成したオプションをサポートさせる際に使います。
     `register_optionflag' は以下のような定形文で呼び出さねば
     なりません:

            MY_FLAG = register_optionflag('MY_FLAG')

     _Added in Python version 2.4_


File: python-lib-jp.info,  Node: 注意,  Prev: オプションフラグとディレクティブ,  Up: 例外はどう扱えばよいのですか?

23.2.6.2 注意
.............

`doctest' では、予想出力に対する厳密な一致を厳しく求めて
います。一致しない文字が一文字でもあると、テストは失敗してしまいます。
このため、Python が出力に関して何を保証していて、何を保証していないかを
正確に知っていないと幾度か混乱させられることでしょう。
例えば、辞書を出力する際、Python はキーと値のペアが常に特定の順番で
並ぶよう保証してはいません。従って、以下のようなテスト

     >>> foo()
     {"Hermione": "hippogryph", "Harry": "broomstick"}

は失敗するかもしれないのです! 回避するには

     >>> foo() == {"Hermione": "hippogryph", "Harry": "broomstick"}
     True

とするのが一つのやり方です。別のやり方は、

     >>> d = foo().items()
     >>> d.sort()
     >>> d
     [('Harry', 'broomstick'), ('Hermione', 'hippogryph')]

です。

他にもありますが、自分で考えてみてください。

以下のように、オブジェクトアドレスを埋め込むような結果を print
するのもよくありません:

     >>> id(1.0) # certain to fail some of the time
     7948648
     >>> class C: pass
     >>> C()   # the default repr() for instances embeds an address
     <__main__.C instance at 0x00AC18F0>

`ELLIPSIS' ディレクティブを使うと、上のような例をうまく解決 できます:

     >>> C() #doctest: +ELLIPSIS
     <__main__.C instance at 0x...>

浮動小数点数もまた、プラットフォーム間での微妙な出力の違いの原因となり
ます。というのも、Python は浮動小数点の書式化をプラットフォームの C
ライブラリにゆだねており、この点では、C ライブラリはプラットフォーム間で
非常に大きく異なっているからです。

     >>> 1./7  # risky
     0.14285714285714285
     >>> print 1./7 # safer
     0.142857142857
     >>> print round(1./7, 6) # much safer
     0.142857

`I/2.**J' の形式になる数値はどのプラットフォームでもうまく
動作するので、私はこの形式の数値を生成するように doctest の例題を
工夫しています:

     >>> 3./4  # utterly safe
     0.75

このように、単分数 (simple fraction) を使えば、人間にとっても
理解しやすくよいドキュメントになります。


File: python-lib-jp.info,  Node: 基本 API,  Next: 単位テスト API,  Prev: 例外はどう扱えばよいのですか?,  Up: doctest

23.2.7 基本 API
---------------

関数 `testmod()' および `testfile()' は、
基本的なほとんどの用途に十分な doctest インタフェースを提供しています。
これら二つの関数についてもっとくだけた説明を読みたければ、 *Note
簡単な利用法 docstring 中の例題をチェックする:: 節および *Note
簡単な利用法 テキストファイル中の例題をチェックする:: 節
を参照してください。

`testfile(filename[, module_relative][, name][, package][, globs][, verbose][, report][, optionflags][, extraglobs][, raise_on_error][, parser][, encoding])'
     FILENAME 以外の引数は全てオプションで、キーワード引数形式で
     指定せねばなりません。

     FILENAME に指定したファイル内にある例題をテストします。
     `(FAILURE_COUNT, TEST_COUNT)' を返します。

     オプション引数の MODULE_RELATIVE は、ファイル名をどのように
     解釈するかを指定します:

        * MODULE_RELATIVE が `True' (デフォルト) の場合、 FILENAME は
          OS に依存しないモジュールの相対パスになります。
          デフォルトでは、このパスは関数 `testfile' を呼び出して
          いるモジュールからの相対パスになります; ただし、PACKAGE
          引数を指定した場合には、パッケージからの相対になります。 OS
          への依存性を除くため、FILENAME ではパスを分割する 文字に`/'
          を使わねばならず、絶対パスにしてはなりません (パス文字列を`/'
          で始めてはなりません)。

        * MODULE_RELATIVE が `False' の場合、FILENAME は OS
          依存のパスを示します。パスは絶対パスでも相対パスでも
          かまいません; 相対パスにした場合、現在の作業ディレクトリを
          基準に解決します。

     オプション引数 NAME には、テストの名前を指定します; デフォルトの
     場合や `None' を指定した場合、 `os.path.basename(FILENAME)'
     になります。

     オプション引数 PACKAGE には、 Python パッケージを指定するか、
     モジュール相対のファイル名の場合には相対の基準ディレクトリとなる
     Python パッケージの名前を指定します。パッケージを指定しない倍、
     関数を呼び出しているモジュールのディレクトリを相対の基準
     ディレクトリとして使います。MODULE_RELATIVE を`False'
     に指定している場合、PACKAGE を指定するとエラーになります。

     オプション引数GLOBS には辞書を指定します。この辞書は、
     例題を実行する際のグローバル変数として用いられます。 doctest
     はこの辞書の浅いコピーを生成するので、例題は白紙の
     状態からスタートします。デフォルトの場合や`None' を指定
     した場合、新たな空の辞書になります。

     オプション引数 EXTRAGLOBS には辞書を指定します。この辞書は、
     例題を実行する際にグローバル変数にマージされます。マージは
     `dict.update()' のように振舞います: GLOBS と EXTRAGLOBS
     との間に同じキー値がある場合、両者を合わせた 辞書中にはEXTRAGLOBS
     の方の値が入ります。この仕様は、 パラメタ付きで doctest
     を実行するという、やや進んだ機能です。
     例えば、一般的な名前を使って基底クラス向けに doctest を書いておき、
     その後で辞書で一般的な名前からテストしたいサブクラスへの対応付けを
     行う辞書をEXTRAGLOBS に渡して、様々なサブクラスをテスト できます。

     オプション引数 VERBOSE が真の場合、様々な情報を出力します。
     偽の場合にはテストの失敗だけを報告します。デフォルトの場合や `None'
     を指定した場合、`sys.argv' に `-v' を指定しない限り
     この値は真になりません。

     オプション引数REPORT が真の場合、テストの最後にサマリを
     出力します。それ以外の場合には何も出力しません。verbose モードの
     場合、サマリには詳細な情報を出力しますが、そうでない場合には
     サマリはとても簡潔になります
     (実際には、全てのテストが成功した場合には 何も出力しません)。

     オプション引数 OPTIONFLAGS は、各オプションフラグの論理和を
     とった値を指定します。*Note オプションフラグとディレクティブ::
     節を参照してください。

     オプション引数 RAISE_ON_ERROR の値はデフォルトでは偽です。
     真にすると、最初のテスト失敗や予期しない例外が起きたときに例外を
     送出します。このオプションを使うと、失敗の原因を検死デバッグ
     (post-mortem debug) できます。デフォルトの動作では、例題の実行を
     継続します。

     オプション引数 PARSER には、`DocTestParser' (または
     そのサブクラス) を指定します。このクラスはファイルから例題を抽出
     するために使われます。デフォルトでは通常のパーザ
     (``DocTestParser'()') です。

     オプション引数 ENCODING
     にはファイルをユニコードに変換する際に使われる
     エンコーディングを指定します。

     _Added in Python version 2.4_

     _Changed in Python version 2.5_


`testmod([m][, name][, globs][, verbose][, report][, optionflags][, extraglobs][, raise_on_error][, exclude_empty])'
     引数は全てオプションで、M以外の引数はキーワード引数として
     指定せねばなりません。

     モジュール M (M を指定しないか`None' にした場合には `__main__')
     から到達可能な関数およびクラスの docstring 内に
     ある例題をテストします。`M.__doc__' 内の例題からテストを
     開始します。

     また、辞書 `M.__test__' が存在し、`None' で
     ない場合、この辞書から到達できる例題もテストします。 `M.__test__'
     は、(文字列の) 名前から関数、クラスおよび
     文字列への対応付けを行っています。関数およびクラスの場合には、
     その docstring 内から例題を検索します。文字列の場合には、docstring
     と同じようにして例題の検索を直接実行します。

     モジュールM に属するオブジェクトにつけられた docstrings のみを
     検索します。

     `(FAILURE_COUNT, TEST_COUNT)' を返します。

     オプション引数 NAME には、モジュールの名前を指定します。
     デフォルトの場合や`None' を指定した場合には、 `M.__name__'
     を使います。

     オプション引数 EXCLUDE_EMPTY はデフォルトでは偽になっています。
     この値を真にすると、doctest を持たないオブジェクトを考慮から
     外します。デフォルトの設定は依存のバージョンとの互換性を考えたハック
     であり、`doctest.master.summarize()' と `testmod()' を
     合わせて利用しているようなコードでも、テスト例題を持たないオブジェクト
     から出力を得るようにしています。 新たに追加された`DocTestFinder'
     のコンストラクタの EXCLUDE_EMPTY はデフォルトで真になります。

     オプション引数 EXTRAGLOBS, VERBOSE, REPORT, OPTIONFLAGS,
     RAISE_ON_ERROR, および GLOBS は 上で説明した `testfile()'
     の引数と同じです。ただし、 GLOBS のデフォルト値は`M.__dict__'
     になります。

     _Changed in Python version 2.3_

     _Changed in Python version 2.4_

     _Changed in Python version 2.5_

単一のオブジェクトに関連付けられた doctest を実行するための関数も
あります。この関数は以前のバージョンとの互換性のために提供されて
います。この関数を撤廃する予定はありませんが、役に立つことは
ほとんどありません:

`run_docstring_examples(f, globs[, verbose][, name][, compileflags][, optionflags])'
     オブジェクト F に関連付けられた例題をテストします。 F
     はモジュール、関数、またはクラスオブジェクトです。

     引数GLOBS に辞書を指定すると、その浅いコピーを実行コンテキスト
     に使います。

     オプション引数NAME はテスト失敗時のメッセージに使われます。
     デフォルトの値は `NoName' です。

     オプション引数 VERBOSE の値を真にすると、テストが失敗しなくても
     出力を生成します。デフォルトでは、例題のテストに失敗したときのみ
     出力を生成します。

     オプション引数COMPILEFLAGS には、例題を実行するときに Python
     バイトコードコンパイラが使うフラグを指定します。デフォルトの場合や
     `None' を指定した場合、フラグはGLOBS 内にある future
     機能セットに対応したものになります。

     オプション引数 OPTIONFLAGS は、上で述べた`testfile()'
     と同様の働きをします。


File: python-lib-jp.info,  Node: 単位テスト API,  Next: 拡張 API,  Prev: 基本 API,  Up: doctest

23.2.8 単位テスト API
---------------------

doctest 化したモジュールのコレクションが増えるにつれ、全ての doctest を
システマティックに実行したいと思うようになるはずです。 Python 2.4
以前の `doctest' には `Tester' という
ほとんどドキュメント化されていないクラスがあり、複数のモジュールの
doctest を統合する初歩的な手段を提供していました。 `Tester'
は非力であり、実際のところ、もっときちんとした Python の
テストフレームワークが `unittest' モジュールで構築されており、
複数のソースコードからのテストを統合する柔軟な方法を提供しています。
そこで Python 2.4 では `doctest' の `Tester' クラスを
撤廃し、モジュールや doctest の入ったテキストファイルから `unittest'
テストスイートを作成できるような二つの関数を `doctest'
側で提供するようにしました。 こうしたテストスイートは、`unittest'
のテストランナを 使って実行できます:

     import unittest
     import doctest
     import my_module_with_doctests, and_another

     suite = unittest.TestSuite()
     for mod in my_module_with_doctests, and_another:
         suite.addTest(doctest.DocTestSuite(mod))
     runner = unittest.TextTestRunner()
     runner.run(suite)

doctest の入ったテキストファイルやモジュールから ``unittest'.TestSuite'
インスタンスを生成するための 主な関数は二つあります:

`DocFileSuite([module_relative][, package][, setUp][, tearDown][, globs][, optionflags][, parser][, encoding])'
     単一または複数のテキストファイルに入っている doctest
     形式のテストを、 ``unittest'.TestSuite' インスタンスに変換します。

     この関数の返す``unittest'.TestSuite' インスタンスは、 unittest
     フレームワークで動作させ、各ファイルの例題を対話的に実行する
     ためのものです。ファイル内の何らかの例題の実行に失敗すると、この関数で
     生成した単位テストは失敗し、該当するテストの入っているファイルの名前と、
     (場合によりだいたいの) 行番号の入った`failureException' 例外を
     送出します。

     関数には、テストを行いたい一つまたは複数のファイルへのパスを
     (文字列で) 渡します。

     `DocFileSuite' には、キーワード引数でオプションを指定できます:

     オプション引数MODULE_RELATIVE はPATHS に指定したファイル名を
     どのように解釈するかを指定します:

        * MODULE_RELATIVE が `True' (デフォルト) の場合、 FILENAME は
          OS に依存しないモジュールの相対パスになります。
          デフォルトでは、このパスは関数 `testfile' を呼び出して
          いるモジュールからの相対パスになります; ただし、PACKAGE
          引数を指定した場合には、パッケージからの相対になります。 OS
          への依存性を除くため、FILENAME ではパスを分割する 文字に`/'
          を使わねばならず、絶対パスにしてはなりません (パス文字列を`/'
          で始めてはなりません)。

        * MODULE_RELATIVE が `False' の場合、FILENAME は OS
          依存のパスを示します。パスは絶対パスでも相対パスでも
          かまいません; 相対パスにした場合、現在の作業ディレクトリを
          基準に解決します。

     オプション引数 PACKAGE には、 Python パッケージを指定するか、
     モジュール相対のファイル名の場合には相対の基準ディレクトリとなる
     Python パッケージの名前を指定します。パッケージを指定しない倍、
     関数を呼び出しているモジュールのディレクトリを相対の基準
     ディレクトリとして使います。MODULE_RELATIVE を`False'
     に指定している場合、PACKAGE を指定するとエラーになります。

     オプション引数 SETUP には、テストスイートのセットアップに使う
     関数を指定します。この関数は、各ファイルのテストを実行する前に
     呼び出されます。 SETUP 関数は `DocTest' オブジェクトに
     引き渡されます。SETUP はGLOBS 属性を介してテストの
     グローバル変数にアクセスできます。

     オプション引数 TEARDOWN には、テストを解体 (tear-down) する
     ための関数を指定します。この関数は、各ファイルのテストの実行を
     終了するたびに呼び出されます。TEARDOWN関数は `DocTest'
     オブジェクトに引き渡されます。TEARDOWN ははGLOBS 属性を
     介してテストのグローバル変数にアクセスできます。

     オプション引数 GLOBS は辞書で、テストのグローバル変数
     の初期値が入ります。この辞書は各テストごとに新たにコピーして使われ
     ます。デフォルトでは GLOBS は空の新たな辞書です。

     オプション引数 OPTIONFLAGS には、テストを実行する際に
     デフォルトで適用される doctest オプションを OR で結合して
     指定します。 *Note オプションフラグとディレクティブ::
     節を参照してください。
     結果レポートに関するオプションの指定する上手いやり方は
     下記の`set_unittest_reportflags()' の説明を参照してください。

     オプション引数 PARSER には、ファイルからテストを抽出するために
     使う`DocTestParser' (またはサブクラス) を指定します。
     デフォルトは通常のパーザ (``DocTestParser'()') です。

     オプション引数 ENCODING
     にはファイルをユニコードに変換する際に使われる
     エンコーディングを指定します。

     _Added in Python version 2.4_

     _Changed in Python version 2.5_

     _Changed in Python version 2.5_


`DocTestSuite([module][, globs][, extraglobs][, test_finder][, setUp][, tearDown][, checker])'
     doctest のテストを ``unittest'.TestSuite' に変換します。

     この関数の返す``unittest'.TestSuite' インスタンスは、 unittest
     フレームワークで動作させ、モジュール内の各 doctest を実行する
     ためのものです。何らかの doctest の実行に失敗すると、この関数で
     生成した単位テストは失敗し、該当するテストの入っているファイルの名前と、
     (場合によりだいたいの) 行番号の入った`failureException' 例外を
     送出します。

     オプション引数 MODULE には、テストしたいモジュールの名前を
     指定します。MODULE にはモジュールオブジェクトまたは (ドット表記の)
     モジュール名を指定できます。MODULE を指定しない場合、この関数を
     呼び出しているモジュールになります。

     オプション引数 GLOBS は辞書で、テストのグローバル変数
     の初期値が入ります。この辞書は各テストごとに新たにコピーして使われ
     ます。デフォルトではGLOB は空の新たな辞書です。

     オプション引数 EXTRAGLOBS には追加のグローバル変数セットを
     指定します。この変数セットは GLOBS に統合されます。
     デフォルトでは、追加のグローバル変数はありません。

     オプション引数 TEST_FINDER は、モジュールから doctest を抽出
     するための `DocTestFinder' オブジェクト (またはその代用となる
     オブジェクト) です。

     オプション引数 SETUP、TEARDOWN、および OPTIONFLAGS は上の
     `DocFileSuite()' と同じです。

     _Added in Python version 2.3_

     _Changed in Python version 2.4_

`DocTestSuite()' は水面下では`doctest.DocTestCase'
インスタンスから``unittest'.TestSuite' を作成しており、 `DocTestCase'
は``unittest'.TestCase' のサブクラス になっています。`DocTestCase'
についてはここでは説明しません (これは内部実装上の詳細だからです)
が、そのコードを調べてみれば、 `unittest'
の組み込みの詳細に関する疑問を解決できるはずです。

同様に、`DocFileSuite()' は`doctest.DocFileCase'
インスタンスから``unittest'.TestSuite' を 作成し、 `DocFileCase' は
`DocTestCase' のサブクラス
になっています。これにははっきりとした訳があります: `doctest'
関数を自分で実行する場合、オプションフラグを `doctest'
関数に渡すことで、`doctest'
のオプションを直接操作できます。しかしながら、`unittest'
フレームワークを書いている場合には、いつどのようにテストを動作させるかを
`unittest' が完全に制御してしまいます。フレームワークの作者は
たいてい、`doctest' のレポートオプションを (コマンドライン
オプションで指定するなどして) 操作したいと考えますが、`unittest'
を介して `doctest' のテストランナにオプションを渡す方法は
存在しないのです。

このため、`doctest' では、以下の関数を使って、 `unittest' サポート
に特化したレポートフラグ表記方法もサポートしています:

`set_unittest_reportflags(flags)'
     `doctest' のレポートフラグをセットします。

     引数FLAGS にはオプションフラグを OR で結合して渡します。 *Note
     オプションフラグとディレクティブ::
     節を参照してください。「レポートフラグ」 しか使えません。

     この関数で設定した内容はモジュール全体にわたる物であり、関数呼び出し
     以後に `unittest' モジュールから実行される全ての doctest
     に影響します: `DocTestCase' の`runTest()' メソッド
     は、`DocTestCase' インスタンスが作成された際に、現在の
     テストケースに指定されたオプションフラグを見に行きます。
     レポートフラグが指定されていない場合
     (通常の場合で、望ましいケースです)、 `doctest' の `unittest'
     レポートフラグが OR で 結合され、doctest
     を実行するために作成される`DocTestRunner'
     インスタンスに渡されます。 `DocTestCase'
     インスタンスを構築する際に何らかのレポートフラグが
     指定されていた場合、`doctest' の`unittest'
     レポートフラグは無視されます。

     この関数は、関数を呼び出す前に有効になっていた`unittest'
     レポートフラグの値を返します。

     _Added in Python version 2.4_


File: python-lib-jp.info,  Node: 拡張 API,  Next: デバッグ,  Prev: 単位テスト API,  Up: doctest

23.2.9 拡張 API
---------------

基本 API は、 doctest を使いやすくするための簡単なラッパであり、
柔軟性があってほとんどのユーザの必要を満たしています; とはいえ、
もっとテストをきめ細かに制御したい場合や、 doctest の機能を
拡張したい場合、拡張 API (advanced API) を使わねばなりません。

拡張 API は、doctest ケースから抽出した対話モードでの例題を
記憶するための二つのコンテナクラスを中心に構成されています:

   * `Example': 一つの Python 実行文と、その予想出力をペアに したもの。

   * `DocTest': `Example' の集まり。通常一つの docstring や
     テキストファイルから抽出されます。

その他に、 doctest の例題を検索、パーズ、実行、チェックするための
処理クラスが以下のように定義されています:

   * `DocTestFinder': 与えられたモジュールから全ての docstring
     を検索し、対話モードでの例題が入った各 docstring から
     `DocTestParser' を使って`DocTest' を生成します。

   * `DocTestParser': (オブジェクトにつけられた docstring のような)
     文字列から`DocTest' オブジェクトを生成します。

   * `DocTestRunner': `DocTest' 内の例題を実行し、 `OutputChecker'
     を使って出力を検証します。

   * `OutputChecker': doctest 例題から実際に出力された結果を
     予想出力と比較し、両者が一致するか判別します。

これらの処理クラスの関係を図にまとめると、以下のようになります:

                                 list of:
     +------+                   +---------+
     |module| --DocTestFinder-> | DocTest | --DocTestRunner-> results
     +------+    |        ^     +---------+     |       ^    (printed)
                 |        |     | Example |     |       |
                 v        |     |   ...   |     v       |
                DocTestParser   | Example |   OutputChecker
                                +---------+

* Menu:

* DocTest オブジェクト::
* Example オブジェクト::
* DocTestFinder オブジェクト::
* DocTestParser オブジェクト::
* DocTestRunner オブジェクト::
* OutputChecker オブジェクト::


File: python-lib-jp.info,  Node: DocTest オブジェクト,  Next: Example オブジェクト,  Prev: 拡張 API,  Up: 拡張 API

23.2.9.1 DocTest オブジェクト
.............................

`DocTest(examples, globs, name, filename, lineno, docstring)'
     単一の名前空間内で実行される doctest 例題の集まりです。
     コンストラクタの引数は `DocTest' インスタンス中の同名の
     メンバ変数の初期化に使われます。 _Added in Python version 2.4_

`DocTest' では、以下のメンバ変数を定義しています。
これらの変数はコンストラクタで初期化されます。直接変更してはなりません。

`examples'
     対話モードにおける例題それぞれをエンコードしていて、テストで実行
     される、`Example' オブジェクトからなるリストです。

`globs'
     例題を実行する名前空間 (いわゆるグローバル変数) です。
     このメンバは、名前から値への対応付けを行っている辞書です。
     例題が名前空間に対して (新たな変数をバインドするなど)
     何らかの変更を行った場合、`globs' への反映はテストの実行後に
     起こります。

`name'
     `DocTest' を識別する名前の文字列です。通常、この値は
     テストを取り出したオブジェクトかファイルの名前になります。

`filename'
     `DocTest' を取り出したファイルの名前です; ファイル名が未知の場合や
     `DocTest' をファイルから取り出したので ない場合には`None'
     になります。

`lineno'
     `filename' 中で`DocTest' のテスト例題が始まっている行の
     行番号です。行番号は、ファイルの先頭をゼロとして数えます。

`docstring'
     テストを取り出した docstring 自体を現す文字列です。 docstring
     文字列を得られない場合や、文字列からテスト例題を
     取り出したのでない場合には `None' になります。


File: python-lib-jp.info,  Node: Example オブジェクト,  Next: DocTestFinder オブジェクト,  Prev: DocTest オブジェクト,  Up: 拡張 API

23.2.9.2 Example オブジェクト
.............................

`Example(source, want[, exc_msg][, lineno][, indent][, options])'
     ひとつの Python
     文と、それに対する予想出力からなる、単一の対話的モードの
     例題です。コンストラクタの引数は `Example' インスタンス中の同名の
     メンバ変数の初期化に使われます。 _Added in Python version 2.4_

`Example' では、以下のメンバ変数を定義しています。
これらの変数はコンストラクタで初期化されます。直接変更してはなりません。

`source'
     例題のソースコードが入った文字列です。ソースコードは単一の Python
     で、末尾は常に改行です。コンストラクタは必要に応じて
     改行を追加します。

`want'
     例題のソースコードを実行した際の予想出力 (標準出力と、例外が生じた
     場合にはトレースバック) です。`want' の末尾は、予想出力が全く
     ない場合を除いて常に改行になります。予想出力がない場合には
     空文字列になります。コンストラクタは必要に応じて 改行を追加します。

`exc_msg'
     例題が例外を生成すると予想される場合の例外メッセージです。
     例外を送出しない場合には `None' です。
     この例外メッセージは、`traceback.format_exception_only()'
     の戻り値と比較されます。 値が `None' でない限り、`exc_msg'
     は改行で終わっていなければなりません; コンストラクタは必要に応じて
     改行を追加します。

`lineno'
     この例題の入っている文字列中における、例題の実行文のある行のの行番号です。
     行番号は文字列の先頭をゼロとして数えます。

`indent'
     例題の入っている文字列のインデント、すなわち例題の最初のプロンプト
     より前にある空白文字の数です。

`options'
     オプションフラグを `True' または `False' に対応付けて
     いる辞書です。例題に対するデフォルトオプションを上書きするために
     用いられます。この辞書に入っていないオプションフラグはデフォルトの
     状態 (`DocTestrunner' の `optionflags' の内容) の ままになります。


File: python-lib-jp.info,  Node: DocTestFinder オブジェクト,  Next: DocTestParser オブジェクト,  Prev: Example オブジェクト,  Up: 拡張 API

23.2.9.3 DocTestFinder オブジェクト
...................................

`DocTestFinder([verbose][, parser][, recurse][, exclude_empty])'
     与えられたオブジェクトについて、その docstring
     か、そのオブジェクトに 入っているオブジェクトの docstring
     から`DocTest' を抽出する処理 クラスです。
     現在のところ、モジュール、関数、クラス、メソッド、静的メソッド、
     クラスメソッド、プロパティから`DocTest' を抽出できます。

     オプション引数 VERBOSE を使うと、抽出処理の対象となるオブジェクト
     を表示できます。デフォルトは `False' (出力をおこなわない) です。

     オプション引数 PARSER には、 docstring から `DocTest' を
     抽出するのに使う`DocTestParser' オブジェクト
     (またはその代替となるオブジェクト) を指定します。

     オプション引数 RECURSE が偽の場合、`DocTestFinder.find()'
     は与えられたオブジェクトだけを調べ、そのオブジェクトに入っている他の
     オブジェクトを調べません。

     オプション引数 EXCLUDE_EMPTY が偽の場合、`DocTestFinder.find()'
     は空の docstring を持つオブジェクトもテスト対象に含めます。

     _Added in Python version 2.4_

`DocTestFinder' では以下のメソッドを定義しています:

`find(obj[, name][, module][, globs][, extraglobs])'
     OBJ または OBJ 内に入っているオブジェクトの docstring 中で
     定義されている`DocTest' のリストを返します。

     オプション引数 NAME には、オブジェクトの名前を指定します。
     この名前は、関数が返す `DocTest' の名前になります。 NAME
     を指定しない場合、`OBJ.__name__' を使います。

     オプションのパラメタ MODULE は、指定したオブジェクトを
     収めているモジュールを指定します。MODULE を指定しないか、 `None'
     を指定した場合には、正しいモジュールを自動的に
     決定しようと試みます。オブジェクトのモジュールは以下のような役割を
     果たします:

        * GLOBS を指定していない場合、オブジェクトのモジュールは
          デフォルトの名前空間になります。

        * 他のモジュールから import されたオブジェクトに対して
          `DocTestFinder' が`DocTest' を抽出するのを避ける
          ために使います (MODULE 由来でないオブジェクトを無視します)。

        * オブジェクトの入っているファイル名を調べるために使います。

        *
          オブジェクトがファイル内の何行目にあるかを調べる手助けにします。

     MODULE が `False' の場合には、モジュールの検索を試みません。
     これは正確さを欠くような使い方で、通常 doctest 自体のテストにしか
     つかいません。 MODULE が`False' の場合、 またはMODULE が`None'
     で自動的に的確なモジュールを見つけ出せない場合には、全てのオブジェクトは
     `(non-existent)' モジュールに属するとみなされ、そのオブジェクト内の
     全てのオブジェクトに対して (再帰的に) doctest
     の検索をおこないます。

     各`DocTest' のグローバル変数は、GLOBS とEXTRAGLOBS を合わせたもの
     (EXTRAGLOBS 内のバインドがGLOBS 内の バインドを上書きする)
     になります。各々の `DocTest' に対して、
     グローバル変数を表す辞書の新たな浅いコピーを生成します。 GLOBS
     を指定しない場合に使われるのデフォルト値は、
     モジュールを指定していればそのモジュールの __DICT__ になり、
     指定していなければ`@' になります。EXTRAGLOBS を指定しない場合、
     デフォルトの値は`@' になります。


File: python-lib-jp.info,  Node: DocTestParser オブジェクト,  Next: DocTestRunner オブジェクト,  Prev: DocTestFinder オブジェクト,  Up: 拡張 API

23.2.9.4 DocTestParser オブジェクト
...................................

`DocTestParser()'
     対話モードの例題を文字列から抽出し、それを使って`DocTest'
     オブジェクトを生成するために使われる処理クラスです。 _Added in
     Python version 2.4_

`DocTestParser' では以下のメソッドを定義しています:

`get_doctest(string, globs, name, filename, lineno)'
     指定した文字列から全ての doctest 例題を抽出し、`DocTest'
     オブジェクト内に集めます。

     GLOBS, NAME, FILENAME, および LINENO は 新たに作成される `DocTest'
     オブジェクトの属性になります。 詳しくは`DocTest'
     のドキュメントを参照してください。

`get_examples(string[, name])'
     指定した文字列から全ての doctest 例題を抽出し、`Example'
     オブジェクトからなるリストにして返します。 各`Example'
     の行番号はゼロから数えます。オプション引数 NAME
     はこの文字列につける名前で、エラーメッセージにしか 使われません。

`parse(string[, name])'
     指定した文字列を、例題とその間のテキストに分割し、 例題を`Example'
     オブジェクトに変換し、`Example' と
     文字列からなるリストにして返します。 各`Example'
     の行番号はゼロから数えます。オプション引数 NAME
     はこの文字列につける名前で、エラーメッセージにしか 使われません。


File: python-lib-jp.info,  Node: DocTestRunner オブジェクト,  Next: OutputChecker オブジェクト,  Prev: DocTestParser オブジェクト,  Up: 拡張 API

23.2.9.5 DocTestRunner オブジェクト
...................................

`DocTestRunner([checker][, verbose][, optionflags])'
     `DocTest' 内の対話モード例題を実行し、検証する際に用いられる
     処理クラスです。

     予想出力と実際の出力との比較は `OutputChecker' で行います。
     比較は様々なオプションフラグを使ってカスタマイズできます;
     詳しくは*Note オプションフラグとディレクティブ::
     を参照してください。
     オプションフラグでは不十分な場合、コンストラクタに `OutputChecker'
     のサブクラスを渡して比較方法をカスタマイズ できます。

     テストランナの表示出力の制御には二つの方法があります。
     一つ目は、`TestRunner.run()' に出力用の関数を渡すというものです。
     この関数は、表示すべき文字列を引数にして呼び出されます。デフォルトは
     `sys.stdout.write' です。出力を取り込んで処理するだけでは
     不十分な場合、`DocTestRunner' をサブクラス化し、 `report_start',
     `report_success', `report_unexpected_exception', および
     `report_failure' をオーバライドすればカスタマイズできます。

     オプションのキーワード引数CHECKER には、`OutputChecker'
     オブジェクト (またはその代用品) を指定します。このオブジェクトは
     doctest 例題の予想出力と実際の出力との比較を行う際に使われます。

     オプションのキーワード引数VERBOSE は、`DocTestRunner'
     の出すメッセージの冗長性を制御します。VERBOSE が`True'
     の場合、各例題を実行するつど、その例題についての情報を出力します。
     VERBOSE が`False' の場合、テストの失敗だけを出力します。 VERBOSE
     を指定しない場合や`None' を指定した場合、 コマンドラインスイッチ
     `-v' を使った場合にのみ VERBOSE 出力を適用します。

     オプションのキーワード引数OPTIONFLAGS を使うと、テストランナが
     予想出力と実際の出力を比較する方法や、テストの失敗を表示する方法を
     制御できます。詳しくは*Note オプションフラグとディレクティブ::
     節を参照してください。

     _Added in Python version 2.4_

`DocTestRunner' では、以下のメソッドを定義しています:

`report_start(out, test, example)'
     テストランナが例題を処理しようとしているときにレポートを出力します。
     `DocTestRunner' の出力をサブクラスでカスタマイズできるように
     するためのメソッドです。直接呼び出してはなりません。

     EXAMPLE は処理する例題です。TEST は EXAMPLE の
     入っているテストです。OUT は出力用の関数で、 `DocTestRunner.run()'
     に渡されます。

`report_success(out, test, example, got)'
     与えられた例題が正しく動作したことを報告します。 このメソッドは
     `DocTestRunner' のサブクラスで
     出力をカスタマイズできるようにするために提供されています;
     直接呼び出してはなりません。

     EXAMPLE は処理する例題です。GOT は例題から実際に得られた
     出力です。TEST は EXAMPLE の入っているテストです。 OUT
     は出力用の関数で、`DocTestRunner.run()' に渡されます。

`report_failure(out, test, example, got)'
     与えられた例題が正しく動作しなかったことを報告します。
     このメソッドは `DocTestRunner' のサブクラスで
     出力をカスタマイズできるようにするために提供されています;
     直接呼び出してはなりません。

     EXAMPLE は処理する例題です。GOT は例題から実際に得られた
     出力です。TEST は EXAMPLE の入っているテストです。 OUT
     は出力用の関数で、`DocTestRunner.run()' に渡されます。

`report_unexpected_exception(out, test, example, exc_info)'
     与えられた例題が予想とは違う例外を送出したことを報告します。
     このメソッドは `DocTestRunner' のサブクラスで
     出力をカスタマイズできるようにするために提供されています;
     直接呼び出してはなりません。

     EXAMPLE は処理する例題です。EXC_INFO には予期せず送出
     された例外の情報を入れたタプル (`sys.exc_info()' の返す内容)
     になります。TEST は EXAMPLE の入っているテストです。 OUT
     は出力用の関数で、`DocTestRunner.run()' に渡されます。

`run(test[, compileflags][, out][, clear_globs])'
     TEST 内の例題 (`DocTest' オブジェクト) を実行し、
     その結果を出力用の関数OUT を使って表示します。

     例題は名前空間 `test.globs' の下で実行されます。 CLEAR_GLOBS が真
     (デフォルト) の場合、名前空間はテストの実行後に
     消去され、ガベージコレクションをうながします。テストの実行完了後に
     その内容を調べたければ、CLEAR_GLOBS を `False' に してください。

     COMPILEFLAGS には、例題を実行する際に Python コンパイラに
     適用するフラグセットを指定します。COMPILEFLAGS を指定しない
     場合、デフォルト値はGLOBS で適用されている future-import フラグ
     セットになります。

     各例題の出力は `DocTestRunner' の出力チェッカで検査され、
     その結果は `DocTestRunner.report_*'. メソッドで書式化 されます。

`summarize([verbose])'
     この DocTestRunner が実行した全てのテストケースのサマリを出力し、
     タプル`(FAILURE_COUNT, TEST_COUNT)' を返します。

     オプションのVERBOSE 引数を使うと、どのくらいサマリを詳しくするかを
     制御できます。冗長度を指定しない場合、`DocTestRunner'
     自体の冗長度を使います。


File: python-lib-jp.info,  Node: OutputChecker オブジェクト,  Prev: DocTestRunner オブジェクト,  Up: 拡張 API

23.2.9.6 OutputChecker オブジェクト
...................................

`OutputChecker()'
     doctest 例題を実際に実行したときの出力が予想出力と一致するかどうか
     をチェックするために使われるクラスです。 `OutputChecker' では、
     与えられた二つの出力を比較して、一致する場合には真を返す
     `check_output' と、二つの出力間の違いを説明する文字列を
     返す`output_difference' の、二つのメソッドがあります。 _Added in
     Python version 2.4_

`OutputChecker' では以下のメソッドを定義しています:

`check_output(want, got, optionflags)'
     例題から実際に得られた出力 (GOT) と、予想出力 (WANT)
     が一致する場合にのみ`True' を返します。
     二つの文字列が全く同一の場合には常に一致するとみなしますが、
     テストランナの使っているオプションフラグにより、厳密には同じ内容
     になっていなくても一致するとみなす場合もあります。オプションフラグに
     ついての詳しい情報は*Note オプションフラグとディレクティブ::
     節を参照してください。

`output_difference(want, got, optionflags)'
     与えられた例題の予想出力 (WANT)と、実際に得られた出力 (GOT)
     の間の差異を解説している文字列を返します。 OPTIONFLAGS はWANT
     とGOT を比較する際に使われる オプションフラグのセットです。


File: python-lib-jp.info,  Node: デバッグ,  Next: 提言,  Prev: 拡張 API,  Up: doctest

23.2.10 デバッグ
----------------

`doctest' では、doctest 例題をデバッグするメカニズムをいくつか
提供しています:

   * doctest を実行可能な Python プログラムに変換し、 Python デバッガ
     `pdb' で実行できるようにするための関数がいくつかあります。

   * `DocTestRunner' のサブクラス`DebugRunner' クラスが
     あります。このクラスは、最初に失敗した例題に対して例外を送出します。
     例外には例題に関する情報が入っています。この情報は例題の検視デバッグ
     に利用できます。

   * `DocTestSuite()' の生成する`unittest' テストケース は、`debug()'
     メソッドをサポートしています。`debug()' は ``unittest'.TestCase'
     で定義されています。

   * ``pdb'.set_trace()' を doctest 例題の中で呼び
     出しておけば、その行が実行されたときに Python
     デバッガが組み込まれます。
     デバッガを組み込んだあとは、変数の現在の値などを調べられます。
     たとえば、以下のようなモジュールレベルの docstring の入ったファイル
     `a.py' があるとします:

          """
          >>> def f(x):
          ...     g(x*2)
          >>> def g(x):
          ...     print x+3
          ...     import pdb; pdb.set_trace()
          >>> f(3)
          9
          """

     対話セッションは以下のようになるでしょう:

          >>> import a, doctest
          >>> doctest.testmod(a)
          --Return--
          > <doctest a[1]>(3)g()->None
          -> import pdb; pdb.set_trace()
          (Pdb) list
            1     def g(x):
            2         print x+3
            3  ->     import pdb; pdb.set_trace()
          [EOF]
          (Pdb) print x
          6
          (Pdb) step
          --Return--
          > <doctest a[0]>(2)f()->None
          -> g(x*2)
          (Pdb) list
            1     def f(x):
            2  ->     g(x*2)
          [EOF]
          (Pdb) print x
          3
          (Pdb) step
          --Return--
          > <doctest a[2]>(1)?()->None
          -> f(3)
          (Pdb) cont
          (0, 3)
          >>>

     _Changed in Python version 2.4_

以下は、doctest を Python コードに変換して、できたコードをデバッガ下で
実行できるようにするための関数です:

`script_from_examples(s)'
     例題の入ったテキストをスクリプトに変換します。

     引数S は doctest 例題の入った文字列です。この文字列は Python
     スクリプトに変換され、その中では S の doctest 例題が
     通常のコードに、それ以外は Python のコメント文になります。
     生成したスクリプトを文字列で返します。例えば、

              import doctest
              print doctest.script_from_examples(r"""
                  Set x and y to 1 and 2.
                  >>> x, y = 1, 2

                  Print their sum:
                  >>> print x+y
                  3
              """)

     は、

              # Set x and y to 1 and 2.
              x, y = 1, 2
              #
              # Print their sum:
              print x+y
              # Expected:
              ## 3

     になります。

     この関数は他の関数 (下記参照)
     から使われていまるが、対話セッションを Python
     スクリプトに変換したいような場合にも便利でしょう。

     _Added in Python version 2.4_

`testsource(module, name)'
     あるオブジェクトの doctest をスクリプトに変換します。

     引数MODULE はモジュールオブジェクトか、対象の doctest を持つ
     オブジェクトの入ったモジュールのドット表記名です。 引数NAME
     は対象の doctest を持つオブジェクトの (モジュール内の)
     名前です。対象オブジェクトの docstring を上の
     `script_from_examples()' で説明した方法で Python スクリプトに
     変換してできた文字列を返しますます。例えば、`a.py' モジュールの
     トップレベルに関数 `f()' がある場合、以下のコード

          import a, doctest
          print doctest.testsource(a, "a.f")

     を実行すると、`f()' の docstring から doctest をコードに
     変換し、それ以外をコメントにしたスクリプトを出力します。

     _Added in Python version 2.3_

`debug(module, name[, pm])'
     オブジェクトの持つ doctest をデバッグします。

     MODULE および NAME 引数は上の `testsource()'
     と同じです。指定したオブジェクトの docstring から合成された Python
     スクリプトは一時ファイルに書き出され、その後 Python デバッガ `pdb'
     の制御下で実行されます。

     ローカルおよびグローバルの実行コンテキストには、 `MODULE.__dict__'
     の浅いコピーが使われます。

     オプション引数PM は、検死デバッグを行うかどうかを指定します。 PM
     が真の場合、スクリプトファイルは直接実行され、
     スクリプトが送出した例外が処理されないまま終了した場合にのみデバッガ
     が立ち入ります。その場合、``pdb'.post_mortem()' によって
     検死デバッグを起動し、処理されなかった例外から得られたトレースバック
     オブジェクトを渡します。PM を指定しないか値を偽にした場合、
     ``pdb'.run()' に適切な `execfile()' 呼び出しを
     渡して、最初からデバッガの下でスクリプトを実行します。

     _Added in Python version 2.3_

     _Changed in Python version 2.4_

`debug_src(src[, pm][, globs])'
     文字列中の doctest をデバッグします。

     上の`debug()' に似ていますが、doctest の入った文字列は SRC
     引数で直接指定します。

     オプション引数 PM は上の `debug()' と同じ意味です。

     オプション引数GLOBS には、ローカルおよびグローバルな
     実行コンテキストの両方に使われる辞書を指定します。GLOBS を
     指定しない場合や`None' にした場合、空の辞書を使います。
     辞書を指定した場合、実際の実行コンテキストには浅いコピーが使われます。

     _Added in Python version 2.4_

`DebugRunner' クラス自体や`DebugRunner' クラスが送出
する特殊な例外は、テストフレームワークの作者にとって非常に興味のある
ところで The `DebugRunner' class, and the special exceptions it may
raise, are of most interest to testing framework authors, and will only
be sketched here.

詳しくはソースコード、とりわけ`DebugRunner' の docstring (それ自体
doctest ですよ!) を参照してください。

`DebugRunner([checker][, verbose][, optionflags])'
     テストの失敗に遭遇するとすぐに例外を送出するようになっている
     `DocTestRunner' のサブクラスです。予期しない例外が生じると、
     `UnexpectedException' 例外を送出します。この例外には、
     テスト、例題、もともと送出された例外が入っています。
     予想出力と実際出力が一致しないために失敗した場合には、
     `DocTestFailure' 例外を送出します。この例外には、
     テスト、例題、実際の出力が入っています。

     コンストラクタのパラメタやメソッドについては、*Note 拡張 API::
     節の `DocTestRunner' のドキュメントを参照してください。

`DebugRunner' インスタンスの送出する例外には以下の二つがあります:

`DocTestFailure(test, example, got)'
     doctest 例題の実際の出力が予想出力と一致しなかったことを示すために
     `DocTestRunner' が送出する例外です。
     コンストラクタの引数は、インスタンスの同名のメンバ変数を
     初期化するために使われます。

`DocTestFailure' では以下のメンバ変数を定義しています:

`test'
     例題が失敗した時に実行されていた`DocTest' オブジェクトです。

`example'
     失敗した `Example' オブジェクトです。

`got'
     例題の実際の出力です。

`UnexpectedException(test, example, exc_info)'
     doctest 例題が予期しない例外を送出したことを示すために
     `DocTestRunner' が送出する例外です。
     コンストラクタの引数は、インスタンスの同名のメンバ変数を
     初期化するために使われます。

`UnexpectedException' では以下のメンバ変数を定義しています:

`test'
     例題が失敗した時に実行されていた`DocTest' オブジェクトです。

`example'
     失敗した `Example' オブジェクトです。

`exc_info'
     予期しない例外についての情報の入ったタプルで、`sys.exc_info()'
     が返すのと同じものです。


File: python-lib-jp.info,  Node: 提言,  Next: 進んだ使い方,  Prev: デバッグ,  Up: doctest

23.2.11 提言
------------

冒頭でも触れたように、`doctest' は、

  1. docstring 内の例題をチェックする、

  2. 回帰テストを行う、

  3. 実行可能なドキュメント/読めるテストの実現、

という三つの主な用途を持つようになりました。これらの用途にはそれぞれ
違った要求があるので、区別して考えるのが重要です。特に、 docstring を
曖昧なテストケースに埋もれさせてしまうとドキュメントとしては最悪です。

docstring の例は注意深く作成してください。 doctest
の作成にはコツがあり、 きちんと学ぶ必要があります --
最初はすんなりできないでしょう。
例題は、ドキュメントに紛れ無しの価値を与えます。
よい例がたくさんの言葉に値することは多々あります。
注意深くやれば、例はユーザにとってはあまり意味のないものになるかも
しれませんが、歳を経るにつれて、あるいは "状況が変わった" 際に何度も
何度も正しく動作させるためにかかることになる時間を節約するという形で、
きっと見返りを得るでしょう。 私は今でも、自分の `doctest'
で処理した例が "たいした事のない"
変更を行った際にうまく動作しなくなることに驚いています。

説明テキストの作成をけちらなければ、`doctest' は回帰テストの
優れたツールにもなり得ます。説明文と例題を交互に記述していけば、
実際に何をどうしてテストしているのかもっと簡単に把握できるように
なるでしょう。もちろん、コードベースのテストに詳しくコメントを入れるのも
手ですが、そんなことをするプログラマはほとんどいません。
多くの人々が、`doctest' のアプローチをとった方がきれいに
テストを書けると気づいています。おそらく、これは単にコード中にコメント
を書くのが少し面倒だからという理由でしょう。私はもう少しうがった見方も
しています: doctest ベースのテストを書くときの自然な態度は、
自分のソフトウェアのよい点を説明しようとして、例題を使って説明
しようとするときの態度そのものだからだ、という理由です。
それゆえに、テストファイルは自然と単純な機能の解説から始め、論理的により
複雑で境界条件的なケースに進むような形になります。結果的に、
一見ランダムに見えるような個別の機能をテストしている個別の関数の集まり
ではなく、首尾一貫した説明ができるようになるのです。 `doctest'
によるテストの作成は全く別の取り組み方であり、
テストと説明の区別をなくして、全く違う結果を生み出すのです。

回帰テストは特定のオブジェクトやファイルにまとめておくのがよいでしょう。
回帰テストの組み方にはいくつか選択肢があります:

   * テストケースを対話モードの例題にして入れたテキストファイルを書き、
     `testifle()' や `DocFileSuite()' を使ってそのファイル
     をテストします。この方法をお勧めします。最初から doctest
     を使うように
     している新たなプロジェクトでは、この方法が一番簡単です。

   * `_regrtest_topic' という名前の関数を定義します。
     この関数には、あるトピックに対応するテストケースの入った docstring
     が一つだけ入っています。この関数はモジュールと同じファイルの中にも
     置けますし、別のテストファイルに分けてもかまいません。

   * 回帰テストのトピックをテストケースの入った docstring に
     対応付けた辞書`__test__' 辞書を定義します。


File: python-lib-jp.info,  Node: 進んだ使い方,  Prev: 提言,  Up: doctest

23.2.12 進んだ使い方
--------------------

doctest をどのように動作させるかを制御する、いくつかのモジュール
レベルの関数が利用できます。

`debug(module, name)'
     doctest を含む単一のドキュメンテーション文字列をデバッグします。

     デバッグしたいドキュメンテーション文字列の入った MODULE
     (またはドットで区切ったモジュール名) と、(モジュール内の)
     デバッグしたいドキュメンテーション文字列を持つオブジェクトの NAME
     を指定してください。

     doctest の例が展開され (`testsource()' 関数を参照してください)、
     一次ファイルに書き込まれます。次に Python デバッガ `pdb'
     がこのファイルに対して起動されます。 _Added in Python version 2.3_

`testmod()'
     この関数は doctest への基本的なインタフェース提供します。
     この関数は  `Tester' のローカルなインスタンスを生成し、
     このクラスの適切なメソッドを動作させ、結果をグローバルな `Tester'
     インスタンスである `master' に統合します。

     `testmod()' が提供するよりも細かい制御を行うには、 `Tester'
     のインスタンスを自作のポリシで作成するか、 `master'
     のメソッドを直接呼び出します。詳細は `Tester.__doc__'
     を参照してください。

`testsource(module, name)'
     doctest の例をドキュメンテーション文字列から展開します。

     展開したいテストの入った MODULE  (またはドットで区切られた
     モジュールの名前) と、展開したいテストの入った docstring を
     持つオブジェクトの (モジュール内の) NAME を与えます。

     doctest 内の例は Python コードの入った文字列として返されます。
     例中での予想される出力のブロックは Python のコメントに変換
     されます。 _Added in Python version 2.3_

`DocTestSuite([module])'
     モジュールにおける doctest のテストプログラムを
     ``unittest'.TestSuite' に変換します。

     返される `TestSuite' は unittest フレームワークで動作する
     ためのもので、モジュール内の各 doctest を走らせます。 doctest
     のいずれかが失敗すると、生成された unittest が失敗し、
     該当するテストを含むファイルと (時に近似の) 行番号を表示する
     `DocTestTestFailure' 例外が送出されます。

     オプションの MODULE 引数はテストするモジュールを与えます。
     この値はモジュールオブジェクトか (場合によってはドットで区切られた)
     モジュール名となります。指定されていなければ、この関数を呼び出している
     モジュールが使われます。

     `unittest' モジュールが `TestSuite' を
     利用する数多くの方法のうちの一つを使った例を以下に示します:

              import unittest
              import doctest
              import my_module_with_doctests

              suite = doctest.DocTestSuite(my_module_with_doctests)
              runner = unittest.TextTestRunner()
              runner.run(suite)

     _Added in Python version 2.3_ _この関数は現在のところ `M.__test__'
     を検索せず、 その検索テクニックはあらゆる点で `testmod()'
     と合致しません。
     将来のバージョンではこれら二つを収斂させる予定です。_


File: python-lib-jp.info,  Node: unittest,  Next: test,  Prev: doctest,  Up: 開発ツール

23.3 単体テストフレームワーク
=============================

単体テストフレームワーク

_Added in Python version 2.1_

このPython単体テストフレームワーク は時に"PyUnit"とも呼ばれ、Kent Beck
と Erich
GammaによるJUnitのPython版です。JUnitはまたKentのSmalltalk用テスト
フレームワークのJava版で、どちらもそれぞれの言語で業界標準の単体テストフ
レームワークとなっています。

`unittest'では、テストの自動化・初期設定と終了処理の共有・テストの分類・テス
ト実行と結果レポートの分離などの機能を提供しており、`unittest'の
クラスを使って簡単にたくさんのテストを開発できるようになっています。

このようなことを実現するために `unittest'では、
テストを以下のような構成で開発します。

"Fixture"
     "test
     fixture(テスト設備)"とは、テスト実行のために必要な準備や終了処
     理を指します。例:テスト用データベースの作成・ディレクトリ・サーバプロセ
     スの起動など。

"テストケース"
     "テストケース"はテストの最小単位で、各入力に対する結果をチェックしま
     す。テストケースを作成する場合は、`unittest'が提供する`TestCase'クラス
     を基底クラスとして利用することができます。

"テストスイート"
     "テストスイート"はテストケースとテストスイートの集まりで、同時に実行
     しなければならないテストをまとめる場合に使用します。

"テストランナー"
     "テストランナー"はテストの実行と結果表示を管理するコンポーネントで
     す。ランナーはグラフィカルインターフェースでもテキストインターフェースで
     も良いですし、何も表示せずにテスト結果を示す値を返すだけの場合もありま
     す。

`unittest'では、テストケースとfixtureを、`TestCase'クラスと
`FunctionTestCase'クラスで提供しています。`TestCase'クラスは
新規にテストを作成する場合に使用し、`FunctionTestCase'は既存のテス
トを`unittest'に組み込む場合に使用します。fixtureの設定処理と終了処理は、
`TestCase'では`setUp()'メソッドと`tearDown()'をオー
バーライドして記述し、`FunctionTestCase'では初期設定・終了処理を行
う既存の関数をコンストラクタで指定します。テスト実行時、まずfixtureの初
期設定が最初に実行されます。初期設定が正常終了した場合、テスト実行後には
テスト結果に関わらず終了処理が実行されます。`TestCase'の各インスタ
ンスが実行するテストは一つだけで、fixtureは各テストごとに新しく作成され
ます。

テストスイートは`TestSuite'クラスで実装されており、複数のテストと
テストスイートをまとめる事ができます。テストスイートを実行すると、スイー
トと子スイートに追加されている全てのテストが実行されます。

テストランナーは`run()'メソッドを持つオブジェクトで、
`run()'は引数として`TestCase'か`TestSuite'オブジェク
トを受け取り、テスト結果を`TestResult'オブジェクトで戻します。
`unittest'ではデフォルトでテスト結果を標準エラーに出力する
`TextTestRunner'をサンプルとして実装しています。これ以外のランナー
(グラフィックインターフェース用など)を実装する場合でも、特定のクラスから
派生する必要はありません。

See also:
     *Note doctest:: Another test-support module with a very different
     flavor.  `Simple Smalltalk Testing: With Patterns'{Kent Beck's
     original paper on testing frameworks using the pattern shared by
     `unittest'.}

* Menu:

* 基礎的な例::
* テストの構成::
* 既存テストコードの再利用::
* クラスと関数::
* TestCase オブジェクト::
* TestSuite オブジェクト::
* TestResultオブジェクト::
* TestLoader オブジェクト::


File: python-lib-jp.info,  Node: 基礎的な例,  Next: テストの構成,  Prev: unittest,  Up: unittest

23.3.1 基礎的な例
-----------------

`unittest'モジュールには、テストの開発や実行の為の優れたツールが
用意されており、この節では、その一部を紹介します。ほとんどのユーザとって
は、ここで紹介するツールだけで十分でしょう。

以下は、`random'モジュールの三つの関数をテストするスクリプトです。

     import random
     import unittest

     class TestSequenceFunctions(unittest.TestCase):

         def setUp(self):
             self.seq = range(10)

         def testshuffle(self):
             # make sure the shuffled sequence does not lose any elements
             random.shuffle(self.seq)
             self.seq.sort()
             self.assertEqual(self.seq, range(10))

         def testchoice(self):
             element = random.choice(self.seq)
             self.assert_(element in self.seq)

         def testsample(self):
             self.assertRaises(ValueError, random.sample, self.seq, 20)
             for element in random.sample(self.seq, 5):
                 self.assert_(element in self.seq)

     if __name__ == '__main__':
         unittest.main()

テストケースは、`unittest.TestCase'のサブクラスとして作成します。メ
ソッド名が`test'で始まる三つのメソッドがテストです。テストランナー
はこの命名規約によってテストを行うメソッドを検索します。

これらのテスト内では、予定の結果が得られていることを確かめるために
`assertEqual()'を、条件のチェックに`assert_()'を、例外が発
生する事を確認するために`assertRaises()'をそれぞれ呼び出していま
す。`assert'文の代わりにこれらのメソッドを使用すると、テストラン
ナーでテスト結果を集計してレポートを作成する事ができます。

`setUp()'メソッドが定義されている場合、テストランナーは各テストを
実行する前に`setUp()'メソッドを呼び出します。同様に、
`tearDown()'メソッドが定義されている場合は各テストの実行後に呼び
出します。上のサンプルでは、それぞれのテスト用に新しいシーケンスを作成するため
に`setUp()'を使用しています。

サンプルの末尾が、簡単なテストの実行方法です。`unittest.main()'は、
テストスクリプトのコマンドライン用インターフェースです。コマンドラインか
ら起動された場合、上記のスクリプトから以下のような結果が出力されます:

     ...
     ----------------------------------------------------------------------
     Ran 3 tests in 0.000s

     OK

簡略化した結果を出力したり、コマンドライン以外からも起動する等のより細かい
制御が必要であれば、`unittest.main()'を使用せずに別の方法でテストを
実行します。例えば、上記サンプルの最後の2行は以下のように書くことができ
ます:

     suite = unittest.TestLoader().loadTestsFromTestCase(TestSequenceFunctions)
     unittest.TextTestRunner(verbosity=2).run(suite)

変更後のスクリプトをインタープリタや別のスクリプトから実行すると、以下の
出力が得られます:

     testchoice (__main__.TestSequenceFunctions) ... ok
     testsample (__main__.TestSequenceFunctions) ... ok
     testshuffle (__main__.TestSequenceFunctions) ... ok

     ----------------------------------------------------------------------
     Ran 3 tests in 0.110s

     OK

以上が`unittest'モジュールでよく使われる機能で、ほとんどのテスト
ではこれだけでも十分です。基礎となる概念や全ての機能については以降の章を
参照してください。


File: python-lib-jp.info,  Node: テストの構成,  Next: 既存テストコードの再利用,  Prev: 基礎的な例,  Up: unittest

23.3.2 テストの構成
-------------------

単体テストの基礎となる構築要素は、"テストケース" -- セットアップと
正しさのチェックを行う、独立したシナリオ -- です。`unittest'では、テスト
ケースは`unittest'モジュールの`TestCase'クラスのインスタ
ンスで示します。テストケースを作成するには`TestCase'のサブクラスを
記述するか、または`FunctionTestCase'を使用します。

`TestCase'から派生したクラスのインスタンスは、このオブジェクトだけ
で一件のテストと初期設定・終了処理を行います。

`TestCase'インスタンスは外部から完全に独立し、単独で実行する事も、
他の任意のテストと一緒に実行する事もできなければなりません。

以下のように、`TestCase'のサブクラスは`runTest()'をオーバライドし、
必要なテスト処理を記述するだけで簡単に書くことができます:

     import unittest

     class DefaultWidgetSizeTestCase(unittest.TestCase):
         def runTest(self):
             widget = Widget('The widget')
             self.assertEqual(widget.size(), (50,50), 'incorrect default size')

何らかのテストを行う場合、ベースクラス`TestCase'の `assert*()' か
`fail*()'メソッドを使用してください。
テストが失敗すると例外が送出され、`unittest'はテスト結果を
"failure"とします。その他の例外は"error"となります。
これによりどこに問題があるかが判ります。"failure"は間違った結果 (6
になるはずが 5 だった)で発生します。"error"は間違ったコード
(たとえば間違った関数呼び出しによる`TypeError')で発生します。

テストの実行方法については後述とし、まずはテストケースインスタンスの作成
方法を示します。テストケースインスタンスは、以下のように引数なしでコンス
トラクタを呼び出して作成します。

     testCase = DefaultWidgetSizeTestCase()

似たようなテストを数多く行う場合、同じ環境設定処理を何度も必要となりま
す。例えば上記のようなWidgetのテストが100種類も必要な場合、それぞれのサ
ブクラスで`Widget'オブジェクトを生成する処理を記述するのは好ましくあり
ません。

このような場合、初期化処理は`setUp()'メソッドに切り出し、テスト実
行時にテストフレームワークが自動的に実行するようにすることができます:

     import unittest

     class SimpleWidgetTestCase(unittest.TestCase):
         def setUp(self):
             self.widget = Widget('The widget')

     class DefaultWidgetSizeTestCase(SimpleWidgetTestCase):
         def runTest(self):
             self.failUnless(self.widget.size() == (50,50),
                             'incorrect default size')

     class WidgetResizeTestCase(SimpleWidgetTestCase):
         def runTest(self):
             self.widget.resize(100,150)
             self.failUnless(self.widget.size() == (100,150),
                             'wrong size after resize')

テスト中に`setUp()'メソッドで例外が発生した場合、テストフレーム
ワークはテストを実行することができないとみなし、`runTest()'を実行
しません。

同様に、終了処理を`tearDown()'メソッドに記述すると、
`runTest()'メソッド終了後に実行されます:

     import unittest

     class SimpleWidgetTestCase(unittest.TestCase):
         def setUp(self):
             self.widget = Widget('The widget')

         def tearDown(self):
             self.widget.dispose()
             self.widget = None

`setUp()'が正常終了した場合、`runTest()'が成功したかどうかに従って
`tearDown()'が実行されます。

このような、テストを実行する環境を"fixture"と呼びます。

JUnitでは、多数の小さなテストケースを同じテスト環境で実行する場合、全て
のテストについて`DefaultWidgetSizeTestCase'のような
`SimpleWidgetTestCase'のサブクラスを作成する必要があります。これは
時間のかかる、うんざりする作業ですので、`unittest'ではより簡単なメカニズムを
用意しています:

     import unittest

     class WidgetTestCase(unittest.TestCase):
         def setUp(self):
             self.widget = Widget('The widget')

         def tearDown(self):
             self.widget.dispose()
             self.widget = None

         def testDefaultSize(self):
             self.failUnless(self.widget.size() == (50,50),
                             'incorrect default size')

         def testResize(self):
             self.widget.resize(100,150)
             self.failUnless(self.widget.size() == (100,150),
                             'wrong size after resize')

この例では`runTest()'がありませんが、二つのテストメソッドを定義し
ています。このクラスのインスタンスは`test*()'メソッドのどちらか一
方の実行と、`self.widget'の生成・解放を行います。この場合、テスト
ケースインスタンス生成時に、コンストラクタの引数として実行するメソッド名
を指定します:

     defaultSizeTestCase = WidgetTestCase('testDefaultSize')
     resizeTestCase = WidgetTestCase('testResize')

`unittest'では`テストスイート'によってテストケースインスタンスをテスト
対象の機能によってグループ化することができます。"テストスイート"
は、`unittest'の`TestSuite'クラスで作成します。

     widgetTestSuite = unittest.TestSuite()
     widgetTestSuite.addTest(WidgetTestCase('testDefaultSize'))
     widgetTestSuite.addTest(WidgetTestCase('testResize'))

各テストモジュールで、テストケースを組み込んだテストスイートオブジェクト
を作成する呼び出し可能オブジェクトを用意しておくと、テストの実行や参照が
容易になります:

     def suite():
         suite = unittest.TestSuite()
         suite.addTest(WidgetTestCase('testDefaultSize'))
         suite.addTest(WidgetTestCase('testResize'))
         return suite

または:

     def suite():
         tests = ['testDefaultSize', 'testResize']

         return unittest.TestSuite(map(WidgetTestCase, tests))

一般的には、`TestCase'のサブクラスには良く似た名前のテスト関数が複
数定義されますので、`unittest'では
テストスイートを作成して個々のテストで満たすプロセスを自動化するのに使う
`TestLoader'を用意しています。 たとえば、

     suite = unittest.TestLoader().loadTestsFromTestCase(WidgetTestCase)

は`WidgetTestCase.testDefaultSize()'と`WidgetTestCase.testResize'
を走らせるテストスイートを作成します。
`TestLoader'は自動的にテストメソッドを識別するのに`'test''という
メソッド名の接頭辞を使います。

いろいろなテストケースが実行される順序は、テスト関数名を組み込み関数`cmp()'
でソートして決定されます。

システム全体のテストを行う場合など、テストスイートをさらにグループ化した
い場合がありますが、このような場合、`TestSuite'インスタンスには
`TestSuite'と同じように`TestSuite'を追加する事ができます。

     suite1 = module1.TheTestSuite()
     suite2 = module2.TheTestSuite()
     alltests = unittest.TestSuite([suite1, suite2])

テストケースやテストスイートは (`widget.py' のような)
テスト対象のモジュール内にも記述できますが、テストは (`test_widget.py'
のような) 独立したモジュールに置いた方が 以下のような点で有利です:

   * テストモジュールだけをコマンドラインから実行することができる。

   * テストコードと出荷するコードを分離する事ができる。

   *
     テストコードを、テスト対象のコードに合わせて修正する誘惑に駆られにくい。

   * テストコードは、テスト対象コードほど頻繁に更新されない。

   * テストコードをより簡単にリファクタリングすることができる。

   *
     Cで書いたモジュールのテストは、どっちにしろ独立したモジュールとなる。

   * テスト戦略を変更した場合でも、ソースコードを変更する必要がない。


File: python-lib-jp.info,  Node: 既存テストコードの再利用,  Next: クラスと関数,  Prev: テストの構成,  Up: unittest

23.3.3 既存テストコードの再利用
-------------------------------

既存のテストコードが有るとき、このテストを`unittest'で実行しようと
するために古いテスト関数をいちいち`TestCase'クラスのサブクラスに
変換するのは大変です。

このような場合は、`unittest'では`TestCase'のサブクラスである
`FunctionTestCase'クラスを使い、既存のテスト関数をラップします。初
期設定と終了処理も行なえます。

以下のテストコードがあった場合:

     def testSomething():
         something = makeSomething()
         assert something.name is not None
         # ...

テストケースインスタンスは次のように作成します:

     testcase = unittest.FunctionTestCase(testSomething)

初期設定、終了処理が必要な場合は、次のように指定します:

     testcase = unittest.FunctionTestCase(testSomething,
                                          setUp=makeSomethingDB,
                                          tearDown=deleteSomethingDB)

既存のテストスイートからの移行を容易にするため、`unittest'は
`AssertionError'の送出でテストの失敗を示すような書き方もサポートしています。
しかしながら、`TestCase.fail*()'および`TestCase.assert*()'
メソッドを使って明確に書くことが推奨されています。`unittest'の
将来のバージョンでは、`AssertionError'は別の目的に使用される可能性が有ります。

_Note:_ `FunctionTestCase'を使って既存のテストを`unittest'ベースの
テスト体系に変換することができますが、この方法は推奨されません。時間を掛けて
`TestCase'のサブクラスに書き直した方が将来的なテストのリファクタリングが
限りなく易しくなります。

